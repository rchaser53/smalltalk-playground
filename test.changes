'From Pharo6.0 of 13 May 2016 [Latest update: #60493] on 17 May 2017 at 1:01:41.053846 pm'!----QUIT----2017-05-17T13:02:17.571196+02:00 Pharo-60493.image priorSource: 0!----QUIT----2017-05-17T13:02:52.052925+02:00 Pharo-60493.image priorSource: 92!----QUIT/NOSAVE----2017-05-17T13:03:08.259387+02:00 Pharo-60493.image priorSource: 172!----QUIT----2017-05-17T13:03:42.089076+02:00 Pharo-60493.image priorSource: 172!----QUIT----2017-05-17T13:09:56.388095+02:00 Pharo-60493.image priorSource: 342!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/17/2017 15:15' prior: 59349094!commentForCurrentUpdate ^ '20064 ClassTest>>#testMethodsReferencingClass uses non-existing BehaviorTests	https://pharo.fogbugz.com/f/cases/20064'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/17/2017 15:15'!script60494	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.144.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.52.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.15.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.192.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.101.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.78.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.85.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.6.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2510.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.173.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.615.mczMorphic-Core-TheIntegrator.313.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.49.mczPharoBootstrap-Initialization-TheIntegrator.4.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.386.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.71.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.37.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.38.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/17/2017 15:15'!update60494	"self new update60494"	self withUpdateLog: '20064 ClassTest>>#testMethodsReferencingClass uses non-existing BehaviorTests	https://pharo.fogbugz.com/f/cases/20064'.	self loadTogether: self script60494 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60493!ScriptLoader removeSelector: #script60493!"ScriptLoader60"!!ClassTest methodsFor: 'testing - navigation' stamp: 'PavelKrivanek 5/16/2017 14:47' prior: 19489936!testMethodsReferencingClass	self assert: (ClassTest methodsReferencingClass: (Smalltalk classNamed: #ExampleForTest111)) equals: {(ClassTest >> #testOrdersACollectionOfClassesBySuperclass)}.	self		assert: ((ClassTest methodsReferencingClass: (Smalltalk classNamed: #ExampleForTest1)) sort: [ :a :b | a name <= b name]) asArray		equals:			{ClassTest>>#referencingMethod1. 			ClassTest>>#referencingMethod2. 			ClassTest>>#testOrdersACollectionOfClassesBySuperclass}.	self assert: (ClassTest methodsReferencingClass: (Smalltalk classNamed: #BehaviorTest)) isEmpty! !"Kernel-Tests"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.568.mcz') load.ScriptLoader new update60494.!----End fileIn----!----QUIT----2017-05-18T09:47:15.580373+02:00 Pharo.image priorSource: 424!----QUIT----2017-05-18T09:47:26.423036+02:00 Pharo.image priorSource: 20220!----QUIT----2017-05-19T09:35:29.483671+02:00 Pharo.image priorSource: 20296!----QUIT----2017-05-19T09:35:36.656906+02:00 Pharo.image priorSource: 20374!----QUIT----2017-05-19T14:15:05.912563+02:00 Pharo.image priorSource: 20452!----QUIT----2017-05-19T14:15:13.143532+02:00 Pharo.image priorSource: 20530!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/22/2017 09:50' prior: 33555030!commentForCurrentUpdate ^ '20064 ClassTest>>#testMethodsReferencingClass uses non-existing BehaviorTests	https://pharo.fogbugz.com/f/cases/2006420074 Red-pane-of-death when sources file missing	https://pharo.fogbugz.com/f/cases/20074'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/22/2017 09:50'!script60495	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.144.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.52.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.15.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.192.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.101.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.78.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.85.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.6.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2510.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.173.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.615.mczMorphic-Core-TheIntegrator.313.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.49.mczPharoBootstrap-Initialization-TheIntegrator.4.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.386.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.37.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.38.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/22/2017 09:50'!update60495	"self new update60495"	self withUpdateLog: '20064 ClassTest>>#testMethodsReferencingClass uses non-existing BehaviorTests	https://pharo.fogbugz.com/f/cases/2006420074 Red-pane-of-death when sources file missing	https://pharo.fogbugz.com/f/cases/20074'.	self loadTogether: self script60495 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60494!ScriptLoader removeSelector: #script60494!"ScriptLoader60"!!SourceFileArray methodsFor: 'private' stamp: 'BenComan 5/21/2017 23:27' prior: 61198173!createReadOnlyFiles	| readOnly failed |		failed := false.	readOnly := files collect: [ :file | 		file 			ifNil: [  failed := true. nil ]			ifNotNil: [ [ file readOnlyCopy ]         		on: FileDoesNotExistException        		do: [ failed := true. nil ] ]	].	^ failed ifFalse: [ readOnly ] ifTrue: [ self closeFileArray: readOnly. nil ]! !"System-Sources"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.571.mcz') load.ScriptLoader new update60495.!----End fileIn----!----QUIT----2017-05-22T09:53:26.771406+02:00 Pharo.image priorSource: 20608!----QUIT----2017-05-22T09:53:36.987945+02:00 Pharo.image priorSource: 40350!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/23/2017 11:30' prior: 33575210!commentForCurrentUpdate ^ '20068 Change sources file name for bootstrapped image	https://pharo.fogbugz.com/f/cases/20068'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/23/2017 11:30'!script60496	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.144.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.52.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.15.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.192.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.101.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.78.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.85.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.6.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2510.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.173.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.615.mczMorphic-Core-TheIntegrator.313.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.49.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.386.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.37.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.38.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/23/2017 11:30'!update60496	"self new update60496"	self withUpdateLog: '20068 Change sources file name for bootstrapped image	https://pharo.fogbugz.com/f/cases/20068'.	self loadTogether: self script60496 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60495!ScriptLoader removeSelector: #script60495!"ScriptLoader60"!!PharoBootstrapInitialization class methodsFor: 'public api' stamp: 'PavelKrivanek 5/18/2017 15:54' prior: 54387033!initializeCommandLineHandlerAndErrorHandling	"This method is run before the new bootstrapped image is saved!!"	ProcessorScheduler initialize.		Delay initialize.	SmallInteger initialize.		ProcessorScheduler startUp.		OSPlatform startUp: true.		"2 following lines are used to initialize Unicode tag constants.	Must be replaced by an uptodate version of Unicode class>>#initializeTagConstants and a call to it"	#(#Cc #Cf #Co #Cs #Ll #Lm #Lo #Lt #Lu #Mc #Me #Mn #Nd #Nl #No #Pc #Pd #Pe #Pf #Pi #Po #Ps #Sc #Sk #Sm #So #Zl #Zp #Zs)			doWithIndex: [ :each :index | Unicode classPool at: each put: index ].Unicode classPool at: #Cn put: 0.	UnicodeDefinitions initializeUnicodeClass.	EncodedCharSet initialize.	String initialize.	ByteString initialize. "needed by TextConverter to install LineEnd convention (called by Smalltalk openLog)"	ZnUTF8Encoder initialize.			"Weak array class initialization 2 lines"	Smalltalk specialObjectsArray at: 42 put: Semaphore new."to put in EPObjectSpace>>#createSpecialObjectsArray?"	WeakArray restartFinalizationProcess.		DiskStore useFilePlugin "initialize".	FileStream initialize.	FileStream classVarNamed: 'TheStdioHandles' put: FileStream stdioHandles. "FileStream startup"	ByteTextConverter initialize.	MultiByteFileStream initialize.	ASTCache default: ASTCache new. "ASTCache initialize, neeeded to print stack on error"	FileLocator startUp: true. "FileLocator initialize"	Smalltalk globals 		at: #Transcript		put: (NonInteractiveTranscript stdout install).	CompilationContext initialize.	Float initialize.	ZipConstants initialize.	ZipWriteStream initialize.	"Initialize classes related to compiler"	InflateStream initialize.	ByteTextConverter initialize.	ZipWriteStream initialize.	SetElement initialize.	ExternalSemaphoreTable initialize.	MacRomanTextConverter initialize.	Collection initialize.	ISOLanguageDefinition initialize.	CompiledMethod initialize.	MD5NonPrimitive initialize.	DangerousClassNotifier initialize.	Categorizer initialize.	Slot initialize.	CP1252TextConverter initialize.	SHA1 initialize.	TraitBehavior initialize.	RPackage initialize.	CompilationContext initialize.	OCASTTranslator initialize.	UIManager classVarNamed: 'Default' put: NonInteractiveUIManager new.	UIManager default activate.	Smalltalk sourceFileVersionString: 'PharoV60'.	(Smalltalk class classVariableNamed: 'LastImagePath') value: Smalltalk imagePath. "set the default value"	SourceFiles := SourceFileArray new ensureOpen. "needed to get source from a compiled method, used to log an error."	Smalltalk openSourceFiles.		BasicCommandLineHandler new activate. "BasicCommandLineHandler startUp:"	Processor terminateActive.! !"PharoBootstrap-Initialization"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.572.mcz') load.ScriptLoader new update60496.!----End fileIn----!----QUIT----2017-05-23T11:33:20.381382+02:00 Pharo.image priorSource: 40428!----QUIT----2017-05-23T11:33:30.825145+02:00 Pharo.image priorSource: 62354!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/23/2017 15:34' prior: 33595030!commentForCurrentUpdate ^ '20084 Highlight Message Send is not enabled by default in bootstrapped/reloaded image	https://pharo.fogbugz.com/f/cases/2008420072 Importing Resource Help needs improvement	https://pharo.fogbugz.com/f/cases/2007219809 Failing test: WeakAnnouncerTest>>#testNoDeadWeakSubscriptions	https://pharo.fogbugz.com/f/cases/19809'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/23/2017 15:34'!script60497	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.144.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.15.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.192.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.101.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.78.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.85.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2510.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.173.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.615.mczMorphic-Core-TheIntegrator.313.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.49.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.386.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.37.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.38.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/23/2017 15:34'!update60497	"self new update60497"	self withUpdateLog: '20084 Highlight Message Send is not enabled by default in bootstrapped/reloaded image	https://pharo.fogbugz.com/f/cases/2008420072 Importing Resource Help needs improvement	https://pharo.fogbugz.com/f/cases/2007219809 Failing test: WeakAnnouncerTest>>#testNoDeadWeakSubscriptions	https://pharo.fogbugz.com/f/cases/19809'.	self loadTogether: self script60497 merge: false.	(SystemAnnouncer uniqueInstance subscriptions glmSubscriptions select: [:sub | sub subscriber isNil]) do: #finalize. 3 timesRepeat: [Smalltalk garbageCollect ].	self flushCaches.! !ScriptLoader removeSelector: #update60496!ScriptLoader removeSelector: #script60496!"ScriptLoader60"!!ImportingResourceHelp class methodsFor: 'documentation' stamp: 'AlexandreBergel 5/19/2017 15:40' prior: 29378986!encodingAndDecoding	^ HelpTopic 		title: 'Encoding and Decoding'		contents: (self heading: 'Encoding and Decoding'),'The basic mechanism to encode and decode data is provided by the class Base64MimeConverter. Consider the following example:mimeEncoded := ''Hello World'' asByteArray base64Encoded.(Base64MimeConverter mimeDecodeToBytes: mimeEncoded readStream) contents asStringThe variable mimeEncoded contains an encoding of the Hello World string using the mime64 encoding. The method #mimeDecodeToBytes: reads mime64 strings from a stream. The example uses a string, but it could refers to any objects. You essentially need a ReadStream. '! !!ImportingResourceHelp class methodsFor: 'documentation' stamp: 'AlexandreBergel 5/19/2017 15:48'!encodingAndDecodingImage	^ HelpTopic 		title: 'Encoding and Decoding Image'		contents: (self heading: 'Encoding and Decoding Image'),'Embedding pictures in plan source code is often the reason why one need to encode resources. The following script loads an image located in the filesystem, create a string-friendly representation, and store it in a method. You probably want to keep the image in a class variable or a hash table.',(self bold: 'form := PNGReadWriter formFromStream: ''/Users/alexandrebergel/Dropbox/Screenshots/Screenshot 2017-05-19 15.25.44.png'' asFileReference readStream."Write the stream on a stream"w := WriteStream on: ByteArray new.PNGReadWriter putForm: form onStream: w.w contents."Convert the byteArray into mime 64. It takes less space in the image"encodedContent := w contents base64Encoded."The following code converts the stream content "PNGReadWriter formFromStream: (Base64MimeConverter mimeDecodeToBytes: encodedContent readStream)."We encode the image as a method"Object compile: ''imageSource  ^ '''',  encodedContent, ''''.Object compile: ''image ^ PNGReadWriter formFromStream: (Base64MimeConverter mimeDecodeToBytes: self imageSource readStream). ''."A better implementation is to cache the image in an instance or class variable""The following expression return the image initially encoded"Object new image '),''! !!ImportingResourceHelp class methodsFor: 'documentation' stamp: 'AlexandreBergel 5/19/2017 15:39' prior: 29378243!overview	^ HelpTopic 		title: 'Overview'		contents: (self heading: 'Overview'),'Non trivial applications often rely on resources that may be externally provided such as icons, pictures, sounds. Such resources are typically defined as external files. Naturally, you can make your application depends on external files, however, importing resource files within the Pharo image and make it integrally part of you code has a number of advantages:- you can simply deploy your application by downloading it from smalltalkhub. - having less dependencies on external files is always good to avoid technical subtilities such as file path containing weird characters. '! !!ImportingResourceHelp class methodsFor: 'accessing' stamp: 'AlexandreBergel 5/19/2017 15:40' prior: 29380828!pages	^#(overview encodingAndDecoding encodingAndDecodingImage)! !!BaselineOfIDE methodsFor: 'actions' stamp: 'PavelKrivanek 5/23/2017 12:47' prior: 18109028!additionalInitialization	self class environment at: #GTGenericStackDebugger ifPresent: [	  Smalltalk tools register: GTGenericStackDebugger as: #debugger.	  Smalltalk tools registeredDebuggersWithRanks.	  Smalltalk tools debuggers add: ((self class environment at: #GTGenericStackDebugger)->3).	  Smalltalk tools debuggers add: ((self class environment at: #GTSUnitDebugger)->70).	  Smalltalk tools debuggers add: ((self class environment at: #GTBytecodeDebugger)->5).].	  	self class environment at: #GTPlayground ifPresent: [:playground | 	  Smalltalk tools register: playground as: #workspace.].	self class environment at: #GTInspector ifPresent: [:inspector | 	  Smalltalk tools register: inspector as: #inspector.].	  Smalltalk tools register: ExternalChangesBrowser as: #changeList.	Smalltalk tools register: FileList as: #fileList.	Smalltalk tools register: Finder as: #finder.	Smalltalk tools register: ProcessBrowser as: #processBrowser.	Smalltalk tools register: RecentMessageList as: #recentMessageList.	Smalltalk tools register: SyntaxErrorDebugger as: #syntaxErrorDebugger.	Smalltalk tools register: TimeProfiler as: #timeProfiler.	(MorphicCoreUIManager classPool at: #UIProcess) ifNotNil: [ :proc | proc terminate ].	MorphicCoreUIManager classPool at: #UIProcess put: nil.	PolymorphSystemSettings desktopColor:  Color veryVeryLightGray lighter.	SourceCodeFonts setSourceCodeFonts: 10.	FreeTypeSystemSettings loadFt2Library: true.	FreeTypeSettings current monitorType: #LCD.	FreeTypeSettings current glyphContrast: 55.		CatalogSettings displayCatalogProjectsInSpotter: false.	RealEstateAgent usedStrategy: #cascadeFor:initialExtent:world:.	GrowlMorph position: #bottomLeft.	ShortcutReminder enabled: true.	self class environment at: #QASettings ifPresent: [:qaSettings |	  qaSettings nautilusPlugin: true].	KMRepository reset.	Morph shortcutsHandler: KMShortcutHandler new.	"because of Komitter"	MCSaveVersionDialog previousMessages add: String new.	RBProgramNode formatterClass: BIConfigurableFormatter.	Color flushCache.	ASTTransformExamplePluginActive recompile.	PharoCommandLineHandler recompile.	SmalltalkImage recompile.		RubCharacterScanner initialize.		RubAbstractTextArea highlightMessageSend: true.		Pharo3DarkTheme beCurrent.		Smalltalk ui theme settings secondarySelectionColor: (Color r: 0.31 g: 0.31 b: 0.36 alpha: 1.0).		3 timesRepeat: [		Smalltalk garbageCollect.		Undeclared removeUnreferencedKeys.].		self loadIceberg.! !"BaselineOfIDE"!"ImportingResource-Help"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.573.mcz') load.ScriptLoader new update60497.!----End fileIn----!----QUIT----2017-05-23T15:38:14.333294+02:00 Pharo.image priorSource: 62432!----QUIT----2017-05-23T15:38:24.907147+02:00 Pharo.image priorSource: 87995!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 6/1/2017 15:55' prior: 33617034!commentForCurrentUpdate ^ '20095 SystemProgressMorph should call doOneCycleNow on refresh only when active process is UIProcess	https://pharo.fogbugz.com/f/cases/2009520099 Cairo fonts crashing on 64bits	https://pharo.fogbugz.com/f/cases/20099'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 6/1/2017 15:55'!script60498	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.15.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.192.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.101.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.78.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.85.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2510.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.173.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.313.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.49.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.386.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.37.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.38.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 6/1/2017 15:55'!update60498	"self new update60498"	self withUpdateLog: '20095 SystemProgressMorph should call doOneCycleNow on refresh only when active process is UIProcess	https://pharo.fogbugz.com/f/cases/2009520099 Cairo fonts crashing on 64bits	https://pharo.fogbugz.com/f/cases/20099'.	self loadTogether: self script60498 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60497!ScriptLoader removeSelector: #script60497!"ScriptLoader60"!!SystemProgressMorph methodsFor: 'updating' stamp: 'DenisKudryashov 5/30/2017 18:12' prior: 63149702!refresh	"We may be blocking the UI thread, and thus have to draw the world ourselves when necessary"	lastRefresh := Time millisecondClockValue.	UIManager default uiProcess == Processor activeProcess		ifTrue: [ self currentWorld doOneCycleNow]! !!CairoFontFace class methodsFor: 'instance creation' stamp: 'EstebanLorenzano 6/1/2017 12:10' prior: 18768599!fromFreetypeFace: aFace	| handle cairoFace |		handle := aFace handle pointerAt: 1. 	cairoFace := self primFtFace: handle loadFlags: ( LoadNoHinting | LoadTargetLCD | LoadNoAutohint | LoadNoBitmap). 		^ cairoFace initializeWithFreetypeFace: aFace! !!CairoFontFace class methodsFor: 'instance creation' stamp: 'EstebanLorenzano 6/1/2017 12:10' prior: 18768082!primFtFace: aFace loadFlags: flags"cairo_font_face_t * cairo_ft_font_face_create_for_ft_face                                                        (FT_Face face,                                                         int load_flags);"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>		^ self nbCall: #( CairoFontFace cairo_ft_font_face_create_for_ft_face(void * aFace , int flags )) ! !!CairoScaledFont class methodsFor: 'instance creation' stamp: 'EstebanLorenzano 6/1/2017 12:09' prior: 18799108!fromFreetypeFont: aFont	| ftFace face |	^ CairoBackendCache soleInstance at: aFont ifAbsentPut: [ | emphasis |			emphasis := aFont simulatedEmphasis.			ftFace := aFont face.			face := CairoBackendCache soleInstance 				at: {ftFace.	emphasis} 				ifAbsentPut: [ | cff |					cff := CairoFontFace fromFreetypeFace: ftFace.					emphasis ifNotNil: [ cff synthesizeEmphasis: emphasis ].					cff ].			self fromFreetypeFont: aFont cairoFace: face ]! !!AthensCairoMatrix class methodsFor: 'field definition' stamp: 'EstebanLorenzano 6/1/2017 15:34' prior: 17537657!fieldsDesc	"self rebuildFieldAccessors"	^ #(   double sx; double shx;   double shy; double sy;   double x; double y;	)! !!SystemProgressItemMorph methodsFor: 'private' stamp: 'DenisKudryashov 5/30/2017 18:12' prior: 63145033!refresh	lastRefresh := Time millisecondClockValue.	UIManager default uiProcess == Processor activeProcess		ifTrue: [ self currentWorld doOneCycleNow ]! !"Athens-Cairo"!"Morphic-Base"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.574.mcz') load.ScriptLoader new update60498.!----End fileIn----!----QUIT----2017-06-01T15:57:07.284048+02:00 Pharo.image priorSource: 88073!----QUIT----2017-06-01T15:57:17.746509+02:00 Pharo.image priorSource: 109737!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 6/6/2017 15:11' prior: 33642674!commentForCurrentUpdate ^ '20102 SmallInteger>>#digitAt: not ready for 64-bit - Some Kernel-Tests-Numbers fail to take 64-bit into account	https://pharo.fogbugz.com/f/cases/2010220070 terminal color not reset after a error message	https://pharo.fogbugz.com/f/cases/2007019949 ensureEndsWith: does not handle start of stream case	https://pharo.fogbugz.com/f/cases/1994920101 Typos and general writing of release welcome text	https://pharo.fogbugz.com/f/cases/20101'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 6/6/2017 15:11'!script60499	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.194.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.103.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.78.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.85.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2513.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.175.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.313.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.386.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.37.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.38.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 6/6/2017 15:11'!update60499	"self new update60499"	self withUpdateLog: '20102 SmallInteger>>#digitAt: not ready for 64-bit - Some Kernel-Tests-Numbers fail to take 64-bit into account	https://pharo.fogbugz.com/f/cases/2010220070 terminal color not reset after a error message	https://pharo.fogbugz.com/f/cases/2007019949 ensureEndsWith: does not handle start of stream case	https://pharo.fogbugz.com/f/cases/1994920101 Typos and general writing of release welcome text	https://pharo.fogbugz.com/f/cases/20101'.	self loadTogether: self script60499 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60498!ScriptLoader removeSelector: #script60498!"ScriptLoader60"!!WelcomeHelp class methodsFor: 'pages' stamp: 'PhilippeBack 6/1/2017 18:10' prior: 84508630!changeLog	^ HelpTopic 		title: 'ChangeLog'		contents: (self heading: 'Highlights (aka New Stuff) in Pharo 6.0'),'- The PharoVM and image are also provided in a 64-bit version in Linux and macOS/OSX and bring even better performance and stability- A new code changes management system named Epicea for reviewing and recovering of your code easily- Integrated support for Git through an easy-to-use tool for repositories and commits management named Iceberg (as a preview in Pharo 6, it will be the default in Pharo 7)- The unified foreign function interface (UnifiedFFI) for interfacing with the outside world is significantly improved- The PharoVM is now part of OpenSmalltalk initiative- Introduction of object immutability, alternative bytecode sets and block closures independent of outer context- Pharo can now be bootstrapped from source code managed by Git- Pharo modularity is improved- Pharo is faster- The Dark Theme was improved and set as default color theme of Pharo', (self heading: 'All Issues'), 'Over 1400 fixes and enhancements were integrated in this release.As the complete list of fixed issues is too large to be placed here, you can review it on the FogBugz issue tracker (', (self url: 'https://pharo.fogbugz.com'), ') (requires account).', (self subheading: 'Tools'),'- Epicea provides a code changes manager- Iceberg provides a Git repositories manager- GTInspector, GTDebugger and other tools are now based on FastTable (long lists of items are rendered much faster)- GToolkit and GTools have been updated- Quality Assistant has been improved- Interrupt key (Cmd+ /, Ctrl+.) has been made more reliable- Playground variables are now visible from debugger- Debugger temp names mapping is fixed- There is a "Close all debuggers"  in the taskbar context menu- GTDebugger has a "Run to here" feature- Results and critiques can be filtered in the MessageBrowser- Dependency Analyzer has been improved- Nautilus enhancements        - Splitting of large variable entries in the Variables menu        - Deprecated methods are shown with strikethrough emphasis        - Abstract classes are shown in italics with a slight color adjustment', (self subheading: 'VM related'), '- 64-bits support- Improvement of host platforms management (32-bit/64-bit)- Improved UnifiedFFI- The PharoVM is now part of OpenSmalltalk initiative- Introduction of object immutability- Introduction of FullBlockClosure which will help in future evolutions of Pharo- Ephemerons support, introduction of the EphemeronRegistry- Support of alternative bytecode sets and introduction of Sista Encoder, the encoder for the SistaV1 bytecode set. This will be the bedrock on which Pharo will improve',(self subheading: 'Reflectivity'), '- General improvements- haltOnce is active by default per method. It does not require global turning on (enable haltOnce) and it is managed from the source code area in Nautilus- Execution counter for message nodes in the source code area in Nautilus- API for Metalinks on AST nodes- Mirror primitives (Those are reflection primitives which access object state without messaging them, see MirrorPrimitives class)- Inlined method const can be implemented by Metalinks', (self subheading: 'Other'), '- Dark Theme improvements- Improvement of theme change while windows are open- Support of two double quotes inside comments- Standalone Morphic worlds in separate windows- Fix of several memory leaks- Improvement of working directory structure (introduction of a ''pharo-local'' directory to include Pharo directories such as ''package-cache'')- Better autocategorization of methods- Introduction of a FuzzyMatcher for approximate string matching- Glamour integration in Spec- Renaming (Cmd+R / Ctrl+R) in Nautilus supports more AST nodes- anObject asMethodConst to cache expressions dynamically- GlobalIdentifier for computer identification- NeoUUIDGenerator replaces the old UUIDGenerator- STON was improved and is now used by Monticello FileTree- Storage of suspended announcements- Improved newAnonymousSubclass- Inheritable process specific variables- Fuel improvements- Enablement of <example> methods so that they can be executed easily- Support for <sampleInstance>- New class and method API for tags as replacement for categories and protocols- TabMorph improvements- Unification of Dictionary APIs (including an OrderedDictionary)- Package manifests improvements- Improvement of RadioButton groups', (self subheading: 'Cleanups'), '- Object>>#name is now deprecated and will be removed in Pharo 7- Better system modularization- Ability for the system to be fully bootstrapped from source code- Turn off of catalog search in Spotter by default (This improves the stability of Pharo when used with poor Internet connections)- Removal of Chroma-CubeHelix and TxWorkspace- Rename of Pragma>>#selector to Pragma>>#methodSelector- Improvement of icons management (#iconNamed: introduced in order to replace DNU-based icons)- Limit use of #asClass in order to rely on an environment- It is now possible to give a rewrite rule when deprecating a method to automatically rewrite code with deprecation (#deprecated:transformWith:)- Deprecation of the following:        Object>>name        ShortRunArray class        Object>>confirm:orCancel:        Object>>ifNil:ifNotNilDo:        Object>>ifNotNilDo:        Object>>ifNotNilDo:ifNil:        Collection>>ifEmpty:ifNotEmptyDo:        Collection>>ifNotEmptyDo:        Collection>>ifNotEmptyDo:ifEmpty:        SequenceableCollection>>copyLast:        Integer>>asBytesDescription        Pragma>>method:', (self subheading: 'Unit testing/Documentation'), '- RecursionStopper provides an easy way to check if we are in a recursion and execute code just once in a recursion- New process specific variable ''CurrentExecutionEnvironment'' with value DefaultExecutionEnvironment by default and TestExecutionEnvironment during a test run- SUnit is improved by introducing a time limit for tests, preventing "forked debuggers"- New assert extension to compare floats with #closeTo:- More class comments and documentation', (self subheading: 'Network'), '- Support Server Name Indication (SNI) in Zodiac/SSLPlugin- Zinc/Zodiac updateYou can see the Pharo 6.0 changelog at: ', (self url: 'https://github.com/pharo-project/pharo-changelogs/blob/master/Pharo60ChangeLogs.md')! !!WelcomeHelp class methodsFor: 'pages' stamp: 'PhilippeBack 6/1/2017 17:54' prior: 84516114!documentation	^ HelpTopic 		title: 'More Documentation'		contents: (self heading: 'More Documentation'), 			'The most important documentation is the one you can get by exploring the system, reading class comments and looking for examples. You can find "in image" help by clicking on the following expression:', (self doItFrom: 'HelpBrowser open.'), 'This browser is also accessible from the World>Help>Help Browser menu (just click the desktop, select Help, and then Help Browser).A compendium of Pharo documentation can be found at: ', (self url: 'http://pharo.org/documentation'), 'There you can find:- Pharo books: ', (self url: 'http://books.pharo.org'), '- Screencasts: ', (self url: 'https://www.youtube.com/channel/UCp3mNigANqkesFzdm058bvw'), '- Presentations: ', (self url: 'http://www.slideshare.net/pharoproject/')! !!WelcomeHelp class methodsFor: 'pages' stamp: 'PhilippeBack 6/1/2017 17:54' prior: 84519806!exploreEnvironment	^ HelpTopic 		title: 'Explore the Pharo Environment'		contents: (self heading: 'Explore the Pharo Environment'), 				'The best way to learn Pharo is to explore it by yourself. This is live objects all the way down: they can be inspected, browsed, changed... everything in the environment you have in your hands.But sometimes it can be hard to get started with the tools and capabilities the environment provides.The most complete and updated guide for the Pharo environment can be found in the "Updated Pharo by Example" free book. It is still a work in progress, but most of it is already done. You can find the book here: ', (self url: 'https://github.com/SquareBracketAssociates/UpdatedPharoByExample'), 'One chapter of particular interest is the one that provides a quick tour of the environment: ', (self url: 'https://ci.inria.fr/pharo-contribution/job/UpdatedPharoByExample/lastSuccessfulBuild/artifact/book-result/PharoTour/PharoTour.pdf')! !!WelcomeHelp class methodsFor: 'pages' stamp: 'PhilippeBack 6/1/2017 17:55' prior: 84515442!gettingHelp	^ HelpTopic 		title: 'Getting Help'		contents: (self heading: 'Getting Help'),		'Pharo has a vibrant community that shares knowledge in different ways: - The "Pharo Users" mailing list: 	', (self url: 'http://lists.pharo.org/mailman/listinfo/pharo-users_lists.pharo.org'), '- The "Pharo Discord channel": 	', 	(self url: 'http://discord.gg/Sj2rhxn'), '- The "Pharo IRC Channel": 	', (self url: 'irc.freenode.net, #pharo channel '), 'You can find more information, lists to browse/suscribe and places to share code at: ', (self url: 'http://pharo.org/community')! !!WelcomeHelp class methodsFor: 'pages' stamp: 'PhilippeBack 6/1/2017 18:11' prior: 84518270!learn	^ HelpTopic 		title: 'Learn Pharo'		contents: (self heading: 'Learn Pharo'), 		'You can learn Pharo by clicking on the following expression: 	', (self doItFrom: 'ProfStef go.'), (self subheading: 'MOOC'), 'Pharo has an excellent MOOC (Massive Open Online Course). You can find more information here: ', (self url: 'http://mooc.pharo.org'), (self subheading: 'Books'), 'There are several free Pharo books that can be download here: ', (self url: 'http://books.pharo.org'), 'A very interesting starting point would be looking into the "Updated Pharo by Example" free book. It is still a work in progress, but most of it is already done. You can find the book here: ', (self url: 'https://github.com/SquareBracketAssociates/UpdatedPharoByExample'), ''! !!WelcomeHelp class methodsFor: 'showing' stamp: 'PhilippeBack 6/1/2017 17:23' prior: 84517046!open	<script>	^ (HelpBrowser openOn: self) next! !!WelcomeHelp class methodsFor: 'showing' stamp: 'PhilippeBack 6/1/2017 17:24' prior: 84515001!openForRelease	<script>	| browser window findBlock |		findBlock := [ :each | (each isKindOf: SystemWindow) and: [ each label = self bookName ] ]. 	World submorphs 		detect: findBlock 		ifFound: [ :oldWindow | oldWindow delete ].	browser := self open.	window := browser dependents detect: findBlock.	window extent: 700@400.	window center: Display extent / 2! !!WelcomeHelp class methodsFor: 'pages' stamp: 'PhilippeBack 6/1/2017 18:13' prior: 84517171!useExternalPackages	^ HelpTopic 		title: 'Using Eternal Packages'		contents: (self heading: 'Using External Packages'), 'Pharo already comes pre-loaded with a rich set of packages that you can use to explore the system and develop your own applications. However there is also a huge library of user contributed projects that you can also load using the "Catalog Browser". To open it click on the following expression:		', (self doItFrom: 'CatalogBrowser open.'), 'This browser is also accessible from the World>Tools>Catalog Browser menu (just click the desktop, select Tools, and then Catalog Browser).Catalog projects can be browsed online: ', (self url: 'http://catalog.pharo.org'), 'You can also a rough list (not very friendly) of many packages available stored in smalltalkhub repository:', (self url: 'http://smalltalkhub.com/list'), '(this list is not a compendium of packages for Pharo but is a good place to start looking for something in particular and which happens to not be present in the catalog).The catalog can be enabled in Spotter by enabling the "Display catalog projects in Spotter" system preference.'! !!WelcomeHelp class methodsFor: 'pages' stamp: 'PhilippeBack 6/1/2017 17:58' prior: 84519159!welcome	^ HelpTopic 		title: 'Welcome to Pharo 6.0'		contents: (self heading: 'Pharo 6.0'), 		'Welcome to Pharo, an immersive live programming environment.Pharo is a pure object-oriented programming language and a powerful environment, focused on simplicity and immediate feedback (think IDE and OS rolled into one).For more information, please visit here: ', (self url: 'http://pharo.org'),(self subheading: 'Color themes'),'White theme: ', (self doItFrom: 'Pharo3Theme beCurrent. '), ' Dark theme: ', (self doItFrom: 'Pharo3DarkTheme beCurrent. ').! !!WriteStreamTest methodsFor: 'tests' stamp: 'KKSubbu 6/2/2017 21:03' prior: 84725775!testEnsureEndsWith	"self debug: #testEnsureEndsWith"	| stream |	stream := self newStream.	stream nextPutAll: 'this is a test'.	stream ensureEndsWith: Character cr.	stream nextPutAll: 'for WriteStreamTest'.	self assert: stream contents equals: (('this is a test' copyWith: Character cr), 'for WriteStreamTest').		"Manually put a new line and verify there are no 2 new lines"	stream := self newStream.	stream nextPutAll: ('this is a test' copyWith: Character cr).	stream ensureEndsWith: Character cr.	stream nextPutAll: 'for WriteStreamTest'.	self assert: stream contents equals: (('this is a test' copyWith: Character cr), 'for WriteStreamTest').		"Test with a empty stream"	stream := self newStream.	stream ensureEndsWith: Character cr.	self assert: stream contents equals: ''.! !!IntegerTest methodsFor: 'tests - bitLogic' stamp: 'SvenVanCaekenberghe 6/1/2017 20:45' prior: 29635981!testBitString	"self debug: #testBitString"		Smalltalk vm wordSize = 4		ifTrue: [			self assert: 2 bitString equals: '0000000000000000000000000000010'.			self assert: -1 bitString equals: '1111111111111111111111111111111'.			self assert: -2 bitString equals: '1111111111111111111111111111110'.			self assert: 2 bitStringLength equals: 31 ]. 	Smalltalk vm wordSize = 8		ifTrue: [			self assert: 2 bitString equals: '0000000000000000000000000000000000000000000000000000000000010'.			self assert: -1 bitString equals: '1111111111111111111111111111111111111111111111111111111111111'.			self assert: -2 bitString equals: '1111111111111111111111111111111111111111111111111111111111110'.			self assert: 2 bitStringLength equals: 61 ]. 	"32 minus 1 for immediate encoding = 31 = 30 for number + 1 for sign"	"64 minus 3 for immediate encoding = 61 = 60 for number + 1 for sign"	self assert: 2 bitStringLength equals: (SmallInteger maxVal highBit + 1).! !!IntegerTest methodsFor: 'tests - instance creation' stamp: 'SvenVanCaekenberghe 6/1/2017 21:07' prior: 29639619!testCreationFromBytes1	"self run: #testCreationFromBytes1"	"it is illegal for a LargeInteger to be less than SmallInteger maxVal." 	"here we test that Integer>>byte!!byte2:byte3:byte4: resconstructs SmallInteger maxVal as an instance of SmallInteger. "  	| maxSmallInt hexString byte1 byte2 byte3 byte4 builtInteger |	Smalltalk vm wordSize = 4 ifFalse: [ ^ self skip ].	maxSmallInt := SmallInteger maxVal.	hexString := maxSmallInt printStringHex.	self assert: hexString size = 8.	byte4 := Number readFrom: (hexString copyFrom: 1 to: 2) base: 16.	byte3 := Number readFrom: (hexString copyFrom: 3 to: 4) base: 16.	byte2 := Number readFrom: (hexString copyFrom: 5 to: 6) base: 16.	byte1 := Number readFrom: (hexString copyFrom: 7 to: 8) base: 16.	builtInteger := Integer byte1: byte1 byte2: byte2 byte3: byte3 byte4: byte4.	self assert: builtInteger = maxSmallInt.	self assert: builtInteger class = SmallInteger! !!IntegerTest methodsFor: 'tests - instance creation' stamp: 'SvenVanCaekenberghe 6/1/2017 21:07' prior: 29640579!testCreationFromBytes2 	"self run: #testCreationFromBytes2"	"it is illegal for a LargeInteger to be less than SmallInteger maxVal." 	"here we test that Integer>>byte!!byte2:byte3:byte4: resconstructs (SmallInteger maxVal + 1) as an instance of LargePositiveInteger. "	| maxSmallInt hexString byte1 byte2 byte3 byte4 builtInteger |	Smalltalk vm wordSize = 4 ifFalse: [ ^ self skip ].	maxSmallInt := SmallInteger maxVal.	hexString := (maxSmallInt + 1) printStringHex.	self assert: hexString size = 8.	byte4 := Number readFrom: (hexString copyFrom: 1 to: 2) base: 16.	byte3 := Number readFrom: (hexString copyFrom: 3 to: 4) base: 16.	byte2 := Number readFrom: (hexString copyFrom: 5 to: 6) base: 16.	byte1 := Number readFrom: (hexString copyFrom: 7 to: 8) base: 16.	builtInteger := Integer byte1: byte1 byte2: byte2 byte3: byte3 byte4: byte4.	self assert: builtInteger = (maxSmallInt + 1).	self deny: builtInteger class = SmallInteger! !!IntegerTest methodsFor: 'tests - instance creation' stamp: 'SvenVanCaekenberghe 6/1/2017 21:07' prior: 29625524!testCreationFromBytes3	"self run: #testCreationFromBytes3"	"it is illegal for a LargeInteger to be less than SmallInteger maxVal." 	"here we test that Integer>>byte!!byte2:byte3:byte4: resconstructs (SmallInteger maxVal - 1) as an instance of SmallInteger. "	| maxSmallInt hexString byte1 byte2 byte3 byte4 builtInteger |	Smalltalk vm wordSize = 4 ifFalse: [ ^ self skip ].	maxSmallInt := SmallInteger maxVal.	hexString := (maxSmallInt - 1) printStringHex.	self assert: hexString size = 8.	byte4 := Number readFrom: (hexString copyFrom: 1 to: 2) base: 16.	byte3 := Number readFrom: (hexString copyFrom: 3 to: 4) base: 16.	byte2 := Number readFrom: (hexString copyFrom: 5 to: 6) base: 16.	byte1 := Number readFrom: (hexString copyFrom: 7 to: 8) base: 16.	builtInteger := Integer byte1: byte1 byte2: byte2 byte3: byte3 byte4: byte4.	self assert: builtInteger = (maxSmallInt - 1).	self assert: builtInteger class = SmallInteger! !!VTermOutputDriver methodsFor: 'coloring' stamp: 'kks 5/19/2017 19:58' prior: 84236066!errorColor 	self red! !!STCommandLineHandler class methodsFor: 'printing' stamp: 'kks 5/19/2017 20:01' prior: 59101401!printCompilerWarning: aSyntaxErrorNotification	| stderr position contents errorLine errorMessage maxLineNumberSize lineNumber |		"format the error"	position := aSyntaxErrorNotification location.	contents := aSyntaxErrorNotification errorCode.	errorLine := contents lineNumberCorrespondingToIndex: position.	stderr := VTermOutputDriver stderr.			"first gather the error title to be able to underline it properly"	errorMessage := String streamContents: [ :s|		s nextPutAll: 'Syntax Error on line '; 			print: errorLine; nextPutAll: ': '; 			print: aSyntaxErrorNotification errorMessage].		 stderr red;		nextPutAll: errorMessage; lf;		nextPutAll: ('' padLeftTo: errorMessage size with: $=); lf;		clear.		"print each source line and mark the found syntax error"	maxLineNumberSize := contents lines size asString size.	lineNumber := 0.	contents lineIndicesDo: [:start :endWithoutDelimiters :end |		lineNumber := lineNumber + 1.		lineNumber == errorLine ifTrue: [ stderr errorColor ].		"0 pad the line numbers to the same size"		stderr 			nextPutAll: (lineNumber asString padLeftTo: maxLineNumberSize with: $0);			nextPutAll: ': ';			nextPutAll: (contents copyFrom: start to: endWithoutDelimiters);			lf.			"print the marker under the error line"		(lineNumber == errorLine)			ifTrue: [					stderr nextPutAll:( '_^_' padLeftTo: position - start + maxLineNumberSize + 4);							 lf;							 clear]	]! !!PharoWelcomePage class methodsFor: 'opening' stamp: 'PhilippeBack 6/1/2017 17:22' prior: 54501828!open	<script>	| group welcome help zen about window |	welcome := WelcomeHelp open.	help := HelpBrowser open.	zen := TextModel new			text: ProfStef pharoZenValuesContents;			title: 'Pharo Zen';			aboutText: ProfStef aboutPharoZen;			beForText;			openWithSpec.				about := TextModel new			text: Smalltalk systemInformationString withCRs;			title: 'About Pharo';			beForText;			openWithSpec.	group := GroupWindowMorph new.	group addWindow: welcome window.	group addWindow: help window.	group addWindow: SettingBrowser open.	group addWindow: KeymapBrowser new openWithSpec window.	group addWindow: zen window.	group addWindow: about window.	window := (group openInWindowLabeled: self title translated)		extent: welcome window extent;		yourself.			group tabGroup selectedPageIndex: 1.	^ window! !!PharoWelcomePage class methodsFor: 'opening' stamp: 'PhilippeBack 6/1/2017 17:22' prior: 54502733!openForRelease	<script>	| window |		World submorphs 		detect: [ :each | (each isKindOf: SystemWindow) and: [ each label = self title ] ] 		ifFound: [ :oldWindow | oldWindow delete ].	window := self open.	window extent: 750@400.	window center: Display extent / 2! !!SmallIntegerTest methodsFor: 'tests - Class Methods' stamp: 'SvenVanCaekenberghe 6/1/2017 20:03' prior: 60216021!testMaxVal	Smalltalk vm wordSize = 4		ifTrue: [ self assert: SmallInteger maxVal = 16r3FFFFFFF ].	Smalltalk vm wordSize = 8		ifTrue: [ self assert: SmallInteger maxVal = 16rFFFFFFFFFFFFFFF ]! !!SmallIntegerTest methodsFor: 'tests - Class Methods' stamp: 'SvenVanCaekenberghe 6/1/2017 20:04' prior: 60215871!testMinVal	Smalltalk vm wordSize = 4		ifTrue: [ self assert: SmallInteger minVal = -16r40000000 ].	Smalltalk vm wordSize = 8		ifTrue: [ self assert: SmallInteger minVal = -16r1000000000000000 ]! !!SmallIntegerTest methodsFor: 'tests - printing' stamp: 'SvenVanCaekenberghe 6/1/2017 20:08' prior: 60217483!testPrintString	self assert: 1 printString equals: '1'.	self assert: -1 printString equals: '-1'.	Smalltalk vm wordSize = 4		ifTrue: [ 			self assert: SmallInteger minVal printString equals: '-1073741824'.			self assert: SmallInteger maxVal printString equals: '1073741823' ].	Smalltalk vm wordSize = 8		ifTrue: [ 			self assert: SmallInteger minVal printString equals: '-1152921504606846976'.			self assert: SmallInteger maxVal printString equals: '1152921504606846975' ].	self assert: 12345 printString equals: '12345'.	self assert: -54321 printString equals: '-54321'.		self assert: 0 decimalDigitLength equals: 1.	self assert: 4 decimalDigitLength equals: 1.	self assert: 12 decimalDigitLength equals: 2.	self assert: 123 decimalDigitLength equals: 3.	self assert: 1234 decimalDigitLength equals: 4.	self assert: 56789 decimalDigitLength equals: 5.	self assert: 657483 decimalDigitLength equals: 6.	self assert: 6571483 decimalDigitLength equals: 7.	self assert: 65174383 decimalDigitLength equals: 8.	self assert: 625744831 decimalDigitLength equals: 9.	self assert: 1000001111 decimalDigitLength equals: 10.	Smalltalk vm wordSize = 4		ifTrue: [ self assert: SmallInteger maxVal decimalDigitLength equals: 10 ].	Smalltalk vm wordSize = 8		ifTrue: [ self assert: SmallInteger maxVal decimalDigitLength equals: 19 ].! !!SmallInteger methodsFor: 'system primitives' stamp: 'SvenVanCaekenberghe 6/2/2017 09:42' prior: 60213036!digitAt: n	"Answer the value of an apparent byte-indexable field in the receiver,	 analogous to the large integers, which are organized as bytes."	n = 1		ifTrue: [ 			"Negate carefully in case the receiver is SmallInteger minVal"			^ self < 0				ifTrue: [ -256 - self bitAnd: 255 ]				ifFalse: [ self bitAnd: 255 ] ].	^ self < 0		ifTrue: [ (-256 - self bitShift: -8) + 1 digitAt: n - 1 ]		ifFalse: [ (self bitShift: 8 - (n bitShift: 3)) bitAnd: 255 ]! !!WriteStream methodsFor: 'accessing' stamp: 'kks 4/18/2017 22:42' prior: 84716398!ensureEndsWith: anObject	"Append anObject to the receiver IFF it is non-empty and there is not one on the end."	(position == 0 or: [(collection at: position) = anObject]) ifTrue: [^self].	self nextPut: anObject! !"CodeImportCommandLineHandlers"!"Collections-Streams"!"Collections-Tests"!"Kernel"!"Kernel-Tests"!"Pharo-Help"!"System-CommandLine"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.575.mcz') load.ScriptLoader new update60499.!----End fileIn----!----QUIT----2017-06-06T15:14:03.768117+02:00 Pharo.image priorSource: 109815!----QUIT----2017-06-06T15:14:14.551317+02:00 Pharo.image priorSource: 153371!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 6/13/2017 17:20' prior: 33664417!commentForCurrentUpdate ^ '20146 ZnHTTPSTests>>#testGetPharoVersion started to fail	https://pharo.fogbugz.com/f/cases/20146'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 6/13/2017 17:20'!script60500	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.194.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.103.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.78.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.85.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2513.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.175.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.313.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.386.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.37.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.40.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 6/13/2017 17:20'!update60500	"self new update60500"	self withUpdateLog: '20146 ZnHTTPSTests>>#testGetPharoVersion started to fail	https://pharo.fogbugz.com/f/cases/20146'.	self loadTogether: self script60500 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60499!ScriptLoader removeSelector: #script60499!"ScriptLoader60"!!ZnHTTPSTests methodsFor: 'testing' stamp: 'PavelKrivanek 6/13/2017 16:53' prior: 85303548!testGetPharoVersion	| client lastBuildVersion version |	self ensureSocketStreamFactory.	self isNativeSSLPluginPresent ifFalse: [ ^ self ].	self runningOnWindowsInriaCI ifTrue: [ ^ self ].	lastBuildVersion := (client := ZnClient new)		beOneShot;		get: 'https://ci.inria.fr/pharo/job/Pharo-6.0/lastSuccessfulBuild/api/xml?xpath=/*/fullDisplayName'.	self assert: client isSuccess.	self assert: (client response contentType matches: ZnMimeType applicationXml).	self assert: client response contentLength > 0.	self assert: lastBuildVersion notNil.	self assert: lastBuildVersion isString.	self assert: lastBuildVersion size > 0.	version := (lastBuildVersion copyAfter: $>) copyUpTo: $<.	self deny: version isEmpty! !"Zinc-Zodiac"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.576.mcz') load.ScriptLoader new update60500.!----End fileIn----!----QUIT----2017-06-14T09:44:11.413887+02:00 Pharo.image priorSource: 153450!----QUIT----2017-06-14T09:44:21.849899+02:00 Pharo.image priorSource: 173343!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 6/14/2017 14:17' prior: 33708053!commentForCurrentUpdate ^ '20093 Missing source stamp makes changes hard to view	https://pharo.fogbugz.com/f/cases/2009320148 transforming deprecations should take #showWarning into account	https://pharo.fogbugz.com/f/cases/20148'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 6/14/2017 14:18'!script60501	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.194.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.103.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.78.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.85.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2515.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.175.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.313.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.388.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.37.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.40.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 6/14/2017 14:18'!update60501	"self new update60501"	self withUpdateLog: '20093 Missing source stamp makes changes hard to view	https://pharo.fogbugz.com/f/cases/2009320148 transforming deprecations should take #showWarning into account	https://pharo.fogbugz.com/f/cases/20148'.	self loadTogether: self script60501 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60500!ScriptLoader removeSelector: #script60500!"ScriptLoader60"!!VersionBrowser methodsFor: 'accessing' stamp: 'akevalion 6/2/2017 12:19' prior: 84263674!displayStringsFor: aMethodVersion	| author version cleanStampParts |		"a stamp is a string in the form  'GuillermoPolito 3/4/2015 14:33'"	"It may be incomplete, empty or even start with spaces."	cleanStampParts := aMethodVersion stamp trim substrings.		author := cleanStampParts ifEmpty: [ '<missing>' ] ifNotEmpty: [ :parts | parts first ].	version := cleanStampParts ifEmpty: [ '<missing>' ] ifNotEmpty: [ :parts | parts allButFirst joinUsing: ' ' ].		^ {author.	version.	(aMethodVersion realClass name).	(aMethodVersion selector).	('{' , aMethodVersion category , '}')}! !!Deprecation class methodsFor: 'logging' stamp: 'MarcusDenker 6/14/2017 10:12' prior: 22471619!deprecationsWhile: aBlock	"returns a log of all deprecated methods seen while executing aBlock"	| oldLog result |	oldLog := Log.	Log := Set new.	aBlock value.	result := Log.	oldLog ifNotNil: [oldLog addAll: result].	Log := oldLog.	^result! !!Deprecation class methodsFor: 'class initialization' stamp: 'MarcusDenker 6/14/2017 10:11' prior: 22471111!initialize	Log := nil "#deprecationsWhile: logs all deprecations here"! !!Deprecation class methodsFor: 'settings' stamp: 'MarcusDenker 6/14/2017 10:12' prior: 22471882!raiseWarning	"If true, then a dialog is popup for each deprecated method invocation"	^ RaiseWarning ifNil: [RaiseWarning := true]! !!Deprecation class methodsFor: 'settings' stamp: 'MarcusDenker 6/14/2017 10:12' prior: 22471221!showWarning	"If true, then a message is send to the Transcript for each deprecated method invocation"	^ ShowWarning ifNil: [ShowWarning := true]! !!Deprecation methodsFor: 'handling' stamp: 'MarcusDenker 6/14/2017 09:49' prior: 22467842!transform	| node rewriteRule aMethod |	self raiseWarning ifFalse: [ ^ self ]. "when desprecations are disables, we do not want to transform, either"	self rewriterClass ifNil:[ ^ self signal ].	aMethod := self contextOfSender method.	aMethod isDoIt ifTrue:[^ self]. "no need to transform doits"	node := self contextOfSender sourceNodeExecuted.	rewriteRule := self rewriterClass new 		replace: rule key with: rule value.	(rewriteRule executeTree: node)		ifFalse: [ ^ self ].	node replaceWith: rewriteRule tree. 	Author 		useAuthor: 'AutoDeprecationRefactoring'		during: [aMethod origin compile: aMethod ast formattedCode classified: aMethod protocol].		Log 		ifNotNil: [:log | log add: self].	self logTranscript! !"Kernel"!"Spec-Tools"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.577.mcz') load.ScriptLoader new update60501.!----End fileIn----!----QUIT----2017-06-14T14:20:25.717131+02:00 Pharo.image priorSource: 173422!----QUIT----2017-06-14T14:20:36.169244+02:00 Pharo.image priorSource: 195237!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 6/23/2017 14:15' prior: 33728025!commentForCurrentUpdate ^ '20110 AllocationTest>>#testOutOfMemorySignal not well suited to 64-bit	https://pharo.fogbugz.com/f/cases/2011020096 Add script pragma to SpaceTally>>printSpaceAnalysis	https://pharo.fogbugz.com/f/cases/2009620174  In the debug halo of a morph: clicking on "inspect morph" and "explore morph" bring up the same window.	https://pharo.fogbugz.com/f/cases/20174'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 6/23/2017 14:15'!script60502	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.194.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.103.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.78.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.85.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2515.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.177.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.315.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.388.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.39.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.40.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 6/23/2017 14:15'!update60502	"self new update60502"	self withUpdateLog: '20110 AllocationTest>>#testOutOfMemorySignal not well suited to 64-bit	https://pharo.fogbugz.com/f/cases/2011020096 Add script pragma to SpaceTally>>printSpaceAnalysis	https://pharo.fogbugz.com/f/cases/2009620174  In the debug halo of a morph: clicking on "inspect morph" and "explore morph" bring up the same window.	https://pharo.fogbugz.com/f/cases/20174'.	self loadTogether: self script60502 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60501!ScriptLoader removeSelector: #script60501!"ScriptLoader60"!!SpaceTally class methodsFor: 'fileout' stamp: 'MarcusDenker 6/22/2017 15:39' prior: 62052990!printSpaceAnalysis		<script>	self new printSpaceAnalysis! !!Morph methodsFor: 'debug and other' stamp: 'MarcusDenker 6/22/2017 15:34' prior: 51484071!buildDebugMenu: aHand	"Answer a debugging menu for the receiver. 	 The hand argument is seemingly historical and plays no role presently"	| aMenu |	aMenu := UIManager default newMenuIn: self for: self.	(self hasProperty: #errorOnDraw)		ifTrue: [ aMenu add: 'start drawing again' selector: #resumeAfterDrawError ].	(self hasProperty: #drawError)		ifTrue: [ aMenu add: 'debug drawing error' selector: #debugDrawError.			aMenu addLine ].	(self hasProperty: #errorOnStep)		ifTrue: [ aMenu add: 'start stepping again' selector: #resumeAfterStepError.			aMenu addLine ].	aMenu add: 'inspect morph' selector: #inspectInMorphic:.	aMenu lastItem		icon: (self iconNamed: #smallInspectItIcon).	aMenu add: 'inspect owner chain' selector: #inspectOwnerChain.	aMenu lastItem		icon: (self iconNamed: #smallInspectItIcon).	self isMorphicModel		ifTrue: [ aMenu add: 'inspect model' target: self model selector: #inspect.			aMenu lastItem				icon: (self iconNamed: #smallInspectItIcon) ].	aMenu addLine.	aMenu		add: 'browse morph class'		target: self		selector: #browseHierarchy.	self isMorphicModel		ifTrue: [ aMenu				add: 'browse model class'				target: self model				selector: #browseHierarchy ].	^ aMenu! !AllocationTest removeSelector: #testOutOfMemorySignal!"Kernel-Tests"!"Morphic-Core"!"Tool-Profilers"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.578.mcz') load.ScriptLoader new update60502.!----End fileIn----!----QUIT----2017-06-26T14:11:01.865402+02:00 Pharo.image priorSource: 195316!----QUIT----2017-06-26T14:11:13.050177+02:00 Pharo.image priorSource: 216495!----QUIT----2017-06-28T07:15:11.489762+02:00 Pharo.image priorSource: 216574!----QUIT----2017-06-28T07:15:18.88258+02:00 Pharo.image priorSource: 216653!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 6/28/2017 17:06' prior: 33749919!commentForCurrentUpdate ^ '20167 Regression with PNGReaderWriter in P6	https://pharo.fogbugz.com/f/cases/2016720198 inner structure access does not work on multiple architecture	https://pharo.fogbugz.com/f/cases/20198'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 6/28/2017 17:06'!script60503	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.194.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.103.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.80.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.87.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2515.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.177.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.315.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.388.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.39.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.40.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 6/28/2017 17:06'!update60503	"self new update60503"	self withUpdateLog: '20167 Regression with PNGReaderWriter in P6	https://pharo.fogbugz.com/f/cases/2016720198 inner structure access does not work on multiple architecture	https://pharo.fogbugz.com/f/cases/20198'.	self loadTogether: self script60503 merge: false.	self loadConfiguration: 'UnifiedFFI' version: '0.26.8'.self flushCaches.! !ScriptLoader removeSelector: #update60502!ScriptLoader removeSelector: #script60502!"ScriptLoader60"!!PNGReadWriterTest methodsFor: 'tests - decoding' stamp: 'dtl 6/18/2017 17:07'!testNewFromSampleBytes	"Based on a problem report by Hilaire Fernandes, this fails on 64 bit Spur if a	synthesized LargeInteger parameter to Bitmap #at:put: is not normalized prior	to calling the primitive. See problem report at	http://lists.pharo.org/pipermail/pharo-users_lists.pharo.org/2017-June/032660.html"	| sampleBytes png form |	sampleBytes := #[137 80 78 71 13 10 26 10 0 0 0 13 73 72		68 82 0 0 0 48 0 0 0 48 16 6 0 0 0 7 146 37 196 0 0 0 6 98 75 71 68 255		255 255 255 255 255 9 88 247 220 0 0 0 9 112 72 89 115 0 0 0 72 0 0 0 72		0 70 201 107 62 0 0 1 153 73 68 65 84 120 218 237 155 73 110 195 48 12		69 227 162 183 211 9 180 11 130 220 77 39 208 249 210 77 181 8 81 69 19		39 169 255 109 12 35 137 197 255 105 81 244 144 219 13 0 0 0 0 0 116 16		66 8 33 188 94 214 113 120 99 214 151 111 238 1 115 206 57 231 235 178		54 68 10 238 19 112 58 1 189 1 238 158 16 233 25 255 37 117 224 221 141		215 210 193 158 128 83 140 215 210 181 156 0 26 216 169 139 180 155 210		218 50 184 124 126 74 34 122 245 204 234 101 207 224 41 221 145 150 14		49 67 118 77 132 118 220 98 93 208 168 64 107 172 226 18 63 19 91 194		172 103 132 117 124 106 194 117 132 210 227 215 143 103 109 124 65 173 4		181 4 173 149 128 254 223 121 49 190 160 190 6 212 4 126 22 94 12 163 91		173 241 229 112 219 141 188 51 106 184 223 46 139 162 62 3 164 137 49		198 24 253 117 89 219 241 183 145 181 82 180 94 154 192 47 212 248 247		253 209 45 152 102 205 120 36 130 137 182 193 159 19 5 22 233 53 158 126		31 48 209 54 190 181 15 8 189 247 215 71 141 174 25 127 218 243 137 105		168 17 53 99 164 140 247 154 8 183 119 67 139 177 41 165 148 210 117 209		125 233 241 181 16 187 18 158 21 254 124 62 30 247 251 186 241 173 113		122 227 148 70 237 145 100 175 33 210 120 139 207 205 237 232 255 22 71		129 45 16 60 3 158 163 123 6 140 214 74 239 198 207 198 201 189 102 12		151 32 26 128 155 23 150 22 105 189 96 38 181 88 31 211 206 113 163 165		151 109 17 182 110 231 118 213 193 222 5 237 154 8 171 184 217 254 31		176 123 9 114 255 146 177 187 128 224 3 0 0 0 0 192 198 252 0 102 116 72		96 211 171 62 8 0 0 0 0 73 69 78 68 174 66 96 130].	png := PNGReadWriter on: sampleBytes readStream.	form := png nextImage.	self assert: Form equals: form class.! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'dtl 6/18/2017 15:04' prior: 53948907!copyPixelsRGB: y	"Handle non-interlaced RGB color mode (colorType = 2)"	| i pixel tempForm tempBits |	(transparentPixelValue isNil and: [ bitsPerChannel = 8 ]) ifTrue: [ "Do the same trick as in #copyPixelsRGBA:"		| targetIndex |		tempBits := ByteArray new: thisScanline size * 4 // 3 withAll: 16rFF.		tempForm := Form extent: width@1 depth: 32 bits: tempBits.		targetIndex := 1.		1 to: thisScanline size by: 3 do: [ :index |			tempBits				at: targetIndex put: (thisScanline at: index);				at: targetIndex + 1 put: (thisScanline at: index + 1);				at: targetIndex + 2 put: (thisScanline at: index + 2).			targetIndex := targetIndex + 4 ].		cachedDecoderMap 			ifNil:[cachedDecoderMap := self rgbaDecoderMapForDepth: depth].		(BitBlt toForm: form)			sourceForm: tempForm;			destOrigin: 0@y;			combinationRule: Form over;			colorMap: cachedDecoderMap;			copyBits.		^self ].	tempForm := Form extent: width@1 depth: 32.	tempBits := tempForm bits.	pixel := LargePositiveInteger new: 4.	pixel at: 4 put: 16rFF.	bitsPerChannel = 8		ifTrue:			[i := 1.			1 to: width do:				[ :x |				pixel					at: 3 put: (thisScanline at: i);					at: 2 put: (thisScanline at: i+1);					at: 1 put: (thisScanline at: i+2).				tempBits at: x put: pixel normalize.				i := i + 3].			transparentPixelValue				ifNotNil:					[1 to: width do: [ :x |						(tempBits at: x) = transparentPixelValue							ifTrue: [tempBits at: x put: 0]]]]		ifFalse:			[i := 1.			1 to: width do:				[ :x |				(transparentPixelValue == nil or: [(1 to: 6) anySatisfy: [:k | (transparentPixelValue digitAt: k) ~= (thisScanline at: i + 6 - k)]])					ifTrue:						[pixel							at: 3 put: (thisScanline at: i);							at: 2 put: (thisScanline at: i+2);							at: 1 put: (thisScanline at: i+4).						tempBits at: x put: pixel normalize]					ifFalse:						[tempBits at: x put: 0].				i := i + 6]].		tempForm displayOn: form at: 0@y rule: Form over.! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'dtl 6/18/2017 15:04' prior: 53957421!copyPixelsRGB: y at: startX by: incX	"Handle interlaced RGB color mode (colorType = 2)"	| i pixel tempForm tempBits xx loopsToDo |	tempForm := Form extent: width@1 depth: 32.	tempBits := tempForm bits.	pixel := LargePositiveInteger new: 4.	pixel at: 4 put: 16rFF.	loopsToDo := width - startX + incX - 1 // incX.	bitsPerChannel = 8		ifTrue:			[i := (startX // incX * 3) + 1.			xx := startX+1.			1 to: loopsToDo do:				[ :j |				pixel					at: 3 put: (thisScanline at: i);					at: 2 put: (thisScanline at: i+1);					at: 1 put: (thisScanline at: i+2).				tempBits at: xx put: pixel normalize.				i := i + 3.				xx := xx + incX].			transparentPixelValue				ifNotNil: [startX to: width-1 by: incX do: [ :x |					(tempBits at: x+1) = transparentPixelValue						ifTrue: [	tempBits at: x+1 put: 0]]]]		ifFalse:			[i := (startX // incX * 6) + 1.			xx := startX+1.			1 to: loopsToDo do:				[ :j |				(transparentPixelValue == nil or: [(1 to: 6) anySatisfy: [:k | (transparentPixelValue digitAt: k) ~= (thisScanline at: i + 6 - k)]])					ifTrue:						[pixel							at: 3 put: (thisScanline at: i);							at: 2 put: (thisScanline at: i+2);							at: 1 put: (thisScanline at: i+4).						tempBits at: xx put: pixel normalize.]					ifFalse:						[tempBits at: xx put: 0].				i := i + 6.				xx := xx + incX]].	tempForm displayOn: form at: 0@y rule: Form over.! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'dtl 6/18/2017 15:03' prior: 53944375!copyPixelsRGBA: y	"Handle non-interlaced RGBA color modes (colorType = 6)"	| i pixel tempForm tempBits ff |	bitsPerChannel = 8 ifTrue: [		ff := Form extent: width@1 depth: 32 bits: thisScanline.		cachedDecoderMap 			ifNil:[cachedDecoderMap := self rgbaDecoderMapForDepth: depth].		(BitBlt toForm: form)			sourceForm: ff;			destOrigin: 0@y;			combinationRule: Form over;			colorMap: cachedDecoderMap;			copyBits.		^self.	].	tempForm := Form extent: width@1 depth: 32.	tempBits := tempForm bits.	pixel := LargePositiveInteger new: 4.	i := -7.	0 to: width-1 do: [ :x |			i := i + 8.			pixel at: 4 put: (thisScanline at: i+6);				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+2);				at: 1 put: (thisScanline at: i+4).			tempBits at: x+1 put: pixel normalize.	].	tempForm displayOn: form at: 0@y rule: Form over.! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'dtl 6/18/2017 15:02' prior: 53963469!copyPixelsRGBA: y at: startX by: incX	"Handle interlaced RGBA color modes (colorType = 6)"	| i pixel tempForm tempBits |	tempForm := Form extent: width@1 depth: 32.	tempBits := tempForm bits.	pixel := LargePositiveInteger new: 4.	bitsPerChannel = 8 ifTrue: [		i := (startX // incX << 2) + 1.		startX to: width-1 by: incX do: [ :x |			pixel at: 4 put: (thisScanline at: i+3);				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+1);				at: 1 put: (thisScanline at: i+2).			tempBits at: x+1 put: pixel normalize.			i := i + 4.		]	] ifFalse: [		i := (startX // incX << 3) +1.		startX to: width-1 by: incX do: [ :x |			pixel at: 4 put: (thisScanline at: i+6);				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+2);				at: 1 put: (thisScanline at: i+4).			tempBits at: x+1 put: pixel normalize.			i := i + 8.		].	].	tempForm displayOn: form at: 0@y rule: Form paintAlpha.! !"Graphics-Files"!"Graphics-Tests"!!ConfigurationOfUnifiedFFI methodsFor: 'symbolic versions' stamp: 'EstebanLorenzano 6/28/2017 12:42' prior: 21193873!stable: spec	<symbolicVersion: #'stable'>	spec for: #'common' version: '0.26.8'! !!ConfigurationOfUnifiedFFI methodsFor: 'versions' stamp: 'EstebanLorenzano 6/28/2017 12:42'!v0_26_8: spec	<version: '0.26.8' imports: #('0.13-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: '- fixed size_t for i386/x86_64- fixed accessing to inner structures for i386/x86_64'.		spec author: 'EstebanLorenzano'.		spec timestamp: '2017-06-28 12:30'.		spec 			package: 'FFI-Pools' with: 'FFI-Pools-eem.3';			package: 'FFI-Kernel' with: 'FFI-Kernel-EstebanLorenzano.45';			package: 'Alien' with: 'Alien-RonieSalgado.40';			package: 'UnifiedFFI' with: 'UnifiedFFI-EstebanLorenzano.111';			package: 'UnifiedFFI-Tests' with: 'UnifiedFFI-Tests-EstebanLorenzano.41';			package: 'UnifiedFFI-Legacy' with: 'UnifiedFFI-Legacy-EstebanLorenzano.3' ]! !"ConfigurationOfUnifiedFFI"!!FFIConstants commentStamp: '' prior: 24017986!!!FFIConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 18:54' prior: 24021054!initialize	"FFIConstants initialize"	self initializeTypeConstants.	self initializeErrorConstants.	self initializeCallingConventions.! !!FFIConstants class methodsFor: 'pool initialization' stamp: 'eem 8/4/2009 19:49' prior: 24020615!initializeCallingConventions	"These constants map onto the flags inst var of an ExternalFunction.	 The first eight bits define the calling convention.  Attribute flags	 occupy bits 8 on up."	"FFIConstants initializeCallingConventions"	FFICallTypesMask := 255.	FFICallTypeCDecl := 0.	FFICallTypeApi := 1.	FFICallFlagThreaded := 256! !!FFIConstants class methodsFor: 'pool initialization' stamp: 'eem 11/5/2009 10:21' prior: 24019118!initializeErrorConstants	"FFIConstants initializeErrorConstants"	"No callout mechanism available"	FFINoCalloutAvailable := -1.	"generic error"	FFIErrorGenericError := 0.	"primitive invoked without ExternalFunction"	FFIErrorNotFunction := 1.	"bad arguments to primitive call"	FFIErrorBadArgs := 2.	"generic bad argument"	FFIErrorBadArg := 3.	"int passed as pointer"	FFIErrorIntAsPointer := 4.	"bad atomic type (e.g., unknown)"	FFIErrorBadAtomicType := 5.	"argument coercion failed"	FFIErrorCoercionFailed := 6.	"Type check for non-atomic types failed"	FFIErrorWrongType := 7.	"struct size wrong or too large"	FFIErrorStructSize := 8.	"unsupported calling convention"	FFIErrorCallType := 9.	"cannot return the given type"	FFIErrorBadReturn := 10.	"bad function address"	FFIErrorBadAddress := 11.	"no module given but required for finding address"	FFIErrorNoModule := 12.	"function address not found"	FFIErrorAddressNotFound := 13.	"attempt to pass 'void' parameter"	FFIErrorAttemptToPassVoid := 14.	"module not found"	FFIErrorModuleNotFound := 15.	"external library invalid"	FFIErrorBadExternalLibrary := 16.	"external function invalid"	FFIErrorBadExternalFunction := 17.	"ExternalAddress points to ST memory (don't you dare to do this!!)"	FFIErrorInvalidPointer := 18.	"Stack frame required more than 16k bytes to pass arguments."	FFIErrorCallFrameTooBig := 19! !!FFIConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 18:34' prior: 24018105!initializeTypeConstants	"type void"	FFITypeVoid := 0.	"type bool"	FFITypeBool := 1.	"basic integer types.	note: (integerType anyMask: 1) = integerType isSigned"	FFITypeUnsignedByte := 2.	FFITypeSignedByte := 3.	FFITypeUnsignedShort := 4.	FFITypeSignedShort := 5.	FFITypeUnsignedInt := 6.	FFITypeSignedInt := 7.	"64bit types"	FFITypeUnsignedLongLong := 8.	FFITypeSignedLongLong := 9.	"special integer types"	FFITypeUnsignedChar := 10.	FFITypeSignedChar := 11.	"float types"	FFITypeSingleFloat := 12.	FFITypeDoubleFloat := 13.	"type flags"	FFIFlagAtomic := 16r40000. "type is atomic"	FFIFlagPointer := 16r20000. "type is pointer to base type"	FFIFlagStructure := 16r10000. "baseType is structure of 64k length"	FFIStructSizeMask := 16rFFFF. "mask for max size of structure"	FFIAtomicTypeMask := 16r0F000000. "mask for atomic type spec"	FFIAtomicTypeShift := 24. "shift for atomic type"! !"FFI-Pools"!!FFIExternalStructureReferenceHandle methodsFor: 'accessing' stamp: 'EstebanLorenzano 6/27/2017 14:29'!getHandle	^ handle! !!FFIExternalStructure class methodsFor: 'accessing' stamp: 'EstebanLorenzano 6/16/2017 08:49' prior: 24067773!structureAlignment	externalStructureAlignment ifNil: [ self compileFields ].	^ externalStructureAlignment! !!ExternalType methodsFor: '*UnifiedFFI' stamp: 'EstebanLorenzano 6/27/2017 15:27' prior: 23753519!offsetReadFieldAt: offsetVariableName	"Answer a string defining the accessor to an entity of the receiver type starting at the 	 given byte offset. 	 Private. Used for field definition only.	 NOTE: This is used on UFFI to define field accessors that depends on a class variable 	 (this works like this to allow mapping 32bits and 64bits structures)"	self isPointerType ifTrue:		[| accessor |		accessor := self pointerSize caseOf: {						[nil]	->	[#pointerAt:].						[4]	->	[#shortPointerAt:].						[8]	->	[#longPointerAt:] }.		 ^String streamContents:			[:s|			 referentClass				ifNil:					[s nextPutAll: '^ExternalData fromHandle: (handle ', accessor, ' ';						nextPutAll: offsetVariableName;						nextPutAll: ') type: ExternalType ';						nextPutAll: (AtomicTypeNames at: self atomicType);						nextPutAll: ' asPointerType']				ifNotNil:					[s nextPutAll: '^';						print: referentClass;						nextPutAll: ' fromHandle: (handle ', accessor, ' ';						nextPutAll: offsetVariableName;						nextPut: $)]]].	self isAtomic ifFalse: "structure type"		[^ self offsetReadStructFieldAt: offsetVariableName ].	"Atomic non-pointer types"	^String streamContents:		[:s|		s nextPutAll:'^handle ';			nextPutAll: (AtomicSelectors at: self atomicType);			space; nextPutAll: offsetVariableName].! !!ExternalType methodsFor: '*UnifiedFFI' stamp: 'EstebanLorenzano 6/27/2017 15:29'!offsetReadStructFieldAt: offsetVariableName	^ '^ {1} fromHandle: (handle structAt: {2} length: {1} byteSize)' 		format: { 			referentClass name.			offsetVariableName }! !!ExternalType methodsFor: '*UnifiedFFI' stamp: 'EstebanLorenzano 6/27/2017 15:21' prior: 23749828!offsetWriteFieldAt: offsetVariableName with: valueName	"Answer a string defining the accessor to an entity of the receiver type starting at the given byte offset. 	 Private. Used for field definition only."	self isPointerType ifTrue:		[| accessor |		accessor := self pointerSize caseOf: {						[nil]	->	[#pointerAt:].						[4]	->	[#shortPointerAt:].						[8]	->	[#longPointerAt:] }.		^String streamContents:			[:s|			s nextPutAll:'handle ', accessor, ' ';				nextPutAll: offsetVariableName;				nextPutAll:' put: ';				nextPutAll: valueName;				nextPutAll:' getHandle.']].	self isAtomic ifFalse:[		^ self offsetWriteStructFieldAt: offsetVariableName with: valueName ].	^String streamContents:[:s|		s nextPutAll:'handle ';			nextPutAll: (AtomicSelectors at: self atomicType); space; 			nextPutAll: offsetVariableName;			nextPutAll:' put: ';			nextPutAll: valueName].! !!ExternalType methodsFor: '*UnifiedFFI' stamp: 'EstebanLorenzano 6/27/2017 15:35'!offsetWriteStructFieldAt: offsetVariableName with: valueName	^ 'handle structAt: {1} put: {2} getHandle length: {3} byteSize' 		format: {			offsetVariableName. 			valueName. 			referentClass name }! !!FFISizeT class methodsFor: 'converting' stamp: 'EstebanLorenzano 6/19/2017 11:17' prior: 24168971!asExternalTypeOn: generator	^ generator resolveType: #ulong! !!FFISizeT methodsFor: 'private' stamp: 'EstebanLorenzano 6/19/2017 10:57' prior: 24168483!basicHandle: aHandle at: index	^ aHandle platformUnsignedLongAt: index! !!FFISizeT methodsFor: 'private' stamp: 'EstebanLorenzano 6/19/2017 10:57' prior: 24168650!basicHandle: aHandle at: index put: value	^ aHandle platformUnsignedLongAt: index put: value! !!FFISizeT methodsFor: 'emitting code' stamp: 'EstebanLorenzano 6/19/2017 11:13'!readFieldAt: byteOffset	self isPointer ifTrue: [ 		^ self pointerReadFieldAt: byteOffset ].	^ String streamContents: [ :stream |		stream << '^handle platformUnsignedLongAt: ' << byteOffset asString ].! !!FFISizeT methodsFor: 'emitting code' stamp: 'EstebanLorenzano 6/19/2017 11:09'!writeFieldAt: byteOffset with: valueName	self isPointer ifTrue: [ 		^ self externalTypeWithArity 			writeFieldAt: byteOffset			with: valueName ].	^ String streamContents: [ :stream |		stream 			<< '^handle platformUnsignedLongAt: ' << byteOffset asString			<< ' put: ' << valueName ]! !!FFIExternalStructureType methodsFor: 'emitting code' stamp: 'EstebanLorenzano 6/27/2017 15:40' prior: 24102484!offsetReadReferenceAt: offsetVariableName	^ '^ {1} fromHandle: (handle referenceStructAt: {2} length: {1} byteSize)'		format: { self objectClass name. offsetVariableName }! !!FFIExternalStructureType methodsFor: 'emitting code' stamp: 'EstebanLorenzano 6/27/2017 15:42' prior: 24102101!readReferenceAt: byteOffset	^ '^ {1} fromHandle: (handle referenceStructAt: {2} length: {1} byteSize)'		format: { 			self objectClass name.			byteOffset }! !!FFICallbackType methodsFor: 'emitting code' stamp: 'EstebanLorenzano 4/13/2017 17:11' prior: 23963994!offsetWriteFieldAt: offsetVariableName with: valueName	| cr tab |	cr := String cr.	tab := String tab.	^ String streamContents: [ :stream | 		stream 			<< 'handle ' << cr 			<< tab << tab << 'pointerAt: ' << offsetVariableName << cr 			<< tab << tab << 'put: (anObject ' << cr 			<< tab << tab << tab << 'ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]' << cr			<< tab << tab << tab << 'ifNil: [ ExternalAddress null ])' ]! !"UnifiedFFI"!"UnifiedFFI-Tests"!"UnifiedFFI-Legacy"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.579.mcz') load.ScriptLoader new update60503.!----End fileIn----!----QUIT----2017-06-28T17:09:15.864278+02:00 Pharo.image priorSource: 216732!----QUIT----2017-06-28T17:09:26.342968+02:00 Pharo.image priorSource: 253892!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 6/29/2017 12:31' prior: 33771334!commentForCurrentUpdate ^ '20185 Request pipe after block argments	https://pharo.fogbugz.com/f/cases/2018520183 TraitDescription>>fileOutLocalMethodsInCategory:on: method temp var name overlap	https://pharo.fogbugz.com/f/cases/2018320184 Request space between argument and selector in StdioStream>>next:	https://pharo.fogbugz.com/f/cases/20184'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 6/29/2017 12:31'!script60504	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.23.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.194.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.103.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.430.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.80.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.87.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2517.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.177.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1180.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.315.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.388.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.39.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-EstebanLorenzano.111.mczUnifiedFFI-Legacy-EstebanLorenzano.3.mczUnifiedFFI-Tests-EstebanLorenzano.41.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.40.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 6/29/2017 12:31'!update60504	"self new update60504"	self withUpdateLog: '20185 Request pipe after block argments	https://pharo.fogbugz.com/f/cases/2018520183 TraitDescription>>fileOutLocalMethodsInCategory:on: method temp var name overlap	https://pharo.fogbugz.com/f/cases/2018320184 Request space between argument and selector in StdioStream>>next:	https://pharo.fogbugz.com/f/cases/20184'.	self loadTogether: self script60504 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60503!ScriptLoader removeSelector: #script60503!"ScriptLoader60"!!Context class methodsFor: 'simulation' stamp: 'MarcusDenker 6/29/2017 11:20' prior: 21724094!runSimulated: aBlock	"Simulate the execution of the argument, current. Answer the result it 	returns."	^ thisContext sender		runSimulated: aBlock		contextAtEachStep: [:ignored | ]	"Context runSimulated: [Pen new defaultNib: 5; go: 100]"! !!MCMczReader methodsFor: 'loading' stamp: 'MarcusDenker 6/29/2017 11:20' prior: 31818543!loadDefinitions	definitions := OrderedCollection new.	(self zip memberNamed: 'snapshot.bin') ifNotNil:		[:m | [^ definitions := (MCDataStream on: m contentStream) next definitions]			on: Error do: [:fallThrough | ]].	"otherwise"	(self zip membersMatching: 'snapshot/*')		do: [:m | self extractDefinitionsFrom: m].! !!MCVersion methodsFor: 'enumerating' stamp: 'MarcusDenker 6/29/2017 11:18' prior: 32089434!withAllDependenciesDo: aBlock	self allDependenciesDo: aBlock ifUnresolved: [:ignored | ].	aBlock value: self! !!MCMcdReader methodsFor: 'loading' stamp: 'MarcusDenker 6/29/2017 11:20' prior: 31808620!loadPatch	| old new |	(self zip memberNamed: 'patch.bin') ifNotNil:		[:m | [^ patch := (MCDataStream on: m contentStream) next ]			on: Error do: [:fallThrough | ]].	definitions := OrderedCollection new.	(self zip membersMatching: 'old/*')		do: [:m | self extractDefinitionsFrom: m].	old := definitions asArray.	definitions := OrderedCollection new.	(self zip membersMatching: 'new/*')		do: [:m | self extractDefinitionsFrom: m].	new := definitions asArray.	^ patch := self buildPatchFrom: old to: new.	! !!MCPatch methodsFor: 'intializing' stamp: 'MarcusDenker 6/29/2017 11:18' prior: 31920696!initializeWithBase: baseSnapshot target: targetSnapshot	| base target |		operations := OrderedCollection new.	base := MCDefinitionIndex definitions: baseSnapshot definitions.	target := MCDefinitionIndex definitions: targetSnapshot definitions.		target definitions 		do: [ :t |			base				definitionLike: t				ifPresent: [:b | (b isSameRevisionAs: t) ifFalse: [operations add: (MCModification of: b to: t)]]				ifAbsent:  [operations add: (MCAddition of: t)] ]		displayingProgress: 'Diffing...'.			base definitions do: [:b |		target			definitionLike: b			ifPresent: [:t | ]			ifAbsent: [operations add: (MCRemoval of: b)]]		! !!TClassDescription methodsFor: '*CodeExport' stamp: 'MarcusDenker 6/29/2017 11:12' prior: 86056743!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	"File out only the local (non-trait) methods for this category."	| selectors selectorsLocal |	aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.   selectorsLocal := selectors select:[:s | self isLocalSelector: s ].	"Overridden to preserve author stamps in sources file regardless"	selectorsLocal do: [:sel |		self printMethodChunk: sel on: aFileStream ].	^ self! !!StdioStream methodsFor: 'accessing' stamp: 'OleksandrZaytsev 6/28/2017 16:54' prior: 62348092!next: n	"Return a string with the next n characters of the filestream in it."	| readBuffer read startingAt |	readBuffer := ByteArray new: n.	startingAt := 1.	peekBuffer ifNotNil: [ 		readBuffer at: 1 put: peekBuffer.		startingAt := startingAt + 1.		peekBuffer := nil ].	read := self primRead: handle into: readBuffer startingAt: startingAt count: n - startingAt + 1.	^read = (n - startingAt + 1)		ifTrue: [ readBuffer ]		ifFalse: [ readBuffer copyFrom: 1 to: read ]! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	"File out only the local (non-trait) methods for this category."	| selectors selectorsLocal |	aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.   selectorsLocal := selectors select:[:s | self isLocalSelector: s ].	"Overridden to preserve author stamps in sources file regardless"	selectorsLocal do: [:sel |		self printMethodChunk: sel on: aFileStream ].	^ self! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	"File out only the local (non-trait) methods for this category."	| selectors selectorsLocal |	aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.   selectorsLocal := selectors select:[:s | self isLocalSelector: s ].	"Overridden to preserve author stamps in sources file regardless"	selectorsLocal do: [:sel |		self printMethodChunk: sel on: aFileStream ].	^ self! !"CodeExport"!"Files"!"Kernel"!"Monticello"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.580.mcz') load.ScriptLoader new update60504.!----End fileIn----!----QUIT----2017-06-29T12:37:38.234233+02:00 Pharo.image priorSource: 253971!----QUIT----2017-06-29T12:37:58.541211+02:00 Pharo.image priorSource: 277897!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 6/30/2017 14:14' prior: 33808574!commentForCurrentUpdate ^ '20187 Request use of block in certain methods	https://pharo.fogbugz.com/f/cases/2018720188 Request representation of integer literal without float exponent	https://pharo.fogbugz.com/f/cases/2018820182 Extra dot in literal array	https://pharo.fogbugz.com/f/cases/2018218760 Failing test: WeakAnnouncerTest>>#testNoDeadWeakSubscriptions	https://pharo.fogbugz.com/f/cases/1876020186 Request removal of extra statement separators (dot)	https://pharo.fogbugz.com/f/cases/20186'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 6/30/2017 14:15'!script60505	^ 'AST-Core-TheIntegrator.496.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.23.mczCodeImport-TheIntegrator.92.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.194.mczCollections-Strings-TheIntegrator.451.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.103.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.31.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.431.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.190.mczGraphics-Files-TheIntegrator.80.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.87.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.32.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2518.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.177.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1180.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.315.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.85.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.892.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.792.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.388.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.76.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.69.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.39.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.990.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.197.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-EstebanLorenzano.111.mczUnifiedFFI-Legacy-EstebanLorenzano.3.mczUnifiedFFI-Tests-EstebanLorenzano.41.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.461.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.40.mczZodiac-Core-TheIntegrator.48.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 6/30/2017 14:15'!update60505	"self new update60505"	self withUpdateLog: '20187 Request use of block in certain methods	https://pharo.fogbugz.com/f/cases/2018720188 Request representation of integer literal without float exponent	https://pharo.fogbugz.com/f/cases/2018820182 Extra dot in literal array	https://pharo.fogbugz.com/f/cases/2018218760 Failing test: WeakAnnouncerTest>>#testNoDeadWeakSubscriptions	https://pharo.fogbugz.com/f/cases/1876020186 Request removal of extra statement separators (dot)	https://pharo.fogbugz.com/f/cases/20186'.	self loadTogether: self script60505 merge: false.	(SystemAnnouncer uniqueInstance subscriptions glmSubscriptions select: [:sub | sub subscriber isNil]) do: #finalize. 3 timesRepeat: [Smalltalk garbageCollect ].	self flushCaches.! !ScriptLoader removeSelector: #update60504!ScriptLoader removeSelector: #script60504!"ScriptLoader60"!!RBProgramNode methodsFor: 'accessing' stamp: 'MarcusDenker 6/30/2017 10:03' prior: 56263770!comments: aCollection	(aCollection ifNil: [#()])		ifEmpty: [ self removeProperty: #comments ifAbsent: [] ] 		ifNotEmpty: [ self propertyAt: #comments put: aCollection ].! !!UTF16TextConverter methodsFor: 'conversion' stamp: 'MarcusDenker 6/29/2017 12:20' prior: 65417347!nextFromStream: aStream	| character1 character2 readBOM charValue |	aStream isBinary ifTrue: [^ aStream basicNext].	character1 := aStream basicNext ifNil: [^nil].	character2 := aStream basicNext ifNil: [^nil].	readBOM := false.	(character1 asciiValue = 16rFF and: [character2 asciiValue = 16rFE]) ifTrue: 		[self useLittleEndian: true.		readBOM := true].	(character1 asciiValue = 16rFE and: [character2 asciiValue = 16rFF]) ifTrue: 		[self useLittleEndian: false.		readBOM := true].	readBOM ifTrue: 		[self useByteOrderMark: true.		character1 := aStream basicNext ifNil: [^nil].		character2 := aStream basicNext ifNil: [^nil]].	charValue := self useLittleEndian 		ifTrue: [(character2 charCode bitShift: 8) + character1 charCode] 		ifFalse: [(character1 charCode bitShift: 8) + character2 charCode].	^ self charFromStream: aStream withFirst: charValue.! !!TemporaryVariable methodsFor: 'comparing' stamp: 'MarcusDenker 6/30/2017 10:05' prior: 63541185!hash	^ (name hash		bitXor: method hash)		bitXor: (startpc ifNil: [0])! !!TextFontChange class methodsFor: 'as yet unclassified' stamp: 'MarcusDenker 6/30/2017 10:05' prior: 63909793!defaultFontChange  "Answer a TextFontChange that represents the default font"  | defaultFontStyle fontIndex |  defaultFontStyle := TextStyle default.  fontIndex := defaultFontStyle ifNil: [1] ifNotNil: [defaultFontStyle defaultFontIndex].  ^ self new fontNumber: fontIndex.! !!UIManager methodsFor: 'ui process' stamp: 'MarcusDenker 6/29/2017 12:17' prior: 65091276!spawnNewProcess	"do nothing by default"! !!ChunkReadStream methodsFor: 'decorated' stamp: 'MarcusDenker 6/29/2017 12:22' prior: 19183935!parseLangTagFor: aString	| string peek runsRaw foundTag |	string := aString.	"Test for ]lang[ tag"	peek := self skipSeparators; peek.	peek = $] ifFalse: [ ^ string ].  "no tag"	foundTag := (decoratedStream upTo: $[).	foundTag = ']lang' ifTrue: [		runsRaw := self basicNextChunk.		string := self decodeString: aString andRuns: runsRaw	] ifFalse: [		"If we find a ] but not a lang tag, there is something really wrong and we are not ready to parse that"		^ string , self basicNextChunk	].	^ string! !!TBehaviorCategorization methodsFor: 'organization' stamp: 'MarcusDenker 6/30/2017 10:08' prior: 85966532!category	"Answer the system organization category for the receiver. First check whether the	category name stored in the ivar is still correct and only if this fails look it up	(latter is much more expensive)"	| result |	self basicCategory ifNotNil: [ :symbol |		((self environment organization listAtCategoryNamed: symbol) includes: self name)			ifTrue: [ ^symbol ] ].	result := (self environment organization categoryOfElement: self name)		ifNil: [ #Unclassified ]		ifNotNil: [ :res | res ].	self basicCategory: result.		^ result! !!Job class methodsFor: 'examples' stamp: 'MarcusDenker 6/29/2017 12:18' prior: 29986359!exampleCurrentValue	[ :job| 		job title: 'Simulating some progress for 1 Second'.		1 second wait. "simulate some work"		job currentValue: 50.		1 second wait. "simulate some more work"		job currentValue: 100.		1 second wait. "simulate some more work"	] asJob run! !!ConfigurationCommandLineHandler methodsFor: 'printing' stamp: 'MarcusDenker 6/30/2017 10:07' prior: 20156717!printConfigurations: configurations	self inform: (String streamContents:  [ :s|		s			nextPutAll: 'Found ';			print: configurations size;			nextPutAll: ' Configuration';			nextPutAll: (configurations size = 1 ifTrue: [':'] ifFalse: ['s:']) ]).		configurations do: [ :name | 			self << name. 			self stdout lf ].	! !!SourceFileArray methodsFor: 'private - copying' stamp: 'MarcusDenker 6/30/2017 10:05' prior: 61195344!readOnlyCopy	"Answer a read only copy of self. The caller is responsible of closing it."	^ self species new		sourcesFileStream: (self sourcesFileStream ifNotNil: [:aStream | aStream readOnlyCopy]);		changesFileStream: (self changesFileStream ifNotNil: [:aStream | aStream readOnlyCopy]);		yourself! !!ZnImageExampleDelegate methodsFor: 'accessing' stamp: 'MarcusDenker 6/30/2017 11:00' prior: 85343737!html	^ ZnHtmlOutputStream streamContents: [ :html |		 html page: 'Image' do: [			html 				tag: #src attributes: #(src 'image?raw=true');				tag: #br;				tag: #form attributes: #(enctype 'multipart/form-data' action image method POST) do: [					html						tag: #h3 with: 'Change the image:';						tag: #input attributes: #(type file name file);						tag: #input attributes: #(type submit value Upload) ] ] ]! !!IRPrinterV2 methodsFor: 'visiting' stamp: 'MarcusDenker 6/29/2017 12:21' prior: 28857190!visitPopIntoRemoteTemp: remoteTemp	stream nextPutAll: 'popIntoRemoteTemp: '.	remoteTemp name printOn: stream.	stream nextPutAll: ' inVector: '.	remoteTemp tempVectorName printOn: stream! !!IRPrinterV2 methodsFor: 'visiting' stamp: 'MarcusDenker 6/29/2017 12:22' prior: 28858059!visitPushRemoteTemp: remoteTemp	stream nextPutAll: 'pushRemoteTemp: '.	remoteTemp name printOn: stream.	stream nextPutAll: ' inVector: '.	remoteTemp tempVectorName printOn: stream! !!IRPrinterV2 methodsFor: 'visiting' stamp: 'MarcusDenker 6/29/2017 12:22' prior: 28855547!visitStoreRemoteTemp: remoteTemp	stream nextPutAll: 'storeRemoteTemp: '.	remoteTemp name printOn: stream.	stream nextPutAll: ' inVector: '.	remoteTemp tempVectorName printOn: stream.! !!IRBytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'MarcusDenker 6/29/2017 12:19' prior: 28775840!jump: dist	| index seq instr newSeq seqs |	index := instructionStream pc + dist.	dist >= 0 ifTrue: [		"jump forward"		^ irBuilder jumpAheadTo: index ].	"jump to the jump instuction itself"	dist >= -2 ifTrue: 		[	irBuilder jumpBackTarget: index.			irBuilder jumpBackTo: index.		^self].	"jump backward"	seqs := irBuilder ir allSequences.	seq := seqs findLast: [:s | s notEmpty and: [s first bytecodeIndex <= index]].	seq := seqs at: seq.	seq first bytecodeIndex = index		ifTrue: [ newSeq := seq ]		ifFalse: [			instr := seq detect: [:i | (seq after: i) bytecodeIndex = index].			newSeq := seq splitAfter: instr ].	irBuilder addJumpBackTarget: index to: newSeq.	"if we have split the currentSequence of the irBuilder, make sure to set it	to the newSeq"	irBuilder currentSequence = seq ifTrue: [irBuilder currentSequence: newSeq].	irBuilder jumpBackTo: index.! !!Form methodsFor: 'other' stamp: 'MarcusDenker 6/29/2017 12:23' prior: 25521945!fillAlpha: alphaValue	"Fill a 32bit form with a constant alpha value"	| bb |	self depth = 32 ifFalse:[^self error: 'Only valid for 32 bit forms'].	bb := BitBlt toForm: self.	bb combinationRule: 7. "bitOr:with:"	bb fillColor: (Bitmap with: alphaValue << 24).	bb copyBits.! !!PharoChangesCondenser methodsFor: 'initialization' stamp: 'MarcusDenker 6/29/2017 12:18' prior: 54402043!reset	remoteStringMap := IdentityDictionary new.	newChangesFile := self temporaryFile.		"Keep a copy of the source streams for performance"	sourceStreams := Array			with: PharoFilesOpener default sourcesFileOrNil			with: PharoFilesOpener default changesFileOrNil! !!MultiByteFileStream methodsFor: 'fileIn/Out' stamp: 'MarcusDenker 6/29/2017 12:24' prior: 52064442!nextChunk	"Answer the contents of the receiver, up to the next terminator	character. Doubled terminators indicate an embedded terminator	character."	self skipSeparators.	^ self		parseLangTagFor: (self basicChunk				ifNil: [String						new: 1000						streamContents: [:stream | 							| character state |							[(character := self next) == nil								or: [character == $!!										and: [state := converter saveStateOf: self.											self next ~~ $!!]]]								whileFalse: [stream nextPut: character].							character								ifNotNil: [converter restoreStateOf: self with: state.]]])! !!MultiByteFileStream methodsFor: 'fileIn/Out' stamp: 'MarcusDenker 6/29/2017 12:24' prior: 52069235!nextPreamble	"Assuming that preamble part does not contain ]lang[ tag"	self skipSeparators.	^ self basicChunk				ifNil: [String						new: 1000						streamContents: [:stream | 							| character state |							[(character := self next) == nil								or: [character == $!!										and: [state := converter saveStateOf: self.											self next ~~ $!!]]]								whileFalse: [stream nextPut: character].							character								ifNotNil: [converter restoreStateOf: self with: state.]]]! !!Protocol methodsFor: 'initialization' stamp: 'MarcusDenker 6/29/2017 12:17' prior: 55287718!initialize	super initialize.	methods := IdentitySet new.	name := self class defaultName.! !!IRReconstructor methodsFor: 'initialize' stamp: 'MarcusDenker 6/29/2017 12:21' prior: 28870270!createTempVectorNamed: name withVars: anArray	" Don't add the temp yet, we only know it's index at the end of the block or method "	"self addVectorTemps: anArray"	" Update the byte index to point before the pushing of the new vector "	sourceMapByteIndex := sourceMapByteIndex - 2.	self add: (IRInstruction createTempVectorNamed: name withVars: anArray)! !!ZdcPluginSSLSession methodsFor: 'accessing' stamp: 'MarcusDenker 6/30/2017 10:07' prior: 84802687!serverName: serverName	"Set the Server Name Indication (SNI) to serverName, 	the fully qualified domain name of the host to connect to.	This should be set by a client before #connect is attempted."		^ self primitiveSSL: handle setStringProperty: 2 toValue: (serverName ifNil: [''])! !!Text class methodsFor: 'instance creation' stamp: 'MarcusDenker 6/30/2017 10:09' prior: 63718200!fromString: aString   "Answer an instance of me whose characters are those of the argument, aString."  | defaultFontStyle fontNumber |  defaultFontStyle := TextStyle default.  fontNumber := defaultFontStyle ifNil: [1] ifNotNil: [defaultFontStyle defaultFontIndex].  ^ self    string: aString    attributes:{ "No default attributes" }! !!Text class methodsFor: 'initialization' stamp: 'MarcusDenker 6/30/2017 11:09' prior: 63716753!initialize	"Text initialize"	"Initialize constants shared by classes associated with text display."	TextSharedInformation at: #CaretForm put:				(Form extent: 16@5					fromArray: #(	 						2r00110000000000000000000000000000 						2r00110000000000000000000000000000 					 	2r01111000000000000000000000000000 					 	2r11111100000000000000000000000000 					 	2r11001100000000000000000000000000)					offset: -3@0).! !!String methodsFor: 'converting' stamp: 'MarcusDenker 6/29/2017 12:24' prior: 62489088!withNoLineLongerThan: aNumber	"Answer a string with the same content as receiver, but rewrapped so that no line has more characters than the given number"	(aNumber isNumber not or: [ aNumber < 1 ]) ifTrue: [self error: 'too narrow'].	^self class		new: self size * (aNumber + 1) // aNumber "provision for supplementary line breaks"		streamContents: [ :stream |			self lineIndicesDo: [ :start :endWithoutDelimiters :end |				| pastEnd lineStart |				pastEnd := endWithoutDelimiters + 1.				"eliminate spaces at beginning of line"				lineStart := (self indexOfAnyOf: CSNonSeparators startingAt: start ifAbsent: [pastEnd]) min: pastEnd.				[| lineStop lineEnd spacePosition |				lineEnd := lineStop  := lineStart + aNumber min: pastEnd.				spacePosition := lineStart.				[spacePosition < lineStop] whileTrue: [					spacePosition := self indexOfAnyOf: CSSeparators startingAt: spacePosition + 1 ifAbsent: [pastEnd].					spacePosition <= lineStop ifTrue: [lineEnd := spacePosition].				].				"split before space or before lineStop if no space"				stream nextPutAll: (self copyFrom: lineStart to: lineEnd - 1).				"eliminate spaces at beginning of next line"				lineStart := self indexOfAnyOf: CSNonSeparators startingAt: lineEnd ifAbsent: [pastEnd].				lineStart <= endWithoutDelimiters ]					whileTrue: [stream cr].				stream nextPutAll: (self copyFrom: pastEnd to: end) ] ]! !!Trait method!category	"Answer the system organization category for the receiver. First check whether the	category name stored in the ivar is still correct and only if this fails look it up	(latter is much more expensive)"	| result |	self basicCategory ifNotNil: [ :symbol |		((self environment organization listAtCategoryNamed: symbol) includes: self name)			ifTrue: [ ^symbol ] ].	result := (self environment organization categoryOfElement: self name)		ifNil: [ #Unclassified ]		ifNotNil: [ :res | res ].	self basicCategory: result.		^ result! !!Trait method!category	"Answer the system organization category for the receiver. First check whether the	category name stored in the ivar is still correct and only if this fails look it up	(latter is much more expensive)"	| result |	self basicCategory ifNotNil: [ :symbol |		((self environment organization listAtCategoryNamed: symbol) includes: self name)			ifTrue: [ ^symbol ] ].	result := (self environment organization categoryOfElement: self name)		ifNil: [ #Unclassified ]		ifNotNil: [ :res | res ].	self basicCategory: result.		^ result! !!Trait method!category	"Answer the system organization category for the receiver. First check whether the	category name stored in the ivar is still correct and only if this fails look it up	(latter is much more expensive)"	| result |	self basicCategory ifNotNil: [ :symbol |		((self environment organization listAtCategoryNamed: symbol) includes: self name)			ifTrue: [ ^symbol ] ].	result := (self environment organization categoryOfElement: self name)		ifNil: [ #Unclassified ]		ifNotNil: [ :res | res ].	self basicCategory: result.		^ result! !"AST-Core"!"CodeImport"!"Collections-Strings"!"ConfigurationCommandLineHandler-Core"!"Files"!"Graphics-Display Objects"!"Jobs"!"Kernel"!"Multilingual-TextConversion"!"OpalCompiler-Core"!"Slot"!"System-Sources"!"Text-Core"!"Traits"!"UIManager"!"Zinc-HTTP"!"Zodiac-Core"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.581.mcz') load.ScriptLoader new update60505.!----End fileIn----!----QUIT----2017-06-30T14:18:17.675696+02:00 Pharo.image priorSource: 277976!----QUIT----2017-06-30T14:18:34.498843+02:00 Pharo.image priorSource: 312306!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 7/4/2017 16:11' prior: 33832579!commentForCurrentUpdate ^ '20092 Improve speed of WriteStream>>tab:	https://pharo.fogbugz.com/f/cases/2009220088 Improve speed of Character>>isSeparator in when the separator is not a space	https://pharo.fogbugz.com/f/cases/2008820204 Text class>>#fromString	https://pharo.fogbugz.com/f/cases/20204'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 7/4/2017 16:11'!script60506	^ 'AST-Core-TheIntegrator.496.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.23.mczCodeImport-TheIntegrator.92.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.195.mczCollections-Strings-TheIntegrator.451.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.105.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.31.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.431.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.190.mczGraphics-Files-TheIntegrator.80.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.87.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.32.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2520.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.177.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1180.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.315.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.85.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.892.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.792.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.388.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.76.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.71.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.39.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.990.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.197.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-EstebanLorenzano.111.mczUnifiedFFI-Legacy-EstebanLorenzano.3.mczUnifiedFFI-Tests-EstebanLorenzano.41.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.461.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.40.mczZodiac-Core-TheIntegrator.48.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 7/4/2017 16:11'!update60506	"self new update60506"	self withUpdateLog: '20092 Improve speed of WriteStream>>tab:	https://pharo.fogbugz.com/f/cases/2009220088 Improve speed of Character>>isSeparator in when the separator is not a space	https://pharo.fogbugz.com/f/cases/2008820204 Text class>>#fromString	https://pharo.fogbugz.com/f/cases/20204'.	self loadTogether: self script60506 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60505!ScriptLoader removeSelector: #script60505!"ScriptLoader60"!!WriteStreamTest methodsFor: 'tests' stamp: 'HenrikNergaard 5/29/2017 12:15'!testEnsureNoSpace	"self debug: #testEnsureASpace2"	| stream |	stream := self newStream.	stream ensureNoSpace.		self assert: stream contents equals: ''.		stream nextPutAll: ' a '.	stream ensureNoSpace.	self assert: stream contents equals: ' a'.		stream nextPutAll: 'b  '.	stream ensureNoSpace.	self assert: stream contents equals: ' ab'.			! !!Character methodsFor: 'testing' stamp: 'MarcusDenker 7/1/2017 14:52' prior: 19056099!isSeparator    | in |    ^ (in := self asInteger) == 32 or: [ in == 13 or: [ in == 9 or: [ in == 10 or: [ in == 12 ] ] ] ]! !!Text class methodsFor: 'instance creation' stamp: 'MarcusDenker 7/1/2017 14:47' prior: 33861804!fromString: aString   "Answer an instance of me whose characters are those of the argument, aString."  ^ self    string: aString    attributes:{ "No default attributes" }! !!Stream methodsFor: 'accessing' stamp: 'HenrikNergaard 5/29/2017 12:09' prior: 62373559!next: anInteger put: anObject 	<compilerOptions: #(+ optionInlineTimesRepeat)>		"Make anObject be the next anInteger number of objects accessible by the 	receiver. Answer anObject."		anInteger timesRepeat: [ self nextPut: anObject ].	^ anObject! !!CharacterTest methodsFor: 'tests' stamp: 'MarcusDenker 7/1/2017 14:55'!testIsSeparator    {Character space.    Character cr.    Character lf.    Character newPage.    Character tab} do: [ :each | self assert: each isSeparator ].    Character alphabet do: [ :each | self deny: each isSeparator ]! !!WriteStream methodsFor: 'accessing' stamp: 'HenrikNergaard 5/29/2017 12:10' prior: 84714960!crlf	"Append a line feed character to the receiver."	self cr; lf! !!WriteStream methodsFor: 'character writing' stamp: 'HenrikNergaard 5/29/2017 12:10' prior: 84721483!crtab	"Append a return character, followed by a single tab character, to the 	receiver."	self cr; tab! !!WriteStream methodsFor: 'character writing' stamp: 'HenrikNergaard 5/29/2017 12:10' prior: 84716139!crtab: anInteger 	"Append a return character, followed by anInteger tab characters, to the 	receiver."	self cr; tab: anInteger! !!WriteStream methodsFor: 'character writing' stamp: 'HenrikNergaard 5/29/2017 12:15' prior: 84721850!ensureNoSpace	"If there is not one on the end, remove it."	| space |		space := Character space.		[ position > 0 and: [(collection at: position) = space ]]		whileTrue: [ self skip: -1 ]! !!WriteStream methodsFor: 'character writing' stamp: 'HenrikNergaard 5/29/2017 12:11' prior: 84719188!space: anInteger 	"Append anInteger space characters to the receiver."		self next: anInteger put: Character space	! !!WriteStream methodsFor: 'character writing' stamp: 'HenrikNergaard 5/29/2017 12:12' prior: 84717846!tab: anInteger 	"Append anInteger tab characters to the receiver."		self next: anInteger put: Character tab! !"Collections-Streams"!"Collections-Tests"!"Kernel"!"Text-Core"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.582.mcz') load.ScriptLoader new update60506.!----End fileIn----!----QUIT----2017-07-04T16:14:02.32477+02:00 Pharo.image priorSource: 312385!----QUIT----2017-07-04T16:14:12.807834+02:00 Pharo.image priorSource: 334804!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 7/6/2017 14:44' prior: 33866987!commentForCurrentUpdate ^ '20218 Master branch (Pharo 6) needs to be safely merged into development branch (Pharo 7).	https://pharo.fogbugz.com/f/cases/20218'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 7/6/2017 14:45'!script60507	^ 'AST-Core-TheIntegrator.496.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.23.mczCodeImport-TheIntegrator.92.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.195.mczCollections-Strings-TheIntegrator.451.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.105.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.31.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.431.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.190.mczGraphics-Files-TheIntegrator.80.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.87.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.34.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2522.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.177.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.195.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1183.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.315.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.85.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.892.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.792.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.388.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.76.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.73.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.39.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.992.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.197.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.113.mczUnifiedFFI-Legacy-EstebanLorenzano.3.mczUnifiedFFI-Tests-EstebanLorenzano.41.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.461.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.40.mczZodiac-Core-TheIntegrator.48.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 7/6/2017 14:45'!update60507	"self new update60507"	self withUpdateLog: '20218 Master branch (Pharo 6) needs to be safely merged into development branch (Pharo 7).	https://pharo.fogbugz.com/f/cases/20218'.	self loadTogether: self script60507 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60506!ScriptLoader removeSelector: #script60506!"ScriptLoader60"!!Context class methodsFor: 'simulation' stamp: 'PavelKrivanek 7/6/2017 11:21' prior: 33827420!runSimulated: aBlock	"Simulate the execution of the argument, current. Answer the result it 	returns."	^ thisContext sender		runSimulated: aBlock		contextAtEachStep: [:ignored |]	"Context runSimulated: [Pen new defaultNib: 5; go: 100]"! !!MCMczReader methodsFor: 'loading' stamp: 'PavelKrivanek 7/6/2017 11:20' prior: 33827758!loadDefinitions	definitions := OrderedCollection new.	(self zip memberNamed: 'snapshot.bin') ifNotNil:		[:m | [^ definitions := (MCDataStream on: m contentStream) next definitions]			on: Error do: [:fallThrough |]].	"otherwise"	(self zip membersMatching: 'snapshot/*')		do: [:m | self extractDefinitionsFrom: m].! !!TBehaviorCategorization methodsFor: 'organization' stamp: 'PavelKrivanek 7/6/2017 11:16' prior: 33854492!category	"Answer the system organization category for the receiver. First check whether the	category name stored in the ivar is still correct and only if this fails look it up	(latter is much more expensive)"	| result |	self basicCategory ifNotNil: [ :symbol |		((self environment organization listAtCategoryNamed: symbol) includes: self name)			ifTrue: [ ^symbol ] ].	result := (self environment organization categoryOfElement: self name)		ifNil: [ #Unclassified ]		ifNotNil: [:aString | aString ].	self basicCategory: result.		^ result! !!MCVersion methodsFor: 'enumerating' stamp: 'PavelKrivanek 7/6/2017 11:19' prior: 33828175!withAllDependenciesDo: aBlock	self allDependenciesDo: aBlock ifUnresolved: [:ignored |].	aBlock value: self! !!Text class methodsFor: 'initialization' stamp: 'PavelKrivanek 7/6/2017 11:18' prior: 33862248!initialize	"Text initialize"	"Initialize constants shared by classes associated with text display."	TextSharedInformation at: #CaretForm put:				(Form extent: 16@5					fromArray: #(							2r00110000000000000000000000000000						2r00110000000000000000000000000000					 	2r01111000000000000000000000000000					 	2r11111100000000000000000000000000					 	2r11001100000000000000000000000000)					offset: -3@0).! !!MCMcdReader methodsFor: 'loading' stamp: 'PavelKrivanek 7/6/2017 11:21' prior: 33828379!loadPatch	| old new |	(self zip memberNamed: 'patch.bin') ifNotNil:		[:m | [^ patch := (MCDataStream on: m contentStream) next ]			on: Error do: [:fallThrough |]].	definitions := OrderedCollection new.	(self zip membersMatching: 'old/*')		do: [:m | self extractDefinitionsFrom: m].	old := definitions asArray.	definitions := OrderedCollection new.	(self zip membersMatching: 'new/*')		do: [:m | self extractDefinitionsFrom: m].	new := definitions asArray.	^ patch := self buildPatchFrom: old to: new.	! !!FFISizeT class methodsFor: 'converting' stamp: 'PavelKrivanek 7/6/2017 11:17' prior: 33805469!asExternalTypeOn: generator	"We resolve size_t to a uint/ulong which may be not the case always"	^ generator resolveType: #ulong! !!MCPatch methodsFor: 'intializing' stamp: 'PavelKrivanek 7/6/2017 11:20' prior: 33828989!initializeWithBase: baseSnapshot target: targetSnapshot	| base target |		operations := OrderedCollection new.	base := MCDefinitionIndex definitions: baseSnapshot definitions.	target := MCDefinitionIndex definitions: targetSnapshot definitions.		target definitions 		do: [ :t |			base				definitionLike: t				ifPresent: [:b | (b isSameRevisionAs: t) ifFalse: [operations add: (MCModification of: b to: t)]]				ifAbsent:  [operations add: (MCAddition of: t)] ]		displayingProgress: 'Diffing...'.			base definitions do: [:b |		target			definitionLike: b			ifPresent: [:t |]			ifAbsent: [operations add: (MCRemoval of: b)]]		! !!Job class methodsFor: 'examples' stamp: 'PavelKrivanek 7/6/2017 11:21' prior: 33855129!exampleCurrentValue	[ :job| 		job title: 'Simulating some progress for 1 Second'. 		1 second wait. "simulate some work"		job currentValue: 50.		1 second wait. "simulate some more work"		job currentValue: 100.		1 second wait. "simulate some more work"	] asJob run! !!Trait method!category	"Answer the system organization category for the receiver. First check whether the	category name stored in the ivar is still correct and only if this fails look it up	(latter is much more expensive)"	| result |	self basicCategory ifNotNil: [ :symbol |		((self environment organization listAtCategoryNamed: symbol) includes: self name)			ifTrue: [ ^symbol ] ].	result := (self environment organization categoryOfElement: self name)		ifNil: [ #Unclassified ]		ifNotNil: [:aString | aString ].	self basicCategory: result.		^ result! !!Trait method!category	"Answer the system organization category for the receiver. First check whether the	category name stored in the ivar is still correct and only if this fails look it up	(latter is much more expensive)"	| result |	self basicCategory ifNotNil: [ :symbol |		((self environment organization listAtCategoryNamed: symbol) includes: self name)			ifTrue: [ ^symbol ] ].	result := (self environment organization categoryOfElement: self name)		ifNil: [ #Unclassified ]		ifNotNil: [:aString | aString ].	self basicCategory: result.		^ result! !!Trait method!category	"Answer the system organization category for the receiver. First check whether the	category name stored in the ivar is still correct and only if this fails look it up	(latter is much more expensive)"	| result |	self basicCategory ifNotNil: [ :symbol |		((self environment organization listAtCategoryNamed: symbol) includes: self name)			ifTrue: [ ^symbol ] ].	result := (self environment organization categoryOfElement: self name)		ifNil: [ #Unclassified ]		ifNotNil: [:aString | aString ].	self basicCategory: result.		^ result! !"Jobs"!"Kernel"!"Monticello"!"Text-Core"!"Traits"!"UnifiedFFI"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.583.mcz') load.ScriptLoader new update60507.!----End fileIn----!----QUIT----2017-07-06T14:47:02.648193+02:00 Pharo.image priorSource: 334882!----QUIT----2017-07-06T14:47:13.080132+02:00 Pharo.image priorSource: 359862!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 7/11/2017 17:51' prior: 33889484!commentForCurrentUpdate ^ '20226 TabMorph should use stepping mechanism for animating background building	https://pharo.fogbugz.com/f/cases/2022620238 Run out of memory the image hangs without out of memory warning	https://pharo.fogbugz.com/f/cases/20238'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 7/11/2017 17:51'!script60508	^ 'AST-Core-TheIntegrator.496.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.23.mczCodeImport-TheIntegrator.92.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.195.mczCollections-Strings-TheIntegrator.451.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.105.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.31.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.431.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.190.mczGraphics-Files-TheIntegrator.80.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.87.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.34.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2522.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.177.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.195.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1183.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.315.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.56.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.85.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.892.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1437.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.792.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.388.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.76.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.73.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.39.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.992.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.197.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.113.mczUnifiedFFI-Legacy-EstebanLorenzano.3.mczUnifiedFFI-Tests-EstebanLorenzano.41.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.461.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.40.mczZodiac-Core-TheIntegrator.48.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 7/11/2017 17:51'!update60508	"self new update60508"	self withUpdateLog: '20226 TabMorph should use stepping mechanism for animating background building	https://pharo.fogbugz.com/f/cases/2022620238 Run out of memory the image hangs without out of memory warning	https://pharo.fogbugz.com/f/cases/20238'.	self loadTogether: self script60508 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60507!ScriptLoader removeSelector: #script60507!"ScriptLoader60"!!TabBuildingIconMorph commentStamp: 'DenisKudryashov 7/6/2017 15:19' prior: 0!I implement rotated icon to animate background tab building. I use stepping mechanizm for animation.Just create my instance with #new message to use in other morphs.Internal Representation and Key Implementation Points.    Instance Variables	progress:		<Integer>	progressIconMorph:		<ImageMorph>    Implementation Points!!MorphicUIManager methodsFor: 'debug' stamp: 'DenisKudryashov 7/11/2017 15:10' prior: 51990251!lowSpaceWatcherDefaultAction: theInterruptedProcess	"Create a Notifier on the active scheduling process with the given label."	| preemptedProcess projectProcess debugSession |	ActiveHand ifNotNil:[ActiveHand interrupted].	ActiveWorld := World. "reinstall active globals"	ActiveHand := World primaryHand.	ActiveHand interrupted. "make sure this one's interrupted too"	ActiveEvent := nil.	projectProcess := self uiProcess.	"we still need the accessor for a while"	preemptedProcess := theInterruptedProcess ifNil: [Processor preemptedProcess].	"Only debug preempted process if its priority is >= projectProcess' priority"	preemptedProcess priority < projectProcess priority 		ifTrue:[preemptedProcess := projectProcess].	preemptedProcess suspend.		debugSession := preemptedProcess 		newDebugSessionNamed: 'Space is low' 		startedAt: preemptedProcess suspendedContext.			debugSession logStackToFileIfNeeded.	debugSession isAboutUIProcess ifTrue: [ 		DefaultExecutionEnvironment beActiveDuring: [self spawnNewProcess]].		Smalltalk tools debugger 		openOn: debugSession 		withFullView: false 		andNotification: self lowSpaceWarningMessage! !!TabBuildingIconMorph methodsFor: 'stepping and presenter' stamp: 'DenisKudryashov 7/6/2017 15:17'!currentIcon	^TabMorph perform: (#refreshIcon, progress asString) asSymbol! !!TabBuildingIconMorph methodsFor: 'initialization' stamp: 'DenisKudryashov 7/6/2017 15:17'!initialize	super initialize.	self 		clipLayoutCells: true;		color: Color transparent.	progress := 1.	progressIconMorph := self currentIcon asMorph.	self addMorphBack: progressIconMorph.	self extent: progressIconMorph extent.! !!TabBuildingIconMorph methodsFor: 'stepping and presenter' stamp: 'DenisKudryashov 7/6/2017 15:17'!step	progress := progress + 1.	progress > 10 ifTrue: [ progress := 1 ].		progressIconMorph form: self currentIcon! !!TabBuildingIconMorph methodsFor: 'stepping and presenter' stamp: 'DenisKudryashov 7/6/2017 15:17'!stepTime		^ 100 "milliseconds"! !!TabMorph methodsFor: 'protocol' stamp: 'DenisKudryashov 7/6/2017 15:12' prior: 63411623!retrieveMorph: aBlock	"This is a hard request. The result is blocking contrary to softRetrieveMorph.	Late binding so the morph may be built only on demand"	morph ifNotNil: [ 		aBlock value: morph.		^ nil ].	retrievingSemaphore isSignaled		ifFalse: [ self softRetrieveMorph ].	^ [ retrievingSemaphore wait.		morph ifNotNil: [ 			UIManager default defer: [aBlock value: morph ]]] 				fork! !!TabMorph methodsFor: 'protocol' stamp: 'DenisKudryashov 7/6/2017 15:20' prior: 63406869!softRetrieveMorph	| oldIcon |	"Like retrieveMorph but done in a separated process"		morph ifNotNil: [ ^ self ].		retrievingProcess 		ifNotNil: [ 			"The retrieving process is already running, let's wait for its result"			retrievingProcess isTerminated 				ifFalse: [ ^ self ] ].		oldIcon := self icon ifNotNil: [ :i | i form ].	label icon: TabBuildingIconMorph new.	retrievingProcess := [ [		morph := retrievingBlock value]	ensure: [				UIManager default defer: [			self icon: oldIcon.			self triggerEvent: #tabRefreshed with: self].		"I should signal all waiters here"		[retrievingSemaphore isEmpty] whileFalse: [ retrievingSemaphore signal].	] ] forkAt: Processor activePriority - 2! !TabMorph removeSelector: #createAnimationProcess!"Morphic-Widgets-Tabs"!"Polymorph-Widgets"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.584.mcz') load.ScriptLoader new update60508.!----End fileIn----!----QUIT----2017-07-12T13:02:48.26072+02:00 Pharo.image priorSource: 359941!----QUIT----2017-07-12T13:02:59.007705+02:00 Pharo.image priorSource: 383187!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 7/21/2017 17:43' prior: 33914544!commentForCurrentUpdate ^ '20262 Update Iceberg to 0.5.4	https://pharo.fogbugz.com/f/cases/20262'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 7/21/2017 17:43'!script60509	^ 'AST-Core-TheIntegrator.496.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.23.mczCodeImport-TheIntegrator.92.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.195.mczCollections-Strings-TheIntegrator.451.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.105.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.31.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.431.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.190.mczGraphics-Files-TheIntegrator.80.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.87.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.34.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2522.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.177.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.195.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1183.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.315.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.56.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.85.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.892.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1437.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.792.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.388.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.76.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.73.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.39.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.992.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.197.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.113.mczUnifiedFFI-Legacy-EstebanLorenzano.3.mczUnifiedFFI-Tests-EstebanLorenzano.41.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.461.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.40.mczZodiac-Core-TheIntegrator.48.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 7/21/2017 17:43'!update60509	"self new update60509"	self withUpdateLog: '20262 Update Iceberg to 0.5.4	https://pharo.fogbugz.com/f/cases/20262'.	self loadTogether: self script60509 merge: false.	#('Iceberg-UI' 'Iceberg-Plugin' 'Iceberg-Metacello-Integration' 'Iceberg-Libgit' 'Iceberg' 'BaselineOfIceberg' 'LibGit-Core' 'BaselineOfLibGit') do: [ :each | each asPackage removeFromSystem ].Metacello new  baseline: 'Iceberg';  repository: 'github://pharo-vcs/iceberg:v0.5.4';  load.(Smalltalk classNamed: #Iceberg) enableMetacelloIntegration: false.	self flushCaches.! !ScriptLoader removeSelector: #update60508!ScriptLoader removeSelector: #script60508!"ScriptLoader60"!Smalltalk globals removeClassNamed: #AnObsoleteIceGlamourPublishBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceCommitInfoModel!Smalltalk globals removeClassNamed: #AnObsoleteGLMSwappedColorDiffPresentation!Smalltalk globals removeClassNamed: #AnObsoleteIceAbstractBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceAskForPlaintextCredentialsModel!Smalltalk globals removeClassNamed: #AnObsoleteIceLocationModel!Smalltalk globals removeClassNamed: #AnObsoleteIceDiffChangeTreeBuilder!Smalltalk globals removeClassNamed: #AnObsoleteSwappedColorDiffMorph!Smalltalk globals removeClassNamed: #AnObsoleteIceNewRepositoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceBranchBrowser!IceTool removeSelector: #pushRepository:andThen:!IceTool removeSelector: #uiManager!IceTool removeSelector: #mergeIntoAnotherBranch:andThen:!IceTool class removeSelector: #uiManager!IceMergeTool removeSelector: #pushRepository:andThen:!IceMergeTool removeSelector: #uiManager!IceMergeTool removeSelector: #mergeIntoAnotherBranch:andThen:!IceMergeTool class removeSelector: #uiManager!IceCommitModel removeSelector: #pushRepository:andThen:!IceCommitModel removeSelector: #uiManager!IceCommitModel removeSelector: #mergeIntoAnotherBranch:andThen:!IceCommitModel class removeSelector: #uiManager!Smalltalk globals removeClassNamed: #AnObsoleteTIceTool!Smalltalk globals removeClassNamed: #AnObsoleteIceCommitModel!Smalltalk globals removeClassNamed: #AnObsoleteIceCreateRepositoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGlamourCommitBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceAskForUsernameAndEmailModel!Smalltalk globals removeClassNamed: #AnObsoleteIceInteractiveCredentialsProvider!Smalltalk globals removeClassNamed: #AnObsoleteIceGlamourSynchronizer!Smalltalk globals removeClassNamed: #AnObsoleteIceRemoteAdded!Smalltalk globals removeClassNamed: #AnObsoleteIceFileModel!Smalltalk globals removeClassNamed: #AnObsoleteIceChangesTreeResetSelectionHelper!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoriesBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceImportLocalRepositoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceMergeTool!Smalltalk globals removeClassNamed: #AnObsoleteIcePackageModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGlamourUpdateBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceCloneRepositoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceEmbeddedBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceAskForSshCredentialsModel!Smalltalk globals removeClassNamed: #AnObsoleteIceRemoteModel!Smalltalk globals removeClassNamed: #AnObsoleteIceTool!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryUpdateHelper!Smalltalk globals removeClassNamed: #AnObsoleteGLMMorphicSwappedColorDiffRenderer!Smalltalk globals removeClassNamed: #AnObsoleteIceDirectoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceCachedValue!Smalltalk globals removeClassNamed: #AnObsoleteIceHistoryBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceGlamourChangesTree!Smalltalk globals removeClassNamed: #AnObsoleteIceEditRepositoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceAbstractModel!MCPatchOperation removeSelector: #canBeBrowsed!Text removeSelector: #allItalic!GLMMorphicRenderer removeSelector: #renderSwappedColorDiffPresentation:!GLMGenericAction removeSelector: #selectionAction:!GLMGenericAction removeSelector: #selectionCondition:!GLMGenericAction removeSelector: #showTitle:!MCModification removeSelector: #icon!MCAddition removeSelector: #icon!DateAndTime removeSelector: #asStringYMDHM!DateAndTime removeSelector: #asLocalStringYMDHM!GLMCompositePresentation removeSelector: #swappedColorDiff!MCRemoval removeSelector: #canBeBrowsed!MCRemoval removeSelector: #icon!Smalltalk globals removeClassNamed: #AnObsoleteIcePharoFogbugzModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubAPI!Smalltalk globals removeClassNamed: #AnObsoleteIcePlugin!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubPullRequestPlugin!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubCommand!Smalltalk globals removeClassNamed: #AnObsoleteIcePharoFogbugzPlugin!Smalltalk globals removeClassNamed: #AnObsoleteIcePluginManager!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubNewPullRequestCommand!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubBadCredentialsError!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubRemoveBranchesCommand!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubError!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubPullRequest!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubGenericError!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubSelectItem!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubPullRequestModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubSelectListModel!Smalltalk globals removeClassNamed: #AnObsoleteIceBaselineInstallerPlugin!IceRepository removeSelector: #pluginManager!Smalltalk globals removeClassNamed: #AnObsoleteIceGitLocalRepositoryType!Smalltalk globals removeClassNamed: #AnObsoleteIceGithubRepositoryType!Smalltalk globals removeClassNamed: #AnObsoleteIceMetacelloRepositoryType!Smalltalk globals removeClassNamed: #AnObsoleteIceMetacelloPharoPlatform!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitVersionReader!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitTreeBuilder!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitLocalRepository!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitCommitWalk!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitWriter!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitStCypressWriter!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitFileUtils!Smalltalk globals removeClassNamed: #AnObsoleteIcePackageLoaded!Smalltalk globals removeClassNamed: #AnObsoleteIceHttpRemote!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryForgotten!Smalltalk globals removeClassNamed: #AnObsoleteIceDiff!Smalltalk globals removeClassNamed: #AnObsoleteIcePackageUnloaded!Smalltalk globals removeClassNamed: #AnObsoleteIceLocalBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceLocalRepositoryMissing!Smalltalk globals removeClassNamed: #AnObsoleteIcePlaintextCredentials!Smalltalk globals removeClassNamed: #AnObsoleteIceMethodChange!Smalltalk globals removeClassNamed: #AnObsoleteNothingToCommitException!Smalltalk globals removeClassNamed: #AnObsoleteIceSavedPackage!Smalltalk globals removeClassNamed: #AnObsoleteIceRemovedClassReference!Smalltalk globals removeClassNamed: #AnObsoleteManifestIceberg!Smalltalk globals removeClassNamed: #AnObsoleteIceCredentialsProvider!Smalltalk globals removeClassNamed: #AnObsoleteTIceRepositoryBackend!Smalltalk globals removeClassNamed: #AnObsoleteIceChangeSet!Smalltalk globals removeClassNamed: #AnObsoleteIceUndefinedRemote!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryModified!Smalltalk globals removeClassNamed: #AnObsoleteIceTemporaryVersion!Smalltalk globals removeClassNamed: #AnObsoleteIceChangeSetChanged!Smalltalk globals removeClassNamed: #AnObsoleteIceTag!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryRegistryModified!Smalltalk globals removeClassNamed: #AnObsoleteIceNetworkRemote!Smalltalk globals removeClassNamed: #AnObsoleteCannotIdentifyVersionForCommit!Smalltalk globals removeClassNamed: #AnObsoleteIceAbstractVersion!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryCreated!Smalltalk globals removeClassNamed: #AnObsoleteIceCommitInfo!Smalltalk globals removeClassNamed: #AnObsoleteIceVersionDoesNotExist!Smalltalk globals removeClassNamed: #AnObsoleteIceFileRemote!Smalltalk globals removeClassNamed: #AnObsoleteIceStructuralChangeSet!Smalltalk globals removeClassNamed: #AnObsoleteIceError!Smalltalk globals removeClassNamed: #AnObsoleteIceberg!Smalltalk globals removeClassNamed: #AnObsoleteIceBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceMetadatalessFileTreeWriter!Smalltalk globals removeClassNamed: #AnObsoleteIcePackageReference!Smalltalk globals removeClassNamed: #AnObsoleteIceClassChangeSet!Smalltalk globals removeClassNamed: #AnObsoleteIceMergeAborted!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryCreator!Smalltalk globals removeClassNamed: #AnObsoleteIceClassReference!Smalltalk globals removeClassNamed: #AnObsoleteIceMCVersionInfo!Smalltalk globals removeClassNamed: #AnObsoleteIceWorkingCopy!Smalltalk globals removeClassNamed: #AnObsoleteIceAbstractDiff!Smalltalk globals removeClassNamed: #AnObsoleteIceWrongUrl!Smalltalk globals removeClassNamed: #AnObsoleteIceRemote!Smalltalk globals removeClassNamed: #AnObsoleteIceSavedPackageVersion!Smalltalk globals removeClassNamed: #AnObsoleteIcePushed!Smalltalk globals removeClassNamed: #AnObsoleteIceLoadedCode!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryAnnouncement!Smalltalk globals removeClassNamed: #AnObsoleteIceGitUsernameOrEmailNotFound!Smalltalk globals removeClassNamed: #AnObsoleteIceHttpsRemote!Smalltalk globals removeClassNamed: #AnObsoleteIceFullDiff!Smalltalk globals removeClassNamed: #AnObsoleteIceCommited!Smalltalk globals removeClassNamed: #AnObsoleteIceRemoteBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceMissingRepositoryEntry!Smalltalk globals removeClassNamed: #AnObsoleteIcePackageChangeSet!Smalltalk globals removeClassNamed: #AnObsoleteIceDuplicatedRepository!Smalltalk globals removeClassNamed: #AnObsoleteIceSshCredentials!Smalltalk globals removeClassNamed: #AnObsoleteIceSimpleClassReference!Smalltalk globals removeClassNamed: #AnObsoleteIceMetadatalessStCypressWriter!Smalltalk globals removeClassNamed: #AnObsoleteIceMetacelloRepositoryAdapter!Smalltalk globals removeClassNamed: #AnObsoleteIcePackageOrganizationChange!Smalltalk globals removeClassNamed: #AnObsoleteYouShouldPullBeforePush!Smalltalk globals removeClassNamed: #AnObsoleteIceRepository!Smalltalk globals removeClassNamed: #AnObsoleteIceBackendWriterAdapter!Smalltalk globals removeClassNamed: #AnObsoleteIceUnbornBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceAbstractCommitWalk!Smalltalk globals removeClassNamed: #AnObsoleteIceNoRemoteBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceScpRemote!Smalltalk globals removeClassNamed: #AnObsoleteIceForeignVersion!Smalltalk globals removeClassNamed: #AnObsoleteIceNoCurrentBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceCommitish!LGitTreeEntry removeSelector: #readStreamDo:!LGitTreeEntry removeSelector: #tree!LGitTreeEntry removeSelector: #name!MCDefinition removeSelector: #iceClass!MCDefinition removeSelector: #addAnalysisToPackageChangeSet:change:!MCDefinition removeSelector: #addToPackageChangeSet:!MCDefinition removeSelector: #icePackage!MCWorkingCopy removeSelector: #loadedVersion!MCVersion removeSelector: #directoryName!MCGitHubRepository removeSelector: #getOrCreateIcebergRepository!MCGitHubRepository removeSelector: #commitIdFor:ifFound:!MCGitHubRepository removeSelector: #commitId!MCGitHubRepository removeSelector: #httpsUrl!MCGitHubRepository removeSelector: #scpUrl!MCPatchOperation removeSelector: #iceClass!MCPatchOperation removeSelector: #icePackage!MCPatchOperation removeSelector: #addToPackageChangeSet:!MCPatchOperation removeSelector: #asIceChangeSet!LGitTag removeSelector: #asIcebergObjectInRepository:!LGitCredentialsPlaintext removeSelector: #readFrom:!LGitDiff removeSelector: #includesFileNamed:!LGitDiff removeSelector: #filesDo:!MCOrganizationDefinition removeSelector: #iceClass!MCOrganizationDefinition removeSelector: #addAnalysisToPackageChangeSet:change:!MCOrganizationDefinition removeSelector: #icePackage!LGitCredentialsSSH removeSelector: #readFrom:!MCPostscriptDefinition removeSelector: #addToPackageChangeSet:!MCRepository removeSelector: #commitIdFor:ifFound:!LGitReturnCodeEnum removeSelector: #asBoolean!RPackage removeSelector: #iceRepository!LGitCommit removeSelector: #changesFileNamed:!LGitCommit removeSelector: #asIcebergObjectInRepository:!MCClassDefinition removeSelector: #classCategory!MCMethodDefinition removeSelector: #method!MCMethodDefinition removeSelector: #classCategory!MCMethodDefinition removeSelector: #icePackage!FileSystemDirectoryEntry removeSelector: #packageName!MCGitHubRepository class removeSelector: #commitIdFor:!Smalltalk globals removeClassNamed: #AnObsoleteBaselineOfIceberg!Smalltalk globals removeClassNamed: #AnObsoleteLGitId!Smalltalk globals removeClassNamed: #AnObsoleteLGitObject!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffBinaryTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushTransferCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffBinary!Smalltalk globals removeClassNamed: #AnObsoleteLGitBlame!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalUInt8Array!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffFileCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitRepositoryNotFound!Smalltalk globals removeClassNamed: #AnObsoleteLGitTreewalkModeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitSafeFFICalloutAPI!Smalltalk globals removeClassNamed: #AnObsoleteLGitIllegalArgument!Smalltalk globals removeClassNamed: #AnObsoleteLGitProxyTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitDatabase!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EEOF!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalEnumerationInt32!LGitExternalStructure removeSelector: #shouldContinuePrintingOn:!LGitExternalStructure removeSelector: #objectPrintOn:!LGitExternalStructure removeSelector: #printOn:!LGitExternalObject removeSelector: #objectPrintOn:!LGitExternalObject removeSelector: #printOn:!Smalltalk globals removeClassNamed: #AnObsoleteTLGitPrintingTrait!Smalltalk globals removeClassNamed: #AnObsoleteLGitTreeEntry!Smalltalk globals removeClassNamed: #AnObsoleteLGitLibrary!Smalltalk globals removeClassNamed: #AnObsoleteLGitPackbuilderForeachPayload!Smalltalk globals removeClassNamed: #AnObsoleteLGitTree!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffFlagTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitActionSequence!Smalltalk globals removeClassNamed: #AnObsoleteLGitRemoteCreateCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffDelta!Smalltalk globals removeClassNamed: #AnObsoleteLGitCommitBuilder!Smalltalk globals removeClassNamed: #AnObsoleteLGitBranchTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffLineCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitRefSpec!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EPEEL!Smalltalk globals removeClassNamed: #AnObsoleteLGitWritepackAppendCallout!Smalltalk globals removeClassNamed: #AnObsoleteLGitCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitReferenceTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EINVALID!Smalltalk globals removeClassNamed: #AnObsoleteLGitMergeOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGitWriteBackValueInt!Smalltalk globals removeClassNamed: #AnObsoleteLGitReturnCodeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitNoReturnCodeHandlerDefined!Smalltalk globals removeClassNamed: #AnObsoleteLGitSafeFFICalloutMethodBuilder!Smalltalk globals removeClassNamed: #AnObsoleteLGitRemoteHead!Smalltalk globals removeClassNamed: #AnObsoleteLGitPathSpecMatchList!Smalltalk globals removeClassNamed: #AnObsoleteLGitStatusCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffHunk!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiff!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutStrategyEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EBUFS!Smalltalk globals removeClassNamed: #AnObsoleteLGitBuf!Smalltalk globals removeClassNamed: #AnObsoleteLGitIndexMatchedPathCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitWritepackFreeCallout!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutPerfDataCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ECERTIFICATE!Smalltalk globals removeClassNamed: #AnObsoleteLGitRemoteCompletionTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EUNMERGED!Smalltalk globals removeClassNamed: #AnObsoleteLGitFetchPruneTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitAbstractError!Smalltalk globals removeClassNamed: #AnObsoleteLGitStringArray!Smalltalk globals removeClassNamed: #AnObsoleteLGitRemote!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffLineTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EUNBORNBRANCH!Smalltalk globals removeClassNamed: #AnObsoleteLGitTransportCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffPerfData!Smalltalk globals removeClassNamed: #AnObsoleteLGitIndex!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredentialsTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EMODIFIED!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredentialsPlaintext!Smalltalk globals removeClassNamed: #AnObsoleteLGitPackbuilderProgressCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitPackBuilder!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalArray!Smalltalk globals removeClassNamed: #AnObsoleteLGitCompletionCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitStatusTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EEXISTS!Smalltalk globals removeClassNamed: #AnObsoleteLGitStructWithDefaults!Smalltalk globals removeClassNamed: #AnObsoleteLGitCallReturnHandler!Smalltalk globals removeClassNamed: #AnObsoleteLGitOpenFlagEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitTransport!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredentials!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGitRevwalk!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffStatsFormatTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitObjectNotFound!Smalltalk globals removeClassNamed: #AnObsoleteLGitTransportMessageCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitError!Smalltalk globals removeClassNamed: #AnObsoleteLGitCommit!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushStatusForeachCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredentialsSSHAgent!Smalltalk globals removeClassNamed: #AnObsoleteLGitAnnotatedCommit!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalStringArray!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EAMBIGUOUS!Smalltalk globals removeClassNamed: #AnObsoleteLGitSubmoduleIgnoreTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffBinaryCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitTransferProgress!Smalltalk globals removeClassNamed: #AnObsoleteLGitObjectNotInitialized!Smalltalk globals removeClassNamed: #AnObsoleteLGitPathSpecFlagTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_OK!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffFindOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGitTreeBuilder!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EAUTH!Smalltalk globals removeClassNamed: #AnObsoleteLGitErrorTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitUpdateTipsCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitOdbWritepack!Smalltalk globals removeClassNamed: #AnObsoleteLGitTag!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffFindTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushUpdateReferenceCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffBinaryFile!Smalltalk globals removeClassNamed: #AnObsoleteLGitBranchIterator!Smalltalk globals removeClassNamed: #AnObsoleteLGitBlameFlagTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitWritingTreeFailed!Smalltalk globals removeClassNamed: #AnObsoleteLGitFunctionReturn!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffHunkCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredentialsFreeCallout!Smalltalk globals removeClassNamed: #AnObsoleteManifestLibGitCore!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushOptionsVersionEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EUSER!Smalltalk globals removeClassNamed: #AnObsoleteLGitFetchOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGitWriteBackValue!Smalltalk globals removeClassNamed: #AnObsoleteLGitObjectTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitCallout!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalStructure!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalStructureFieldParser!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushUpdate!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ERROR!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffFormatTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitPatch!Smalltalk globals removeClassNamed: #AnObsoleteLGitRepositoryCreateCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffFile!Smalltalk globals removeClassNamed: #AnObsoleteLGitConfig!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutNotifyTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EINVALIDSPEC!Smalltalk globals removeClassNamed: #AnObsoleteLGitBlameHunk!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffNotifyCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitWritepackCommitCallout!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EUNCOMMITTED!Smalltalk globals removeClassNamed: #AnObsoleteLGitRemoteAutotagOptionTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutNotifyCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitProxyOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ECONFLICT!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalEnumerationUInt32!Smalltalk globals removeClassNamed: #AnObsoleteLGitWriteBackValueUInt!Smalltalk globals removeClassNamed: #AnObsoleteLGitSignature!Smalltalk globals removeClassNamed: #AnObsoleteLGitReference!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EAPPLIED!Smalltalk globals removeClassNamed: #AnObsoleteLGitTransferProgressCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffLine!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffStats!Smalltalk globals removeClassNamed: #AnObsoleteLGitCloneLocalTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitPackbuilderForeachCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutPerfData!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EORPHANEDHEAD!LGitGlobal removeSelector: #safeFFICalloutIn:!LGitGlobal removeSelector: #signalNotReady!LGitGlobal removeSelector: #validate:shouldBe:!LGitGlobal removeSelector: #ifNotReady:!LGitGlobal removeSelector: #withReturnHandlerDo:!LGitGlobal removeSelector: #ffiLibrary!LGitGlobal removeSelector: #ffiLibraryName!LGitGlobal removeSelector: #callUnchecked:options:!LGitGlobal removeSelector: #call:options:!LGitGlobal removeSelector: #signalIfNotReady!LGitGlobal removeSelector: #call:!LGitGlobal removeSelector: #ffiNull!LGitGlobal removeSelector: #isReady!LGitGlobal class removeSelector: #ffiLibrary!LGitGlobal class removeSelector: #ffiLibraryName!LGitGlobal class removeSelector: #call:options:!LGitGlobal class removeSelector: #validate:shouldBe:!LGitGlobal class removeSelector: #call:!LGitGlobal class removeSelector: #withReturnHandlerDo:!LGitExternalObject removeSelector: #safeFFICalloutIn:!LGitExternalObject removeSelector: #signalNotReady!LGitExternalObject removeSelector: #validate:shouldBe:!LGitExternalObject removeSelector: #ifNotReady:!LGitExternalObject removeSelector: #withReturnHandlerDo:!LGitExternalObject removeSelector: #ffiLibrary!LGitExternalObject removeSelector: #ffiLibraryName!LGitExternalObject removeSelector: #callUnchecked:options:!LGitExternalObject removeSelector: #call:options:!LGitExternalObject removeSelector: #signalIfNotReady!LGitExternalObject removeSelector: #call:!LGitExternalObject removeSelector: #ffiNull!LGitExternalObject class removeSelector: #ffiLibrary!LGitExternalObject class removeSelector: #ffiLibraryName!LGitExternalObject class removeSelector: #call:options:!LGitExternalObject class removeSelector: #validate:shouldBe:!LGitExternalObject class removeSelector: #call:!LGitExternalObject class removeSelector: #withReturnHandlerDo:!Smalltalk globals removeClassNamed: #AnObsoleteTLGitCalloutTrait!Smalltalk globals removeClassNamed: #AnObsoleteLGitOdb!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutProgressCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitRevwalkSortTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ELOCKED!Smalltalk globals removeClassNamed: #AnObsoleteLGitRemoteCallbacks!Smalltalk globals removeClassNamed: #AnObsoleteLGitCallError!Smalltalk globals removeClassNamed: #AnObsoleteLGitFilemodeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EBAREREPO!Smalltalk globals removeClassNamed: #AnObsoleteLGitBlameOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalObject!Smalltalk globals removeClassNamed: #AnObsoleteLGitRepositoryObject!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffOptionTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitOpeningRepositoryError!Smalltalk globals removeClassNamed: #AnObsoleteLGitTransportCertificateCheckCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffSimilarityMetric!Smalltalk globals removeClassNamed: #AnObsoleteLGitBlob!Smalltalk globals removeClassNamed: #AnObsoleteLGitDeltaTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushNegotiationCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredentialsSSH!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ENOTFOUND!Smalltalk globals removeClassNamed: #AnObsoleteLGitRepository!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalCommitArray!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredAcquireCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitStructVersionsEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ENONFASTFORWARD!Smalltalk globals removeClassNamed: #AnObsoleteLGitTime!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_PASSTHROUGH!Smalltalk globals removeClassNamed: #AnObsoleteLGitOptionsVersionsEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ITEROVER!Smalltalk globals removeClassNamed: #AnObsoleteLGitCloneOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGitNoCredentialsProvided!Smalltalk globals removeClassNamed: #AnObsoleteLGitDirectionEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitStatusList!Smalltalk globals removeClassNamed: #AnObsoleteLGitGlobal!Smalltalk globals removeClassNamed: #AnObsoleteLGitTreewalkCallback!Object removeSelector: #handleLGitReturnCode!String removeSelector: #asLGitExternalString!Smalltalk globals removeClassNamed: #AnObsoleteBaselineOfLibGit!!BaselineOfIceberg methodsFor: 'baseline' stamp: ' 7/21/2017 17:44:53'!baseline: spec	<baseline>	spec for: #common do: [ 				spec postLoadDoIt: #resetKMRepository.				spec		configuration: 'OSSubprocess' with: [ spec			versionString: #stable;			repository: 'github://marianopeck/OSSubprocess/repository' ];		configuration: 'ProcessWrapper' with: [ spec			versionString: #stable;			repository: 'http://smalltalkhub.com/mc/Pharo/MetaRepoForPharo50/main' ];		baseline: 'FileTree' with: [ spec			repository: 'github://pharo-vcs/filetree:pharo6.0_dev/repository';			loads: 'Git' ];		baseline: 'LibGit' with: [ spec			repository: 'github://pharo-vcs/libgit2-pharo-bindings:v0.25.1';  			loads: 'default' ];		project: 'LibGit-Tests'          copyFrom: 'LibGit'          with: [ spec loads: #('tests') ];		for: #MacOS do: [ spec			package: 'Iceberg-GitCommand'			with: [ spec requires: #('OSSubprocess') ] ];		for: #Unix do: [ spec			package: 'Iceberg-GitCommand'			with: [ spec requires: #('OSSubprocess' ) ] ];		for: #Windows do: [ spec			package: 'Iceberg-GitCommand'			with: [ spec requires: #('ProcessWrapper') ] ];		package: 'Iceberg';		package: 'Iceberg-Plugin' with: [ spec requires: #('Iceberg') ];		package: 'Iceberg-Plugin-GitHub' with: [ spec requires: #('Iceberg-Plugin' 'Iceberg-UI') ];		package: 'Iceberg-Metacello-Integration' with: [ spec requires: #('Iceberg')];		package: 'Iceberg-UI' with: [ spec requires: #('Iceberg') ];		package: 'Iceberg-Tests' with: [ spec requires: #('Iceberg' 'Iceberg-GitCommand') ];		package: 'Iceberg-UI-Tests' with: [ spec requires: #('Iceberg-UI' 'Iceberg-Tests')];		package: 'Iceberg-GitFileTree' with: [ spec requires: #('Iceberg' 'FileTree') ];		package: 'Iceberg-GitFileTree-Tests' with: [ spec requires: #('Iceberg-GitFileTree' 'Iceberg-Tests') ];		package: 'Iceberg-Libgit' with: [ spec requires: #('Iceberg' 'LibGit') ];		group: 'minimal' with: #('Iceberg' 'Iceberg-Libgit');		group: 'default' with: #(minimal 'Iceberg-Metacello-Integration' 'Iceberg-UI' 'Iceberg-Plugin' 'Iceberg-Plugin-GitHub');		group: 'allTests' with: #('Iceberg-Tests' 'LibGit-Tests' 'Iceberg-GitFileTree-Tests' 'Iceberg-UI-Tests' );		group: 'development' with: #(default 'Iceberg-GitFileTree' allTests)	]! !!BaselineOfIceberg methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:53'!customProjectAttributes	Smalltalk os isMacOS ifTrue: [ ^ #(#MacOS) ].	Smalltalk os isUnix ifTrue: [ ^ #(#Unix) ].	Smalltalk os isWindows ifTrue: [ ^ #(#Windows) ]! !!BaselineOfIceberg methodsFor: 'script' stamp: ' 7/21/2017 17:44:53'!resetKMRepository	KMRepository reset! !"BaselineOfIceberg"!!BaselineOfLibGit methodsFor: 'baseline' stamp: ' 7/21/2017 17:44:56'!baseline: spec  <baseline>  spec    for: #(common)    do: [       spec        package: 'LibGit-Tests' with: [ spec requires: 'LibGit-Core' ];        package: 'LibGit-GT' with: [ spec requires: 'LibGit-Core' ];        package: 'LibGit-Patches' with: [ spec requires: 'LibGit-Core' ];        package: 'LibGit-Core'.      spec        group: 'default'        with: #('LibGit-Core').		spec			group: 'development'			with: #('default' 'LibGit-Tests' 'LibGit-Patches' 'LibGit-GT').		spec			group: 'tests'			with: #('LibGit-Tests').		spec postLoadDoIt: #postLoadActions ]! !!BaselineOfLibGit methodsFor: 'doits' stamp: ' 7/21/2017 17:44:56'!changeRepositoryType	| repos newRepo |	(Smalltalk hasClassNamed: #MCGitRepository) ifFalse: [ ^ self ].		repos := MCRepositoryGroup default repositories		select: [ :r | (r description includesSubstring: 'LibGit:master') or: [ 			r description includesSubstring: 'LibGit/master' ] ].	repos ifEmpty: [  ^ self ].		'github-cache/theseion' asFileReference deleteAll.	newRepo := (Smalltalk at: #MCGitRepository) new		repoUrl: 'git@github.com:theseion/LibGit';		ensureDirectory;		yourself.			MCRepositoryGroup allInstances		select: [ :group | group repositories includesAnyOf: repos ]		thenDo: [ :group | 			repos do: [ :repo | group removeRepository: repo ].			group addRepository: newRepo ]! !!BaselineOfLibGit methodsFor: 'doits' stamp: ' 7/21/2017 17:44:56'!postLoadActions	self changeRepositoryType! !"BaselineOfLibGit"!!LGitExternalArray commentStamp: 'MaxLeske 7/14/2015 09:09' prior: 0!I provide general implementations for my subclasses that represent dedicated arrays of a certain type.!!LGitExternalCommitArray commentStamp: 'MaxLeske 7/13/2015 17:10' prior: 0!I represent an external array of commits.!!LGitExternalStringArray commentStamp: 'MaxLeske 7/13/2015 17:12' prior: 0!I represent an external array of strings. Since strings are of variable size, they can not be easily represented by the general implementation.I take care of converting regular strings to external ones (which allocates and reserves the memory) and reading strings from memory.I override #free to ensure that the memory for the external strings is correctly freed.!!LGitExternalUInt8Array commentStamp: 'MaxLeske 7/15/2015 10:31' prior: 0!My elements are 8 bit unsigned integers.!!LGitExternalEnumerationUInt32 commentStamp: 'MaxLeske 3/17/2014 13:57' prior: 0!See the comment in NBExternalEnumeration. I am a copy of NBExternalEnumeration with the exception that I inherit from Object, not from SharedPool.!!LGitCheckoutStrategyEnum commentStamp: 'MaxLeske 8/13/2015 11:06' prior: 0!/** * Checkout behavior flags * * In libgit2, checkout is used to update the working directory and index * to match a target tree.  Unlike git checkout, it does not move the HEAD * commit for you - use `git_repository_set_head` or the like to do that. * * Checkout looks at (up to) four things: the "target" tree you want to * check out, the "baseline" tree of what was checked out previously, the * working directory for actual files, and the index for staged changes. * * You give checkout one of three strategies for update: * * - `GIT_CHECKOUT_NONE` is a dry-run strategy that checks for conflicts, *   etc., but doesn't make any actual changes. * * - `GIT_CHECKOUT_FORCE` is at the opposite extreme, taking any action to *   make the working directory match the target (including potentially *   discarding modified files). * * - `GIT_CHECKOUT_SAFE` is between these two options, it will only make *   modifications that will not lose changes. * *                         |  target == baseline   |  target !!= baseline  | *    ---------------------|-----------------------|----------------------| *     workdir == baseline |       no action       |  create, update, or  | *                         |                       |     delete file      | *    ---------------------|-----------------------|----------------------| *     workdir exists and  |       no action       |   conflict (notify   | *       is !!= baseline    | notify dirty MODIFIED | and cancel checkout) | *    ---------------------|-----------------------|----------------------| *      workdir missing,   | notify dirty DELETED  |     create file      | *      baseline present   |                       |                      | *    ---------------------|-----------------------|----------------------| * * To emulate `git checkout`, use `GIT_CHECKOUT_SAFE` with a checkout * notification callback (see below) that displays information about dirty * files.  The default behavior will cancel checkout on conflicts. * * To emulate `git checkout-index`, use `GIT_CHECKOUT_SAFE` with a * notification callback that cancels the operation if a dirty-but-existing * file is found in the working directory.  This core git command isn't * quite "force" but is sensitive about some types of changes. * * To emulate `git checkout -f`, use `GIT_CHECKOUT_FORCE`. * * * There are some additional flags to modified the behavior of checkout: * * - GIT_CHECKOUT_ALLOW_CONFLICTS makes SAFE mode apply safe file updates *   even if there are conflicts (instead of cancelling the checkout). * * - GIT_CHECKOUT_REMOVE_UNTRACKED means remove untracked files (i.e. not *   in target, baseline, or index, and not ignored) from the working dir. * * - GIT_CHECKOUT_REMOVE_IGNORED means remove ignored files (that are also *   untracked) from the working directory as well. * * - GIT_CHECKOUT_UPDATE_ONLY means to only update the content of files that *   already exist.  Files will not be created nor deleted.  This just skips *   applying adds, deletes, and typechanges. * * - GIT_CHECKOUT_DONT_UPDATE_INDEX prevents checkout from writing the *   updated files' information to the index. * * - Normally, checkout will reload the index and git attributes from disk *   before any operations.  GIT_CHECKOUT_NO_REFRESH prevents this reload. * * - Unmerged index entries are conflicts.  GIT_CHECKOUT_SKIP_UNMERGED skips *   files with unmerged index entries instead.  GIT_CHECKOUT_USE_OURS and *   GIT_CHECKOUT_USE_THEIRS to proceed with the checkout using either the *   stage 2 ("ours") or stage 3 ("theirs") version of files in the index. * * - GIT_CHECKOUT_DONT_OVERWRITE_IGNORED prevents ignored files from being *   overwritten.  Normally, files that are ignored in the working directory *   are not considered "precious" and may be overwritten if the checkout *   target contains that file. * * - GIT_CHECKOUT_DONT_REMOVE_EXISTING prevents checkout from removing *   files or folders that fold to the same name on case insensitive *   filesystems.  This can cause files to retain their existing names *   and write through existing symbolic links. */!!LGitDeltaTypeEnum commentStamp: 'MaxLeske 8/13/2015 10:32' prior: 0!/** * What type of change is described by a git_diff_delta? * * `GIT_DELTA_RENAMED` and `GIT_DELTA_COPIED` will only show up if you run * `git_diff_find_similar()` on the diff object. * * `GIT_DELTA_TYPECHANGE` only shows up given `GIT_DIFF_INCLUDE_TYPECHANGE` * in the option flags (otherwise type changes will be split into ADDED / * DELETED pairs). */!!LGitDiffBinaryTypeEnum commentStamp: 'MaxLeske 8/13/2015 14:28' prior: 0!/** * When producing a binary diff, the binary data returned will be * either the deflated full ("literal") contents of the file, or * the deflated binary delta between the two sides (whichever is * smaller). */!!LGitOptionsVersionsEnum commentStamp: 'MaxLeske 7/17/2015 13:37' prior: 0!I map names to versions for all the option structs.!!LGitProxyTypeEnum commentStamp: '<historical>' prior: 0!/** * The type of proxy to use. */!!LGitRevwalkSortTypeEnum commentStamp: 'MaxLeske 3/1/2015 16:39' prior: 0!/** * Sort the repository contents in no particular ordering; * this sorting is arbitrary, implementation-specific * and subject to change at any time. * This is the default sorting for new walkers. */#define GIT_SORT_NONE			(0)/** * Sort the repository contents in topological order * (parents before children); this sorting mode * can be combined with time sorting. */#define GIT_SORT_TOPOLOGICAL (1 << 0)/** * Sort the repository contents by commit time; * this sorting mode can be combined with * topological sorting. */#define GIT_SORT_TIME			(1 << 1)/** * Iterate through the repository contents in reverse * order; this sorting mode can be combined with * any of the above. */#define GIT_SORT_REVERSE		(1 << 2)!!LGitStatusTypeEnum commentStamp: 'MaxLeske 8/13/2015 10:34' prior: 0!/** * Status flags for a single file. * * A combination of these values will be returned to indicate the status of * a file.  Status compares the working directory, the index, and the * current HEAD of the repository.  The `GIT_STATUS_INDEX` set of flags * represents the status of file in the index relative to the HEAD, and the * `GIT_STATUS_WT` set of flags represent the status of the file in the * working directory relative to the index. */!!LGitRefSpec commentStamp: 'MaxLeske 4/18/2014 11:59' prior: 0!Use:	LGitRefSpec fromString: '+refs/heads/*:refs/remotes/origin/*'.Note: The asterisk wildcard (*) matches all refs of a given path (not explicitly documented in the below).From the git-fetch man page:<refspec>           The format of a <refspec> parameter is an optional plus +, followed by the source           ref <src>, followed by a colon :, followed by the destination ref <dst>.           The remote ref that matches <src> is fetched, and if <dst> is not empty string,           the local ref that matches it is fast-forwarded using <src>. If the optional plus           + is used, the local ref is updated even if it does not result in a fast-forward           update.               Note               If the remote branch from which you want to pull is modified in non-linear               ways such as being rewound and rebased frequently, then a pull will attempt a               merge with an older version of itself, likely conflict, and fail. It is under               these conditions that you would want to use the + sign to indicate               non-fast-forward updates will be needed. There is currently no easy way to               determine or declare that a branch will be made available in a repository               with this behavior; the pulling user simply must know this is the expected               usage pattern for a branch.               Note               You never do your own development on branches that appear on the right hand               side of a <refspec> colon on Pull: lines; they are to be updated by git               fetch. If you intend to do development derived from a remote branch B, have a               Pull: line to track it (i.e.  Pull: B:remote-B), and have a separate branch               my-B to do your development on top of it. The latter is created by git branch               my-B remote-B (or its equivalent git checkout -b my-B remote-B). Run git               fetch to keep track of the progress of the remote side, and when you see               something new on the remote branch, merge it into your development branch               with git pull . remote-B, while you are on my-B branch.               Note               There is a difference between listing multiple <refspec> directly on git pull               command line and having multiple Pull: <refspec> lines for a <repository> and               running git pull command without any explicit <refspec> parameters. <refspec>               listed explicitly on the command line are always merged into the current               branch after fetching. In other words, if you list more than one remote refs,               you would be making an Octopus. While git pull run without any explicit               <refspec> parameter takes default <refspec>s from Pull: lines, it merges only               the first <refspec> found into the current branch, after fetching all the               remote refs. This is because making an Octopus from remote refs is rarely               done, while keeping track of multiple remote heads in one-go by fetching more               than one is often useful.Some short-cut notations are also supported.           o    tag <tag> means the same as refs/tags/<tag>:refs/tags/<tag>; it requests               fetching everything up to the given tag.           o   A parameter <ref> without a colon fetches that ref into FETCH_HEAD, and               updates the remote-tracking branches (if any).!!LGitExternalStructure commentStamp: 'MaxLeske 3/1/2015 20:36' prior: 0!Important: structs in libgit2 are usually freed by libgit2 itself.	We therefore disable freeing of structs during GC to prevent invalid	memory accesses. However, users of any struct need to make sure that	they free the struct (using a manual #free send) iff it is necessary.	Otherwise the structs will leak and we can't reclaim the space once the	object representing the struct has been collected!!LGitCredentialsSSH commentStamp: '<historical>' prior: 0!I'm a set of credentials who asks public/private keys from from files (in case you need something different than what is answered by ssh-agent, provided by LGitCredentialsSSHAgent)!!LGitCredentialsSSHAgent commentStamp: '<historical>' prior: 0!I'm a set of credentials who feeds from the ssh-agent client.!!LGitDiffBinary commentStamp: 'MaxLeske 8/13/2015 14:22' prior: 0!/** Structure describing the binary contents of a diff. */!!LGitDiffBinaryFile commentStamp: 'MaxLeske 8/13/2015 14:22' prior: 0!/** The contents of one of the files in a binary diff. */!!LGitDiffDelta commentStamp: 'MaxLeske 7/4/2015 17:03' prior: 0!I represent the difference between two entities (e.g. two files). If one of the entities is new or deleted the "nfiles" field will hold be set to 1, otherwise it will be set to 2.!!LGitId commentStamp: '<historical>' prior: 0!I'm an unique identity of any object (commit, tree, blob, tag).https://libgit2.github.com/libgit2/#HEAD/type/git_oidNOTE: This might be replaces by an FFITypeArray in the future.!!LGitRemoteHead commentStamp: 'EstebanLorenzano 1/5/2017 16:00' prior: 0!I'm a description of a reference advertised by a remote server, given out on `ls` calls.https://libgit2.github.com/libgit2/#HEAD/type/git_remote_head!!LGitSignature commentStamp: '<historical>' prior: 0!A LGitSignature represents the information of a specific person for a commit.Instance Variables	email:		ByteString	name:		ByteString	when:		DateAndTime!!LGitProxyOptions commentStamp: '<historical>' prior: 0!/** * Options for connecting through a proxy * * Note that not all types may be supported, depending on the platform * and compilation options. */!!LGitPushOptions commentStamp: 'MaxLeske 8/13/2015 23:46' prior: 0!/** * Controls the behavior of a git_push object. */!!LGitRemoteCallbacks commentStamp: 'MaxLeske 8/13/2015 13:20' prior: 0!/** * The callback settings structure * * Set the callbacks to be called by the remote when informing the user * about the progress of the network operations. */!!LGitSafeFFICalloutAPI commentStamp: 'JanVanDeSandt 5/1/2016 21:18' prior: 0!I'm a variant of FFICalloutAPI that uses a different builder to generate methods with an extra check to see if the object is 'ready' or not.!!LGitRepository commentStamp: '<historical>' prior: 0!A LGitRepository represents a git repository.Instance Variables	handle:		NBExternalObjecthandle	- reference to the external object!!LGitConfig commentStamp: 'NicoPasserini 2/8/2017 00:51' prior: 0!/** Memory representation of a set of config files */typedef struct git_config git_config;https://libgit2.github.com/libgit2/#HEAD/type/git_config!!LGitCommit commentStamp: 'NicoPasserini 11/3/2016 15:40' prior: 0!A LGitCommit represents a specific commit and the associate information.Instance Variables	handle:		NBExternalObjecthandle	- the handle to the external data object!!LGitTag commentStamp: 'NicoPasserini 11/3/2016 15:40' prior: 0!A LGitTag represents a git tag and the associate information.Instance Variables	handle:		NBExternalObjecthandle	- the handle to the external data object!!LGitReference commentStamp: '<historical>' prior: 0!A LGitReference represents the reference to a git object. References can be symbolic as for instance HEAD or a branch etc.Instance Variables	handle:			NBExternalObject	repoHandle:	NBExternalObjecthandle	- the reference to the external object representing the referencerepoHandle	- the reference to the repository in which the reference is contained!!LGitNoCredentialsProvided commentStamp: 'EstebanLorenzano 2/8/2017 16:19' prior: 0!I'm an error thrown in callbacks when no credentials has been found.Callbacks supplying credentials HAVE to throw this error and not one created by themselves (because libgit2 aborts processing with this exception and not with others). !!ManifestLibGitCore commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!LGitCredAcquireCallback commentStamp: 'MaxLeske 3/1/2015 16:57' prior: 0!/** * Signature of a function which acquires a credential object. * * - cred: The newly created credential object. * - url: The resource for which we are demanding a credential. * - username_from_url: The username that was embedded in a "user@host" *                          remote url, or NULL if not included. * - allowed_types: A bitmask stating which cred types are OK to return. * - payload: The payload provided when specifying this callback. * - returns 0 for success, < 0 to indicate an error, > 0 to indicate *       no credential was acquired */!!LGitIndexMatchedPathCallback commentStamp: '<historical>' prior: 0!I define a git_index_matched_path_cb.https://libgit2.github.com/libgit2/#HEAD/group/callback/git_index_matched_path_cb!!LGitSafeFFICalloutMethodBuilder commentStamp: 'JanVanDeSandt 5/1/2016 21:17' prior: 0!I'm a variant of FFICalloutMethodBuilder  that adds a call to  #signalIfNotReady  before the actual ffi call.!!TLGitCalloutTrait classTrait methodsFor: 'ffi-calls' stamp: ' 7/21/2017 17:44:56'!call: fnSpec	^ (self ffiCalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibrary! !!TLGitCalloutTrait classTrait methodsFor: 'ffi-calls' stamp: ' 7/21/2017 17:44:56'!call: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibrary! !!TLGitCalloutTrait classTrait methodsFor: 'resources' stamp: ' 7/21/2017 17:44:56'!ffiLibrary	^LGitLibrary ! !!TLGitCalloutTrait classTrait methodsFor: 'resources' stamp: ' 7/21/2017 17:44:56'!ffiLibraryName	^self ffiLibrary! !!TLGitCalloutTrait classTrait methodsFor: 'argument validation' stamp: ' 7/21/2017 17:44:56'!validate: anObject shouldBe: aClass	"I allow for nil values."	(anObject isNil or: [ anObject isKindOf: aClass ])		ifFalse: [ LGitIllegalArgument signalWith: anObject shouldBe: aClass ]! !!TLGitCalloutTrait classTrait methodsFor: 'exit code handling' stamp: ' 7/21/2017 17:44:56'!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!TLGitCalloutTrait methodsFor: 'ffi-calls' stamp: ' 7/21/2017 17:44:56'!call: fnSpec	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibraryName! !!TLGitCalloutTrait methodsFor: 'ffi-calls' stamp: ' 7/21/2017 17:44:56'!call: fnSpec options: options	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!TLGitCalloutTrait methodsFor: 'ffi-calls' stamp: ' 7/21/2017 17:44:56'!callUnchecked: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!TLGitCalloutTrait methodsFor: 'resources' stamp: ' 7/21/2017 17:44:56'!ffiLibrary	^self class ffiLibrary! !!TLGitCalloutTrait methodsFor: 'resources' stamp: ' 7/21/2017 17:44:56'!ffiLibraryName	^self class ffiLibrary! !!TLGitCalloutTrait methodsFor: 'resources' stamp: ' 7/21/2017 17:44:56'!ffiNull	^FFIExternalObject null! !!TLGitCalloutTrait methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!ifNotReady: aBlock	"use extra block so compiler can optimize"	self isReady ifFalse: [ aBlock value ]! !!TLGitCalloutTrait methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isReady	^ true! !!TLGitCalloutTrait methodsFor: 'ffi-calls' stamp: ' 7/21/2017 17:44:56'!safeFFICalloutIn: aContext	^ LGitSafeFFICalloutAPI inContext: aContext! !!TLGitCalloutTrait methodsFor: 'signalling' stamp: ' 7/21/2017 17:44:56'!signalIfNotReady	self ifNotReady: [ self signalNotReady ]! !!TLGitCalloutTrait methodsFor: 'signalling' stamp: ' 7/21/2017 17:44:56'!signalNotReady	LGitObjectNotInitialized signalWith: self! !!TLGitCalloutTrait methodsFor: 'argument validation' stamp: ' 7/21/2017 17:44:56'!validate: anObject shouldBe: aClass	self class validate: anObject shouldBe: aClass! !!TLGitCalloutTrait methodsFor: 'exit code handling' stamp: ' 7/21/2017 17:44:56'!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!TLGitPrintingTrait methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!objectPrintOn: aStream! !!TLGitPrintingTrait methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!printOn: aStream	| title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: [ 'an ' ] ifFalse: [ 'a ' ]);		nextPutAll: title.			(self shouldContinuePrintingOn: aStream) ifFalse: [ ^ self ].		aStream nextPutAll: ' ('.	self objectPrintOn: aStream.	aStream nextPut: $)! !!TLGitPrintingTrait methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!shouldContinuePrintingOn: aStream	^ true! !!LGitExternalArray class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!externalNew: numberOfElements	^ self 		externalNewType: self type 		size: numberOfElements! !!LGitExternalArray class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!onAddress: handle size: numberOfElements	^ self fromHandle: handle type: self type size: numberOfElements! !!LGitExternalArray class methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!type 	^ self subclassResponsibility! !!LGitExternalArray methodsFor: 'converting' stamp: ' 7/21/2017 17:44:56'!asArray	| array |	array := Array new: self size.	1 to: self size do: [ :index |		array			at: index			put: (self at: index) ].			^ array! !!LGitExternalCommitArray class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!fromCollection: aCollection	| instance |	instance := self externalNew: aCollection size.	aCollection withIndexDo: [ :commit :index |		instance at: index put: commit ].		^ instance! !!LGitExternalCommitArray class methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!type 	^ LGitCommit! !!LGitExternalCommitArray methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!at: anIndex	^ LGitCommit fromHandle: (super at: anIndex)! !!LGitExternalCommitArray methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!at: anIndex put: aLGitCommit	^ super at: anIndex put: aLGitCommit getHandle! !!LGitExternalStringArray class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!fromCollection: aCollection	| instance |	instance := self externalNew: aCollection size.	aCollection withIndexDo: [ :element :index |		instance at: index put: element ].		^ instance! !!LGitExternalStringArray class methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!type	^ 'char*'! !!LGitExternalStringArray methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!at: anInteger	^ (self primAt: anInteger) readString! !!LGitExternalStringArray methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!at: index put: aString	^ super at: index put: aString asLGitExternalString getHandle! !!LGitExternalStringArray methodsFor: 'initialize-release' stamp: ' 7/21/2017 17:44:56'!free	1 to: self size do: [ :index | 		(self primAt: index) free ].		super free! !!LGitExternalStringArray methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!primAt: anInteger	^ super at: anInteger! !!LGitExternalUInt8Array class methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!type	^ FFIUInt32! !!LGitExternalUInt8Array methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!type 	^ FFIUInt8! !!LGitBlameFlagTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^ #(		"Normal blame the default"		GIT_BLAME_NORMAL 0		"Track lines that have moved within a file (like `git blame -M`).		 * NOT IMPLEMENTED."		GIT_BLAME_TRACK_COPIES_SAME_FILE 1		"Track lines that have moved across files in the same commit (like `git blame -C`).		 * NOT IMPLEMENTED."		GIT_BLAME_TRACK_COPIES_SAME_COMMIT_MOVES 2		"Track lines that have been copied from another file that exists in the		 * same commit (like `git blame -CC`). Implies SAME_FILE.		 * NOT IMPLEMENTED."		GIT_BLAME_TRACK_COPIES_SAME_COMMIT_COPIES 4		"Track lines that have been copied from another file that exists in *any*		 * commit (like `git blame -CCC`). Implies SAME_COMMIT_COPIES.		 * NOT IMPLEMENTED."		GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES 8		"Restrict the search of commits to those reachable following only the		 * first parents."		GIT_BLAME_FIRST_PARENT 16	)! !!LGitBlameFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_blame_first_parent	^ self basicNew		value: 16;		yourself! !!LGitBlameFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_blame_normal	^ self basicNew		value: 0;		yourself! !!LGitBlameFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_blame_track_copies_any_commit_copies	^ self basicNew		value: 8;		yourself! !!LGitBlameFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_blame_track_copies_same_commit_copies	^ self basicNew		value: 4;		yourself! !!LGitBlameFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_blame_track_copies_same_commit_moves	^ self basicNew		value: 2;		yourself! !!LGitBlameFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_blame_track_copies_same_file	^ self basicNew		value: 1;		yourself! !!LGitBranchTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_BRANCH_LOCAL 1	GIT_BRANCH_REMOTE 2	GIT_BRANCH_ALL 3)! !!LGitBranchTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_branch_all	^ self basicNew		value: 3;		yourself! !!LGitBranchTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_branch_local	^ self basicNew		value: 1;		yourself! !!LGitBranchTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_branch_remote	^ self basicNew		value: 2;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_CHECKOUT_NOTIFY_NONE 0	GIT_CHECKOUT_NOTIFY_CONFLICT 1	GIT_CHECKOUT_NOTIFY_DIRTY 2	GIT_CHECKOUT_NOTIFY_UPDATED 4	GIT_CHECKOUT_NOTIFY_UNTRACKED 8	GIT_CHECKOUT_NOTIFY_IGNORED 16	GIT_CHECKOUT_NOTIFY_ALL 65535)! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_notify_all	^ self basicNew		value: 65535;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_notify_conflict	^ self basicNew		value: 1;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_notify_dirty	^ self basicNew		value: 2;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_notify_ignored	^ self basicNew		value: 16;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_notify_none	^ self basicNew		value: 0;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_notify_untracked	^ self basicNew		value: 8;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_notify_updated	^ self basicNew		value: 4;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'enum description' stamp: ' 7/21/2017 17:44:56'!enumDecl	^ #(		GIT_CHECKOUT_NONE  0 "< default is a dry run, no actual updates "		" Allow safe updates that cannot overwrite uncommitted data "		GIT_CHECKOUT_SAFE  "1 bitShift: 0" 1		" Allow all updates to force working directory to look like index "		GIT_CHECKOUT_FORCE  "1 bitShift: 1" 2		" Allow checkout to recreate missing files "		GIT_CHECKOUT_RECREATE_MISSING  "1 bitShift: 2" 4		" Allow checkout to make safe updates even if conflicts are found "		GIT_CHECKOUT_ALLOW_CONFLICTS  "1 bitShift: 4" 16		" Remove untracked files not in index (that are not ignored) "		GIT_CHECKOUT_REMOVE_UNTRACKED  "1 bitShift: 5" 32		" Remove ignored files not in index "		GIT_CHECKOUT_REMOVE_IGNORED  "1 bitShift: 6" 64		" Only update existing files, don't create new ones "		GIT_CHECKOUT_UPDATE_ONLY  "1 bitShift: 7" 128		"		 * Normally checkout updates index entries as it goes; this stops that.		 * Implies `GIT_CHECKOUT_DONT_WRITE_INDEX`.		 "		GIT_CHECKOUT_DONT_UPDATE_INDEX  "1 bitShift: 8" 256		" Don't refresh index/config/etc before doing checkout "		GIT_CHECKOUT_NO_REFRESH  "1 bitShift: 9" 512		" Allow checkout to skip unmerged files "		GIT_CHECKOUT_SKIP_UNMERGED  "1 bitShift: 10" 1024		" For unmerged files, checkout stage 2 from index "		GIT_CHECKOUT_USE_OURS  "1 bitShift: 11" 2048		" For unmerged files, checkout stage 3 from index "		GIT_CHECKOUT_USE_THEIRS  "1 bitShift: 12" 4096		" Treat pathspec as simple list of exact match file paths "		GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH  "1 bitShift: 13" 8192		" Ignore directories in use, they will be left empty "		GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES  "1 bitShift: 18" 262144		" Don't overwrite ignored files that exist in the checkout target "		GIT_CHECKOUT_DONT_OVERWRITE_IGNORED  "1 bitShift: 19" 524288		" Write normal merge files for conflicts "		GIT_CHECKOUT_CONFLICT_STYLE_MERGE  "1 bitShift: 20" 1048576		" Include common ancestor data in diff3 format files for conflicts "		GIT_CHECKOUT_CONFLICT_STYLE_DIFF3  "1 bitShift: 21" 2097152		" Don't overwrite existing files or folders "		GIT_CHECKOUT_DONT_REMOVE_EXISTING  "1 bitShift: 22" 4194304		" Normally checkout writes the index upon completion; this prevents that. "		GIT_CHECKOUT_DONT_WRITE_INDEX  "1 bitShift: 23" 8388608		"		 * THE FOLLOWING OPTIONS ARE NOT YET IMPLEMENTED		 "		" Recursively checkout submodules with same options (NOT IMPLEMENTED) "		GIT_CHECKOUT_UPDATE_SUBMODULES  "1 bitShift: 16" 65536		" Recursively checkout submodules if HEAD moved in super repo (NOT IMPLEMENTED) "		GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED  "1 bitShift: 17" 131072)! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_allow_conflicts	^ self basicNew		value: 16;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_conflict_style_diff3	^ self basicNew		value: 2097152;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_conflict_style_merge	^ self basicNew		value: 1048576;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_disable_pathspec_match	^ self basicNew		value: 8192;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_dont_overwrite_ignored	^ self basicNew		value: 524288;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_dont_remove_existing	^ self basicNew		value: 4194304;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_dont_update_index	^ self basicNew		value: 256;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_dont_write_index	^ self basicNew		value: 8388608;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_force	^ self basicNew		value: 2;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_no_refresh	^ self basicNew		value: 512;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_none	^ self basicNew		value: 0;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_recreate_missing	^ self basicNew		value: 4;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_remove_ignored	^ self basicNew		value: 64;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_remove_untracked	^ self basicNew		value: 32;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_safe	^ self basicNew		value: 1;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_safe_create	^ self basicNew		value: 2;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_skip_locked_directories	^ self basicNew		value: 262144;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_skip_unmerged	^ self basicNew		value: 1024;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_update_only	^ self basicNew		value: 128;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_update_submodules	^ self basicNew		value: 65536;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_update_submodules_if_changed	^ self basicNew		value: 131072;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_use_ours	^ self basicNew		value: 2048;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_use_theirs	^ self basicNew		value: 4096;		yourself! !!LGitCloneLocalTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^ #(			GIT_CLONE_LOCAL_AUTO 0			GIT_CLONE_LOCAL 1			GIT_CLONE_NO_LOCAL 2			GIT_CLONE_LOCAL_NO_LINKS 3		)! !!LGitCloneLocalTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_clone_local	^ self basicNew		value: 1;		yourself! !!LGitCloneLocalTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_clone_local_auto	^ self basicNew		value: 0;		yourself! !!LGitCloneLocalTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_clone_local_no_links	^ self basicNew		value: 3;		yourself! !!LGitCloneLocalTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_clone_no_local	^ self basicNew		value: 2;		yourself! !!LGitCredentialsTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_CREDTYPE_USERPASS_PLAINTEXT 1	GIT_CREDTYPE_SSH_KEY 2	GIT_CREDTYPE_SSH_CUSTOM 4	GIT_CREDTYPE_DEFAULT 8)! !!LGitCredentialsTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_credtype_default	^ self basicNew		value: 8;		yourself! !!LGitCredentialsTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_credtype_ssh_custom	^ self basicNew		value: 4;		yourself! !!LGitCredentialsTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_credtype_ssh_key	^ self basicNew		value: 2;		yourself! !!LGitCredentialsTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_credtype_userpass_plaintext	^ self basicNew		value: 1;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_DELTA_UNMODIFIED 0 "no changes"	GIT_DELTA_ADDED 1 "entry does not exist in old version"	GIT_DELTA_DELETED 2 "entry does not exist in new version"	GIT_DELTA_MODIFIED 3 "entry content changed between old and new"	GIT_DELTA_RENAMED 4 "entry was renamed between old and new"	GIT_DELTA_COPIED 5 "entry was copied from another old entry"	GIT_DELTA_IGNORED 6 "entry is ignored item in workdir"	GIT_DELTA_UNTRACKED 7 "entry is untracked item in workdir"	GIT_DELTA_TYPECHANGE 8 "type of entry changed between old and new"	GIT_DELTA_UNREADABLE 9 "entry is unreadable"	GIT_DELTA_CONFLICTED 10 "< entry in the index is conflicted")! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_delta_added	^ self basicNew		value: 1;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_delta_conflicted	^ self basicNew		value: 10;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_delta_copied	^ self basicNew		value: 5;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_delta_deleted	^ self basicNew		value: 2;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_delta_ignored	^ self basicNew		value: 6;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_delta_modified	^ self basicNew		value: 3;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_delta_renamed	^ self basicNew		value: 4;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_delta_typechange	^ self basicNew		value: 8;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_delta_unmodified	^ self basicNew		value: 0;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_delta_unreadable	^ self basicNew		value: 9;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_delta_untracked	^ self basicNew		value: 7;		yourself! !!LGitDiffBinaryTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(		" There is no binary delta. "		GIT_DIFF_BINARY_NONE 0		" The binary data is the literal contents of the file. "		GIT_DIFF_BINARY_LITERAL 1		" The binary data is the delta from one side to the other. "		GIT_DIFF_BINARY_DELTA 2	)! !!LGitDiffBinaryTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_binary_delta	^ self basicNew		value: 2;		yourself! !!LGitDiffBinaryTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_binary_literal	^ self basicNew		value: 1;		yourself! !!LGitDiffBinaryTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_binary_none	^ self basicNew		value: 0;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	<todo: 'enum defines 0 twice (one commented out). Use second enum?'>	^#(	" Obey `diff.renames`. Overridden by any other GIT_DIFF_FIND_... flag. "	GIT_DIFF_FIND_BY_CONFIG 0	" Look for renames? (`--find-renames`) "	GIT_DIFF_FIND_RENAMES 1	" Consider old side of MODIFIED for renames? (`--break-rewrites=N`) "	GIT_DIFF_FIND_RENAMES_FROM_REWRITES 2	" Look for copies? (a la `--find-copies`). "	GIT_DIFF_FIND_COPIES 4	" Consider UNMODIFIED as copy sources? (`--find-copies-harder`).	 *	 * For this to work correctly use GIT_DIFF_INCLUDE_UNMODIFIED when	 * the initial `git_diff` is being generated.	 "	GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED 8	" Mark significant rewrites for split (`--break-rewrites=/M`) "	GIT_DIFF_FIND_REWRITES 16	" Actually split large rewrites into delete/add pairs "	GIT_DIFF_BREAK_REWRITES 32	" Mark rewrites for split and break into delete/add pairs "	GIT_DIFF_FIND_AND_BREAK_REWRITES 48	" Find renames/copies for UNTRACKED items in working directory.	 *	 * For this to work correctly use GIT_DIFF_INCLUDE_UNTRACKED when the	 * initial `git_diff` is being generated (and obviously the diff must	 * be against the working directory for this to make sense).	 "	GIT_DIFF_FIND_FOR_UNTRACKED 64	" Turn on all finding features. "	GIT_DIFF_FIND_ALL 255	" Measure similarity ignoring leading whitespace (default) "	"GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE 0"	" Measure similarity ignoring all whitespace "	GIT_DIFF_FIND_IGNORE_WHITESPACE 4096	" Measure similarity including all data "	GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE 8192	" Measure similarity only by comparing SHAs (fast and cheap) "	GIT_DIFF_FIND_EXACT_MATCH_ONLY 16384	" Do not break rewrites unless they contribute to a rename.	 *	 * Normally GIT_DIFF_FIND_AND_BREAK_REWRITES will measure the self-	 * similarity of modified files and split the ones that have changed a	 * lot into a DELETE / ADD pair.  Then the sides of that pair will be	 * considered candidates for rename and copy detection.	 *	 * If you add this flag in and the split pair is *not* used for an	 * actual rename or copy then the modified record will be restored to	 * a regular MODIFIED record instead of being split.	 "	GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY 32768	" Remove any UNMODIFIED deltas after find_similar is done.	 *	 * Using GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED to emulate the	 * --find-copies-harder behavior requires building a diff with the	 * GIT_DIFF_INCLUDE_UNMODIFIED flag.  If you do not want UNMODIFIED	 * records in the final result pass this flag to have them removed.	 "	GIT_DIFF_FIND_REMOVE_UNMODIFIED 65536	)! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_break_rewrites	^ self basicNew		value: 32;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_break_rewrites_for_renames_only	^ self basicNew		value: 32768;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_all	^ self basicNew		value: 255;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_and_break_rewrites	^ self basicNew		value: 48;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_by_config	^ self basicNew		value: 0;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_copies	^ self basicNew		value: 4;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_copies_from_unmodified	^ self basicNew		value: 8;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_dont_ignore_whitespace	^ self basicNew		value: 8192;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_exact_match_only	^ self basicNew		value: 16384;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_for_untracked	^ self basicNew		value: 64;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_ignore_whitespace	^ self basicNew		value: 4096;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_remove_unmodified	^ self basicNew		value: 65536;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_renames	^ self basicNew		value: 1;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_renames_from_rewrites	^ self basicNew		value: 2;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_rewrites	^ self basicNew		value: 16;		yourself! !!LGitDiffFlagTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_DIFF_FLAG_BINARY 0 "file(s) treated as binary data"	GIT_DIFF_FLAG_NOT_BINARY 1 "file(s) treated as text data"	GIT_DIFF_FLAG_VALID_ID  2 "`id` value is known correct"	)! !!LGitDiffFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_flag_binary	^ self basicNew		value: 0;		yourself! !!LGitDiffFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_flag_not_binary	^ self basicNew		value: 1;		yourself! !!LGitDiffFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_flag_valid_id	^ self basicNew		value: 2;		yourself! !!LGitDiffFormatTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_DIFF_FORMAT_PATCH        1 "full git diff"	GIT_DIFF_FORMAT_PATCH_HEADER 2 "just the file headers of patch"	GIT_DIFF_FORMAT_RAW          3 "like git diff --raw"	GIT_DIFF_FORMAT_NAME_ONLY    4 "like git diff --name-only"	GIT_DIFF_FORMAT_NAME_STATUS  5 "like git diff --name-status"	)! !!LGitDiffFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_format_name_only	^ self basicNew		value: 4;		yourself! !!LGitDiffFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_format_name_status	^ self basicNew		value: 5;		yourself! !!LGitDiffFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_format_patch	^ self basicNew		value: 1;		yourself! !!LGitDiffFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_format_patch_header	^ self basicNew		value: 2;		yourself! !!LGitDiffFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_format_raw	^ self basicNew		value: 3;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^{	 "These values will be sent to `git_diff_line_cb` along with the line"	#GIT_DIFF_LINE_CONTEXT.   '$ '.	#GIT_DIFF_LINE_ADDITION.  '$+'.	#GIT_DIFF_LINE_DELETION.  '$-'.	#GIT_DIFF_LINE_CONTEXT_EOFNL. '$='."Both files have no LF at end"	#GIT_DIFF_LINE_ADD_EOFNL. '$>'.    "Old has no LF at end new does"	#GIT_DIFF_LINE_DEL_EOFNL. '$<'.    "Old has LF at end new does not"	"The following values will only be sent to a `git_diff_line_cb` when	 * the content of a diff is being formatted through `git_diff_print`.	"	#GIT_DIFF_LINE_FILE_HDR.  '$F'.	#GIT_DIFF_LINE_HUNK_HDR.  '$H'.	#GIT_DIFF_LINE_BINARY.    '$B' "For 'Binary files x and y differ'"	}! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_line_add_eofnl	^ self basicNew		value: $>;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_line_addition	^ self basicNew		value: $+;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_line_binary	^ self basicNew		value: $B;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_line_context	^ self basicNew		value: $ ;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_line_context_eofnl	^ self basicNew		value: $=;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_line_del_eofnl	^ self basicNew		value: $<;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_line_deletion	^ self basicNew		value: $-;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_line_file_hdr	^ self basicNew		value: $F;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_line_hunk_hdr	^ self basicNew		value: $H;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	"Normal diff, the default"	GIT_DIFF_NORMAL 0	"	 * Options controlling which files will be in the diff	"	"Reverse the sides of the diff"	GIT_DIFF_REVERSE 1	"Include ignored files in the diff"	GIT_DIFF_INCLUDE_IGNORED 2	"Even with GIT_DIFF_INCLUDE_IGNORED, an entire ignored directory	 *  will be marked with only a single entry in the diff; this flag	 *  adds all files under the directory as IGNORED entries, too.	"	GIT_DIFF_RECURSE_IGNORED_DIRS 4	"Include untracked files in the diff"	GIT_DIFF_INCLUDE_UNTRACKED 8	"Even with GIT_DIFF_INCLUDE_UNTRACKED, an entire untracked	 *  directory will be marked with only a single entry in the diff	 *  (a la what core Git does in `git status`); this flag adds *all*	 *  files under untracked directories as UNTRACKED entries, too.	"	GIT_DIFF_RECURSE_UNTRACKED_DIRS 16	"Include unmodified files in the diff"	GIT_DIFF_INCLUDE_UNMODIFIED 32	"Normally, a type change between files will be converted into a	 *  DELETED record for the old and an ADDED record for the new; this	 *  options enabled the generation of TYPECHANGE delta records.	"	GIT_DIFF_INCLUDE_TYPECHANGE 64	"Even with GIT_DIFF_INCLUDE_TYPECHANGE, blob->tree changes still	 *  generally show as a DELETED blob.  This flag tries to correctly	 *  label blob->tree transitions as TYPECHANGE records with new_file's	 *  mode set to tree.  Note: the tree SHA will not be available.	"	GIT_DIFF_INCLUDE_TYPECHANGE_TREES 128	"Ignore file mode changes"	GIT_DIFF_IGNORE_FILEMODE 256	"Treat all submodules as unmodified"	GIT_DIFF_IGNORE_SUBMODULES 512	"Use case insensitive filename comparisons"	GIT_DIFF_IGNORE_CASE 1024	"If the pathspec is set in the diff options, this flags means to	 *  apply it as an exact match instead of as an fnmatch pattern.	"	GIT_DIFF_DISABLE_PATHSPEC_MATCH 4096	"Disable updating of the `binary` flag in delta records.  This is	 *  useful when iterating over a diff if you don't need hunk and data	 *  callbacks and want to avoid having to load file completely.	"	GIT_DIFF_SKIP_BINARY_CHECK 8192	"When diff finds an untracked directory, to match the behavior of	 *  core Git, it scans the contents for IGNORED and UNTRACKED files.	 *  If *all* contents are IGNORED, then the directory is IGNORED; if	 *  any contents are not IGNORED, then the directory is UNTRACKED.	 *  This is extra work that may not matter in many cases.  This flag	 *  turns off that scan and immediately labels an untracked directory	 *  as UNTRACKED (changing the behavior to not match core Git).	"	GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS 16384	"When diff finds a file in the working directory with stat	 * information different from the index, but the OID ends up being the	 * same, write the correct stat information into the index.  Note:	 * without this flag, diff will always leave the index untouched.	"	GIT_DIFF_UPDATE_INDEX 32768	"Include unreadable files in the diff"	GIT_DIFF_INCLUDE_UNREADABLE 65536		"Include unreadable files in the diff"	GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED 131072	"	 * Options controlling how output will be generated	"	"Treat all files as text, disabling binary attributes & detection"	GIT_DIFF_FORCE_TEXT 1048576	"Treat all files as binary, disabling text diffs"	GIT_DIFF_FORCE_BINARY 2097152	"Ignore all whitespace"	GIT_DIFF_IGNORE_WHITESPACE 4194304	"Ignore changes in amount of whitespace"	GIT_DIFF_IGNORE_WHITESPACE_CHANGE 8388608	"Ignore whitespace at end of line"	GIT_DIFF_IGNORE_WHITESPACE_EOL 16777216	"When generating patch text, include the content of untracked	 *  files.  This automatically turns on GIT_DIFF_INCLUDE_UNTRACKED but	 *  it does not turn on GIT_DIFF_RECURSE_UNTRACKED_DIRS.  Add that	 *  flag if you want the content of every single UNTRACKED file.	"	GIT_DIFF_SHOW_UNTRACKED_CONTENT 33554432	"When generating output, include the names of unmodified files if	 *  they are included in the git_diff.  Normally these are skipped in	 *  the formats that list files (e.g. name-only, name-status, raw).	 *  Even with this, these will not be included in patch format.	"	GIT_DIFF_SHOW_UNMODIFIED 67108864	"Use the 'patience diff' algorithm"	GIT_DIFF_PATIENCE 268435456	"Take extra time to find minimal diff"	GIT_DIFF_MINIMAL 536870912	"Include the necessary deflate / delta information so that `git-apply`	 *  can apply given diff information to binary files.	"	GIT_DIFF_SHOW_BINARY 1073741824	)! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_disable_pathspec_match	^ self basicNew		value: 4096;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_enable_fast_untracked_dirs	^ self basicNew		value: 16384;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_force_binary	^ self basicNew		value: 2097152;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_force_text	^ self basicNew		value: 1048576;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_ignore_case	^ self basicNew		value: 1024;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_ignore_filemode	^ self basicNew		value: 256;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_ignore_submodules	^ self basicNew		value: 512;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_ignore_whitespace	^ self basicNew		value: 4194304;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_ignore_whitespace_change	^ self basicNew		value: 8388608;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_ignore_whitespace_eol	^ self basicNew		value: 16777216;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_include_ignored	^ self basicNew		value: 2;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_include_typechange	^ self basicNew		value: 64;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_include_typechange_trees	^ self basicNew		value: 128;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_include_unmodified	^ self basicNew		value: 32;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_include_unreadable	^ self basicNew		value: 65536;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_include_unreadable_as_untracked	^ self basicNew		value: 131072;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_include_untracked	^ self basicNew		value: 8;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_minimal	^ self basicNew		value: 536870912;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_normal	^ self basicNew		value: 0;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_patience	^ self basicNew		value: 268435456;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_recurse_ignored_dirs	^ self basicNew		value: 4;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_recurse_untracked_dirs	^ self basicNew		value: 16;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_reverse	^ self basicNew		value: 1;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_show_binary	^ self basicNew		value: 1073741824;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_show_unmodified	^ self basicNew		value: 67108864;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_show_untracked_content	^ self basicNew		value: 33554432;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_skip_binary_check	^ self basicNew		value: 8192;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_update_index	^ self basicNew		value: 32768;		yourself! !!LGitDiffStatsFormatTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	"No stats"	GIT_DIFF_STATS_NONE 0	"Full statistics equivalent of `--stat`"	GIT_DIFF_STATS_FULL 1	"Short statistics equivalent of `--shortstat`"	GIT_DIFF_STATS_SHORT 2	"Number statistics equivalent of `--numstat`"	GIT_DIFF_STATS_NUMBER 4	"Extended header information such as creations renames and mode changes equivalent of `--summary`"	GIT_DIFF_STATS_INCLUDE_SUMMARY 8	)! !!LGitDiffStatsFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_stats_full	^ self basicNew		value: 1;		yourself! !!LGitDiffStatsFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_stats_include_summary	^ self basicNew		value: 8;		yourself! !!LGitDiffStatsFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_stats_none	^ self basicNew		value: 0;		yourself! !!LGitDiffStatsFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_stats_number	^ self basicNew		value: 4;		yourself! !!LGitDiffStatsFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_stats_short	^ self basicNew		value: 2;		yourself! !!LGitDirectionEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_DIRECTION_FETCH 0	GIT_DIRECTION_PUSH 1)! !!LGitDirectionEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_direction_fetch	^ self basicNew		value: 0;		yourself! !!LGitDirectionEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_direction_push	^ self basicNew		value: 1;		yourself! !!LGitErrorTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^ #(		GITERR_NONE 0		GITERR_NOMEMORY		1		GITERR_OS				2		GITERR_INVALID		3			GITERR_REFERENCE		4		GITERR_ZLIB			5		GITERR_REPOSITORY	6		GITERR_CONFIG	7		GITERR_REGEX	8		GITERR_ODB	9		GITERR_INDEX			10		GITERR_OBJECT			11		GITERR_NET				12		GITERR_TAG			13		GITERR_TREE			14		GITERR_INDEXER		15		GITERR_SSL				16		GITERR_SUBMODULE	17		GITERR_THREAD		18		GITERR_STASH			19		GITERR_CHECKOUT		20		GITERR_FETCHHEAD	21		GITERR_MERGE			22		GITERR_SSH	23		GITERR_FILTER 24		GITERR_REVERT	25		GITERR_CALLBACK	26		GITERR_CHERRYPICK	27		GITERR_DESCRIBE	28		GITERR_REBASE	29		GITERR_FILESYSTEM	30)! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_callback	^ self basicNew		value: 26;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_checkout	^ self basicNew		value: 20;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_cherrypick	^ self basicNew		value: 27;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_config	^ self basicNew		value: 7;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_describe	^ self basicNew		value: 28;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_fetchhead	^ self basicNew		value: 21;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_filesystem	^ self basicNew		value: 30;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_filter	^ self basicNew		value: 24;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_index	^ self basicNew		value: 10;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_indexer	^ self basicNew		value: 15;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_invalid	^ self basicNew		value: 3;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_merge	^ self basicNew		value: 22;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_net	^ self basicNew		value: 12;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_nomemory	^ self basicNew		value: 1;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_none	^ self basicNew		value: 0;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_object	^ self basicNew		value: 11;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_odb	^ self basicNew		value: 9;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_os	^ self basicNew		value: 2;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_rebase	^ self basicNew		value: 29;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_reference	^ self basicNew		value: 4;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_regex	^ self basicNew		value: 8;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_repository	^ self basicNew		value: 6;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_revert	^ self basicNew		value: 25;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_ssh	^ self basicNew		value: 23;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_ssl	^ self basicNew		value: 16;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_stash	^ self basicNew		value: 19;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_submodule	^ self basicNew		value: 17;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_tag	^ self basicNew		value: 13;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_thread	^ self basicNew		value: 18;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_tree	^ self basicNew		value: 14;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!giterr_zlib	^ self basicNew		value: 5;		yourself! !!LGitExternalEnumerationInt32 class methodsFor: 'accessing-defaults' stamp: ' 7/21/2017 17:44:56'!defaultRepresentationType	^ FFIInt32 new! !!LGitObjectTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_OBJ_ANY -2	GIT_OBJ_BAD -1	GIT_OBJ__EXT1 0	GIT_OBJ_COMMIT 1	GIT_OBJ_TREE 2	GIT_OBJ_BLOB 3	GIT_OBJ_TAG 4	GIT_OBJ__EXT2 5	GIT_OBJ_OFS_DELTA 6	GIT_OBJ_REF_DELTA 7)! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_obj__ext1	^ self basicNew		value: 0;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_obj__ext2	^ self basicNew		value: 5;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_obj_any	^ self basicNew		value: -2;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_obj_bad	^ self basicNew		value: -1;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_obj_blob	^ self basicNew		value: 3;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_obj_commit	^ self basicNew		value: 1;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_obj_ofs_delta	^ self basicNew		value: 6;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_obj_ref_delta	^ self basicNew		value: 7;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_obj_tag	^ self basicNew		value: 4;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_obj_tree	^ self basicNew		value: 2;		yourself! !!LGitReturnCodeEnum class methodsFor: 'enum description' stamp: ' 7/21/2017 17:44:56'!enumDecl	^ #(			GIT_OK           0		"< No error "			GIT_ERROR       -1		"< Generic error "			GIT_ENOTFOUND   -3		"< Requested object could not be found "			GIT_EEXISTS     -4		"< Object exists preventing operation "			GIT_EAMBIGUOUS  -5		"< More than one object matches "			GIT_EBUFS       -6		"< Output buffer too short to hold data "			"GIT_EUSER is a special error that is never generated by libgit2			 * code.  You can return it from a callback (e.g to stop an iteration)			 * to know that it was generated by the callback and not by libgit2.			 "			GIT_EUSER       -7			GIT_EBAREREPO         -8	"< Operation not allowed on bare repository "			GIT_EUNBORNBRANCH     -9	"< HEAD refers to branch with no commits "			GIT_EUNMERGED        -10	"< Merge in progress prevented operation "			GIT_ENONFASTFORWARD  -11	"< Reference was not fast-forwardable "			GIT_EINVALIDSPEC     -12	"< Name/ref spec was not in a valid format "			GIT_ECONFLICT        -13	"< Checkout conflicts prevented operation "			GIT_ELOCKED          -14	"< Lock file prevented operation "			GIT_EMODIFIED        -15	"< Reference value does not match expected "			GIT_EAUTH            -16      "< Authentication error "			GIT_ECERTIFICATE     -17      "< Server certificate is invalid "			GIT_EAPPLIED         -18	"< Patch/merge has already been applied "			GIT_EPEEL            -19      "< The requested peel operation is not possible "			GIT_EEOF             -20      "< Unexpected EOF "			GIT_EINVALID         -21      "< Invalid operation or input "			GIT_EUNCOMMITTED     -22	"< Uncommitted changes in index prevented operation "			GIT_PASSTHROUGH      -30	"< Internal only "			GIT_ITEROVER         -31	"< Signals end of iteration with iterator "		)! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_eambiguous	^ self basicNew		value: -5;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_eapplied	^ self basicNew		value: -18;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_eauth	^ self basicNew		value: -16;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_ebarerepo	^ self basicNew		value: -8;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_ebufs	^ self basicNew		value: -6;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_ecertificate	^ self basicNew		value: -17;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_econflict	^ self basicNew		value: -13;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_eeof	^ self basicNew		value: -20;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_eexists	^ self basicNew		value: -4;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_einvalid	^ self basicNew		value: -21;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_einvalidspec	^ self basicNew		value: -12;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_elocked	^ self basicNew		value: -14;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_emodified	^ self basicNew		value: -15;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_enonfastforward	^ self basicNew		value: -11;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_enotfound	^ self basicNew		value: -3;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_epeel	^ self basicNew		value: -19;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_error	^ self basicNew		value: -1;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_eunbornbranch	^ self basicNew		value: -9;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_euncommitted	^ self basicNew		value: -22;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_eunmerged	^ self basicNew		value: -10;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_euser	^ self basicNew		value: -7;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_iterover	^ self basicNew		value: -31;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_ok	^ self basicNew		value: 0;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_passthrough	^ self basicNew		value: -30;		yourself! !!LGitReturnCodeEnum class methodsFor: 'handlers' stamp: ' 7/21/2017 17:44:56'!handlers	^ handlers ifNil: [ handlers := self setUpHandlers ]! !!LGitReturnCodeEnum class methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!setUpHandlers	^ (self declaration associations collect: [ :nameToValue |		nameToValue key -> (LGitCallReturnHandler for: (self perform: nameToValue key)) ]) asDictionary! !!LGitReturnCodeEnum methodsFor: 'handling' stamp: ' 7/21/2017 17:44:56'!handleLGitReturnCode	| handler |	self isOk		ifTrue: [ ^ self ].	handler := self handlers		at: self symbol		ifAbsent: [ LGitNoReturnCodeHandlerDefined signalWith: self ].	^ handler isError		ifTrue: [ handler signalWith: LGitError last ]		ifFalse: [ self ]! !!LGitReturnCodeEnum methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!handlers	^ self class handlers! !!LGitReturnCodeEnum methodsFor: 'as yet unclassified' stamp: ' 7/21/2017 17:44:56'!isOk	^ value = 0! !!LGitExternalEnumerationUInt32 class methodsFor: 'converting' stamp: ' 7/21/2017 17:44:56'!asExternalTypeOn: generator	^ FFIExternalEnumerationType 		objectClass: self 		representationType: self representationType! !!LGitExternalEnumerationUInt32 class methodsFor: 'class initialization' stamp: ' 7/21/2017 17:44:56'!buildDeclaration	| dictionary |	self removeOldAccessors.	dictionary := self literalDeclaration.	self compileAccessorsFrom: dictionary.		^ declaration := dictionary! !!LGitExternalEnumerationUInt32 class methodsFor: 'class initialization' stamp: ' 7/21/2017 17:44:56'!compileAccessorsFrom: aDictionary	aDictionary keysAndValuesDo: [ :symbol :value |		self class			compile: (String streamContents: [ :stream |				stream					nextPutAll: symbol asString; cr; tab;					nextPutAll: '^ self basicNew'; cr; tab; tab;					nextPutAll: 'value: ';					nextPutAll: value asString;					nextPutAll: ';'; cr; tab; tab;					nextPutAll: 'yourself' ])			classified: 'accessing-values' ]! !!LGitExternalEnumerationUInt32 class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!declaration	^ declaration ifNil: [ declaration := self literalDeclaration ]! !!LGitExternalEnumerationUInt32 class methodsFor: 'accessing-defaults' stamp: ' 7/21/2017 17:44:56'!defaultRepresentationType	^ FFIUInt32 new! !!LGitExternalEnumerationUInt32 class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#()! !!LGitExternalEnumerationUInt32 class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!fromInteger: anInteger	^self basicNew		value: anInteger;		yourself! !!LGitExternalEnumerationUInt32 class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!includes: aSymbol	^ self declaration includesKey: aSymbol! !!LGitExternalEnumerationUInt32 class methodsFor: 'class initialization' stamp: ' 7/21/2017 17:44:56'!initialize	declaration := nil.	representationType := nil.! !!LGitExternalEnumerationUInt32 class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!literalDeclaration	| dictionary |	dictionary := self enumDecl in: [ :decl |		decl isDictionary			ifTrue: [ decl ]			ifFalse: [ Dictionary newFromPairs: decl ] ].			self makeSelectorsLegalIn: dictionary.	^ dictionary! !!LGitExternalEnumerationUInt32 class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!makeSelectorsLegalIn: aDictionary	aDictionary associationsDo: [ :nameToValue |		| selector |		selector := nameToValue key asLowercase asSymbol.		nameToValue key: selector ]! !!LGitExternalEnumerationUInt32 class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!new	^ self shouldNotImplement ! !!LGitExternalEnumerationUInt32 class methodsFor: 'class initialization' stamp: ' 7/21/2017 17:44:56'!removeOldAccessors	declaration ifNil: [ ^ self ].		declaration keys do: [ :selector |		self class removeSelector: selector ]! !!LGitExternalEnumerationUInt32 class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!representationType	^ representationType ifNil: [ representationType := self defaultRepresentationType ]! !!LGitExternalEnumerationUInt32 methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!= anEnumInst	^ self class == anEnumInst class and: [		self value = anEnumInst value ]! !!LGitExternalEnumerationUInt32 methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!hash	^ self className hash bitXor: self value hash! !!LGitExternalEnumerationUInt32 methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isPartOfBitFlag: anInteger	"A bit flag may be composed of several values, where every bit	represents the state of one flag. Therefore, a 2 bit value can	represent 2 different flags, for instance. The #bitAnd: operation	will mask all other flags.		For some reason the libgit2 folks thought it would make sense to	use flags of value 0 in bit flags. That forces one to check for zero	(on the entire word)	explicitly. WTF."	^ self value isZero		ifTrue: [ anInteger isZero ]		ifFalse: [ (self value bitAnd: anInteger) = self value ]! !!LGitExternalEnumerationUInt32 methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!printOn: stream	super printOn: stream.	value isInteger 		" temp: due to a uffi bug (?) sometimes value == self"		ifFalse: [ ^ self ].	stream nextPut: $(;		nextPutAll: self symbol printString;		nextPutAll: ' [';		nextPutAll: self value asString;		nextPut: $];		nextPut: $)! !!LGitExternalEnumerationUInt32 methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!symbol	<todo: 'now we can handle enums which define the same value multiple times, but in case of this handler, we don''t know which name we need to associate with the return value. This is basically random...'>	^ self class declaration		keyAtValue: self value		ifAbsent: [ nil ]! !!LGitExternalEnumerationUInt32 methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!value	^ value! !!LGitExternalEnumerationUInt32 methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!value: anInteger	value := anInteger ! !!LGitFetchPruneTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^ #(		"		 * Use the setting from the configuration		 "		GIT_FETCH_PRUNE_UNSPECIFIED 0		"		 * Force pruning on		 "		GIT_FETCH_PRUNE 1		"		 * Force pruning off		 "		GIT_FETCH_NO_PRUNE 2	)! !!LGitFetchPruneTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_fetch_no_prune	^ self basicNew		value: 2;		yourself! !!LGitFetchPruneTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_fetch_prune	^ self basicNew		value: 1;		yourself! !!LGitFetchPruneTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_fetch_prune_unspecified	^ self basicNew		value: 0;		yourself! !!LGitFilemodeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_FILEMODE_NEW 0	GIT_FILEMODE_TREE 16384	GIT_FILEMODE_BLOB 33188	GIT_FILEMODE_BLOB_EXECUTABLE 33261	GIT_FILEMODE_LINK 40960	GIT_FILEMODE_COMMIT 57344)! !!LGitFilemodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_filemode_blob	^ self basicNew		value: 33188;		yourself! !!LGitFilemodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_filemode_blob_executable	^ self basicNew		value: 33261;		yourself! !!LGitFilemodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_filemode_commit	^ self basicNew		value: 57344;		yourself! !!LGitFilemodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_filemode_link	^ self basicNew		value: 40960;		yourself! !!LGitFilemodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_filemode_new	^ self basicNew		value: 0;		yourself! !!LGitFilemodeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_filemode_tree	^ self basicNew		value: 16384;		yourself! !!LGitOpenFlagEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_REPOSITORY_OPEN_NO_SEARCH 1	GIT_REPOSITORY_OPEN_CROSS_FS 2	GIT_REPOSITORY_OPEN_BARE 4)! !!LGitOpenFlagEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_repository_open_bare	^ self basicNew		value: 4;		yourself! !!LGitOpenFlagEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_repository_open_cross_fs	^ self basicNew		value: 2;		yourself! !!LGitOpenFlagEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_repository_open_no_search	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_BLAME_OPTIONS_VERSION_1 1	GIT_CHECKOUT_OPTIONS_VERSION_1 1	GIT_CLONE_OPTIONS_VERSION_1 1	GIT_DIFF_OPTIONS_VERSION_1 1	GIT_DIFF_FIND_OPTIONS_VERSION_1 1	GIT_FETCH_OPTIONS_VERSION_1 1	GIT_PUSH_OPTIONS_VERSION_1 1	)! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_blame_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_checkout_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_clone_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_find_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_diff_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_fetch_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_merge_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_push_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_PATHSPEC_DEFAULT 0	"forces match to ignore case; otherwise match will use native case sensitivity of platform filesystem"	GIT_PATHSPEC_IGNORE_CASE 1	"forces case sensitive match; otherwise match will use native case sensitivity of platform filesystem"	GIT_PATHSPEC_USE_CASE 2	"disables glob patterns and just uses simple string comparison for matching"	GIT_PATHSPEC_NO_GLOB 4	"means the match functions return error code GIT_ENOTFOUND if no matches are found; otherwise no matches is still success (return 0) but git_pathspec_match_list_entrycount will indicate 0 matches."	GIT_PATHSPEC_NO_MATCH_ERROR 8	"means that the git_pathspec_match_list should track which patterns matched which files so that at the end of the match we can identify patterns that did not match any files."	GIT_PATHSPEC_FIND_FAILURES 16	"means that the git_pathspec_match_list does not need to keep the actual matching filenames. Use this to just test if there were any matches at all or in combination with GIT_PATHSPEC_FIND_FAILURES to validate a pathspec."	GIT_PATHSPEC_FAILURES_ONLY 32)! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_pathspec_default	^ self basicNew		value: 0;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_pathspec_failures_only	^ self basicNew		value: 32;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_pathspec_find_failures	^ self basicNew		value: 16;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_pathspec_ignore_case	^ self basicNew		value: 1;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_pathspec_no_glob	^ self basicNew		value: 4;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_pathspec_no_match_error	^ self basicNew		value: 8;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_pathspec_use_case	^ self basicNew		value: 2;		yourself! !!LGitProxyTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^ #(	"/**	 * Do not attempt to connect through a proxy	 *	 * If built against libcurl, it itself may attempt to connect	 * to a proxy if the environment variables specify it.	 */"	GIT_PROXY_NONE 0	"/**	 * Try to auto-detect the proxy from the git configuration.	 */"	GIT_PROXY_AUTO 1	"/**	 * Connect via the URL given in the options	 */"	GIT_PROXY_SPECIFIED 2	)! !!LGitProxyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_proxy_auto	^ self basicNew		value: 1;		yourself! !!LGitProxyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_proxy_none	^ self basicNew		value: 0;		yourself! !!LGitProxyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_proxy_specified	^ self basicNew		value: 2;		yourself! !!LGitPushOptionsVersionEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^ #(			LGIT_PUSH_OPTIONS_VERSION_1 1		)! !!LGitPushOptionsVersionEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!lgit_push_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitReferenceTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_REF_INVALID 0	GIT_REF_OID 1	GIT_REF_SYMBOLIC 2	GIT_REF_LISTALL 3)! !!LGitReferenceTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_ref_invalid	^ self basicNew		value: 0;		yourself! !!LGitReferenceTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_ref_listall	^ self basicNew		value: 3;		yourself! !!LGitReferenceTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_ref_oid	^ self basicNew		value: 1;		yourself! !!LGitReferenceTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_ref_symbolic	^ self basicNew		value: 2;		yourself! !!LGitRemoteAutotagOptionTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^ #(		"		 * Use the setting from the configuration.		 "		GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED 0		"		 * Ask the server for tags pointing to objects we're already		 * downloading.		 "		GIT_REMOTE_DOWNLOAD_TAGS_AUTO 1		"		 * Don't ask for any tags beyond the refspecs.		 "		GIT_REMOTE_DOWNLOAD_TAGS_NONE 2		"		 * Ask for the all the tags.		 "		GIT_REMOTE_DOWNLOAD_TAGS_ALL 3	)! !!LGitRemoteAutotagOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_remote_download_tags_all	^ self basicNew		value: 3;		yourself! !!LGitRemoteAutotagOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_remote_download_tags_auto	^ self basicNew		value: 1;		yourself! !!LGitRemoteAutotagOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_remote_download_tags_none	^ self basicNew		value: 2;		yourself! !!LGitRemoteAutotagOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_remote_download_tags_unspecified	^ self basicNew		value: 0;		yourself! !!LGitRemoteCompletionTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_REMOTE_COMPLETION_DOWNLOAD 0	GIT_REMOTE_COMPLETION_INDEXING 1	GIT_REMOTE_COMPLETION_ERROR 2)! !!LGitRemoteCompletionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_remote_completion_download	^ self basicNew		value: 0;		yourself! !!LGitRemoteCompletionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_remote_completion_error	^ self basicNew		value: 2;		yourself! !!LGitRemoteCompletionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_remote_completion_indexing	^ self basicNew		value: 1;		yourself! !!LGitRevwalkSortTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_SORT_NONE 0	GIT_SORT_TOPOLOGICAL 1	GIT_SORT_TIME 2	GIT_SORT_REVERSE 4	)! !!LGitRevwalkSortTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_sort_none	^ self basicNew		value: 0;		yourself! !!LGitRevwalkSortTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_sort_reverse	^ self basicNew		value: 4;		yourself! !!LGitRevwalkSortTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_sort_time	^ self basicNew		value: 2;		yourself! !!LGitRevwalkSortTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_sort_topological	^ self basicNew		value: 1;		yourself! !!LGitStatusTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(		GIT_STATUS_CURRENT  0		GIT_STATUS_INDEX_NEW         "1 bitShift: 0" 1		GIT_STATUS_INDEX_MODIFIED    "1 bitShift: 1" 2		GIT_STATUS_INDEX_DELETED     "1 bitShift: 2" 4		GIT_STATUS_INDEX_RENAMED     "1 bitShift: 3" 8		GIT_STATUS_INDEX_TYPECHANGE  "1 bitShift: 4" 16		GIT_STATUS_WT_NEW            "1 bitShift: 7" 128		GIT_STATUS_WT_MODIFIED       "1 bitShift: 8" 256		GIT_STATUS_WT_DELETED        "1 bitShift: 9" 512		GIT_STATUS_WT_TYPECHANGE     "1 bitShift: 10" 1024		GIT_STATUS_WT_RENAMED        "1 bitShift: 11" 2048		GIT_STATUS_WT_UNREADABLE     "1 bitShift: 12" 4096		GIT_STATUS_IGNORED           "1 bitShift: 14" 16384		GIT_STATUS_CONFLICTED        "1 bitShift: 15" 32768)! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_conflicted	^ self basicNew		value: 32768;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_current	^ self basicNew		value: 0;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_ignored	^ self basicNew		value: 16384;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_index_deleted	^ self basicNew		value: 4;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_index_modified	^ self basicNew		value: 2;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_index_new	^ self basicNew		value: 1;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_index_renamed	^ self basicNew		value: 8;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_index_typechange	^ self basicNew		value: 16;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_wt_deleted	^ self basicNew		value: 512;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_wt_modified	^ self basicNew		value: 256;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_wt_new	^ self basicNew		value: 128;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_wt_renamed	^ self basicNew		value: 2048;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_wt_typechange	^ self basicNew		value: 1024;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_status_wt_unreadable	^ self basicNew		value: 4096;		yourself! !!LGitStructVersionsEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(		GIT_REMOTE_CALLBACKS_VERSION_1 1	)! !!LGitStructVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_remote_callbacks_version_1	^ self basicNew		value: 1;		yourself! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_SUBMODULE_IGNORE_RESET     -1 "reset to on-disk value"	GIT_SUBMODULE_IGNORE_NONE      1  "any change or untracked == dirty"	GIT_SUBMODULE_IGNORE_UNTRACKED 2  "dirty if tracked files change"	GIT_SUBMODULE_IGNORE_DIRTY     3  "only dirty if HEAD moved"	GIT_SUBMODULE_IGNORE_ALL       4  "never dirty"	GIT_SUBMODULE_IGNORE_DEFAULT   0)! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_submodule_ignore_all	^ self basicNew		value: 4;		yourself! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_submodule_ignore_default	^ self basicNew		value: 0;		yourself! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_submodule_ignore_dirty	^ self basicNew		value: 3;		yourself! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_submodule_ignore_none	^ self basicNew		value: 1;		yourself! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_submodule_ignore_reset	^ self basicNew		value: -1;		yourself! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_submodule_ignore_untracked	^ self basicNew		value: 2;		yourself! !!LGitTreewalkModeEnum class methodsFor: 'enum declaration' stamp: ' 7/21/2017 17:44:56'!enumDecl	^#(	GIT_TREEWALK_PRE 0	GIT_TREEWALK_POST 1)! !!LGitTreewalkModeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_treewalk_post	^ self basicNew		value: 1;		yourself! !!LGitTreewalkModeEnum class methodsFor: 'accessing-values' stamp: ' 7/21/2017 17:44:56'!git_treewalk_pre	^ self basicNew		value: 0;		yourself! !!LGitFunctionReturn class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!methodSelector: aSymbol value: anObject	^ self new		methodSelector: aSymbol;		value: anObject;		yourself! !!LGitFunctionReturn methodsFor: 'handling' stamp: ' 7/21/2017 17:44:56'!handleLGitReturnCode	^ self value handleLGitReturnCode! !!LGitFunctionReturn methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!methodSelector	^ methodSelector! !!LGitFunctionReturn methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!methodSelector: aSymbol	methodSelector := aSymbol! !!LGitFunctionReturn methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!value	^ value! !!LGitFunctionReturn methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!value: anObject	value := anObject! !!LGitGlobal class methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!checkInitialized	"Make sure that LigGit2 is properly initialized."	self ffiLibrary isInitialized 		ifFalse: [ self ffiLibrary uniqueInstance initializeLibGit2 ]! !!LGitGlobal class methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!runSequence: aBlock	LGitActionSequence value ifNotNil: aBlock.		LGitActionSequence		value: thisContext sender		during: [			self checkInitialized.			aBlock value ]! !!LGitRefSpec class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!fromString: aString	^ self new		initializeFromString: aString;		yourself! !!LGitRefSpec methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!beForced	forced := true! !!LGitRefSpec methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!destination	^ destination ifNil: [ '' ]! !!LGitRefSpec methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!destination: aString	destination := aString! !!LGitRefSpec methodsFor: 'intialization' stamp: ' 7/21/2017 17:44:56'!initializeFromString: aString	<todo: 'use exceptions instead of assertions'>	| stream |	self assert: ('((\+[\w/]+)|([\w/]*))\:[\w/]+' asRegex matches: aString).		stream := aString readStream.	[		(stream peek = $+) ifTrue: [ 			self beForced.			stream next ].		self source: (stream upTo: $:).		self destination: stream upToEnd ] ensure: [ stream close ]! !!LGitRefSpec methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isForced	^ forced ifNil: [ false ]! !!LGitRefSpec methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!printOn: aStream	self isForced ifTrue: [ aStream nextPut: $+ ].	aStream		nextPutAll: self source;		nextPut: $:;		nextPutAll: self destination! !!LGitRefSpec methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!source	^ source ifNil: [ '' ]! !!LGitRefSpec methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!source: aString	source := aString! !!Object methodsFor: '*LibGit-Core-FFI-Handling' stamp: ' 7/21/2017 17:44:56'!handleLGitReturnCode	^ self! !!LGitBlameHunk class methodsFor: 'alignment' stamp: ' 7/21/2017 17:44:56'!byteAlignment	^ 1! !!LGitBlameHunk class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	<hack: 'orig_start_line_number is a uint16_t according to spec. The offset of orig_signature however is 56, not 54 (while the first fields are *not* aligned). To fix that, I changed the type of orig_start_line_number to uint32_t'>	^ #(		#FFIUInt16 lines_in_hunk "is the number of lines in this hunk"		LGitId final_commit_id "is the OID of the commit where this line was last changed."		#FFIUInt16 final_start_line_number "is the 1-based line number where this hunk begins, in the final version of the file"		LGitSignature * final_signature				LGitId orig_commit_id "is the OID of the commit where this hunk was found. This will usually be the same as final_commit_id, except when GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES has been specified."		String orig_path "is the path to the file where this hunk originated, as of the commit specified by orig_commit_id."		#FFIUInt32 orig_start_line_number "is the 1-based line number where this hunk begins in the file named by orig_path in the commit specified by orig_commit_id."		LGitSignature * orig_signature				Boolean boundary "is 1 iff the hunk has been tracked to a boundary commit (the root, or the commit specified in git_blame_options.oldest_commit)"	)! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!boundary	^ self prim_boundary! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!finalCommitId	"prim version doesn't work"	"^ self prim_final_commit_id"		^ LGitId fromHandle: (handle copyFrom: 3 to: 22)! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!finalSignature		^ self prim_final_signature! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!finalStartLineNumber	^ self prim_final_start_line_number! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!numberOfLines	^ self prim_lines_in_hunk! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!originalCommitId	"prim version doesn't work"	"^ self prim_orig_commit_id"		^LGitId fromHandle: (handle copyFrom: 29 to: 48)! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!originalPath	^ self prim_orig_path readString! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!originalSignature		^ self prim_orig_signature! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!originalStartLineNumber	^ self prim_orig_start_line_number! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_boundary	"This method was automatically generated"	^handle booleanAt: OFFSET_PRIM_BOUNDARY! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_boundary: anObject	"This method was automatically generated"	handle booleanAt: OFFSET_PRIM_BOUNDARY put: anObject! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_final_commit_id	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_FINAL_COMMIT_ID length: LGitId byteSize)! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_final_commit_id: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_FINAL_COMMIT_ID put: anObject getHandle length: LGitId byteSize! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_final_signature	"This method was automatically generated"	^LGitSignature fromHandle: (handle pointerAt: OFFSET_PRIM_FINAL_SIGNATURE)! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_final_signature: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_FINAL_SIGNATURE put: anObject getHandle.! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_final_start_line_number	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_FINAL_START_LINE_NUMBER! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_final_start_line_number: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_FINAL_START_LINE_NUMBER put: anObject! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_lines_in_hunk	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_LINES_IN_HUNK! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_lines_in_hunk: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_LINES_IN_HUNK put: anObject! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_orig_commit_id	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_ORIG_COMMIT_ID length: LGitId byteSize)! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_orig_commit_id: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_ORIG_COMMIT_ID put: anObject getHandle length: LGitId byteSize! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_orig_path	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_ORIG_PATH) type: ExternalType char asPointerType! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_orig_path: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_ORIG_PATH put: anObject getHandle.! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_orig_signature	"This method was automatically generated"	^LGitSignature fromHandle: (handle pointerAt: OFFSET_PRIM_ORIG_SIGNATURE)! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_orig_signature: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_ORIG_SIGNATURE put: anObject getHandle.! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_orig_start_line_number	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_ORIG_START_LINE_NUMBER! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_orig_start_line_number: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_ORIG_START_LINE_NUMBER put: anObject! !!LGitBuf class methodsFor: 'field definition' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^ #(		char * ptr;		size_t asize;		size_t size;	)		"self rebuildFieldAccessors"! !!LGitBuf class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!signature_free: handle 	^ self		call: #(void git_buf_free(void *handle))		options: #(  )! !!LGitBuf methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!free	"Free the memory referred to by the git_buf.	Note that this does not free the git_buf itself, just the memory pointed to by buffer->ptr. This 	will not free the memory if it looks like it was not allocated internally, but it will clear the 	buffer back to the empty state."	self class signature_free: handle! !!LGitBuf methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_asize	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_ASIZE! !!LGitBuf methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_asize: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_ASIZE put: anObject! !!LGitBuf methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_ptr	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PTR) type: ExternalType char asPointerType! !!LGitBuf methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_ptr: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PTR put: anObject getHandle.! !!LGitBuf methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_size	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_SIZE! !!LGitBuf methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_size: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_SIZE put: anObject! !!LGitCheckoutPerfData class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^ #(		size_t mkdir_calls;		size_t stat_calls;		size_t chmod_calls;	)! !!LGitCheckoutPerfData methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_chmod_calls	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_CHMOD_CALLS! !!LGitCheckoutPerfData methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_chmod_calls: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_CHMOD_CALLS put: anObject! !!LGitCheckoutPerfData methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_mkdir_calls	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_MKDIR_CALLS! !!LGitCheckoutPerfData methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_mkdir_calls: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_MKDIR_CALLS put: anObject! !!LGitCheckoutPerfData methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_stat_calls	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_STAT_CALLS! !!LGitCheckoutPerfData methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_stat_calls: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_STAT_CALLS put: anObject! !!LGitCredentials class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(	LGitCredentialsTypeEnum credtype;	LGitCredentialsFreeCallout free;	)! !!LGitCredentials methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createWith: aStructure	self subclassResponsibility! !!LGitCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!passphrase	^ passphrase! !!LGitCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!passphrase: aString	passphrase := aString! !!LGitCredentials methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_credtype	"This method was automatically generated"	^LGitCredentialsTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_CREDTYPE)! !!LGitCredentials methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_credtype: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CREDTYPE put: anObject value! !!LGitCredentials methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_free	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_FREE) type: ExternalType void asPointerType! !!LGitCredentials methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_free: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_FREE put: anObject getHandle.! !!LGitCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!username	^ username! !!LGitCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!username: aString	username := aString! !!LGitCredentialsPlaintext class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!createFrom: provider onto: lgitCredentials	| credentials |	[		credentials := self new.		provider providePlaintextCredentialsTo: credentials.		credentials createWith: lgitCredentials.		^ 0	]	on: LGitNoCredentialsProvided do: [ :e | 		LGitError setError: 'Invalid username and/or password provided.'.						^ -1 ]! !!LGitCredentialsPlaintext class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!username: username passphrase: passphrase	^ self new		username: username;		passphrase: passphrase;		yourself! !!LGitCredentialsPlaintext methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createWith: aStructure	<todo: 'use exceptions instead of assertions'>	self assert: self username isEmptyOrNil not.	self assert: self passphrase isEmptyOrNil not.	self withReturnHandlerDo: [ 		self 			cred_userpass_plaintext_new: aStructure			username: self username			password: self passphrase ]! !!LGitCredentialsPlaintext methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!cred_userpass_plaintext_new: out username: usernameString password: password 	^self call: #(		LGitReturnCodeEnum git_cred_userpass_plaintext_new(			LGitCredentials * out, 			String username, 			String password)	) options: #(  )! !!LGitCredentialsPlaintext methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_credtype	"This method was automatically generated"	^LGitCredentialsTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_CREDTYPE)! !!LGitCredentialsPlaintext methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_credtype: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CREDTYPE put: anObject value! !!LGitCredentialsPlaintext methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_free	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_FREE) type: ExternalType void asPointerType! !!LGitCredentialsPlaintext methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_free: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_FREE put: anObject getHandle.! !!LGitCredentialsSSH class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!createFrom: provider onto: lgitCredentials	| credentials |	 	[		credentials := self new.		provider provideSshCredentialsTo: credentials.		credentials createWith: lgitCredentials.		^ 0	]	on: LGitNoCredentialsProvided do: [ 		LGitError setError: 'Invalid ssh keys in provided files.'.				-1 ]! !!LGitCredentialsSSH class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!createFrom: provider username: username onto: lgitCredentials	 ^ self createFrom: provider onto: lgitCredentials! !!LGitCredentialsSSH class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!username: username passphrase: passphrase publicKeyReference: publicKeyFileReference privateKeyReference: privateKeyFileReference	^ self new		username: username;		passphrase: passphrase;		publicKeyReference: publicKeyFileReference;		privateKeyReference: privateKeyFileReference;		yourself! !!LGitCredentialsSSH methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createWith: aStructure	<todo: 'use exceptions instead of assertions'>	self assert: self username isEmptyOrNil not.	self assert: self publicKeyReference exists.	self assert: self privateKeyReference exists.	self withReturnHandlerDo: [ 		self 			cred_ssh_key_new: aStructure			username: self username			publickey: self publicKeyReference fullName			privatekey: self privateKeyReference fullName			passphrase: self passphrase ]! !!LGitCredentialsSSH methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!cred_ssh_key_new: out username: usernameString publickey: publickey privatekey: privatekey passphrase: passphraseString	^self call: 		#(int git_cred_ssh_key_new(			LGitCredentials * out, 			String usernameString, 			String publickey, 			String privatekey, 			String passphraseString)) options: #(  )! !!LGitCredentialsSSH methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!cred_username_new: out username: usernameString	^ self 		call: #(int git_cred_username_new (LGitCredentials * out, String usernameString)) 		options: #()			! !!LGitCredentialsSSH methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_credtype	"This method was automatically generated"	^LGitCredentialsTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_CREDTYPE)! !!LGitCredentialsSSH methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_credtype: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CREDTYPE put: anObject value! !!LGitCredentialsSSH methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_free	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_FREE) type: ExternalType void asPointerType! !!LGitCredentialsSSH methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_free: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_FREE put: anObject getHandle.! !!LGitCredentialsSSH methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!privateKeyReference	^ privateKeyReference! !!LGitCredentialsSSH methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!privateKeyReference: aFileReference	privateKeyReference := aFileReference! !!LGitCredentialsSSH methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!publicKeyReference	^ publicKeyReference! !!LGitCredentialsSSH methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!publicKeyReference: aFileReference	publicKeyReference := aFileReference! !!LGitCredentialsSSH methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!setGitUsernameIn: aStructure	self withReturnHandlerDo: [ 		self cred_username_new: aStructure username: 'git'	]! !!LGitCredentialsSSHAgent class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!createFrom: provider username: username onto: lgitCredentials	| credentials |		[  		credentials := self new.		provider provideSshAgentCredentialsTo: credentials.			credentials createWith: username onto: lgitCredentials.		^ 0 ]	on: LGitNoCredentialsProvided do: [ 		LGitError setError: 'No ssh-agent suitable credentials found.'.		^ -1 ]! !!LGitCredentialsSSHAgent methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createWith: aName onto: aStructure	<todo: 'use exceptions instead of assertions'>	self assert: aName isEmptyOrNil not.	self withReturnHandlerDo: [ 		self cred_ssh_key_new: aStructure username: aName ]! !!LGitCredentialsSSHAgent methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!cred_ssh_key_new: out username: aName	^ self call: #(int git_cred_ssh_key_from_agent(LGitCredentials *out, String aName))! !!LGitCredentialsSSHAgent methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_credtype	"This method was automatically generated"	^LGitCredentialsTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_CREDTYPE)! !!LGitCredentialsSSHAgent methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_credtype: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CREDTYPE put: anObject value! !!LGitCredentialsSSHAgent methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_free	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_FREE) type: ExternalType void asPointerType! !!LGitCredentialsSSHAgent methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_free: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_FREE put: anObject getHandle.! !!LGitDiffBinary class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(			uint contains_data;		LGitDiffBinaryFile old_file; "< The contents of the old file."		LGitDiffBinaryFile new_file; "< The contents of the new file."	)! !!LGitDiffBinary methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_contains_data	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_CONTAINS_DATA! !!LGitDiffBinary methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_contains_data: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CONTAINS_DATA put: anObject! !!LGitDiffBinary methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_new_file	"This method was automatically generated"	^ LGitDiffBinaryFile fromHandle: (handle referenceStructAt: OFFSET_PRIM_NEW_FILE length: LGitDiffBinaryFile byteSize)! !!LGitDiffBinary methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_new_file: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_NEW_FILE put: anObject getHandle length: LGitDiffBinaryFile byteSize! !!LGitDiffBinary methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_old_file	"This method was automatically generated"	^ LGitDiffBinaryFile fromHandle: (handle referenceStructAt: OFFSET_PRIM_OLD_FILE length: LGitDiffBinaryFile byteSize)! !!LGitDiffBinary methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_old_file: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_OLD_FILE put: anObject getHandle length: LGitDiffBinaryFile byteSize! !!LGitDiffBinaryFile class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(		" The type of binary data for this file. "		LGitDiffBinaryTypeEnum type;		" The binary data, deflated. is char* originally, but I do not want to get the \0"		void *data;		" The length of the binary data. "		size_t datalen;		" The length of the binary data after inflation. "		size_t inflatedlen;	)! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_DATA) type: ExternalType void asPointerType! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_DATA put: anObject getHandle.! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_datalen	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_DATALEN! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_datalen: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_DATALEN put: anObject! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_inflatedlen	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_INFLATEDLEN! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_inflatedlen: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_INFLATEDLEN put: anObject! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_type	"This method was automatically generated"	^LGitDiffBinaryTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_TYPE)! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_type: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_TYPE put: anObject value! !!LGitDiffDelta class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(		LGitDeltaTypeEnum status	uint32 flags	"for RENAMED and COPIED, value 0-100"	uint16 similarity	"number of files in this delta"	uint16 nfiles	LGitDiffFile old_file	LGitDiffFile new_file	)! !!LGitDiffDelta methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!newFile	^ self prim_new_file! !!LGitDiffDelta methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!numberOfFiles	^ self prim_nfiles! !!LGitDiffDelta methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!oldFile	^ self prim_old_file! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FLAGS! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FLAGS put: anObject! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_new_file	"This method was automatically generated"	^ LGitDiffFile fromHandle: (handle referenceStructAt: OFFSET_PRIM_NEW_FILE length: LGitDiffFile byteSize)! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_new_file: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_NEW_FILE put: anObject getHandle length: LGitDiffFile byteSize! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_nfiles	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_NFILES! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_nfiles: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_NFILES put: anObject! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_old_file	"This method was automatically generated"	^ LGitDiffFile fromHandle: (handle referenceStructAt: OFFSET_PRIM_OLD_FILE length: LGitDiffFile byteSize)! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_old_file: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_OLD_FILE put: anObject getHandle length: LGitDiffFile byteSize! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_similarity	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_SIMILARITY! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_similarity: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_SIMILARITY put: anObject! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_status	"This method was automatically generated"	^LGitDeltaTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_STATUS)! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_status: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_STATUS put: anObject value! !!LGitDiffDelta methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!status	^ self prim_status! !!LGitDiffFile class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(	LGitId id	String path	int64 size	uint32 flags	uint16 mode	uint16 id_abbrev	)! !!LGitDiffFile methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!id	^ self prim_id! !!LGitDiffFile methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!path	^ self prim_path readString! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FLAGS! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FLAGS put: anObject! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_id	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_ID length: LGitId byteSize)! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_id: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_ID put: anObject getHandle length: LGitId byteSize! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_id_abbrev	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_ID_ABBREV! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_id_abbrev: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_ID_ABBREV put: anObject! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_mode	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_MODE! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_mode: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_MODE put: anObject! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_path	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PATH) type: ExternalType char asPointerType! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_path: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PATH put: anObject getHandle.! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_size	"This method was automatically generated"	^handle signedLongLongAt: OFFSET_PRIM_SIZE! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_size: anObject	"This method was automatically generated"	handle signedLongLongAt: OFFSET_PRIM_SIZE put: anObject! !!LGitDiffFile methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!size	^ self prim_size! !!LGitDiffHunk class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(	int old_start "Starting line number in old_file"	int old_lines "Number of lines in old_file"	int new_start "Starting line number in new_file"	int new_lines "Number of lines in new_file"	size_t header_len "Number of bytes in header text"	Char128 header "Header text, NUL-byte terminated" 		)! !!LGitDiffHunk class methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!initialize	Char128 := FFITypeArray ofType: #char size: 128! !!LGitDiffHunk methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_patch_get_hunk: out lines_in_hunk: lines_in_hunk patch: patch hunk_idx: hunk_idx	^ self		call: #(LGitReturnCodeEnum git_patch_get_hunk(LGitDiffHunk * self, LGitWriteBackValueSizeT lines_in_hunk, LGitPatch patch, size_t hunk_idx))		options: #(  )! !!LGitDiffHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!newNumberOfLines	^ self prim_new_lines! !!LGitDiffHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!newStart	^ self prim_new_start! !!LGitDiffHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!oldNumberOfLines	^ self prim_old_lines! !!LGitDiffHunk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!oldStart	^ self prim_old_start! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_header	"This method was automatically generated"	^(FFITypeArray ofType: #FFICharacterType size: 128) fromHandle: (handle copyFrom: OFFSET_PRIM_HEADER to: OFFSET_PRIM_HEADER + 127)! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_header: anObject	"This method was automatically generated"	handle replaceFrom: OFFSET_PRIM_HEADER to: OFFSET_PRIM_HEADER + 127 with: anObject getHandle startingAt: 1! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_header_len	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_HEADER_LEN! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_header_len: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_HEADER_LEN put: anObject! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_new_lines	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_NEW_LINES! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_new_lines: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_NEW_LINES put: anObject! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_new_start	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_NEW_START! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_new_start: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_NEW_START put: anObject! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_old_lines	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_OLD_LINES! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_old_lines: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_OLD_LINES put: anObject! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_old_start	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_OLD_START! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_old_start: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_OLD_START put: anObject! !!LGitDiffLine class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(	LGitDiffLineTypeEnum	  origin       "A git_diff_line_t value"	int    old_lineno   "Line number in old file or -1 for added line"	int    new_lineno   "Line number in new file or -1 for deleted line"	int    num_lines    "Number of newline characters in content"	size_t content_len  "Number of bytes of data"	int64 content_offset "Offset in the original file to the content"	String content "Pointer to diff text, not NUL-byte terminated"	) ! !!LGitDiffLine methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!content	^ (self prim_content getHandle copyFrom: 1 to: self prim_content_len) asString! !!LGitDiffLine methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!newLineNumber	^ self prim_new_lineno! !!LGitDiffLine methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!oldLineNumber	^ self prim_old_lineno! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_content	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_CONTENT) type: ExternalType char asPointerType! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_content: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_CONTENT put: anObject getHandle.! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_content_len	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_CONTENT_LEN! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_content_len: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_CONTENT_LEN put: anObject! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_content_offset	"This method was automatically generated"	^handle signedLongLongAt: OFFSET_PRIM_CONTENT_OFFSET! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_content_offset: anObject	"This method was automatically generated"	handle signedLongLongAt: OFFSET_PRIM_CONTENT_OFFSET put: anObject! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_new_lineno	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_NEW_LINENO! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_new_lineno: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_NEW_LINENO put: anObject! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_num_lines	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_NUM_LINES! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_num_lines: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_NUM_LINES put: anObject! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_old_lineno	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_OLD_LINENO! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_old_lineno: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_OLD_LINENO put: anObject! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_origin	"This method was automatically generated"	^LGitDiffLineTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_ORIGIN)! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_origin: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_ORIGIN put: anObject value! !!LGitDiffLine methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!size	^ self prim_content_len! !!LGitDiffPerfData class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(	uint version	size_t stat_calls "Number of stat() calls performed"	size_t oid_calculations "Number of ID calculations"	)! !!LGitDiffPerfData methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_oid_calculations	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_OID_CALCULATIONS! !!LGitDiffPerfData methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_oid_calculations: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_OID_CALCULATIONS put: anObject! !!LGitDiffPerfData methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_stat_calls	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_STAT_CALLS! !!LGitDiffPerfData methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_stat_calls: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_STAT_CALLS put: anObject! !!LGitDiffPerfData methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_VERSION! !!LGitDiffPerfData methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject! !!LGitDiffSimilarityMetric class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc"int (*file_signature)(		void **out, const git_diff_file *file,		const char *fullpath, void *payload);	int (*buffer_signature)(		void **out, const git_diff_file *file,		const char *buf, size_t buflen, void *payload);	void (*free_signature)(void *sig, void *payload);	int (*similarity)(int *score, void *siga, void *sigb, void *payload);	void *payload;"	^#(	LGitFileSignatureCallback file_signature;	LGitBufferSignatureCallback buffer_signature;	LGitFreeSignatureCallback free_signature;	LGitSimilarityCallback similarity;	void *payload;	)! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_buffer_signature	"This method was automatically generated"	^LGitBufferSignatureCallback forAddress: ((handle pointerAt: OFFSET_PRIM_BUFFER_SIGNATURE) asInteger)! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_buffer_signature: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_BUFFER_SIGNATURE		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_file_signature	"This method was automatically generated"	^LGitFileSignatureCallback forAddress: ((handle pointerAt: OFFSET_PRIM_FILE_SIGNATURE) asInteger)! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_file_signature: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_FILE_SIGNATURE		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_free_signature	"This method was automatically generated"	^LGitFreeSignatureCallback forAddress: ((handle pointerAt: OFFSET_PRIM_FREE_SIGNATURE) asInteger)! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_free_signature: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_FREE_SIGNATURE		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PAYLOAD) type: ExternalType void asPointerType! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PAYLOAD put: anObject getHandle.! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_similarity	"This method was automatically generated"	^LGitSimilarityCallback forAddress: ((handle pointerAt: OFFSET_PRIM_SIMILARITY) asInteger)! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_similarity: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_SIMILARITY		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitError class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(	String message;	LGitErrorTypeEnum klass;	)! !!LGitError class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!giterr_clear	^ self call: #(void giterr_clear()) options: #(  )! !!LGitError class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!giterr_last	^ self call: #(void *giterr_last()) options: #(  )! !!LGitError class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!giterr_set_str: string	"GIT_EUSER = -7"	^ self call: #(void giterr_set_str(-7, String string))! !!LGitError class methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!last	| externalData |	externalData := self giterr_last.	^ self fromHandle: externalData getHandle! !!LGitError class methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!lastMessage	^ self last message! !!LGitError class methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!setError: aString	self giterr_set_str: aString! !!LGitError methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!message	^ self isNull		ifFalse: [ self prim_message readString ]		ifTrue: [ 'no error message set by libgit2' ]! !!LGitError methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_klass	"This method was automatically generated"	^LGitErrorTypeEnum fromInteger: (handle signedLongAt: OFFSET_PRIM_KLASS)! !!LGitError methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_klass: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_KLASS put: anObject value! !!LGitError methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_message	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_MESSAGE) type: ExternalType char asPointerType! !!LGitError methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_message: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_MESSAGE put: anObject getHandle.! !!LGitError methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!type	^ self isNull		ifFalse: [ self prim_klass ]		ifTrue: [ nil ]! !!LGitExternalStructure class methodsFor: 'managing accessors' stamp: ' 7/21/2017 17:44:56'!createAccessorsFor: fieldName 	"Define read/write accessors for the given field"	| code |	code := fieldName,'	"This method was automatically generated"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>		^ self fieldAt: ' , fieldName printString.	Author useAuthor: 'NativeBoost' during: [ 		| selector |		selector := self compileSilently: code classified: (self protocolForField: fieldName).		self package addMethod: (self compiledMethodAt: selector) ].		code := fieldName,': anObject	"This method was automatically generated"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>		^ self fieldAt: ' , fieldName printString , ' put: anObject'.	Author useAuthor: 'NativeBoost' during: [ 		| selector |		selector := self compileSilently: code classified: (self protocolForField: fieldName).		self package addMethod: (self compiledMethodAt: selector) ]! !!LGitExternalStructure class methodsFor: 'managing accessors' stamp: ' 7/21/2017 17:44:56'!fieldNamesAndProtocols	^ Dictionary new! !!LGitExternalStructure class methodsFor: 'managing accessors' stamp: ' 7/21/2017 17:44:56'!fieldSpec	^ LGitExternalStructureFieldParser new  		parseFields: self fieldsDesc structure: self.! !!LGitExternalStructure class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!finalizeResourceData: aHandle	"Call the class specific free frunction if aHandle is still a valid external address."	aHandle isNull ifTrue: [ ^self ].	self perform: self freeFunctionSelector with: aHandle.	aHandle beNull! !!LGitExternalStructure class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!free: aHandle	aHandle free! !!LGitExternalStructure class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #free:! !!LGitExternalStructure class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!fromExternalAddress: anAddress	anAddress isNull		ifTrue: [ ^ nil ].	^ self fromHandle: anAddress getHandle! !!LGitExternalStructure class methodsFor: 'managing accessors' stamp: ' 7/21/2017 17:44:56'!generatedFieldProtocolName	^ 'libgit-fields'! !!LGitExternalStructure class methodsFor: 'managing accessors' stamp: ' 7/21/2017 17:44:56'!protocolForField: aString	^ self fieldNamesAndProtocols		at: aString		ifAbsent: [ 'libgit-fields' ]! !!LGitExternalStructure class methodsFor: 'managing accessors' stamp: ' 7/21/2017 17:44:56'!removeAccessor: aSelector	self package removeMethod: (self		compiledMethodAt: aSelector		ifAbsent: [ ^ self ]).			^ super removeAccessor: aSelector! !!LGitExternalStructure methodsFor: 'initialize-release' stamp: ' 7/21/2017 17:44:56'!autoRelease	"Some LGit structures need specialised free functions. Use the same autoRelease functionality	as FFIExternalReference to achieve this.	Note, subclasses should implement #resourceData	and #finalizeResourceData: on class side"	FFIExternalResourceManager addResource: self! !!LGitExternalStructure methodsFor: 'initialize-release' stamp: ' 7/21/2017 17:44:56'!free	handle isExternalAddress 		ifTrue: [ 			self class finalizeResourceData: handle.			self assert: handle isNull ]! !!LGitExternalStructure methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isExternal	"answer true if data referenced by receiver located in external heap, or just in object memory "	^ handle isExternalAddress! !!LGitExternalStructure methodsFor: 'initialize-release' stamp: ' 7/21/2017 17:44:56'!resourceData	^ self getHandle! !!LGitId class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(	uint8 data1;	uint8 data2;	uint8 data3;	uint8 data4;	uint8 data5;	uint8 data6;	uint8 data7;	uint8 data8;	uint8 data9;	uint8 data10;	uint8 data11;	uint8 data12;	uint8 data13;	uint8 data14;	uint8 data15;	uint8 data16;	uint8 data17;	uint8 data18;	uint8 data19;	uint8 data20;	)! !!LGitId class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!fromByteArray: aByteArray	^ self new		prim_data1: (aByteArray at: 1);		prim_data2: (aByteArray at: 2);		prim_data3: (aByteArray at: 3);		prim_data4: (aByteArray at: 4);		prim_data5: (aByteArray at: 5);		prim_data6: (aByteArray at: 6);		prim_data7: (aByteArray at: 7);		prim_data8: (aByteArray at: 8);		prim_data9: (aByteArray at: 9);		prim_data10: (aByteArray at: 10);		prim_data11: (aByteArray at: 11);		prim_data12: (aByteArray at: 12);		prim_data13: (aByteArray at: 13);		prim_data14: (aByteArray at: 14);		prim_data15: (aByteArray at: 15);		prim_data16: (aByteArray at: 16);		prim_data17: (aByteArray at: 17);		prim_data18: (aByteArray at: 18);		prim_data19: (aByteArray at: 19);		prim_data20: (aByteArray at: 20);		yourself! !!LGitId class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!fromHexString: aString	^ self fromByteArray: (ByteArray readHexFrom: aString)! !!LGitId methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!= anObject	^ self == anObject		or: [ self class = anObject class			and: [ self compare: anObject ] ]! !!LGitId methodsFor: 'converting' stamp: ' 7/21/2017 17:44:56'!asByteArray	^ (ByteArray new: 20)		at: 1 put: (self prim_data1);		at: 2 put: (self prim_data2);		at: 3 put: (self prim_data3);		at: 4 put: (self prim_data4);		at: 5 put: (self prim_data5);		at: 6 put: (self prim_data6);		at: 7 put: (self prim_data7);		at: 8 put: (self prim_data8);		at: 9 put: (self prim_data9);		at: 10 put: (self prim_data10);		at: 11 put: (self prim_data11);		at: 12 put: (self prim_data12);		at: 13 put: (self prim_data13);		at: 14 put: (self prim_data14);		at: 15 put: (self prim_data15);		at: 16 put: (self prim_data16);		at: 17 put: (self prim_data17);		at: 18 put: (self prim_data18);		at: 19 put: (self prim_data19);		at: 20 put: (self prim_data20);		yourself	! !!LGitId methodsFor: 'converting' stamp: ' 7/21/2017 17:44:56'!asInteger	^ self asByteArray asInteger! !!LGitId methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!asRelativePathString	| string |	string := String new: 41.	string pin.	self		oid_pathfmt: string		id: self.	string unpin.	^ string! !!LGitId methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!compare: anId	^ (self 		oid_cmp: self		b: anId) isZero! !!LGitId methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!hexString	| string |	self isExternal 		ifFalse: [ ^handle hex ].	string := String new: 40.	string pin.	self		oid_fmt: string		id: self.		string unpin.	^ string! !!LGitId methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!internalize	"Copy the data of this object over to Smalltalk memory if it is currently external.	Now we can keep on using this object after the containing object (Blob, Tree or Commit)	has been freed."	(handle isExternalAddress and: [ handle isNull not ])		ifTrue: [ 			| bytes |			bytes := handle copyFrom: 1 to: self class byteSize.			handle := bytes ]! !!LGitId methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!objectPrintOn: aStream	aStream nextPutAll: self hexString surroundedBySingleQuotes! !!LGitId methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!oid_cmp: a b: b 	^self call: #(int git_oid_cmp(LGitId * self, LGitId * b)) options: #(  )! !!LGitId methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!oid_fmt: out id:  objectId	^self call: #(void git_oid_fmt(void *out, LGitId * self)) options: #(  )! !!LGitId methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!oid_pathfmt: out id: id 	^ self call: #(void git_oid_pathfmt(void *out, LGitId * self)) options: #(  )! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data1	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA1! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data10	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA10! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data10: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA10 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data11	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA11! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data11: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA11 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data12	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA12! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data12: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA12 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data13	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA13! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data13: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA13 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data14	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA14! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data14: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA14 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data15	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA15! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data15: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA15 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data16	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA16! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data16: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA16 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data17	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA17! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data17: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA17 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data18	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA18! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data18: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA18 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data19	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA19! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data19: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA19 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data1: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA1 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data2	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA2! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data20	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA20! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data20: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA20 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data2: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA2 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data3	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA3! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data3: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA3 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data4	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA4! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data4: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA4 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data5	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA5! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data5: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA5 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data6	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA6! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data6: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA6 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data7	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA7! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data7: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA7 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data8	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA8! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data8: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA8 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data9	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA9! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_data9: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA9 put: anObject! !!LGitOdbWritepack class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(	"git_odb_backend *" void *backend; "Using void* because I didn't mapped the structure git_odb_backend"	LGitWritepackAppendCallout append;	LGitWritepackCommitCallout commit;	LGitWritepackFreeCallout free;	)! !!LGitOdbWritepack methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!appendWithBuffer: anAddress length: anInteger progress: aTransferProgress	| data callout|	data := self prim_append.	callout := LGitWritepackAppendCallout fromHandle: data getHandle.	^ callout		writepack: self		buffer: anAddress		length: anInteger		progress: aTransferProgress! !!LGitOdbWritepack methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!commitWithProgress: aTransferProgress	self withReturnHandlerDo: [		self prim_commit			writepack: self			progress: aTransferProgress ]! !!LGitOdbWritepack methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!free	self prim_free writepack: self! !!LGitOdbWritepack methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!odb_write_pack: out db: db progress_cb: progress_cb progress_payload: progress_payload 	^ self		call: #(#LGitReturnCodeEnum git_odb_write_pack(LGitOdbWritepack * self, LGitOdb db, LGitTransferProgressCallback progress_cb, void * progress_payload))		options: #( optMayGC optCoerceNilToNull )! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_append	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_APPEND) type: ExternalType void asPointerType! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_append: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_APPEND put: anObject getHandle.! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_backend	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_BACKEND) type: ExternalType void asPointerType! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_backend: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_BACKEND put: anObject getHandle.! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_commit	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_COMMIT) type: ExternalType void asPointerType! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_commit: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_COMMIT put: anObject getHandle.! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_free	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_FREE) type: ExternalType void asPointerType! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_free: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_FREE put: anObject getHandle.! !!LGitPackbuilderForeachPayload class methodsFor: 'field definition' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(		LGitTransferProgress *stats;		LGitTransferProgressCallback *progress_cb;		void *progress_payload;		LGitOdbWritepack *writepack;	)! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_progress_cb	"This method was automatically generated"	^LGitTransferProgressCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PROGRESS_CB) asInteger)! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_progress_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PROGRESS_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_progress_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PROGRESS_PAYLOAD) type: ExternalType void asPointerType! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_progress_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PROGRESS_PAYLOAD put: anObject getHandle.! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_stats	"This method was automatically generated"	^LGitTransferProgress fromHandle: (handle pointerAt: OFFSET_PRIM_STATS)! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_stats: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_STATS put: anObject getHandle.! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_writepack	"This method was automatically generated"	^LGitOdbWritepack fromHandle: (handle pointerAt: OFFSET_PRIM_WRITEPACK)! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_writepack: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_WRITEPACK put: anObject getHandle.! !!LGitPackbuilderForeachPayload methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!stats	^ self prim_stats! !!LGitPackbuilderForeachPayload methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!stats: aTransferProgress	self prim_stats: aTransferProgress! !!LGitPackbuilderForeachPayload methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!writepack	^ self prim_writepack! !!LGitPackbuilderForeachPayload methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!writepack: aWritepack	self prim_writepack: aWritepack! !!LGitPushUpdate class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(		"		 * The source name of the reference		 "		String src_refname;		"		 * The name of the reference to update on the server		 "		String dst_refname;		"		 * The current target of the reference		 "		LGitId src		"		 * The new target for the reference		 "		LGitId dst	)! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_dst	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_DST length: LGitId byteSize)! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_dst: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_DST put: anObject getHandle length: LGitId byteSize! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_dst_refname	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_DST_REFNAME) type: ExternalType char asPointerType! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_dst_refname: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_DST_REFNAME put: anObject getHandle.! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_src	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_SRC length: LGitId byteSize)! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_src: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_SRC put: anObject getHandle length: LGitId byteSize! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_src_refname	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_SRC_REFNAME) type: ExternalType char asPointerType! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_src_refname: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_SRC_REFNAME put: anObject getHandle.! !!LGitRemoteHead class methodsFor: 'field definition' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	"self rebuildFieldAccessors"	^#(	int local; " available locally "	LGitId oid;	LGitId loid;	String name;	"	 * If the server send a symref mapping for this ref, this will	 * point to the target.	"	String symref_target;	)! !!LGitRemoteHead methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!name 	^ (self prim_name) readString! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_local	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_LOCAL! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_local: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_LOCAL put: anObject! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_loid	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_LOID length: LGitId byteSize)! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_loid: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_LOID put: anObject getHandle length: LGitId byteSize! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_name	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_NAME) type: ExternalType char asPointerType! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_name: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_NAME put: anObject getHandle.! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_oid	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_OID length: LGitId byteSize)! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_oid: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_OID put: anObject getHandle length: LGitId byteSize! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_symref_target	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_SYMREF_TARGET) type: ExternalType char asPointerType! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_symref_target: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_SYMREF_TARGET put: anObject getHandle.! !!LGitSignature class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(		char * name;		char * email;		LGitTime when;	)! !!LGitSignature class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!name: nameString email: emailString	^ self name: nameString email: emailString when: DateAndTime now! !!LGitSignature class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!name: nameString email: emailString when: dateAndTime	"Allocate an instance on the external heap and initialize it.	Use autoRelease so the data will be freed when the instance is gc'ed."	^ self externalNew			name: nameString;			email: emailString;			dateAndTime: dateAndTime;			autoRelease;			yourself! !!LGitSignature class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!signature_free: handle 	^ self		call: #(void git_signature_free(void *handle))		options: #(  )! !!LGitSignature methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!= anObject	^ self == anObject		or: [ self class == anObject class			and: [ self name = anObject name				and: [ self email = anObject email					and: [ self dateAndTime = anObject dateAndTime ] ] ] ]! !!LGitSignature methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!dateAndTime	^ self prim_when asDateAndTime! !!LGitSignature methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!dateAndTime: aDateAndTime	self prim_when: (LGitTime fromDateAndTime: aDateAndTime)! !!LGitSignature methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!email	^ self prim_email readString! !!LGitSignature methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!email: aString	self prim_email: aString asLGitExternalString! !!LGitSignature methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!hash	^ ((self name hash bitXor: self email hash) bitXor: self email hash) bitXor: self dateAndTime hash! !!LGitSignature methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!name	^ self prim_name readString! !!LGitSignature methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!name: aString	self prim_name: aString asLGitExternalString! !!LGitSignature methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!objectPrintOn: aStream	aStream		nextPutAll: self name;		nextPutAll: ' <';		nextPutAll: self email;		nextPutAll: '> '.	self dateAndTime printOn: aStream! !!LGitSignature methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_email	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_EMAIL) type: ExternalType char asPointerType! !!LGitSignature methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_email: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_EMAIL put: anObject getHandle.! !!LGitSignature methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_name	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_NAME) type: ExternalType char asPointerType! !!LGitSignature methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_name: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_NAME put: anObject getHandle.! !!LGitSignature methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_when	"This method was automatically generated"	^ LGitTime fromHandle: (handle referenceStructAt: OFFSET_PRIM_WHEN length: LGitTime byteSize)! !!LGitSignature methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_when: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_WHEN put: anObject getHandle length: LGitTime byteSize! !!LGitStringArray class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(		LGitExternalStringArray * strings;		size_t count;	)! !!LGitStringArray class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!strarray_free: handle	"libgit2 will also free all the strings in this struct"	^ self		call: #(void git_strarray_free(void *handle))		options: #()! !!LGitStringArray class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!withAll: stringCollection	"Allocate an instance on the external heap and initialize it with	<stringCollection>. Use autoRelease so the data will be freed when	the instance is gc'ed."	^ self externalNew		count: stringCollection size;		strings: stringCollection;		autoRelease;		yourself! !!LGitStringArray methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!count	^ self prim_count! !!LGitStringArray methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!count: anInteger	self prim_count: anInteger! !!LGitStringArray methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_count	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_COUNT! !!LGitStringArray methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_count: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_COUNT put: anObject! !!LGitStringArray methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_strings	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_STRINGS) type: ExternalType void asPointerType! !!LGitStringArray methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_strings: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_STRINGS put: anObject getHandle.! !!LGitStringArray methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!strings	| externalArray |	self count = 0		ifTrue: [ ^ #() ].	externalArray := LGitExternalStringArray 		onAddress: self prim_strings getHandle 		size: self count.	^externalArray asArray! !!LGitStringArray methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!strings: aCollection	| array |	array := LGitExternalStringArray fromCollection: aCollection.	self prim_strings: array! !!LGitBlameOptions class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^ #(		LGitOptionsVersionsEnum version		uint32 flags "is a combination of the git_blame_flag_t values above."		uint16 min_match_characters "is the lower bound on the number of alphanumeric characters that must be detected as moving/copying within a file for it to associate those lines with the parent commit. The default value is 20. This value only takes effect if any of the GIT_BLAME_TRACK_COPIES_* flags are specified."		LGitId newest_commit "is the id of the newest commit to consider. The default is HEAD."		LGitId oldest_commit "is the id of the oldest commit to consider. The default is the first commit encountered with a NULL parent."		size_t min_line "is the first line in the file to blame. The default is 1 (line numbers start with 1)."		size_t max_line "is the last line in the file to blame. The default is the last line of the file."	)! !!LGitBlameOptions methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blame_init_options: opts version: version	^ self		callUnchecked: #(int git_blame_init_options(LGitBlameOptions * self, LGitOptionsVersionsEnum version))		options: #( )! !!LGitBlameOptions methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!initializeWithDefaults	self withReturnHandlerDo: [		self			blame_init_options: self			version: LGitOptionsVersionsEnum git_blame_options_version_1 ]! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FLAGS! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FLAGS put: anObject! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_max_line	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_MAX_LINE! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_max_line: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_MAX_LINE put: anObject! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_min_line	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_MIN_LINE! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_min_line: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_MIN_LINE put: anObject! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_min_match_characters	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_MIN_MATCH_CHARACTERS! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_min_match_characters: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_MIN_MATCH_CHARACTERS put: anObject! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_newest_commit	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_NEWEST_COMMIT length: LGitId byteSize)! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_newest_commit: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_NEWEST_COMMIT put: anObject getHandle length: LGitId byteSize! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_oldest_commit	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_OLDEST_COMMIT length: LGitId byteSize)! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_oldest_commit: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_OLDEST_COMMIT put: anObject getHandle length: LGitId byteSize! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitCheckoutOptions class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(		LGitOptionsVersionsEnum version;		uint checkout_strategy; "< default will be a dry run "		int disable_filters;    "< don't apply filters like CRLF conversion "		uint dir_mode;  "< default is 0755 "		uint file_mode; "< default is 0644 or 0755 as dictated by blob "		int file_open_flags;    "< default is O_CREAT | O_TRUNC | O_WRONLY "		uint notify_flags; "< see `git_checkout_notify_t` above "		LGitCheckoutNotifyCallback notify_cb;		void *notify_payload;		" Optional callback to notify the consumer of checkout progress. "		LGitCheckoutProgressCallback progress_cb;		void *progress_payload;		" When not zeroed out, array of fnmatch patterns specifying which		 *  paths should be taken into account, otherwise all files.  Use		 *  GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH to treat as simple list.		 "		LGitStringArray paths;		" The expected content of the working directory; defaults to HEAD.		 *  If the working directory does not match this baseline information,		 *  that will produce a checkout conflict.		 "		LGitTree *baseline;		" Like `baseline` above, though expressed as an index.  This		 *  option overrides `baseline`.		 "		LGitIndex *baseline_index; "< expected content of workdir, expressed as an index. "		String target_directory; "< alternative checkout path to workdir "		String ancestor_label; "< the name of the common ancestor side of conflicts "		String our_label; "< the name of the *our* side of conflicts "		String their_label; "< the name of the *their* side of conflicts "		" Optional callback to notify the consumer of performance data. "		LGitCheckoutPerfDataCallback perfdata_cb;		void *perfdata_payload;	)! !!LGitCheckoutOptions methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!checkoutStrategy: aCheckoutStrategyEnum	self prim_checkout_strategy: aCheckoutStrategyEnum value! !!LGitCheckoutOptions methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!checkout_init_options: opts version: version 	^ self		callUnchecked: #(int git_checkout_init_options(LGitCheckoutOptions * self, LGitOptionsVersionsEnum version))		options: #(  )! !!LGitCheckoutOptions methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!initializeWithDefaults	self withReturnHandlerDo: [		self			checkout_init_options: self			version: LGitOptionsVersionsEnum git_checkout_options_version_1 ]! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_ancestor_label	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_ANCESTOR_LABEL) type: ExternalType char asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_ancestor_label: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_ANCESTOR_LABEL put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_baseline	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_BASELINE) type: ExternalType void asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_baseline: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_BASELINE put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_baseline_index	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_BASELINE_INDEX) type: ExternalType void asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_baseline_index: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_BASELINE_INDEX put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_checkout_strategy	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_CHECKOUT_STRATEGY! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_checkout_strategy: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CHECKOUT_STRATEGY put: anObject! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_dir_mode	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_DIR_MODE! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_dir_mode: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_DIR_MODE put: anObject! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_disable_filters	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_DISABLE_FILTERS! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_disable_filters: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_DISABLE_FILTERS put: anObject! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_file_mode	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FILE_MODE! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_file_mode: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FILE_MODE put: anObject! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_file_open_flags	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_FILE_OPEN_FLAGS! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_file_open_flags: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_FILE_OPEN_FLAGS put: anObject! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_notify_cb	"This method was automatically generated"	^LGitCheckoutNotifyCallback forAddress: ((handle pointerAt: OFFSET_PRIM_NOTIFY_CB) asInteger)! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_notify_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_NOTIFY_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_notify_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_NOTIFY_FLAGS! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_notify_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_NOTIFY_FLAGS put: anObject! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_notify_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_NOTIFY_PAYLOAD) type: ExternalType void asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_notify_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_NOTIFY_PAYLOAD put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_our_label	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_OUR_LABEL) type: ExternalType char asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_our_label: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_OUR_LABEL put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_paths	"This method was automatically generated"	^ LGitStringArray fromHandle: (handle referenceStructAt: OFFSET_PRIM_PATHS length: LGitStringArray byteSize)! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_paths: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_PATHS put: anObject getHandle length: LGitStringArray byteSize! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_perfdata_cb	"This method was automatically generated"	^LGitCheckoutPerfDataCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PERFDATA_CB) asInteger)! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_perfdata_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PERFDATA_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_perfdata_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PERFDATA_PAYLOAD) type: ExternalType void asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_perfdata_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PERFDATA_PAYLOAD put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_progress_cb	"This method was automatically generated"	^LGitCheckoutProgressCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PROGRESS_CB) asInteger)! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_progress_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PROGRESS_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_progress_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PROGRESS_PAYLOAD) type: ExternalType void asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_progress_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PROGRESS_PAYLOAD put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_target_directory	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_TARGET_DIRECTORY) type: ExternalType char asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_target_directory: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_TARGET_DIRECTORY put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_their_label	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_THEIR_LABEL) type: ExternalType char asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_their_label: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_THEIR_LABEL put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitCloneOptions class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(		LGitOptionsVersionsEnum version;				"		 * These options are passed to the checkout step. To disable		 * checkout, set the `checkout_strategy` to		 * `GIT_CHECKOUT_NONE`.		 "		LGitCheckoutOptions checkout_opts;		"		 * Options which control the fetch, including callbacks.		 *		 * The callbacks are used for reporting fetch progress, and for acquiring		 * credentials in the event they are needed.		 "		LGitFetchOptions fetch_opts;		"		 * Set to zero (false) to create a standard repo, or non-zero		 * for a bare repo		 "		Boolean bare;		"		 * Whether to use a fetch or copy the object database.		 "		LGitCloneLocalTypeEnum local;		"		 * The name of the branch to checkout. NULL means use the		 * remote's default branch.		 "		String checkout_branch;		"		 * A callback used to create the new repository into which to		 * clone. If NULL, the 'bare' field will be used to determine		 * whether to create a bare repository.		 "		LGitRepositoryCreateCallback repository_cb;		"		 * An opaque payload to pass to the git_repository creation callback.		 * This parameter is ignored unless repository_cb is non-NULL.		 "		void *repository_cb_payload;		"		 * A callback used to create the git_remote, prior to its being		 * used to perform the clone operation. See the documentation for		 * git_remote_create_cb for details. This parameter may be NULL,		 * indicating that git_clone should provide default behavior.		 "		LGitRemoteCreateCallback remote_cb;		"		 * An opaque payload to pass to the git_remote creation callback.		 * This parameter is ignored unless remote_cb is non-NULL.		 "		void *remote_cb_payload;	)! !!LGitCloneOptions class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!withCredentialsCallback: aBlock	| credentialsCallback callbacks fetchOptions  |	credentialsCallback := LGitCredAcquireCallback on: aBlock.	callbacks := LGitRemoteCallbacks defaults		credentials: credentialsCallback;		yourself.	fetchOptions := LGitFetchOptions defaults		callbacks: callbacks;		yourself.	^ self defaults		fetchOptions: fetchOptions;		yourself.	! !!LGitCloneOptions class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!withCredentialsProvider: provider	| fetchOptions |	fetchOptions := LGitFetchOptions defaults		callbacks: (LGitRemoteCallbacks withProvider: provider);		yourself.	^ self defaults		fetchOptions: fetchOptions		yourself.	! !!LGitCloneOptions methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!clone_init_options: opts version: version 	^ self		callUnchecked: #(LGitReturnCodeEnum git_clone_init_options(LGitCloneOptions *self, LGitOptionsVersionsEnum version))		options: #(  )! !!LGitCloneOptions methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fetchOptions	^ self prim_fetch_opts! !!LGitCloneOptions methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fetchOptions: _fetchOptions	fetchOptions := _fetchOptions.	self prim_fetch_opts: fetchOptions! !!LGitCloneOptions methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!initializeWithDefaults	self withReturnHandlerDo: [		self			clone_init_options: self			version: LGitOptionsVersionsEnum  git_clone_options_version_1 ]! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_bare	"This method was automatically generated"	^handle booleanAt: OFFSET_PRIM_BARE! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_bare: anObject	"This method was automatically generated"	handle booleanAt: OFFSET_PRIM_BARE put: anObject! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_checkout_branch	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_CHECKOUT_BRANCH) type: ExternalType char asPointerType! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_checkout_branch: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_CHECKOUT_BRANCH put: anObject getHandle.! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_checkout_opts	"This method was automatically generated"	^ LGitCheckoutOptions fromHandle: (handle referenceStructAt: OFFSET_PRIM_CHECKOUT_OPTS length: LGitCheckoutOptions byteSize)! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_checkout_opts: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_CHECKOUT_OPTS put: anObject getHandle length: LGitCheckoutOptions byteSize! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_fetch_opts	"This method was automatically generated"	^ LGitFetchOptions fromHandle: (handle referenceStructAt: OFFSET_PRIM_FETCH_OPTS length: LGitFetchOptions byteSize)! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_fetch_opts: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_FETCH_OPTS put: anObject getHandle length: LGitFetchOptions byteSize! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_local	"This method was automatically generated"	^LGitCloneLocalTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_LOCAL)! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_local: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_LOCAL put: anObject value! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_remote_cb	"This method was automatically generated"	^LGitRemoteCreateCallback forAddress: ((handle pointerAt: OFFSET_PRIM_REMOTE_CB) asInteger)! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_remote_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_REMOTE_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_remote_cb_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_REMOTE_CB_PAYLOAD) type: ExternalType void asPointerType! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_remote_cb_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_REMOTE_CB_PAYLOAD put: anObject getHandle.! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_repository_cb	"This method was automatically generated"	^LGitRepositoryCreateCallback forAddress: ((handle pointerAt: OFFSET_PRIM_REPOSITORY_CB) asInteger)! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_repository_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_REPOSITORY_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_repository_cb_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_REPOSITORY_CB_PAYLOAD) type: ExternalType void asPointerType! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_repository_cb_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_REPOSITORY_CB_PAYLOAD put: anObject getHandle.! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitCloneOptions methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!remoteCallback	^ self prim_remote_cb! !!LGitCloneOptions methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!remoteCallback: aRemoteCallback	self prim_remote_cb: aRemoteCallback! !!LGitDiffFindOptions class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(		LGitOptionsVersionsEnum version;		"Combination of git_diff_find_t values (default GIT_DIFF_FIND_BY_CONFIG).		 NOTE: if you don't explicitly set this, `diff.renames` could be set		 to false, resulting in `git_diff_find_similar` doing nothing."		uint32 flags;		" Similarity to consider a file renamed (default 50) "		uint16 rename_threshold;		" Similarity of modified to be eligible rename source (default 50) "		uint16 rename_from_rewrite_threshold;		" Similarity to consider a file a copy (default 50) "		uint16 copy_threshold;		" Similarity to split modify into delete/add pair (default 60) "		uint16 break_rewrite_threshold;		"Maximum similarity sources to examine for a file (somewhat like		 git-diff's `-l` option or `diff.renameLimit` config) (default 200)"		size_t rename_limit;		" Pluggable similarity metric; pass NULL to use internal metric "		LGitDiffSimilarityMetric metric;	)! !!LGitDiffFindOptions methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_find_init_options: opts version: version	^ self		callUnchecked: #(LGitReturnCodeEnum git_diff_find_init_options(LGitDiffFindOptions * self, LGitOptionsVersionsEnum version))		options: #(  )! !!LGitDiffFindOptions methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!initializeWithDefaults	self withReturnHandlerDo: [		self			diff_find_init_options: self			version: LGitOptionsVersionsEnum git_diff_find_options_version_1 ]! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_break_rewrite_threshold	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_BREAK_REWRITE_THRESHOLD! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_break_rewrite_threshold: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_BREAK_REWRITE_THRESHOLD put: anObject! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_copy_threshold	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_COPY_THRESHOLD! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_copy_threshold: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_COPY_THRESHOLD put: anObject! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FLAGS! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FLAGS put: anObject! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_metric	"This method was automatically generated"	^ LGitDiffSimilarityMetric fromHandle: (handle referenceStructAt: OFFSET_PRIM_METRIC length: LGitDiffSimilarityMetric byteSize)! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_metric: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_METRIC put: anObject getHandle length: LGitDiffSimilarityMetric byteSize! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_rename_from_rewrite_threshold	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_RENAME_FROM_REWRITE_THRESHOLD! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_rename_from_rewrite_threshold: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_RENAME_FROM_REWRITE_THRESHOLD put: anObject! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_rename_limit	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_RENAME_LIMIT! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_rename_limit: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_RENAME_LIMIT put: anObject! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_rename_threshold	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_RENAME_THRESHOLD! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_rename_threshold: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_RENAME_THRESHOLD put: anObject! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitDiffOptions class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(		LGitOptionsVersionsEnum version      "version for the struct"		uint32 flags            "defaults to GIT_DIFF_NORMAL"		"options controlling which files are in the diff"		LGitSubmoduleIgnoreTypeEnum ignore_submodules "submodule ignore rule"		LGitStringArray       pathspec     "defaults to include all paths"		LGitDiffNotifyCallback notify_cb		void *notify_payload		"options controlling how to diff text is generated"		uint32    context_lines    "defaults to 3"		uint32    interhunk_lines  "defaults to 0"		uint16    id_abbrev       "default 'core.abbrev' or 7 if unset"		int64   max_size         "defaults to 512MB"		String old_prefix       "defaults to 'a'"		String new_prefix       "defaults to 'b'"	)! !!LGitDiffOptions methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_init_options: opts version: version	^ self		callUnchecked: #(LGitReturnCodeEnum git_diff_init_options(LGitDiffOptions * self, LGitOptionsVersionsEnum version))		options: #(  )! !!LGitDiffOptions methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!initializeWithDefaults	self withReturnHandlerDo: [		self			diff_init_options: self			version: LGitOptionsVersionsEnum git_diff_options_version_1 ]! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_context_lines	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_CONTEXT_LINES! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_context_lines: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CONTEXT_LINES put: anObject! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FLAGS! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FLAGS put: anObject! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_id_abbrev	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_ID_ABBREV! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_id_abbrev: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_ID_ABBREV put: anObject! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_ignore_submodules	"This method was automatically generated"	^LGitSubmoduleIgnoreTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_IGNORE_SUBMODULES)! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_ignore_submodules: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_IGNORE_SUBMODULES put: anObject value! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_interhunk_lines	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_INTERHUNK_LINES! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_interhunk_lines: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_INTERHUNK_LINES put: anObject! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_max_size	"This method was automatically generated"	^handle signedLongLongAt: OFFSET_PRIM_MAX_SIZE! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_max_size: anObject	"This method was automatically generated"	handle signedLongLongAt: OFFSET_PRIM_MAX_SIZE put: anObject! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_new_prefix	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_NEW_PREFIX) type: ExternalType char asPointerType! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_new_prefix: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_NEW_PREFIX put: anObject getHandle.! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_notify_cb	"This method was automatically generated"	^LGitDiffNotifyCallback forAddress: ((handle pointerAt: OFFSET_PRIM_NOTIFY_CB) asInteger)! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_notify_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_NOTIFY_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_notify_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_NOTIFY_PAYLOAD) type: ExternalType void asPointerType! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_notify_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_NOTIFY_PAYLOAD put: anObject getHandle.! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_old_prefix	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_OLD_PREFIX) type: ExternalType char asPointerType! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_old_prefix: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_OLD_PREFIX put: anObject getHandle.! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_pathspec	"This method was automatically generated"	^ LGitStringArray fromHandle: (handle referenceStructAt: OFFSET_PRIM_PATHSPEC length: LGitStringArray byteSize)! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_pathspec: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_PATHSPEC put: anObject getHandle length: LGitStringArray byteSize! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitFetchOptions class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^ #(		LGitOptionsVersionsEnum version;		"		 * Callbacks to use for this fetch operation		 "		LGitRemoteCallbacks callbacks;		"		 * Whether to perform a prune after the fetch		 "		LGitFetchPruneTypeEnum prune;		"		 * Whether to write the results to FETCH_HEAD. Defaults to		 * on. Leave this default in order to behave like git.		 "		Boolean update_fetchhead;		"		 * Determines how to behave regarding tags on the remote, such		 * as auto-downloading tags for objects we're downloading or		 * downloading all of them.		 *		 * The default is to auto-follow tags.		 "		LGitRemoteAutotagOptionTypeEnum download_tags;		"	    * Proxy options to use, by default no proxy is used.	   "		LGitProxyOptions proxy_opts;		"	  	 * Extra headers for this fetch operation	 	"		LGitStringArray custom_headers;	)! !!LGitFetchOptions methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!callbacks	^ self prim_callbacks! !!LGitFetchOptions methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!callbacks: _callbacks	callbacks := _callbacks.	self prim_callbacks: callbacks! !!LGitFetchOptions methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!fetch_init_options: opts version: version	^ self		callUnchecked: #(LGitReturnCodeEnum git_fetch_init_options(LGitFetchOptions * self, LGitOptionsVersionsEnum version))		options: #(  )! !!LGitFetchOptions methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!initializeWithDefaults	self withReturnHandlerDo: [		self			fetch_init_options: self			version: LGitOptionsVersionsEnum git_fetch_options_version_1 ]! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_callbacks	"This method was automatically generated"	^ LGitRemoteCallbacks fromHandle: (handle referenceStructAt: OFFSET_PRIM_CALLBACKS length: LGitRemoteCallbacks byteSize)! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_callbacks: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_CALLBACKS put: anObject getHandle length: LGitRemoteCallbacks byteSize! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_custom_headers	"This method was automatically generated"	^ LGitStringArray fromHandle: (handle referenceStructAt: OFFSET_PRIM_CUSTOM_HEADERS length: LGitStringArray byteSize)! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_custom_headers: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_CUSTOM_HEADERS put: anObject getHandle length: LGitStringArray byteSize! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_download_tags	"This method was automatically generated"	^LGitRemoteAutotagOptionTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_DOWNLOAD_TAGS)! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_download_tags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_DOWNLOAD_TAGS put: anObject value! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_proxy_opts	"This method was automatically generated"	^ LGitProxyOptions fromHandle: (handle referenceStructAt: OFFSET_PRIM_PROXY_OPTS length: LGitProxyOptions byteSize)! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_proxy_opts: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_PROXY_OPTS put: anObject getHandle length: LGitProxyOptions byteSize! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_prune	"This method was automatically generated"	^LGitFetchPruneTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_PRUNE)! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_prune: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_PRUNE put: anObject value! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_update_fetchhead	"This method was automatically generated"	^handle booleanAt: OFFSET_PRIM_UPDATE_FETCHHEAD! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_update_fetchhead: anObject	"This method was automatically generated"	handle booleanAt: OFFSET_PRIM_UPDATE_FETCHHEAD put: anObject! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitMergeOptions class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	"https://libgit2.github.com/libgit2/#HEAD/type/git_merge_options"	^#(		LGitOptionsVersionsEnum version;		uint32 flags; "Should be: git_merge_flag_t"		uint rename_threshold;		uint target_limit;		void* metric; "Should be: git_diff_similarity_metric *"		uint recursion_limit;		String default_driver;		uint32 file_favor; "Should be: git_merge_favor_flag_t"		uint32 file_flags; "Should be: git_merge_file_flag_t"	)! !!LGitMergeOptions methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!initializeWithDefaults	self withReturnHandlerDo: [		self			merge_init_options: self			version: LGitOptionsVersionsEnum git_merge_options_version_1 ]! !!LGitMergeOptions methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!merge_init_options: opts version: version 	^ self		callUnchecked: #(int git_merge_init_options(			LGitMergeOptions * self, 			LGitOptionsVersionsEnum version))		options: #()! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_default_driver	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_DEFAULT_DRIVER) type: ExternalType char asPointerType! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_default_driver: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_DEFAULT_DRIVER put: anObject getHandle.! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_file_favor	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FILE_FAVOR! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_file_favor: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FILE_FAVOR put: anObject! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_file_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FILE_FLAGS! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_file_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FILE_FLAGS put: anObject! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FLAGS! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FLAGS put: anObject! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_metric	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_METRIC) type: ExternalType void asPointerType! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_metric: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_METRIC put: anObject getHandle.! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_recursion_limit	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_RECURSION_LIMIT! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_recursion_limit: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_RECURSION_LIMIT put: anObject! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_rename_threshold	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_RENAME_THRESHOLD! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_rename_threshold: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_RENAME_THRESHOLD put: anObject! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_target_limit	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_TARGET_LIMIT! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_target_limit: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_TARGET_LIMIT put: anObject! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitProxyOptions class methodsFor: 'field definition' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^ #(	LGitOptionsVersionsEnum version;	"/**	 * The type of proxy to use, by URL, auto-detect.	 */"	LGitProxyTypeEnum type;	"/**	 * The URL of the proxy.	 */"	String url;	"/**	 * This will be called if the remote host requires	 * authentication in order to connect to it.	 *	 * Returning GIT_PASSTHROUGH will make libgit2 behave as	 * though this field isn't set.	 */"	LGitCredAcquireCallback credentials;	"/**	 * If cert verification fails, this will be called to let the	 * user make the final decision of whether to allow the	 * connection to proceed. Returns 1 to allow the connection, 0	 * to disallow it or a negative value to indicate an error.	 */"   LGitTransportCertificateCheckCallback certificate_check;	"/**	 * Payload to be provided to the credentials and certificate	 * check callbacks.	 */"	void *payload;	)! !!LGitProxyOptions methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!initializeWithDefaults	self withReturnHandlerDo: [		self			proxy_init_options: self getHandle getHandle			version: LGitOptionsVersionsEnum git_fetch_options_version_1 ]! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_certificate_check	"This method was automatically generated"	^LGitTransportCertificateCheckCallback forAddress: ((handle pointerAt: OFFSET_PRIM_CERTIFICATE_CHECK) asInteger)! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_certificate_check: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_CERTIFICATE_CHECK		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_credentials	"This method was automatically generated"	^LGitCredAcquireCallback forAddress: ((handle pointerAt: OFFSET_PRIM_CREDENTIALS) asInteger)! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_credentials: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_CREDENTIALS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PAYLOAD) type: ExternalType void asPointerType! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PAYLOAD put: anObject getHandle.! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_type	"This method was automatically generated"	^LGitProxyTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_TYPE)! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_type: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_TYPE put: anObject value! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_url	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_URL) type: ExternalType char asPointerType! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_url: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_URL put: anObject getHandle.! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitProxyOptions methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!proxy_init_options: opts version: version	^ self		callUnchecked: #(LGitReturnCodeEnum git_proxy_init_options(void *handle, LGitOptionsVersionsEnum version))		options: #(  )! !!LGitPushOptions class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^ #(	LGitOptionsVersionsEnum version;	"	 * If the transport being used to push to the remote requires the creation	 * of a pack file, this controls the number of worker threads used by	 * the packbuilder when creating that pack file to be sent to the remote.	 *	 * If set to 0, the packbuilder will auto-detect the number of threads	 * to create. The default value is 1.	 "	uint pb_parallelism;	"	 * Callbacks to use for this push operation	 "	LGitRemoteCallbacks callbacks;			"	* Proxy options to use, by default no proxy is used.	"	LGitProxyOptions proxy_opts;	"	 * Extra headers for this push operation	"	LGitStringArray custom_headers;)! !!LGitPushOptions methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!callbacks	^ self prim_callbacks! !!LGitPushOptions methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!callbacks: _callbacks	callbacks := _callbacks.	^ self prim_callbacks: callbacks! !!LGitPushOptions methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!initializeWithDefaults	self withReturnHandlerDo: [		self			push_init_options: self			version: LGitOptionsVersionsEnum git_push_options_version_1 ]! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_callbacks	"This method was automatically generated"	^ LGitRemoteCallbacks fromHandle: (handle referenceStructAt: OFFSET_PRIM_CALLBACKS length: LGitRemoteCallbacks byteSize)! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_callbacks: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_CALLBACKS put: anObject getHandle length: LGitRemoteCallbacks byteSize! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_custom_headers	"This method was automatically generated"	^ LGitStringArray fromHandle: (handle referenceStructAt: OFFSET_PRIM_CUSTOM_HEADERS length: LGitStringArray byteSize)! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_custom_headers: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_CUSTOM_HEADERS put: anObject getHandle length: LGitStringArray byteSize! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_pb_parallelism	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_PB_PARALLELISM! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_pb_parallelism: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_PB_PARALLELISM put: anObject! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_proxy_opts	"This method was automatically generated"	^ LGitProxyOptions fromHandle: (handle referenceStructAt: OFFSET_PRIM_PROXY_OPTS length: LGitProxyOptions byteSize)! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_proxy_opts: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_PROXY_OPTS put: anObject getHandle length: LGitProxyOptions byteSize! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitPushOptions methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!push_init_options: options version: version	self		callUnchecked: #(LGitReturnCodeEnum git_push_init_options(LGitPushOptions * self, LGitOptionsVersionsEnum version))		options: #()! !!LGitRemoteCallbacks class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!defaults	^ super defaults 		certificateCheck: self newCertificateCheckCallback;		yourself! !!LGitRemoteCallbacks class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(		LGitStructVersionsEnum version;		"		 * Textual progress from the remote. Text send over the		 * progress side-band will be passed to this function (this is		 * the 'counting objects' output.		 "		LGitTransportMessageCallback sideband_progress;		"		 * Completion is called when different parts of the download		 * process are done (currently unused).		 "		LGitCompletionCallback completion;		"		 * This will be called if the remote host requires		 * authentication in order to connect to it.		 *		 * Returning GIT_PASSTHROUGH will make libgit2 behave as		 * though this field isn't set.		 "		LGitCredAcquireCallback credentials;		"		 * If cert verification fails, this will be called to let the		 * user make the final decision of whether to allow the		 * connection to proceed. Returns 1 to allow the connection, 0		 * to disallow it or a negative value to indicate an error.		 "	   LGitTransportCertificateCheckCallback certificate_check;		"		 * During the download of new data, this will be regularly		 * called with the current count of progress done by the		 * indexer.		 "		LGitTransferProgressCallback transfer_progress;		"		 * Each time a reference is updated locally, this function		 * will be called with information about it.		 "		LGitUpdateTipsCallback update_tips;		"		 * Function to call with progress information during pack		 * building. Be aware that this is called inline with pack		 * building operations, so performance may be affected.		 "		LGitPackbuilderProgressCallback pack_progress;		"		 * Function to call with progress information during the		 * upload portion of a push. Be aware that this is called		 * inline with pack building operations, so performance may be		 * affected.		 "		LGitPushTransferProgressCallback push_transfer_progress;		"		 * Called for each updated reference on push. If `status` is		 * not `NULL`, the update was rejected by the remote server		 * and `status` contains the reason given.		 "		LGitPushUpdateReferenceCallback push_update_reference;		"		 * Called once between the negotiation step and the upload. It		 * provides information about what updates will be performed.		 "		LGitPushNegotiationCallback push_negotiation;		"		 * Create the transport to use for this operation. Leave NULL		 * to auto-detect.		 "		LGitTransport transport;		"		 * This will be passed to each of the callbacks in this struct		 * as the last parameter.		 "		void *payload;	)! !!LGitRemoteCallbacks class methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!newCertificateCheckCallback	self flag: #fixMe. "I need to skip the verification of certificate because on macOS, 	libgit2 has problems to be compiled with Secure framework, and if compiled with 	openssl instead, openssl for macOS does not checks agains the certificates installed 	at S.O., so it will fail almost always. This is, of course, a workaround... eventually 	libgit2 will work :P"	^ LGitTransportCertificateCheckCallback on: [ :cert :value :host :payload  |		1 ]! !!LGitRemoteCallbacks class methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!newCredentialsCallbackFor: provider	^ LGitCredAcquireCallback		on: [ :output :url :username_from_url :allowed_types :data | 			"Allowed types are defined in git_credtype_t 		https://github.com/libgit2/libgit2/blob/HEAD/include/git2/transport.h#L81-111"			self				putCredentialsType: allowed_types				username: username_from_url				provider: provider				onto: output ]! !!LGitRemoteCallbacks class methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!putCredentialsType: types username: username provider: provider onto: output  	(types anyMask: 1 << 0) ifTrue: [ 		^ LGitCredentialsPlaintext createFrom: provider onto: output ].	(types anyMask: 1 << 1) ifTrue: [ 		^ provider sshCredentialsClass 			createFrom: provider 			username: username			onto: output ].	Transcript logCr: ('I can''t create credentials for type: {1}' format: {types}).	^ -1! !!LGitRemoteCallbacks class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!withProvider: provider	^ LGitRemoteCallbacks defaults		credentials: (self newCredentialsCallbackFor: provider);		certificateCheck: self newCertificateCheckCallback;		yourself! !!LGitRemoteCallbacks methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!certificateCheck: aCallback	certificateCheckCallback := aCallback.	self prim_certificate_check: aCallback! !!LGitRemoteCallbacks methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!credentials	^ self prim_credentials! !!LGitRemoteCallbacks methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!credentials: aCredentialsCallback	credentialsCallback := aCredentialsCallback.	self prim_credentials: credentialsCallback! !!LGitRemoteCallbacks methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!initializeWithDefaults	self withReturnHandlerDo: [		self			remote_init_callbacks: self			version: LGitStructVersionsEnum git_remote_callbacks_version_1 ]! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_certificate_check	"This method was automatically generated"	^LGitTransportCertificateCheckCallback forAddress: ((handle pointerAt: OFFSET_PRIM_CERTIFICATE_CHECK) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_certificate_check: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_CERTIFICATE_CHECK		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_completion	"This method was automatically generated"	^LGitCompletionCallback forAddress: ((handle pointerAt: OFFSET_PRIM_COMPLETION) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_completion: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_COMPLETION		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_credentials	"This method was automatically generated"	^LGitCredAcquireCallback forAddress: ((handle pointerAt: OFFSET_PRIM_CREDENTIALS) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_credentials: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_CREDENTIALS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_pack_progress	"This method was automatically generated"	^LGitPackbuilderProgressCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PACK_PROGRESS) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_pack_progress: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PACK_PROGRESS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PAYLOAD) type: ExternalType void asPointerType! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PAYLOAD put: anObject getHandle.! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_push_negotiation	"This method was automatically generated"	^LGitPushNegotiationCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PUSH_NEGOTIATION) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_push_negotiation: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PUSH_NEGOTIATION		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_push_transfer_progress	"This method was automatically generated"	^LGitPushTransferProgressCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PUSH_TRANSFER_PROGRESS) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_push_transfer_progress: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PUSH_TRANSFER_PROGRESS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_push_update_reference	"This method was automatically generated"	^LGitPushUpdateReferenceCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PUSH_UPDATE_REFERENCE) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_push_update_reference: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PUSH_UPDATE_REFERENCE		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_sideband_progress	"This method was automatically generated"	^LGitTransportMessageCallback forAddress: ((handle pointerAt: OFFSET_PRIM_SIDEBAND_PROGRESS) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_sideband_progress: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_SIDEBAND_PROGRESS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_transfer_progress	"This method was automatically generated"	^LGitTransferProgressCallback forAddress: ((handle pointerAt: OFFSET_PRIM_TRANSFER_PROGRESS) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_transfer_progress: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_TRANSFER_PROGRESS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_transport	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_TRANSPORT) type: ExternalType void asPointerType! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_transport: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_TRANSPORT put: anObject getHandle.! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_update_tips	"This method was automatically generated"	^LGitUpdateTipsCallback forAddress: ((handle pointerAt: OFFSET_PRIM_UPDATE_TIPS) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_update_tips: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_UPDATE_TIPS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version	"This method was automatically generated"	^LGitStructVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitRemoteCallbacks methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_init_callbacks: opts version: version 	^ self		call: #(LGitReturnCodeEnum git_remote_init_callbacks(LGitRemoteCallbacks * self, LGitStructVersionsEnum version))		options: #(  )! !!LGitStructWithDefaults class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!defaults	^ self externalNew		initializeWithDefaults;		yourself! !!LGitStructWithDefaults methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!initialize	super initialize.		"Options are only ever used during a single setup function call.	The contents of the struct are then copied to a libgit2 internal	struct."	self autoRelease! !!LGitStructWithDefaults methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!initializeWithDefaults	self subclassResponsibility! !!LGitTime class methodsFor: 'fields description' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(	int64 time;	int offset;	)! !!LGitTime class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!fromDateAndTime: aDateAndTime	^ self new 		time: aDateAndTime asUnixTime;		offset: aDateAndTime offset asMinutes asInteger;		yourself! !!LGitTime methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!= anObject	^ self == anObject		or: [ self class == anObject class			and: [ self time = anObject time				and: [  self offset = anObject offset ] ] ]! !!LGitTime methodsFor: 'converting' stamp: ' 7/21/2017 17:44:56'!asDateAndTime	^ (DateAndTime fromUnixTime: self time) 		offset: self offset;		yourself! !!LGitTime methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!hash	^ (super hash bitXor: self time) bitXor: self offset! !!LGitTime methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!objectPrintOn: aStream	self asDateAndTime printOn: aStream! !!LGitTime methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!offset	^ self prim_offset! !!LGitTime methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!offset: anInteger	self prim_offset: anInteger! !!LGitTime methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_offset	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_OFFSET! !!LGitTime methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_offset: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_OFFSET put: anObject! !!LGitTime methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_time	"This method was automatically generated"	^handle signedLongLongAt: OFFSET_PRIM_TIME! !!LGitTime methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_time: anObject	"This method was automatically generated"	handle signedLongLongAt: OFFSET_PRIM_TIME put: anObject! !!LGitTime methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!time	^ self prim_time! !!LGitTime methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!time: anInteger	^ self prim_time: anInteger! !!LGitTransferProgress class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fieldsDesc	^#(	uint total_objects;	uint indexed_objects;	uint received_objects;	uint local_objects;	uint total_deltas;	uint indexed_deltas;	size_t received_bytes;	)! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_indexed_deltas	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_INDEXED_DELTAS! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_indexed_deltas: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_INDEXED_DELTAS put: anObject! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_indexed_objects	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_INDEXED_OBJECTS! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_indexed_objects: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_INDEXED_OBJECTS put: anObject! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_local_objects	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_LOCAL_OBJECTS! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_local_objects: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_LOCAL_OBJECTS put: anObject! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_received_bytes	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_RECEIVED_BYTES! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_received_bytes: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_RECEIVED_BYTES put: anObject! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_received_objects	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_RECEIVED_OBJECTS! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_received_objects: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_RECEIVED_OBJECTS put: anObject! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_total_deltas	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_TOTAL_DELTAS! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_total_deltas: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_TOTAL_DELTAS put: anObject! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_total_objects	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_TOTAL_OBJECTS! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/21/2017 17:44:56'!prim_total_objects: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_TOTAL_OBJECTS put: anObject! !!LGitSafeFFICalloutAPI methodsFor: 'action' stamp: ' 7/21/2017 17:44:56'!newBuilder	^ LGitSafeFFICalloutMethodBuilder calloutAPI: self! !!String methodsFor: '*libgit-core' stamp: ' 7/21/2017 17:44:56'!asLGitExternalString	| data |	data := ExternalData		fromHandle: (ExternalAddress allocate: self size + 1)		type: ExternalType char asPointerType.	LibC memCopy: self to: data size: self size.	data getHandle byteAt: self size + 1 put: 0.	^ data! !!LGitCredentialsFreeCallout methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!credentials: credentials	^ self		call: #(void #(LGitCredentials * credentials))		options: #(optMayGC)! !!LGitWritepackAppendCallout methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!writepack: writepack buffer: buffer length: length progress: progress		^ self		call:			#(int #(LGitOdbWritepack * writepack , void * buffer , int length , LGitTransferProgress * progress))		options: #(optMayGC)! !!LGitWritepackCommitCallout methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!writepack: writepack progress: progress	^ self		call: #(int #(LGitOdbWritepack *writepack , LGitTransferProgress *progress))		options: #(optMayGC)! !!LGitWritepackFreeCallout methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!writepack: writepack	^ self call: #(void #(LGitOdbWritepack *writepack)) options: #()! !!LGitExternalObject class methodsFor: 'finalization' stamp: ' 7/21/2017 17:44:56'!finalizeResourceData: aHandle	"Call the class specific free frunction if aHandle is still a valid external address."	aHandle isNull ifTrue: [ ^self ].	self perform: self freeFunctionSelector with: aHandle.	aHandle beNull! !!LGitExternalObject class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #object_free:! !!LGitExternalObject class methodsFor: 'as yet unclassified' stamp: ' 7/21/2017 17:44:56'!fromHandle: aHandle	^self basicNew setHandle: aHandle! !!LGitExternalObject class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!object_free: handle 	"We pass a handle in here instead of the object. We can't pass the object since that	has already been gc'ed."	^self call: #(void git_object_free(void *handle)) options: #(  )! !!LGitExternalObject methodsFor: 'initialize-release' stamp: ' 7/21/2017 17:44:56'!free	handle isExternalAddress 		ifTrue: [ 			self class finalizeResourceData: handle.			self assert: handle isNull ]! !!LGitExternalObject methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isReady	^ self isNull not! !!LGitExternalObject methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!shouldContinuePrintingOn: aStream	self ifNotReady: [ aStream nextPutAll: ' (<not initialized>)' ].		^ self isReady! !!LGitOdb class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #odb_free:! !!LGitOdb class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!odb_free: handle		^ self call: #(void git_odb_free #(void *handle)) options: #()! !!LGitPackBuilder class methodsFor: 'native-boost' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #packbuilder_free:! !!LGitPackBuilder class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!packbuilder_free: handle		^ self		call: #(void git_packbuilder_free #(void *handle))		options: #()! !!LGitPackBuilder methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!packbuilder_foreach: pb cb: cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_packbuilder_foreach #(self , LGitPackbuilderForeachCallback cb ,  void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitPackBuilder methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!packbuilder_insert_commit: pb id: id		^ self		call:			#(LGitReturnCodeEnum git_packbuilder_insert_commit #(self , LGitId * id))		options: #(optMayGC)! !!LGitPackBuilder methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!packbuilder_insert_tree: pb id: id		^ self		call: #(LGitReturnCodeEnum git_packbuilder_insert_tree #(self , LGitId * id))		options: #(optMayGC)! !!LGitPackBuilder methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!packbuilder_new: out repo: repo		^ self		callUnchecked:			#(LGitReturnCodeEnum git_packbuilder_new #(LGitPackBuilder * self , LGitRepository repo))		options: #()! !!LGitRepository class methodsFor: 'native-boost' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #repository_free:! !!LGitRepository class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!new	self error: 'This class should be instantiated with a give path.'! !!LGitRepository class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!on: aFileReference	LGitGlobal checkInitialized.	^ self basicNew		initialize;		initializeOn: aFileReference! !!LGitRepository class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_free: handle		^ self call: #(void git_repository_free #(void *handle)) options: #()! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!addRemote: aName url: anUrl	(LGitRemote of: self named: aName url: anUrl) createWithoutSpec! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!allBranches	^ OrderedCollection new: 10 streamContents: [ :stream |		self allBranchesDo: [ :reference | 			stream nextPut: reference ] ]! !!LGitRepository methodsFor: 'enumerating' stamp: ' 7/21/2017 17:44:56'!allBranchesDo: aBlock	LGitBranchIterator allBranchesOf: self do: aBlock! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!allRemotes	| out |		out := LGitStringArray externalNew autoRelease.	self remote_list: out.	^ out strings collect: [ :each | (LGitRemote of: self named: each) lookup ]! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!beOpen	isOpen := true! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!branchNames	^ self branches collect: #name! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!branch_lookup: out branch_name: branch_name branch_type: branch_type		^ self		call:			#(LGitReturnCodeEnum git_branch_lookup #(LGitReference * out , self , String branch_name , LGitBranchTypeEnum branch_type))		options: #()! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!branches	^ OrderedCollection new: 10 streamContents: [ :stream |		self branchesDo: [ :reference | stream nextPut: reference ] ]! !!LGitRepository methodsFor: 'enumerating' stamp: ' 7/21/2017 17:44:56'!branchesDo: aBlock	LGitBranchIterator localBranchesOf: self do: aBlock.! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!checkout: aString	<todo: 'use proper exceptions'>	self assert: aString notNil.	self assert: aString trimBoth notEmpty.	[ 		| branch |		branch := self lookupLocalBranch: aString ifAbsent: [ self createBranchFromOrigin: aString ].		self checkout_treeish: branch object.		self setHead: branch.	] 	on: LGit_GIT_EINVALIDSPEC, LGit_GIT_ENOTFOUND do: [		"aString is not a valid branch name, so try to find a corresponding treeish using revparse, 		this will handle stuff like 'master~1'"		| commitish | 		commitish := self revparse: aString.		self checkout_treeish: commitish.		self setHeadDetached: commitish.	].! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!checkoutHead	self withReturnHandlerDo: [ 		self checkout_head_opts: (			LGitCheckoutOptions defaults				checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_safe;				yourself) ]! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!checkout_head_opts: opts	^ self		call:			#(LGitReturnCodeEnum git_checkout_head #(self , LGitCheckoutOptions * opts))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!checkout_treeish: treeish	"treeish can be a commit, tag or tree (or NULL to use HEAD)"	self withReturnHandlerDo: [ 		self			checkout_treeish: treeish			opts:				(LGitCheckoutOptions defaults					checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_safe;					yourself) ].! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!checkout_treeish: treeish opts: opts	^ self		call:			#(LGitReturnCodeEnum git_checkout_tree #(self , LGitObject treeish , LGitCheckoutOptions * opts))		options: #()! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!clone: aString	| cloneOptions |	cloneOptions := LGitCloneOptions defaults.	self		clone: aString		options: cloneOptions	! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!clone: aString options: cloneOptions	self		clone: aString		options: cloneOptions		to: self repositoryReference! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!clone: aString options: cloneOptions to: aFileReference	<todo: 'use exceptions instead of assertion'>	self assert: aString isEmptyOrNil not.	self assert: aFileReference notNil.	self assert: cloneOptions notNil.		aFileReference ensureCreateDirectory.		self withReturnHandlerDo: [ 		self 			clone: self			url: aString			local_path: aFileReference pathString			options: cloneOptions ]! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!clone: out url: url local_path: local_path options: options		^ self		callUnchecked:			#(LGitReturnCodeEnum git_clone (LGitRepository *out, String url, String local_path, LGitCloneOptions *options))		options: #(optCoerceNilToNull)! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!clone: aString withCredentials: aCredentialsProvider 	| cloneOptions |	cloneOptions := LGitCloneOptions withCredentialsProvider: aCredentialsProvider.	self		clone: aString		options: cloneOptions	! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!cloneHttps: aString	<todo: 'use exceptions instead of assertion'>	self assert: (aString beginsWith: 'https://').		self clone: aString! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!cloneLocal: aString	self clone: aString! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!cloneRemote: aRemote signature: aSignature	self		cloneRemote: aRemote		signature: aSignature		branch: 'master'! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!cloneRemote: aRemote signature: aSignature branch: aString	self		cloneRemote: aRemote		signature: aSignature		branch: aString		checkoutOptions: LGitCheckoutOptions defaults! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!cloneRemote: aRemote  signature: aSignature branch: aString checkoutOptions: options	<todo: 'use exceptions instead of assertions'>	self assert: aRemote hasFetchSpec.		self withReturnHandlerDo: [		self 			clone_into: self			remote: aRemote			co_opts: options			branch: aString			signature: aSignature ]! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!cloneSsh: aString	| credentials cloneOptions |	credentials := LGitRemote credentialsSsh.	cloneOptions := LGitCloneOptions withCredentialsCallback: 		[ :cred :url :username_from_url :allowed_types :data | 			allowed_types = 32 				ifTrue: [ credentials setGitUsernameIn: cred ]				ifFalse: [ credentials createWith: cred ].			0 		].		self		clone: aString		options: cloneOptions	! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!config	| config |	config := (LGitConfig of: self) autoRelease.	self withReturnHandlerDo: [ self repository_config: config ].	^ config! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!create	self exists ifTrue: [ ^ self ].		self repositoryReference ensureCreateDirectory! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createBranch: aString force: aBoolean	<todo: 'this method belongs somewhere else and should allow to specify the target'>	| reference |	reference := LGitReference of: self.	reference createSymbolic: 'refs/heads/' , aString target: 'refs/dummy' force: aBoolean.	^ reference! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createBranch: aString target: aGitReference	<todo: 'this method belongs somewhere else'>	^ self createBranch: aString target: aGitReference force: false! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createBranch: aString target: aGitReference force: aBoolean	<todo: 'this method belongs somewhere else'>	| reference |	reference := LGitReference of: self.	reference 		createDirect: 'refs/heads/' , aString 		target: aGitReference object id 		force: aBoolean.	^ reference! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createBranch: aString targetId: aGitId force: aBoolean	<todo: 'this method belongs somewhere else'>	| reference |	reference := LGitReference of: self.	reference createDirect: 'refs/heads/' , aString target: aGitId force: aBoolean.	^ reference! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createBranchFromOrigin: branchName	| remoteBranchName remoteBranch localBranch |	remoteBranchName := 'origin/', branchName.	remoteBranch := self lookupRemoteBranch: remoteBranchName.	localBranch := self createBranch: branchName target: remoteBranch.	localBranch setUpstream: remoteBranchName.	^ localBranch! !!LGitRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!createPackForReference: aReference	| odb walk packbuilder writepack stats packbuilderPayload progresscb packbuilderCallback |	odb := self database.	walk := (LGitRevwalk of: self)		beSortedByCommitTime;		pushReference: aReference;		yourself.	packbuilder := LGitPackBuilder new.	packbuilder packbuilder_new: packbuilder repo: self.	"hideCallback := LG2RevwalkHideCb on: [ :oid :payload |  ].	LG2RevwalkH uniqueInstance		revwalk_add_hide_cb: walk		hide_cb: hideCallback		payload: nil."	[ walk hasNext ] whileTrue: [ 		| commit tree |		commit := walk next.		tree := commit tree.		packbuilder			packbuilder_insert_commit: packbuilder id: commit id;			packbuilder_insert_tree: packbuilder id: tree id.		commit free.		tree free ].	progresscb := LGitTransferProgressCallback on: [ :progress :data | 0 ].	writepack := LGitOdbWritepack externalNew.	writepack		odb_write_pack: writepack		db: odb		progress_cb: progresscb		progress_payload: ExternalAddress null.	writepack := LGitOdbWritepack fromHandle: writepack getHandle pointer.	stats := LGitTransferProgress externalNew.	packbuilderPayload := LGitPackbuilderForeachPayload externalNew.	packbuilderCallback := LGitPackbuilderForeachCallback		on: [ :buffer :length :payload | payload writepack appendWithBuffer: buffer length: length progress: payload stats ].	packbuilderPayload		writepack: writepack;		stats: stats.	packbuilder packbuilder_foreach: packbuilder cb: packbuilderCallback payload: packbuilderPayload.	writepack commitWithProgress: stats! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createTag: aString targetId: aGitId force: aBoolean	"Create a tag. Based on #createBranch:targetId:force:"	| reference |	reference := LGitReference of: self.	reference		createDirect: 'refs/tags/', aString		target: aGitId		force: aBoolean.	^ reference! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!database	| database |	database := LGitOdb new.	self withReturnHandlerDo: [		self			repository_odb: database			repo: self ].			^ database! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!defaultSignature	| signaturePointer |	signaturePointer := ExternalAddress new.	self withReturnHandlerDo: [ self signature_default: signaturePointer repo: self ].	^ LGitSignature fromHandle: signaturePointer! !!LGitRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!deleteAllLooseObjectsForReference: aReference	(self repositoryReference / '.git' / 'objects') children		select: [ :entry | entry basename ~= 'pack' ]		thenDo: [ :entry | entry deleteAll ].		"raise an exception if not resolvable"	self head	"	| walker oid baseReference |	walker := LGitRevwalkType new.	LG2RevwalkH uniqueInstance		revwalk_new: walker		repo: self.	LG2RevwalkH uniqueInstance		revwalk_sorting: walker		sort_mode: 2.	LG2RevwalkH uniqueInstance		revwalk_push_ref: walker		refname: aReference name.	baseReference := aReference repository repositoryReference / '.git' / 'objects'.	oid := LGitId new.	[ (LG2RevwalkH uniqueInstance		revwalk_next: oid		walk: walker) isZero ] whileTrue: [			| fileReference |			fileReference := baseReference resolve: oid asRelativePathString.			fileReference delete.			fileReference parent hasChildren ifFalse: [ fileReference parent delete ] ]"! !!LGitRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!exists	^ self repositoryReference exists! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!fastForward	<todo: 'check for conflicts'>	"currently forces fastForward in every case"	self head resolve setTarget: (self lookup: 'FETCH_HEAD')! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!fetchFrom: remoteName 	(LGitRemote of: self named: remoteName) 		lookup; 		fetch! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!head	| head |	head := LGitReference of: self.	self withReturnHandlerDo: [ self repository_head: head of: self ].	^ head! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!index	| index |	index := LGitIndex of: self.	self withReturnHandlerDo: [ self repository_index: index repo: self ].	^ index! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!init	self initBare: false! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!initBare: aBoolean	self withReturnHandlerDo: [		self			repository_init: self			path: self repositoryReference pathString			is_bare: aBoolean ].	self autoRelease ! !!LGitRepository methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!initializeOn: aFileReference	repositoryPath := aFileReference! !!LGitRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isBare	^ self repository_is_bare: self! !!LGitRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isDirty: aFileReference	^ self index isDirty: aFileReference! !!LGitRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isEmpty	self exists ifFalse: [ ^ true ].		^ self repository_is_empty: self! !!LGitRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isInitialized	^ self isReady! !!LGitRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isOpen	^ isOpen ifNil: [ false ]! !!LGitRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isProperRepository	| return |	return := self		repository_open_ext: self		path: self repositoryReference pathString		flags: LGitOpenFlagEnum git_repository_open_no_search		ceiling_dirs: nil.			^ return isOk! !!LGitRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isUnborn	^ self repository_is_unborn: self! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/21/2017 17:44:56'!lookup: name	| reference |	reference := LGitReference of: self.	self withReturnHandlerDo: [		self			reference_lookup: reference			repo: self			shorthand: name ].			^ reference! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/21/2017 17:44:56'!lookupBranch: name	^ (name includes: $/)		ifTrue: [ self lookupRemoteBranch: (name withoutPrefix: 'refs/remotes/') ]		ifFalse: [ self lookupLocalBranch: name ] ! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/21/2017 17:44:56'!lookupBranch: branchName inRemote: remoteName	^ self lookupRemoteBranch: remoteName, '/', branchName! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/21/2017 17:44:56'!lookupBranch: name type: branchType	| reference |	reference := LGitReference of: self.	self withReturnHandlerDo: [ 		self			branch_lookup: reference			branch_name: name			branch_type: branchType	].	^ reference! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/21/2017 17:44:56'!lookupLocalBranch: name	^ self lookupBranch: name type: LGitBranchTypeEnum git_branch_local ! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/21/2017 17:44:56'!lookupLocalBranch: name ifAbsent: aBlock	^ [ self lookupLocalBranch: name ]		on: LGit_GIT_ENOTFOUND 		do: aBlock ! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/21/2017 17:44:56'!lookupRemoteBranch: name	^ self lookupBranch: name type: LGitBranchTypeEnum git_branch_remote! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!merge: aLGitAnnotatedCommit 	| heads |	heads := (FFIExternalArray externalNewType: LGitAnnotatedCommit size: 1) autoRelease;		at: 1 put: aLGitAnnotatedCommit handle;		yourself.	self withReturnHandlerDo: [		self merge_heads: heads 			length: 1 			merge_options: LGitMergeOptions defaults			checkout_options: LGitCheckoutOptions defaults 	]! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!mergeBaseBetween: aLGitId and: aLGitId2 	| base |	base := LGitId new.	self withReturnHandlerDo: [ self merge_base: base between: aLGitId and: aLGitId2 ].	^ base! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!merge_base: out between: one and: two	^ self call: #(	LGitReturnCodeEnum git_merge_base #(			LGitId * out, 			self, 			LGitId * one, 			LGitId * two))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!merge_heads: heads length: length merge_options: mergeOptions checkout_options: checkoutOptions		^ self		callUnchecked:			#(LGitReturnCodeEnum git_merge #(				self , 				FFIExternalArray heads ,				int length , 				LGitMergeOptions * mergeOptions ,				LGitCheckoutOptions * checkoutOptions))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!new_signature: out name:name email:email time:time		^ self		call:			#(LGitReturnCodeEnum git_signature_new #(void **out , String name, String email, LGitTime time, 0))		options: #()! !!LGitRepository methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!objectPrintOn: aStream	aStream nextPutAll: self repositoryReference fullName.	self isBare 		ifTrue: [ aStream nextPutAll: ' [bare]' ]! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!open	self withReturnHandlerDo: [ 		self			repository_open: self			bare_path: self repositoryReference pathString ].	self beOpen! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!origin	^ (LGitRemote of: self named: 'origin') lookup; yourself! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!packHead	<todo: 'This method is distructive. It will delete *all* objects, including those not in the pack (not reachable from head'>	"USE VERY CAREFULLY"		LGitGlobal runSequence: [ self createPackForReference: self head ].	self deleteAllLooseObjectsForReference: self head! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_lookup: out repo: repo shorthand: shorthand		^ self		call:			#(LGitReturnCodeEnum git_reference_lookup #(LGitReference * out , self , String shorthand))		options: #()! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!references	self notYetImplemented! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_list: out	^ self 		call: #( int git_remote_list ( LGitStringArray *out, self ) ) 		options: #()! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!repositoryReference	^ repositoryPath! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_config: config	^ self		call:			#(LGitReturnCodeEnum git_repository_config(LGitConfig *config, self))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_head: reference of: repository		^ self		call:			#(LGitReturnCodeEnum git_repository_head #(LGitReference * reference , self))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_index: out repo: repo		^ self		call: #(LGitReturnCodeEnum git_repository_index #(LGitIndex * out , self))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_init: out path: path is_bare: is_bare		^ self		callUnchecked:			#(int git_repository_init #(LGitRepository * out , String path , Boolean is_bare))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_is_bare: repo		^ self call: #(Boolean git_repository_is_bare #(self)) options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_is_empty: repo		^ self call: #(Boolean git_repository_is_empty #(self)) options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_is_unborn: repo	^ self call: #( Boolean git_repository_head_unborn (self) ) options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_odb: out repo: repo		^ self		call: #(LGitReturnCodeEnum git_repository_odb #(LGitOdb * out , self))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_open: out bare_path: bare_path		^ self		callUnchecked:			#(LGitReturnCodeEnum git_repository_open #(LGitRepository * out , String bare_path))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_open_ext: out path: path flags: flags ceiling_dirs: ceiling_dirs		^ self		callUnchecked:			#(LGitReturnCodeEnum git_repository_open_ext #(LGitRepository * out , String path , LGitOpenFlagEnum flags , String ceiling_dirs))		options: #(optCoerceNilToNull optStringOrNull)! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_set_head: refname log_message: log_message		^ self		call:			#(int git_repository_set_head #(self , String refname , String log_message))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_set_head_detached: commitish		^ self		call:			#(int git_repository_set_head_detached #(self, LGitId * commitish))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!repository_workdir: repo		^ self call: #(String git_repository_workdir #(self)) options: #()! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!revparse: aString	"See git-rev-parse documentation.	Examples:		repository revparse: 'HEAD' 	# last commit		repository revparse: 'HEAD~5'	# 5 commits back from last commit		repository revparse: 'develop'	# last commit from develop branch	"	| object |	self assert: aString notNil.	self assert: aString trimBoth notEmpty.	object := LGitObject of: self.	self withReturnHandlerDo: [ 		self			revparse_single: object			repo: self			spec: aString ].	^ object concreteObject	! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!revparse_single: out repo: repo spec: spec		^ self		call:			#(LGitReturnCodeEnum git_revparse_single #(LGitObject * out , self , String spec))		options: #()! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!setHead: aLGitReference	self withReturnHandlerDo: [ 		self			repository_set_head: aLGitReference name			log_message: 'set head to refs/heads/' , aLGitReference name ]! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!setHeadDetached: commitish	self withReturnHandlerDo: [ 		self repository_set_head_detached: commitish id	]! !!LGitRepository methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!signatureWithName: name email: email dateTime: dateTime	| signaturePointer time |	signaturePointer := ExternalAddress new.	time := LGitTime fromDateAndTime: dateTime.	self		withReturnHandlerDo: [ self				new_signature: signaturePointer				name: name				email: email				time: time ].	^ LGitSignature fromHandle: signaturePointer! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!signature_default: out repo: repo		^ self		call:			#(LGitReturnCodeEnum git_signature_default #(void **out , self))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tag_list: tag_names repo: repo		^ self		call:			#(LGitReturnCodeEnum git_tag_list #(LGitStringArray * tag_names , LGitRepository repo))		options: #()! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!tags	| array strings |	array := LGitStringArray externalNew.	self withReturnHandlerDo: [		self			tag_list: array			repo: self ].	strings := array strings.	array free.	^ strings	! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!workingDirectory	^ workingDirectory ifNil: [			workingDirectory := self withReturnHandlerDo: [				(self repository_workdir: self) asFileReference ] ]! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!workingDirectoryName	^ self isBare			ifTrue: [ nil ]			ifFalse: [ self workingDirectory basename ]! !!LGitAnnotatedCommit class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!annotated_commit_free: handle	^ self		call: #(void git_annotated_commit_free #(void *handle))		options: #()! !!LGitAnnotatedCommit class methodsFor: 'ligbit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #annotated_commit_free:! !!LGitAnnotatedCommit class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!fromRef: anLGitReference	^ (self of: anLGitReference repository) initializeFromRef: anLGitReference ! !!LGitAnnotatedCommit methodsFor: 'initialize' stamp: ' 7/21/2017 17:44:56'!annotated_commit_from_ref: ref	^ self callUnchecked: #(		int git_annotated_commit_from_ref #(			LGitAnnotatedCommit * self , 			LGitRepository repository ,			LGitReference ref)) 		options: #()! !!LGitAnnotatedCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!annotated_commit_id	 ^ self call: #(LGitId * git_annotated_commit_id #(self)) options: #()! !!LGitAnnotatedCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!id	^ self annotated_commit_id! !!LGitAnnotatedCommit methodsFor: 'initialize' stamp: ' 7/21/2017 17:44:56'!initializeFromRef: anLGitReference	self withReturnHandlerDo: [ 		self annotated_commit_from_ref: anLGitReference	].	self autoRelease! !!LGitBlame class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blame_free: handle	^ self call: #(void git_blame_free #(void *handle)) options: #()! !!LGitBlame class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #blame_free:! !!LGitBlame class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: aRepository on: aFileReference	^ (self of: aRepository)		getForReference: aFileReference;		yourself! !!LGitBlame methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blame_buffer: out reference: reference buffer: buffer buffer_len: buffer_len		^ self		callUnchecked:			#(FFIInt32 git_blame_buffer #(LGitBlame *self , LGitBlame reference , String buffer , size_t buffer_len))		options: #()! !!LGitBlame methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blame_file: out repo: repo path: path options: options		^ self		callUnchecked:			#(int git_blame_file #(LGitBlame * self , LGitRepository repo , String path , LGitBlameOptions * options))		options: #()! !!LGitBlame methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blame_get_hunk_byindex: blame index: index	"todo: using LGitBlameHunk* as return value causes random crashes"		^ self		call: #(void * git_blame_get_hunk_byindex #(self , uint32 index))		options: #()! !!LGitBlame methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blame_get_hunk_byline: blame lineno: lineno	"todo: using LGitBlameHunk* as return value causes random crashes"		^ self		call: #(void * git_blame_get_hunk_byline #(self , size_t lineno))		options: #()! !!LGitBlame methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blame_get_hunk_count: blame		^ self		call: #(uint32 git_blame_get_hunk_count #(self))		options: #()! !!LGitBlame methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!getForReference: aFileReference	^ self withReturnHandlerDo: [		self			blame_file: self			repo: self repository			path: ((aFileReference relativeTo: self repository repositoryReference) printWithDelimiter: $/)			options: LGitBlameOptions defaults ]! !!LGitBlame methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!hunkAt: anInteger	"use 1 based offset"	^ LGitBlameHunk fromExternalAddress: (		self			blame_get_hunk_byindex: self			index: anInteger - 1)! !!LGitBlame methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!hunkAtLineNumber: anInteger	"first line has index 1"	^ LGitBlameHunk fromExternalAddress: (		self			blame_get_hunk_byline: self			lineno: anInteger)! !!LGitBlame methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!numberOfHunks	^ self blame_get_hunk_count: self! !!LGitBranchIterator class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!allBranchesOf: repository do: aBlock	self 		of: repository 		branchType: LGitBranchTypeEnum git_branch_all		do: aBlock! !!LGitBranchIterator class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!branch_iterator_free: handle		^ self		call: #(void git_branch_iterator_free #(void *handle))		options: #()! !!LGitBranchIterator class methodsFor: 'native-boost' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #branch_iterator_free:! !!LGitBranchIterator class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!localBranchesOf: repository do: aBlock	self 		of: repository 		branchType: LGitBranchTypeEnum git_branch_local		do: aBlock! !!LGitBranchIterator class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: aRepository branchType: aLGitBranchTypeEnum do: aBlock	^ (self of: aRepository)		iterate: aLGitBranchTypeEnum;		branchesDo: aBlock! !!LGitBranchIterator class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!remoteBranchesOf: repository do: aBlock	self 		of: repository 		branchType: LGitBranchTypeEnum git_branch_remote		do: aBlock! !!LGitBranchIterator methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!branch_iterator_new: out repo: repo list_flags: list_flags		^ self		callUnchecked:			#(LGitReturnCodeEnum git_branch_iterator_new #(LGitBranchIterator * self , LGitRepository repo , LGitBranchTypeEnum list_flags))		options: #()! !!LGitBranchIterator methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!branch_next: out out_type: out_type	^ self		call:			#(LGitReturnCodeEnum git_branch_next #(				LGitReference * out ,				LGitWriteBackValueUInt * out_type,				LGitBranchIterator self))		options: #()! !!LGitBranchIterator methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!branchesDo: aBlock	| returnCode branchType reference finishedCode isLocal |		returnCode := LGitReturnCodeEnum git_ok.	finishedCode := LGitReturnCodeEnum git_iterover.	branchType := LGitWriteBackValueUInt new.		[ 		reference := LGitReference of: self repository.		returnCode := self branch_next: reference out_type: branchType.		isLocal := branchType value = LGitBranchTypeEnum git_branch_local value.		returnCode = finishedCode 	] 	whileFalse: [ aBlock cull: reference cull: isLocal ]! !!LGitBranchIterator methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!iterate: aLGitBranchTypeEnum	self repository signalIfNotReady.	self withReturnHandlerDo: [		self			branch_iterator_new: self			repo: self repository			list_flags: aLGitBranchTypeEnum ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!author	^ author ifNil: [		author := self repository defaultSignature ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!author: anLGitSignature	author := anLGitSignature! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!commitId	^ commitId ifNil: [ commitId := LGitId new ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!commitId: anLGitId	commitId := anLGitId! !!LGitCommitBuilder methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_create: theCommitId repo: repo update_ref: update_ref author: theAuthor committer: theCommitter message_encoding: message_encoding message: theMessage tree: theTree parent_count: parent_count parents: parentsPointer		<todo:		'try to use original function signature instead of passing ExternalAddress as last arg'>	^ self		callUnchecked:			#(LGitReturnCodeEnum git_commit_create #(LGitId * theCommitId , LGitRepository repo , String update_ref , LGitSignature * theAuthor , LGitSignature * theCommitter , String message_encoding , String theMessage , LGitTree theTree , int parent_count , void *parentsPointer))		options: #(optCoerceNilToNull)! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!committer	^ committer ifNil: [ 		committer := self repository defaultSignature ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!committer: anLGitSignature	committer := anLGitSignature! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!message	^ message ifNil: [ message := 'empty message' ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!message: aString	message := aString! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!messageEncoding	^ messageEncoding ifNil: [ 'UTF-8' ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!messageEncoding: aString	messageEncoding := aString! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!parents	^ parents ifNil: [ parents := #() ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!parents: aCollection	parents := aCollection! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!tree	<todo: 'use proper exceptions'>	^ tree ifNil: [ self error: 'need an existing tree here' ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!tree: anLGitTree	tree := anLGitTree! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!updateReference	^ updateReference! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!updateReference: aReference	updateReference := aReference! !!LGitCommitBuilder methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!writeCommit	| parentsPointer |	self withReturnHandlerDo: [ 		self assert: (self parents allSatisfy: #isReady).		parentsPointer := self parents			ifEmpty: [ ExternalAddress null ]			ifNotEmpty: [ (LGitExternalCommitArray fromCollection: self parents) getHandle ].	self withReturnHandlerDo: [ 		self			commit_create: self commitId			"libgit2 asserts the identity of this repository and the one it retrieves for the tree, so they need to be the same here"			repo: self tree owner 			update_ref: self updateReference			author: self author			committer: self committer			message_encoding: self messageEncoding			message: self message withUnixLineEndings			tree: self tree			parent_count: self parents size			parents: parentsPointer] ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!writtenCommit	<todo: 'use proper exceptions'>	commitId ifNil: [ self error: 'haven''t written the commit yet!!' ].	^ LGitCommit of: self repository fromId: self commitId! !!LGitConfig class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!config_free: handle	^ self		call: #(void git_config_free #(void *handle))		options: #()! !!LGitConfig class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #config_free:! !!LGitConfig methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!config_get_string: name output: output	^ self call:			#(LGitReturnCodeEnum git_config_get_string_buf(				LGitBuf* output, 				self, 				String name))		options: #()! !!LGitConfig methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!config_open_global: out	^ self call: #(int git_config_open_global("LGitConfig **"void **out, self))! !!LGitConfig methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!config_set_bool: name to: value	^ self call:			#(LGitReturnCodeEnum git_config_set_bool(				self, 				String name, 				Boolean value))		options: #()! !!LGitConfig methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!config_set_string: name to: value	^ self call:			#(LGitReturnCodeEnum git_config_set_string(				self, 				String name, 				String value))		options: #()! !!LGitConfig methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!getString: name ifAbsent: aBlock	^ self getString: name ifPresent: #yourself ifAbsent: aBlock! !!LGitConfig methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!getString: name ifPresent: presentBlock ifAbsent: absentBlock	| buf |	buf := LGitBuf new.	^ [		self config_get_string: name output: buf.		buf prim_ptr readString 			ifNotEmpty: presentBlock			ifEmpty: absentBlock	]	ensure: [ buf free ]! !!LGitConfig methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!openGlobal	| outHandle |	outHandle := ExternalAddress null.	self config_open_global: outHandle.	^ (self class fromHandle: outHandle) autoRelease	! !!LGitConfig methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!setBoolean: aBoolean to: varName! !!LGitConfig methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!setString: name to: value	self config_set_string: name to: value! !!LGitDiff class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_free: handle		^ self call: #(void git_diff_free #(void *handle)) options: #()! !!LGitDiff class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #diff_free:! !!LGitDiff methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!deltaAt: anInteger	"use 1 based offset as in Smalltalk"	^ LGitDiffDelta fromHandle: (		self			diff_get_delta: self			idx: anInteger - 1) getHandle! !!LGitDiff methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!diffIndexToWorkDir	self diffIndexToWorkDirOptions: LGitDiffOptions defaults! !!LGitDiff methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!diffIndexToWorkDirOptions: anLGitDiffOptions	self withReturnHandlerDo: [		self			diff_index_to_workdir: self			repo: self repository			index: self repository index			opts: anLGitDiffOptions ]! !!LGitDiff methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!diffTree: oldTree toTree: newTree	self		diffTree: oldTree		toTree: newTree		options: LGitDiffOptions defaults! !!LGitDiff methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!diffTree: oldTree toTree: newTree options: anLGitDiffOptions	self withReturnHandlerDo: [		self			diff_tree_to_tree: self			repo: self repository			old_tree: oldTree			new_tree: newTree			opts: anLGitDiffOptions ]! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_blob_to_buffer: old_blob old_as_path: old_as_path buffer: buffer buffer_len: buffer_len buffer_as_path: buffer_as_path options: options file_cb: file_cb hunk_cb: hunk_cb line_cb: line_cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_diff_blob_to_buffer #(LGitBlob old_blob , String old_as_path , String buffer , size_t buffer_len , String buffer_as_path , LGitDiffOptions * options , LGitDiffFileCallback file_cb , LGitDiffHunkCallback hunk_cb , LGitDiffLineCallback line_cb , void * payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_blobs: old_blob old_as_path: old_as_path new_blob: new_blob new_as_path: new_as_path options: options file_cb: file_cb hunk_cb: hunk_cb line_cb: line_cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_diff_blobs (LGitBlob old_blob , String old_as_path , LGitBlob new_blob , String new_as_path , LGitDiffOptions *options , LGitDiffFileCallback file_cb , LGitDiffHunkCallback hunk_cb , LGitDiffLineCallback line_cb , void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_buffers: old_buffer old_len: old_len old_as_path: old_as_path new_buffer: new_buffer new_len: new_len new_as_path: new_as_path options: options file_cb: file_cb hunk_cb: hunk_cb line_cb: line_cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_diff_buffers #(FFIVoid * old_buffer , size_t old_len , String old_as_path , void *new_buffer , size_t new_len , String new_as_path , LGitDiffOptions * options , LGitDiffFileCallback file_cb , LGitDiffHunkCallback hunk_cb , LGitDiffLineCallback line_cb , void * payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_foreach: diff file_cb: file_cb binary_cb: binary_cb hunk_cb: hunk_cb line_cb: line_cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_diff_foreach #(self , LGitDiffFileCallback file_cb , LGitDiffBinaryCallback binary_cb , LGitDiffHunkCallback hunk_cb , LGitDiffLineCallback line_cb , void * payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_get_delta: diff idx: idx	<todo: 'use LGitDiffDelta* as return type'>		^ self		call: #(void *git_diff_get_delta #(self , size_t idx))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_get_perfdata: out diff: diff		^ self		call:			#(LGitReturnCodeEnum git_diff_get_perfdata #(LGitDiffPerfData * out , self))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_get_stats: out diff: diff		^ self		call: #(LGitReturnCodeEnum git_diff_get_stats #(LGitDiffStats * out , self))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_index_to_workdir: diff repo: repo index: index opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_diff_index_to_workdir #(LGitDiff * self , LGitRepository repo , LGitIndex index , LGitDiffOptions * opts))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_is_sorted_icase: diff		^ self call: #(Boolean git_diff_is_sorted_icase #(self)) options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_num_deltas: diff		^ self call: #(size_t git_diff_num_deltas #(self)) options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_num_deltas_of_type: diff type: type		^ self		call: #(size_t git_diff_num_deltas_of_type #(self , LGitDeltaTypeEnum type))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_print: diff format: format print_cb: print_cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_diff_print #(self , LGitDiffFormatTypeEnum format , LGitDiffLineCallback print_cb , void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_status_char: status		^ self		call: #(Character git_diff_status_char #(LGitDeltaTypeEnum status))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_tree_to_index: diff repo: repo old_tree: old_tree index: index opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_diff_tree_to_index #(LGitDiff * self , LGitRepository repo , LGitTree old_tree , LGitIndex index , LGitDiffOptions * opts))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_tree_to_tree: diff repo: repo old_tree: old_tree new_tree: new_tree opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_diff_tree_to_tree #(LGitDiff * diff , LGitRepository repo , LGitTree old_tree , LGitTree new_tree , LGitDiffOptions * opts))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_tree_to_workdir: diff repo: repo old_tree: old_tree opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_diff_tree_to_workdir #(LGitDiff * self , LGitRepository repo , LGitTree old_tree , LGitDiffOptions * opts))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_tree_to_workdir_with_index: diff repo: repo old_tree: old_tree opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_diff_tree_to_workdir_with_index #(LGitDiff * self , LGitRepository repo , LGitTree old_tree , LGitDiffOptions * opts))		options: #()! !!LGitDiff methodsFor: 'enumerating' stamp: ' 7/21/2017 17:44:56'!filesDo: filesBlockOrNil binaryFilesDo: binaryBlockOrNil hunksDo: hunksBlockOrNil linesDo: linesBlockOrNil	^ self		diff_foreach: self		file_cb: (filesBlockOrNil 			ifNotNil: [ LGitDiffFileCallback on: filesBlockOrNil ]			ifNil: [ LGitCallback null ])		binary_cb: (binaryBlockOrNil 			ifNotNil: [ 	LGitDiffBinaryCallback on: binaryBlockOrNil ]			ifNil: [ LGitCallback null ])		hunk_cb: (hunksBlockOrNil 			ifNotNil: [ 	LGitDiffHunkCallback on: hunksBlockOrNil ]			ifNil: [ LGitCallback null ])		line_cb: (linesBlockOrNil 			ifNotNil: [ 	LGitDiffLineCallback on: linesBlockOrNil ]			ifNil: [ LGitCallback null ])		payload: ExternalAddress null! !!LGitDiff methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!numberOfDeltas	^ self diff_num_deltas: self! !!LGitDiff methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!patchAt: anInteger	^ LGitPatch		fromDiff: self		at: anInteger! !!LGitDiffStats class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_stats_free: handle		^ self call: #(void git_diff_stats_free #(void *handle)) options: #()! !!LGitDiffStats class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #diff_stats_free:! !!LGitDiffStats methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_stats_deletions: stats		^ self		call: #(size_t git_diff_stats_deletions #(self))		options: #()! !!LGitDiffStats methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_stats_files_changed: stats		^ self		call: #(size_t git_diff_stats_files_changed #(self))		options: #()! !!LGitDiffStats methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_stats_insertions: stats		^ self		call: #(size_t git_diff_stats_insertions #(self))		options: #()! !!LGitDiffStats methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_stats_to_buf: out stats: stats format: format width: width		^ self		call:			#(LGitReturnCodeEnum git_diff_stats_to_buf #(LGitBuffer out , self , LGitDiffStatsFormatTypeEnum format , size_t width))		options: #()! !!LGitIndex class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #index_free:! !!LGitIndex class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!index_free: handle		^ self call: #(void git_index_free #(void *handle)) options: #()! !!LGitIndex methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!addAll	| pathspec |	pathspec := LGitStringArray withAll: #().	self withReturnHandlerDo: [ 		self			index_add_all: self			pathspec: pathspec			flags: 0			callback: (LGitIndexMatchedPathCallback on: [ :a :b :c | 0 ])			payload: ExternalAddress null ]! !!LGitIndex methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!addAll: pathSpecs	| pathspec |	pathspec := LGitStringArray withAll: pathSpecs.	self withReturnHandlerDo: [ 		self			index_add_all: self			pathspec: pathspec			flags: 0			callback: (LGitIndexMatchedPathCallback on: [ :a :b :c | 0 ])			payload: ExternalAddress null ]! !!LGitIndex methodsFor: 'enumerating' stamp: ' 7/21/2017 17:44:56'!allFilesStatusDo: aBlock	"The callback is passed the path of the file, the status (a combination of the git_status_t values above) and the payload data pointer passed into this function.If the callback returns a non-zero value, this function will stop looping and return that value to caller."	self withReturnHandlerDo: [ 		self			status_foreach: self repository			callback: (LGitStatusCallback on: aBlock)			payload: nil ]! !!LGitIndex methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!checkout	self withReturnHandlerDo: [ 		self checkout_index_withOptions: 			(LGitCheckoutOptions defaults				checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_force;				yourself) ]! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!checkout_index_withOptions: opts	^ self		call: #(LGitReturnCodeEnum 			git_checkout_index(				LGitRepository repository, 				self, 				LGitCheckoutOptions *opts))		options: #()! !!LGitIndex methodsFor: 'enumerating' stamp: ' 7/21/2017 17:44:56'!entriesSelect: aBlock	| entries |	entries := OrderedCollection new.	self allFilesStatusDo: [ :path :status :payload |		(aBlock value: path value: status) ifTrue: [ entries add: {path. status. payload} ].		0 ].		^ entries! !!LGitIndex methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!entryCount	^ self index_entrycount: self! !!LGitIndex methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!forceRefresh	self withReturnHandlerDo: [ 		self			index_read: self			force: true ]! !!LGitIndex methodsFor: 'hack' stamp: ' 7/21/2017 17:44:56'!hackOwner: aRepository	"There is a bug in version 0.23 of libgit2, the returned index does not have an 	 owner (a pointer to a repository), as you would expect from the documentation. 	This breaks libgit encapsulation, and will probably fail if updating to a newer 	version, but anyway if we migrate this bug should be fixed."	self flag: #fixMe. "When possible :)"	"	NOTE: is Smalltalk wordSize + 1 because the structure is something like: 	struct git_index {		git_refcount rc; 		...	}		then:		struct git_refcount { 		git_atomic refcount;		void *owner;	}		and finally: 	git_atomic = int -> 32bits	git_atomic = int64_t -> 64bits		So we need to ensure the owner is set properly.	"	self handle 		pointerAt: Smalltalk wordSize + 1		put: repository handle! !!LGitIndex methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!hasConflicts	^ self index_has_conflicts asBoolean! !!LGitIndex methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!hasEntry: aString	^ self withReturnHandlerDo: [ 		self			index_find: nil			index: self			path: aString ]! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!index_add_all: index pathspec: pathspec flags: flags callback: callback payload: payload		^ self		call:			#(LGitReturnCodeEnum git_index_add_all #(				self, 				LGitStringArray *pathspec, 				uint flags, 				LGitIndexMatchedPathCallback callback, 				void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!index_entrycount: index		^ self call: #(size_t git_index_entrycount #(self)) options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!index_find: at_pos index: index path: path		^ self		call:			#(LGitReturnCodeEnum git_index_find #(LGitWriteBackValueSizeT *at_pos , self, String path))		options: #(optCoerceNilToNull)! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!index_has_conflicts 	^ self call: #(LGitReturnCodeEnum git_index_has_conflicts #(self)) options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!index_owner	^ self call: #(LGitRepository * git_index_owner (LGitIndex self)) options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!index_path	^ self		call: #(String git_index_path #(self))		options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!index_read: index force: force		^ self		call: #(LGitReturnCodeEnum git_index_read #(self , Boolean force))		options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!index_remove_all: index pathspec: pathspec callback: callback payload: payload		^ self		call:			#(LGitReturnCodeEnum git_index_remove_all #(self, LGitStringArray * pathspec, LGitIndexMatchedPathCallback callback, void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!index_update_all: index pathspec: pathspec callback: callback payload: payload		^ self		call:			#(LGitReturnCodeEnum git_index_update_all #(self, LGitStringArray *pathspec, LGitIndexMatchedPathCallback callback, void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!index_write	^ self		call: #(LGitReturnCodeEnum git_index_write #(self))		options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!index_write_tree: out index: index		^ self		call: #(LGitReturnCodeEnum git_index_write_tree #(LGitId * out , self))		options: #()! !!LGitIndex methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isBeingTracked: aString	| intValue |	(self repository repositoryReference resolve: aString) isDirectory ifTrue: [ ^ true ].		intValue := LGitWriteBackValueUInt new.	self withReturnHandlerDo: [ 		self			status_file: intValue			repo: self repository			path: aString ].	^ (LGitStatusTypeEnum  git_status_wt_new isPartOfBitFlag: intValue value) not! !!LGitIndex methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isDirty: aFileReference	| intValue |	intValue := LGitWriteBackValueInt new.	self withReturnHandlerDo: [		self			status_file: intValue			repo: self repository			path: ((aFileReference relativeTo: self repository repositoryReference) printWithDelimiter: $/) ].			^ intValue value isZero not! !!LGitIndex methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!owner	^ self index_owner! !!LGitIndex methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!path	^ self index_path! !!LGitIndex methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!removeAll	| pathspec |	pathspec := LGitStringArray withAll: #().	self withReturnHandlerDo: [ 		self			index_remove_all: self			pathspec: pathspec			callback: (LGitIndexMatchedPathCallback on: [ :a :b :c | 0 ])			payload: nil ]! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!status_file: status_flags repo: repo path: path		^ self		call:			#(LGitReturnCodeEnum git_status_file #(LGitWriteBackValueUInt status_flags, LGitRepository repo, String path))		options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!status_foreach: repo callback: callback payload: payload		^ self		call:			#(LGitReturnCodeEnum git_status_foreach #(LGitRepository repo, LGitStatusCallback callback, void * payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitIndex methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!updateAll	| pathspec |	pathspec := LGitStringArray withAll: { '*' }.	self withReturnHandlerDo: [ 		self			index_update_all: self			pathspec: pathspec			callback: (LGitIndexMatchedPathCallback on: [ :a :b :c | 0 ])			payload: nil ]! !!LGitIndex methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!writeToDisk	self withReturnHandlerDo: [ self index_write ]! !!LGitIndex methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!writeTreeAndReturnOid	| oid |	oid := LGitId externalNew.	self withReturnHandlerDo: [ 		self			index_write_tree: oid			index: self ].			^ oid! !!LGitBlob class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blob_create_frombuffer: objectId repo: repo buffer: buffer len: len		^ self		call:			#(LGitReturnCodeEnum git_blob_create_frombuffer #(LGitId * objectId , LGitRepository repo , void  *buffer , size_t len))		options: #()! !!LGitBlob class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blob_create_fromdisk: objectId repo: repo path: path		^ self		call:			#(LGitReturnCodeEnum git_blob_create_fromdisk #(LGitId * objectId , LGitRepository repo , FFIExternalString path))		options: #()! !!LGitBlob class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blob_free: handle		^ self		call: 	#(void git_blob_free(void *handle))		options: #()! !!LGitBlob class methodsFor: 'accessing-defaults' stamp: ' 7/21/2017 17:44:56'!defaultFilemode	^ LGitFilemodeEnum git_filemode_blob! !!LGitBlob class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #blob_free:! !!LGitBlob class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isType: aType	^ aType = LGitObjectTypeEnum git_obj_blob! !!LGitBlob class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: aRepository fromExternalCollection: aCollection	| id |	self assert: (aCollection class = ByteArray or: [ aCollection class theMetaClass canUnderstand: #asExternalTypeOn: ]).	id := LGitId new.	self		blob_create_frombuffer: id		repo: aRepository		buffer: aCollection		len: aCollection size.	^ (self of: aRepository)		initializeWithId: id;		yourself! !!LGitBlob class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: aRepository fromFile: aFileReference	| id |	id := LGitId new.	self blob_create_fromdisk: id repo: aRepository path: aFileReference fullName.	^ (self of: aRepository)		initializeWithId: id;		yourself! !!LGitBlob class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: aRepository fromString: aString	^ self of: aRepository fromExternalCollection: aString! !!LGitBlob methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!= anObject	^ self == anObject or: [		self class == anObject class and: [			self isReady and: [				anObject isReady and: [					self id = anObject id ] ] ] ]! !!LGitBlob methodsFor: 'private-accessing' stamp: ' 7/21/2017 17:44:56'!binaryContents	| bytes |	"freeing not required. See #rawBuffer"	bytes := ByteArray new: self rawSize.	LibC memCopy: self rawBuffer to: bytes size: bytes size.	^bytes! !!LGitBlob methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blob_id: blob		^ self call: #(void * git_blob_id #(self)) options: #()! !!LGitBlob methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blob_is_binary: blob		^ self call: #(Boolean git_blob_is_binary #(self)) options: #()! !!LGitBlob methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blob_lookup: blob repo: repo id: objectId		^ self		callUnchecked:			#(LGitReturnCodeEnum git_blob_lookup #(LGitBlob * blob , LGitRepository repo , LGitId * objectId))		options: #()! !!LGitBlob methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blob_rawcontent: blob		^ self call: #(void * git_blob_rawcontent #(self)) options: #()! !!LGitBlob methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!blob_rawsize: blob		^ self call: #(int64 git_blob_rawsize #(self)) options: #()! !!LGitBlob methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!contents	^ self isBinary		ifTrue:  [ self binaryContents ]		ifFalse: [ self rawBuffer readStringUTF8 ]		! !!LGitBlob methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!get_id_data	^ self blob_id: self! !!LGitBlob methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!hash	^ self contents hash! !!LGitBlob methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isBinary	^ self blob_is_binary: self! !!LGitBlob methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isBlob	^ true! !!LGitBlob methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!lookup	self withReturnHandlerDo: [ self		blob_lookup: self 		repo: self repository		id: self id ].	self autoRelease! !!LGitBlob methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!names	| names |	names := OrderedCollection new.	self repository head object tree allEntriesDo: [ :rootPath :entry :payload |		entry repository: self repository.		entry object = self ifTrue: [ names add: entry filename ].		0 ].		^ names! !!LGitBlob methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!objectPrintOn: aStream	self id objectPrintOn: aStream! !!LGitBlob methodsFor: 'private-accessing' stamp: ' 7/21/2017 17:44:56'!rawBuffer	"freeing not required (see http://libgit2.github.com/libgit2/#HEAD/group/blob/git_blob_rawcontent)"	^ self blob_rawcontent: self! !!LGitBlob methodsFor: 'private-accessing' stamp: ' 7/21/2017 17:44:56'!rawSize	^ self blob_rawsize: self! !!LGitCommit class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_free: handle		^ self call: #(void git_commit_free #(void *handle)) options: #()! !!LGitCommit class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #commit_free:! !!LGitCommit class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isType: aType	^ aType = LGitObjectTypeEnum git_obj_commit! !!LGitCommit class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: aRepository fromHexString: aCommitId	^ self of: aRepository fromId: (LGitId fromHexString: aCommitId)! !!LGitCommit methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!= anObject	^ self == anObject or: [ 		self class == anObject class and: [			self isReady and: [				anObject isReady and: [					self id = anObject id ] ] ] ]! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!author	^ self commit_author: self! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!authorStruct	^ self commit_author: self! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_author: commit		^ self		call: #(LGitSignature * git_commit_author #(self))		options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_committer: commit		^ self		call: #(LGitSignature * git_commit_committer #(self))		options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_id: commit		^ self call: #(void * git_commit_id #(self)) options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_lookup: commit repo: repo id: objectId		^ self		callUnchecked:			#(LGitReturnCodeEnum git_commit_lookup #(LGitCommit * commit , LGitRepository repo , LGitId * objectId))		options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_message: commit		^ self call: #(String git_commit_message #(self)) options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_message_encoding: commit		^ self		call: #(String git_commit_message_encoding #(self))		options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_parent_id: commit n: n	<todo: 'using LGitId * as return type causes a crash'>		^ self		call: #(void *git_commit_parent_id #(self , uint n))		options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_parentcount: commit		^ self call: #(uint git_commit_parentcount #(self)) options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_raw_header: aCommit	^ self call: #(const char * git_commit_raw_header(self))! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_time: commit		^ self call: #(int64 git_commit_time #(self)) options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_time_offset: commit		^ self call: #(int git_commit_time_offset #(self)) options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!commit_tree: tree_out commit: commit		^ self		call: #(LGitReturnCodeEnum git_commit_tree #(LGitTree *tree_out , self))		options: #()! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!committer	^ self commit_committer: self! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!committerStruct	^ self commit_committer: self! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!entryByPath: aString 	^ self tree entryByPath: aString! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!entryByPath: aString ifAbsent: aBlock	^ self tree entryByPath: aString ifAbsent: aBlock! !!LGitCommit methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!get_id_data	^ self commit_id: self! !!LGitCommit methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!hasParents	^ self parents notEmpty! !!LGitCommit methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isCommit	^ true! !!LGitCommit methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isMerge	^ self parents size > 1! !!LGitCommit methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!lookup	self withReturnHandlerDo: [ 		self			commit_lookup: self			repo: self repository			id: self id ].	self autoRelease! !!LGitCommit methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!merge: anotherCommit	"Merge two commits, producing a git_index that reflects the result of the merge."	| index | 	index := LGitIndex of: self repository.	self withReturnHandlerDo: [ 		self merge_result: index commit: anotherCommit options: LGitMergeOptions defaults.	].	"There is a bug on libgit2 and we need to set the owner of the index (because it is not	setting it)"	index hackOwner: self repository.		^ index! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!merge_result: out commit: anotherCommit options: options	^ self call: #(		LGitReturnCodeEnum git_merge_commits(			LGitIndex *out, 			LGitRepository repository, 			LGitCommit self, 			LGitCommit anotherCommit, 			LGitMergeOptions *options))		options: #()! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!message	<todo: 'use encoding to properly read the message'>	|  encoding |	encoding := self commit_message_encoding: self.	^ self commit_message: self! !!LGitCommit methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!objectPrintOn: aStream	self id hexString in: [ :hexId |		aStream			nextPutAll: (hexId first: 7);			nextPutAll: '...';			nextPutAll: (hexId last: 7);			nextPutAll: ', ';			nextPutAll: self message surroundedBySingleQuotes ]! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!owner	^ self 		call: #(void *git_commit_owner(self)) 		options: #()! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!parents	| parentCount |	parentCount := self commit_parentcount: self.	^ Array		new: parentCount		streamContents: [ :stream | 			0 to: parentCount - 1 do: [ :i | 				| parentOid parent |				parentOid := LGitId fromHandle: (self commit_parent_id: self n: i) getHandle.				parent := self class of: self repository fromId: parentOid.				stream nextPut: parent ] ]! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!rawHeader 	^ self commit_raw_header: self! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!time	| time offset |	time := self commit_time: self.	offset := self commit_time_offset: self.	^ LGitTime new		time: time;		offset: offset;		yourself! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!tree	| tree |	tree := LGitTree of: self repository.	self commit_tree: tree commit: self.	^ tree! !!LGitObject class methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!classFor: aType	^ self subclasses detect: [ :class | class isType: aType ]! !!LGitObject class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #object_free:! !!LGitObject class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isType: aType	^ self subclassResponsibility! !!LGitObject class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!newFromReference: aReference	^self of: aReference repository from: aReference targetId! !!LGitObject class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!object_free: handle 	^self call: #(void git_object_free(void *handle)) options: #(  )! !!LGitObject class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: aRepository fromId: id	^ (self of: aRepository)		initializeWithId: id;		yourself! !!LGitObject methodsFor: 'converting' stamp: ' 7/21/2017 17:44:56'!concreteObject	^ (self class classFor: self type) of: self repository fromId: self id! !!LGitObject methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!get_id_data	^ self object_id: self! !!LGitObject methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!id	| data |	(id notNil or: [ self isNull ]) ifTrue: [ ^ id ].	data := self get_id_data.	id := LGitId fromHandle: data getHandle.	id internalize.	^ id	! !!LGitObject methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!initializeWithId: gitOid	id := gitOid.	self lookup! !!LGitObject methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isBlob	^ false! !!LGitObject methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isCommit	^ false! !!LGitObject methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isTag	^ false! !!LGitObject methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isTree	^ false! !!LGitObject methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!lookup	self withReturnHandlerDo: [ self		object_lookup: self 		repo: self repository		id: self id 		type: LGitObjectTypeEnum git_obj_any ]! !!LGitObject methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!objectPrintOn: aStream	self id ifNil: [ ^ self ].		aStream nextPutAll: self id hexString! !!LGitObject methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!object_dup: dest from: source		^ self		callUnchecked: #(LGitObjectTypeEnum git_object_dup(LGitObject *dest, LGitObject source))		options: #()! !!LGitObject methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!object_id: obj		^ self		call: #(void * git_object_id #(self))		options: #()! !!LGitObject methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!object_lookup: object repo: repo id: oid type: type		^ self		callUnchecked:			#(LGitReturnCodeEnum git_object_lookup #(LGitObject * object , LGitRepository repo , LGitId * oid , LGitObjectTypeEnum type))		options: #()! !!LGitObject methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!object_short_id: out		^ self		call: #(LGitObjectTypeEnum git_object_short_id(LGitBuf *out, self))		options: #()! !!LGitObject methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!object_type: obj		^ self		call: #(LGitObjectTypeEnum git_object_type #(self))		options: #()! !!LGitObject methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!shortId	| buf shortId |	buf := LGitBuf new.	self object_short_id: buf.	shortId := buf prim_ptr readString.	buf free.	^shortId ! !!LGitObject methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!type	^ self object_type: self! !!LGitTag class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #tag_free:! !!LGitTag class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isType: aType	^ aType = LGitObjectTypeEnum git_obj_tag! !!LGitTag class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tag_free: handle	^ self call: #(void git_tag_free #(void *handle)) options: #()! !!LGitTag methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!name	^ self tag_name! !!LGitTag methodsFor: 'accesing' stamp: ' 7/21/2017 17:44:56'!object	| peeled |	peeled := LGitObject of: self repository.	self tag_peel: peeled.	^ peeled concreteObject! !!LGitTag methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tag_name	^ self call: #(String git_tag_name #(self)) options: #()! !!LGitTag methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tag_peel: result	^ self		call: #(LGitReturnCodeEnum git_tag_peel #(LGitObject * result, self))		options: #()! !!LGitTree class methodsFor: 'accessing-defaults' stamp: ' 7/21/2017 17:44:56'!defaultFilemode	^ LGitFilemodeEnum git_filemode_tree! !!LGitTree class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #tree_free:! !!LGitTree class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isType: aType	^ aType = LGitObjectTypeEnum git_obj_tree! !!LGitTree class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_free: handle		^ self call: #(void git_tree_free #(void *handle)) options: #()! !!LGitTree methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!= anObject	^ self == anObject or: [ 		self class == anObject class and: [ 			self isReady and: [				anObject isReady and: [					self id = anObject id ] ] ] ]! !!LGitTree methodsFor: 'enumerating' stamp: ' 7/21/2017 17:44:56'!allEntriesDo: aBlock	"The entries will be traversed in the specified order, children subtrees will be automatically loaded as required, and the callback will be called once per entry with the current (relative) root for the entry and the entry data itself.If the callback returns a positive value, the passed entry will be skipped on the traversal (in pre mode). A negative value stops the walk."	self withReturnHandlerDo: [ 		self			tree_walk: self			mode: LGitTreewalkModeEnum git_treewalk_pre			callback: (LGitTreewalkCallback on: aBlock)			payload: ExternalAddress null ]! !!LGitTree methodsFor: 'traversing' stamp: ' 7/21/2017 17:44:56'!entries	| entryCount |	entryCount := self tree_entrycount: self.		^ Array new: entryCount streamContents: [ :stream |		0 to: entryCount - 1 do: [ :i || entry |			entry := self tree_entry_byindex: self idx: i.			entry repository: self repository.			stream nextPut: entry ] ]! !!LGitTree methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!entryByName: aString 	^ self entryByName: aString ifAbsent: [ 		self error: ('Entry {1} is not present in tree {2}' format: {aString. self})].! !!LGitTree methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!entryByName: aString ifAbsent: aBlock	| entry |	entry := self tree_entry_byname: self name: aString.	(entry isNil or: [ entry isNull ])		ifTrue: [ ^aBlock value ].	entry repository: self repository.	^entry! !!LGitTree methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!entryByPath: aString 	^ self entryByPath: aString ifAbsent: [ 		self error: ('Entry {1} is not present in tree {2}' format: {aString. self})].! !!LGitTree methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!entryByPath: aString ifAbsent: aBlock	| entry |	entry := LGitTreeEntry of: self repository.	self tree_entry_bypath: entry path: aString.	^ entry isNull		ifTrue: [ aBlock value ]		ifFalse: [ 			entry repository: self repository.			entry ]! !!LGitTree methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!get_id_data	^ self tree_id: self! !!LGitTree methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!hash	^ super hash bitXor: self id asInteger! !!LGitTree methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isEmpty	^ self entries isEmpty! !!LGitTree methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isLeaf	^ self entries noneSatisfy: [ :entry |		entry type = LGitObjectTypeEnum git_obj_tree  ]! !!LGitTree methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isTree	^ true! !!LGitTree methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!lookup	self withReturnHandlerDo: [		self			tree_lookup: self			repo: self repository			id: self id ].	self autoRelease! !!LGitTree methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!names	<todo: 'decide what to do with this:	- will not work for trees not referenced from head (e.g. in an older commit)	- very slow for large repositories because every entry is visited'>	| names |	names := OrderedCollection new.	self repository head object tree allEntriesDo: [ :name :entry :payload |		entry repository: self repository.		entry object = self ifTrue: [ names add: name ].		0 ].		^ names! !!LGitTree methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!objectPrintOn: aStream	aStream		nextPutAll: 'number of entries: ';		nextPutAll: self size asString! !!LGitTree methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!owner	^ self tree_owner: self! !!LGitTree methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!size	^ self tree_entrycount: self! !!LGitTree methodsFor: 'traversing' stamp: ' 7/21/2017 17:44:56'!subTreeEntries	^ self entries select: [ :entry |		entry type = LGitObjectTypeEnum git_obj_tree ]! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_entry_byindex: tree idx: idx		^ self		call: #(LGitTreeEntry git_tree_entry_byindex #(self , size_t idx))		options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_entry_byname: tree name: name		^ self		call: #(LGitTreeEntry git_tree_entry_byname #(self , String name))		options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_entry_bypath: out path: path		^ self		call:			#(LGitReturnCodeEnum git_tree_entry_bypath #(LGitTreeEntry * out, self, String path))		options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_entrycount: tree		^ self call: #(int git_tree_entrycount #(self)) options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_id: tree		^ self call: #(void * git_tree_id #(self)) options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_lookup: out repo: repo id: objectId		^ self		callUnchecked:			#(LGitReturnCodeEnum git_tree_lookup #(LGitTree * out , LGitRepository repo , LGitId * objectId))		options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_owner: tree		^ self call: #(LGitRepository git_tree_owner #(self)) options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_walk: tree mode: mode callback: callback payload: payload		^ self		call:			#(LGitReturnCodeEnum git_tree_walk #(LGitTree tree , LGitTreewalkModeEnum mode , LGitTreewalkCallback callback , void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitPatch class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!diff_patch_free: handle		^ self call: #(void git_patch_free #(void *handle)) options: #()! !!LGitPatch class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #diff_patch_free:! !!LGitPatch class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!fromDiff: aDiff at: anInteger	^ (self of: aDiff repository)		fromDiff: aDiff at: anInteger;		yourself! !!LGitPatch methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!fromDiff: aDiff at: anInteger	"use 1 based offset as in Smalltalk"	self withReturnHandlerDo: [		self			patch_from_diff: self			diff: aDiff			idx: anInteger - 1 ].	self autoRelease! !!LGitPatch methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!hunkAt: anInteger	| hunk lines |	hunk := LGitDiffHunk externalNew.	lines := LGitWriteBackValueSizeT new.	self withReturnHandlerDo: [		self			patch_get_hunk: hunk			lines_in_hunk: lines patch: self			hunk_idx: anInteger ].			^ hunk! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!patch_from_blob_and_buffer: out old_blob: old_blob old_as_path: old_as_path buffer: buffer buffer_len: buffer_len buffer_as_path: buffer_as_path opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_patch_from_blob_and_buffer #(LGitPatch * self , LGitBlob old_blob , String old_as_path , String buffer , FFIUInt32 buffer_len , String buffer_as_path , LGitDiffOptions * opts))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!patch_from_blobs: out old_blob: old_blob old_as_path: old_as_path new_blob: new_blob new_as_path: new_as_path opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_patch_from_blobs #(LGitPatch * self , LGitBlob old_blob , String old_as_path , LGitBlob new_blob , String new_as_path , LGitDiffOptions * opts))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!patch_from_buffers: out old_buffer: old_buffer old_len: old_len old_as_path: old_as_path new_buffer: new_buffer new_len: new_len new_as_path: new_as_path opts: opts	self flag: #todo. "This one doesnt seems to exist anymore. Instead I think it is git_patch_from_blob_and_buffer"	^ self		callUnchecked:			#(LGitReturnCodeEnum git_patch_from_blobuffers #(LGitPatch * self , FFIVoid * old_buffer , FFIUInt32 old_len , String old_as_path , String new_buffer , FFIUInt32 new_len , String new_as_path , LGitDiffOptions * opts))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!patch_from_diff: out diff: diff idx: idx		^ self		callUnchecked:			#(LGitReturnCodeEnum git_patch_from_diff #(LGitPatch * self , LGitDiff diff , size_t idx))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!patch_get_delta: patch		^ self		call: #(LGitDiffDelta * git_patch_get_delta #(self))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!patch_get_hunk: out lines_in_hunk: lines_in_hunk patch: patch hunk_idx: hunk_idx		^ self		call:			#(LGitReturnCodeEnum git_patch_get_hunk #(				LGitDiffHunk **out , 				LGitWriteBackValueSizeT *lines_in_hunk, 				LGitPatch *patch, 				size_t hunk_idx))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!patch_get_line_in_hunk: out patch: patch hunk_idx: hunk_idx line_of_hunk: line_of_hunk		^ self		call:			#(LGitReturnCodeEnum git_patch_get_line_in_hunk #(LGitDiffLine * out , self , size_t hunk_idx , size_t line_of_hunk))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!patch_print: patch print_cb: print_cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_patch_print #(self , LGitDiffLineCallback print_cb , void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitPatch methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!printDiff	^ String new: 500 streamContents: [ :stream |		self printDiffOn: stream ]! !!LGitPatch methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!printDiffOn: aStream	| callback |	callback := LGitDiffLineCallback on: [ :delta :hunk :line :payload |		aStream nextPutAll: line content. 0 ].		self withReturnHandlerDo: [		self			patch_print: self			print_cb: callback			payload: nil ]! !!LGitPathSpecMatchList class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #pathspec_match_list_free:! !!LGitPathSpecMatchList class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!pathspec_match_list_free: handle		^ self		call: #(void git_pathspec_match_list_free #(void *handle))		options: #()! !!LGitPathSpecMatchList methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!pathspec_match_diff: out diff: diff flags: flags ps: ps		^ self		callUnchecked:			#(int git_pathspec_match_diff #(LGitPathSpecMatchList * self , LGitDiff diff , LGitPathSpecFlagTypeEnum flags , LGitPathSpec ps))		options: #()! !!LGitPathSpecMatchList methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!pathspec_match_list_diff_entry: m pos: pos		^ self		call:			#(LGitDiffDelta git_pathspec_match_list_diff_entry #(LGitPathSpecMatchList m , size_t pos))		options: #()! !!LGitReference class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #reference_free:! !!LGitReference class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_free: handle	^ self		call: #(void git_reference_free #(void *handle))		options: #()! !!LGitReference methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!= anObject	self class == anObject class ifFalse: [ ^ false ].		^ self == anObject or: [		(self 			reference_cmp: self 			ref2: anObject) = LGitReturnCodeEnum git_ok  ]	! !!LGitReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!annotatedCommit	^ LGitAnnotatedCommit fromRef: self! !!LGitReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!basename	^ self name copyAfterLast: $/! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!branch_is_head: branch		^ self call: #(int git_branch_is_head #(self)) options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!branch_set_upstream: upstream	^ self		callUnchecked:			#(LGitReturnCodeEnum git_branch_set_upstream #(self , String upstream))		options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!branch_upstream: out local: local	^ self		callUnchecked:			#(LGitReturnCodeEnum git_branch_upstream #(LGitReference * out , self))		options: #()! !!LGitReference methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createDirect: nameString target: aGitId force: aBoolean	self withReturnHandlerDo: [ 		self			reference_create: self			repo: self repository			name: nameString			id: aGitId			force: aBoolean			log_message: 'created reference ', nameString ]! !!LGitReference methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createSymbolic: nameString target: targetString force: aBoolean	self withReturnHandlerDo: [ 		self			reference_symbolic_create: self			repo: self repository			name: nameString			target: targetString			force: aBoolean			log_message: 'created reference ', nameString ]! !!LGitReference methodsFor: 'initialize-release' stamp: ' 7/21/2017 17:44:56'!initializeOn: aHandle in: aRepo	handle := aHandle.	self repository: aRepo.! !!LGitReference methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isBranch	^ (self reference_is_branch: self) = 1! !!LGitReference methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isDirect	^ (self reference_type: self) = LGitReferenceTypeEnum git_ref_oid! !!LGitReference methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isHead	^ (self branch_is_head: self) = 1! !!LGitReference methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isLocal	^ self reference_is_remote not! !!LGitReference methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isSymbolic	^ (self reference_type: self) = LGitReferenceTypeEnum git_ref_symbolic! !!LGitReference methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isTag	^ self reference_is_tag = 1! !!LGitReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!name	^ self reference_name: self! !!LGitReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!object	self isDirect 		ifFalse: [ ^ self resolve object ].	^(LGitObject of: self repository fromId: self targetId) concreteObject! !!LGitReference methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!objectPrintOn: aStream	aStream nextPutAll: self name surroundedBySingleQuotes! !!LGitReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!owner	^ self call: #(void * git_reference_owner #(self)) options: #()! !!LGitReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!pushUpstream	| pushRemote | 	^ self repository config 		getString: 'remote.pushDefault'		ifPresent: [ :pushRemoteName |			self repository 				lookupBranch: self upstream basename				inRemote: pushRemoteName ]		ifAbsent: [ self upstream ]! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_cmp: ref1 ref2: ref2		^ self		call: #(LGitReturnCodeEnum git_reference_cmp #(self , LGitReference ref2))		options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_create: out repo: repo name: name id: id force: force log_message: log_message		^ self		callUnchecked:			#(LGitReturnCodeEnum git_reference_create #(LGitReference * self , LGitRepository repo , String name , LGitId * id , Boolean force , String log_message))		options: #(optCoerceNilToNull)! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_is_branch: ref		^ self call: #(int git_reference_is_branch #(self)) options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_is_remote	^ self call: #(Boolean git_reference_is_remote #(self)) options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_is_tag		^ self call: #(int git_reference_is_tag #(self)) options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_lookup: out repo: repo name: name		^ self		callUnchecked:			#(LGitReturnCodeEnum git_reference_lookup #(LGitReference * self , LGitRepository repo , String name))		options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_name: ref		^ self call: #(String git_reference_name #(self)) options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_resolve: out ref: ref		^ self		callUnchecked: #(LGitReturnCodeEnum git_reference_resolve #(LGitReference * out , self))		options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_set_target: out ref: ref id: id log_message: log_message		^ self		call:			#(LGitReturnCodeEnum git_reference_set_target #(LGitReference * out , self , LGitId * id , String log_message))		options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_symbolic_create: out repo: repo name: name target: target force: force log_message: log_message		^ self		callUnchecked:			#(LGitReturnCodeEnum git_reference_symbolic_create #(LGitReference * self , LGitRepository repo , String name , String target , Boolean force , String log_message))		options: #(optCoerceNilToNull)! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_symbolic_set_target: out ref: ref target: target log_message: log_message		^ self		callUnchecked:			#(LGitReturnCodeEnum git_reference_symbolic_set_target #(LGitReference * self , LGitReference ref , String target , String log_message))		options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_target: ref	<todo: 'using LGitId* as return value causes random crashes'>		^ self call: #(void * git_reference_target #(self)) options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!reference_type: ref		^ self		call: #(LGitReferenceTypeEnum git_reference_type #(self))		options: #()! !!LGitReference methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!resolve	| resolved |	self isDirect 		ifTrue: [ ^ self ].	resolved := self class of: self repository.	self withReturnHandlerDo: [ self reference_resolve: resolved ref: self ].	^ resolved! !!LGitReference methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!setTarget: aReference	self setTargetId: aReference object id! !!LGitReference methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!setTargetId: aGitId	| newRef |	newRef := LGitReference of: self repository.	self		withReturnHandlerDo: [ 			self				reference_set_target: newRef				ref: self				id: aGitId				log_message: 'set ' , self name , ' to ' , aGitId hexString ]! !!LGitReference methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!setUpstream: upstreamName	self withReturnHandlerDo: [		self branch_set_upstream: upstreamName	]! !!LGitReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!shortName	^ self isLocal 		ifTrue: [ self basename ]		ifFalse: [ self name withoutPrefix: 'refs/remotes/']! !!LGitReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!targetId	| data oId |	data := self reference_target: self.	data getHandle isNull		ifTrue: [ ^ nil ].	oId := LGitId fromExternalAddress: data.	oId internalize.	^ oId! !!LGitReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!upstream	| upstream | 	upstream  := self class of: self repository.	[ self withReturnHandlerDo: [		self branch_upstream: upstream local: self	]] 	on: LGit_GIT_ENOTFOUND do: [ ^ nil ].	^ upstream! !!LGitRemote class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!credentials	^ Credentials ifNil: [ Credentials := SmallDictionary new ]! !!LGitRemote class methodsFor: 'convenience' stamp: ' 7/21/2017 17:44:56'!credentialsPlaintext	^ LGitCredentialsPlaintext		username: self username		passphrase: self password! !!LGitRemote class methodsFor: 'convenience' stamp: ' 7/21/2017 17:44:56'!credentialsSsh	^ LGitCredentialsSSH		username: self usernameSsh		passphrase: self keyPassPhrase		publicKeyReference: self keyFilePublicPath asFileReference		privateKeyReference: self keyFilePrivatePath asFileReference! !!LGitRemote class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #remote_free:! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!keyFilePrivatePath	^ self credentials		at: #keyFilePrivatePath		ifAbsentPut: [ UIManager default request: 'Path to your private key file (/home/foo/.ssh/key)?' ]! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!keyFilePrivatePath: aString	self credentials		at: #keyFilePrivatePath		put: aString! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!keyFilePublicPath	^ self credentials		at: #keyFilePublicPath		ifAbsentPut: [ UIManager default request: 'Path to your public key file (/home/foo/.ssh/key.pub)?' ]! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!keyFilePublicPath: aString	self credentials		at: #keyFilePublicPath		put: aString! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!keyPassPhrase	^ self credentials		at: #keyPassPhrase		ifAbsentPut: [ UIManager default request: 'Passphrase of your private key file?' ]! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!keyPassPhrase: aString	self credentials		at: #keyPassPhrase		put: aString! !!LGitRemote class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: aRepository named: aString	^ self of: aRepository named: aString url: nil! !!LGitRemote class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: aRepository named: nameString url: urlString	^ self		of: aRepository		named: nameString		url: urlString		fetchSpec: nil! !!LGitRemote class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: aRepository named: nameString url: urlString fetchSpec: aRefSpec	^ (self of: aRepository)		remoteName: nameString;		url: urlString;		fetchSpec: aRefSpec;		yourself! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!password	^ self credentials		at: #password		ifAbsentPut: [ UIManager default request: 'What''s the password for your account?' ]! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!password: aString	self credentials		at: #password		put: aString! !!LGitRemote class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_free: handle		^ self call: #(void git_remote_free #(void *handle)) options: #()! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!resetCredentials	Credentials := nil! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!username	^ self credentials		at: #username		ifAbsentPut: [ UIManager default request: 'What''s your account name?' ]! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!username: aString	self credentials		at: #username		put: aString! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!usernameSsh	^ self credentials		at: #usernameSsh		ifAbsentPut: [ 			UIManager default 				request: 'What''s your username for SSH (probably "git")?'				initialAnswer: 'git' ]! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/21/2017 17:44:56'!usernameSsh: aString	self credentials		at: #usernameSsh		put: aString! !!LGitRemote methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!addFetch	self withReturnHandlerDo: [ 		self			remote_add_fetch: self repository			remote: self remoteName			refspec: self fetchSpec ]! !!LGitRemote methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!addPush	self withReturnHandlerDo: [ 		self			remote_add_push: self repository			remote: self remoteName			refspec: self fetchSpec ]! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!connectFetch	self withReturnHandlerDo: [ 		self 			remote_connect: self 			direction: LGitDirectionEnum git_direction_fetch			callbacks: LGitRemoteCallbacks defaults ]! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!connectFetchWithCredentials: aCredentialsProvider	self withReturnHandlerDo: [ 		self 			remote_connect: self 			direction: LGitDirectionEnum git_direction_fetch			callbacks: (LGitRemoteCallbacks withProvider: aCredentialsProvider) ]! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!connectPushWithCredentials: aCredentialsProvider	self withReturnHandlerDo: [ 		self 			remote_connect: self 			direction: LGitDirectionEnum git_direction_push			callbacks: (LGitRemoteCallbacks withProvider: aCredentialsProvider) ]! !!LGitRemote methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!create	<todo: 'use exceptions instead of assertions'>	self assert: url notNil.	self assert: self repository isReady.		[ self hasFetchSpec		ifFalse: [ self createWithoutSpec ]		ifTrue: [ self createWithFetchSpec ] ]			on: LGit_GIT_EEXISTS			do: [ "all good then" ]! !!LGitRemote methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!createWithFetchSpec	self withReturnHandlerDo: [ 		self			remote_create_with_fetchspec: self			repo: self repository			name: self remoteName			url: self url			fetch: self fetchSpec ]! !!LGitRemote methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!createWithoutSpec	self withReturnHandlerDo: [ 		self			remote_create: self			repo: self repository			name: self remoteName			url: self url ]! !!LGitRemote methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!delete	self withReturnHandlerDo: [		self			remote_delete: self repository			name: self remoteName ]! !!LGitRemote methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!fetch	self isReady ifFalse: [ self create ].	self withReturnHandlerDo: [ 		self			remote_fetch: self			refspecs: self ffiNull handle			opts: (LGitFetchOptions defaults				callbacks: LGitRemoteCallbacks defaults;				yourself)			reflog_message: nil ]! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fetchSpec	^ fetchSpec! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fetchSpec: aRefSpec	fetchSpec := aRefSpec! !!LGitRemote methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!fetchWithCredentials: aCredentialsProvider	self isReady ifFalse: [ self create ].	self withReturnHandlerDo: [ 		self			remote_fetch: self			refspecs: self ffiNull handle			opts: (LGitFetchOptions defaults				callbacks:(LGitRemoteCallbacks withProvider: aCredentialsProvider);				yourself)			reflog_message: nil ]! !!LGitRemote methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!fetchWithMessage: aString	self create.			self withReturnHandlerDo: [ 		self			remote_fetch: self			refspecs: nil			opts: LGitFetchOptions defaults			reflog_message: aString ]! !!LGitRemote methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!fetchWithMessage: aString credentials: aCredentialsProvider 	self create.			self withReturnHandlerDo: [ 		self			remote_fetch: self			refspecs: nil			opts: (LGitFetchOptions defaults				callbacks: (LGitRemoteCallbacks withProvider: aCredentialsProvider);				yourself)			reflog_message: aString ]! !!LGitRemote methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!hasFetchSpec	^ self fetchSpec notNil ! !!LGitRemote methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!lookup	self withReturnHandlerDo: [ 		self			remote_lookup: self			repo: self repository			name: self remoteName.		self url: self remote_url ].	self flag: #todo. "shouldn't be autoreleased?"! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!ls	"I list all HEADS in connected remotes (you will need to #connectFetch or 	#connectPushWithCredentials: first)"	| out sizeBuf heads size |		sizeBuf := ByteArray new: FFISizeT externalTypeSize.	out := ExternalAddress new.		self withReturnHandlerDo: [ 		self remote_ls: out size: sizeBuf ].		size := sizeBuf signedLongAt: 1.	heads := Array new: size. 	1 to: size do: [ :index | 		heads at: index put: (LGitRemoteHead fromHandle: (out pointerAt: 1)).		out := out + FFIExternalType pointerSize ].		^ heads! !!LGitRemote methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!objectPrintOn: aStream	aStream nextPutAll: self remoteName! !!LGitRemote methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!pullWithFetchOptions: fetchOptions	<todo: 'check for conflicts'>	self repository isReady ifFalse: [  ^ self ].	self lookup.		self withReturnHandlerDo: [ 		self			remote_fetch: self			refspecs: nil			opts: fetchOptions			reflog_message: 'automatic pull from libgit2' ].		"assume that there are no conflicts and fast-forwad to FETCH_HEAD"	self repository fastForward! !!LGitRemote methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!pushWithRefSpec: aRefSpec pushOptions: pushOptions	| refspecs return |	refspecs := LGitStringArray withAll: { aRefSpec asString }.	return := self withReturnHandlerDo: [		self			remote_push: self			refspecs: refspecs			opts: pushOptions ].			^ return! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!refSpecs 	| specs |	specs := LGitStringArray externalNew autoRelease.	self withReturnHandlerDo: [ 		self remote_get_fetch_refspecs: specs ].	^ specs strings! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!remoteName	^ remoteName! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!remoteName: aString	remoteName := aString! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_add_fetch: repo remote: remote refspec: refspec		^ self		call:			#(LGitReturnCodeEnum git_remote_add_fetch #(LGitRepository repo , String remote String refspec))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_add_push: repo remote: remote refspec: refspec		^ self		call:			#(LGitReturnCodeEnum git_remote_add_push #(LGitRepository repo , String remote , String refspec))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_connect: remote direction: direction callbacks: remoteCallbacks		^ self		call:			#(LGitReturnCodeEnum git_remote_connect #(self , LGitDirectionEnum direction , LGitRemoteCallbacks * remoteCallbacks))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_create: out repo: repo name: name url: urlString		^ self		callUnchecked:			#(LGitReturnCodeEnum git_remote_create #(LGitRemote * self , LGitRepository repo , String name , String urlString))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_create_with_fetchspec: out repo: repo name: name url: urlString fetch: fetch		^ self		callUnchecked:			#(LGitReturnCodeEnum git_remote_create_with_fetchspec #(LGitRemote * self , LGitRepository repo , String name , String urlString , String fetch))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_delete: repo name: name		^ self		call:			#(LGitReturnCodeEnum git_remote_delete #(LGitRepository repo , String name))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_fetch: remote refspecs: refspecs opts: opts reflog_message: reflog_message		^ self		call:			#(LGitReturnCodeEnum git_remote_fetch #(self , void * refspecs , LGitFetchOptions * opts , String reflog_message))		options: #(optCoerceNilToNull)! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_get_fetch_refspecs: array	^ self call: #(int git_remote_get_fetch_refspecs(LGitStringArray *array, self))! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_lookup: out repo: repo name: name		^ self		callUnchecked:			#(LGitReturnCodeEnum git_remote_lookup #(LGitRemote * self , LGitRepository repo , String name))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_ls: out size: size	"	Since I will take a lost of addresses, I'm interested on 2nd level of 'out', that's why 	I transform `const git_remote_head ***out` into `void **out`	This is the original function: 		int git_remote_ls(const git_remote_head ***out, size_t *size, git_remote *remote)"	^ self call: #( LGitReturnCodeEnum git_remote_ls ( void **out, size_t *size, self ))! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_push: remote refspecs: refspecs opts: opts		^ self		call:			#(LGitReturnCodeEnum git_remote_push #(self , LGitStringArray * refspecs , LGitPushOptions * opts))		options: #(optCoerceNilToNull)! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_set_url: repo remote: remote url: urlString		^ self		call:			#(LGitReturnCodeEnum git_remote_set_url #(LGitRepository repo , String remote , String urlString))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_update_tips: remote callbacks: remoteCallbacks update_fetchhead: update_fetchhead download_tags: download_tags reflog_message: reflog_message		^ self		call:			#(LGitReturnCodeEnum git_remote_update_tips #(self , LGitRemoteCallbacks * remoteCallbacks , Boolean update_fetchhead , LGitRemoteAutotagOptionTypeEnum download_tags , String reflog_message))		options: #(optStringOrNull)! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!remote_url	^ self		call: #(String git_remote_url #(self))		options: #()! !!LGitRemote methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!setUrl: aString	self withReturnHandlerDo: [ 		self			remote_set_url: self repository			remote: self remoteName			url: aString]! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!url	^ url! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!url: aString	url := aString! !!LGitRepositoryObject class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!new	self error: 'Use #of: to create an instance of ', self name! !!LGitRepositoryObject class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: aRepository	^ self basicNew		initialize;		repository: aRepository;		yourself! !!LGitRepositoryObject methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!repository	^ repository! !!LGitRepositoryObject methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!repository: aRepository	repository := aRepository! !!LGitRevwalk class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #revwalk_free:! !!LGitRevwalk class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: aRepository	^ (super of: aRepository)		createNew;		yourself! !!LGitRevwalk class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!revwalk_free: handle		^ self call: #(void git_revwalk_free #(void *handle)) options: #()! !!LGitRevwalk methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!basicNext	"Note: in the C code you would check the return code to see when the loop is over.	This method uses instances variables to enable more Smalltalk like looping:	[ walk hasNext ] whileTrue: [ walk next ]."	| previousCommit nextId |	previousCommit := currentCommit.	nextId := self basicNextObjectId.	currentCommit := self hasNext		ifTrue: [			LGitCommit				of: self repository				fromId: nextId ]		ifFalse: [ nil ].		^ previousCommit! !!LGitRevwalk methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!basicNextObjectId	| nextId returnCode |	nextId := LGitId new.	returnCode := self		revwalk_next: nextId		walk: self.	(returnCode ~= LGitReturnCodeEnum git_iterover and: [ 		returnCode ~= LGitReturnCodeEnum git_ok ]) ifTrue: [ returnCode handleLGitReturnCode ].	hasNext := returnCode ~= LGitReturnCodeEnum git_iterover.		^ nextId! !!LGitRevwalk methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!basicSort: sortingEnum	sorting := sorting		ifNil: [ sortingEnum value ]		ifNotNil: [ sorting bitOr: sortingEnum value ].			self withReturnHandlerDo: [		self			revwalk_sorting: self			sort_mode: sorting ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!beSortedByCommitTime	self basicSort: LGitRevwalkSortTypeEnum git_sort_time! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!beSortedParentsBeforeChildren	self basicSort: LGitRevwalkSortTypeEnum git_sort_topological! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!beSortedReverse	self basicSort: LGitRevwalkSortTypeEnum git_sort_reverse! !!LGitRevwalk methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!createNew	self withReturnHandlerDo: [		self			revwalk_new: self			repo: self repository ]! !!LGitRevwalk methodsFor: 'walking' stamp: ' 7/21/2017 17:44:56'!do: aBlock	[ self hasNext ] whileTrue: [ 		aBlock value: self next	]! !!LGitRevwalk methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!hasNext	^ hasNext ifNil: [		self basicNext.		hasNext ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!hideCommit: aLGitId	self withReturnHandlerDo: [ self revwalk_hide: aLGitId ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!hideReference: aReference	self withReturnHandlerDo: [		self			revwalk_hide_ref: self			refname: aReference name ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!next	self hasNext ifFalse: [ ^ LGit_GIT_ITEROVER signal ].		^ self basicNext! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!pushCommit: aLGitId 	self withReturnHandlerDo: [ self revwalk_push: aLGitId ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!pushHead	self withReturnHandlerDo: [ self revwalk_push_head: self ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!pushReference: aReference	self withReturnHandlerDo: [		self			revwalk_push_ref: self			refname: aReference name ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!reset	self withReturnHandlerDo: [ self revwalk_reset: self ]! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!revwalk_hide: commitId	^ self 		call:			#(LGitReturnCodeEnum git_revwalk_hide #(self , LGitId * commitId))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!revwalk_hide_ref: walk refname: refname		^ self		call:			#(LGitReturnCodeEnum git_revwalk_hide_ref #(self , String refname))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!revwalk_new: out repo: repo		^ self		callUnchecked:			#(LGitReturnCodeEnum git_revwalk_new #(LGitRevwalk * self , LGitRepository repo))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!revwalk_next: out walk: walk		^ self		call: #(LGitReturnCodeEnum git_revwalk_next #(LGitId * out , self))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!revwalk_push: commitId	^ self 		call:			#(LGitReturnCodeEnum git_revwalk_push #(self , LGitId * commitId))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!revwalk_push_head: walk		^ self		call: #(LGitReturnCodeEnum git_revwalk_push_head #(self))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!revwalk_push_ref: walk refname: refname		^ self		call:			#(LGitReturnCodeEnum git_revwalk_push_ref #(self , String refname))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!revwalk_reset: revwalk		^ self call: #(void git_revwalk_reset #(self)) options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!revwalk_sorting: walk sort_mode: sort_mode		^ self		call: #(void git_revwalk_sorting #(self , uint sort_mode))		options: #()! !!LGitRevwalk methodsFor: 'walking' stamp: ' 7/21/2017 17:44:56'!select: selectionBlock thenDo: actionBlock	self do: [ :result | 		(selectionBlock value: result) 			ifTrue: [ actionBlock value: result ] ]! !!LGitStatusList class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #status_list_free:! !!LGitStatusList class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!status_list_free: handle		^ self		call: #(void git_status_list_free #(void *handle))		options: #()! !!LGitStatusList methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!status_list_get_perfdata: out status: status		^ self		call:			#(LGitReturnCodeEnum git_status_list_get_perfdata #(LGitPerfData * out , self))		options: #()! !!LGitTreeBuilder class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #treebuilder_free:! !!LGitTreeBuilder class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!fromTree: aTree	self validate: aTree shouldBe: LGitTree.	^ self of: aTree repository fromTree: aTree! !!LGitTreeBuilder class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!of: repository fromTree: aTree	^ (self of: repository)		initializeWithTree: aTree;		yourself! !!LGitTreeBuilder class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!treebuilder_free: handle		^ self		call: #(void git_treebuilder_free #(void *handle))		options: #()! !!LGitTreeBuilder methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!addEntry: aLGitObject filename: aString	self 		addEntryWithId: aLGitObject id 		filename: aString 		filemode: aLGitObject class defaultFilemode! !!LGitTreeBuilder methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!addEntryWithId: oidStruct filename: aString filemode: anInteger	self withReturnHandlerDo: [ 			self				treebuilder_insert: (LGitTreeEntry of: self repository)				bld: self				filename: aString				id: oidStruct				filemode: anInteger ]! !!LGitTreeBuilder methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!clear	self treebuilder_clear: self! !!LGitTreeBuilder methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!createNew	self withReturnHandlerDo: [ 		self 			treebuilder_new: self			repo: self repository			source: self ffiNull handle ]! !!LGitTreeBuilder methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!getEntryNamed: aString	| entry |	entry := self		treebuilder_get: self		filename: aString.	entry repository: self repository.		^ entry! !!LGitTreeBuilder methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!initializeWithTree: aTree	self withReturnHandlerDo: [		self			treebuilder_new: self			repo: self repository			source: (aTree ifNotNil: #handle) ]! !!LGitTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!newTree	^ LGitTree of: self repository fromId: self write! !!LGitTreeBuilder methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!treebuilder_clear: bld		^ self call: #(void git_treebuilder_clear #(self)) options: #()! !!LGitTreeBuilder methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!treebuilder_get: bld filename: filename		^ self		call: #(LGitTreeEntry git_treebuilder_get #(self , String filename))		options: #()! !!LGitTreeBuilder methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!treebuilder_insert: out bld: bld filename: filename id: id filemode: filemode		^ self		call:			#(LGitReturnCodeEnum git_treebuilder_insert #(LGitTreeEntry * out , self , String filename , LGitId * id , LGitFilemodeEnum filemode))		options: #()! !!LGitTreeBuilder methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!treebuilder_new: out repo: repo source: source	^ self		callUnchecked:			#(LGitReturnCodeEnum git_treebuilder_new #(LGitTreeBuilder * out , LGitRepository repo , void * source))		options: #(+ optCoerceNilToNull)! !!LGitTreeBuilder methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!treebuilder_write: id bld: bld		^ self		call: #(LGitReturnCodeEnum git_treebuilder_write #(LGitId * id , self))		options: #()! !!LGitTreeBuilder methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!write	| id errorCode |	id := LGitId new.	errorCode := self		treebuilder_write: id		bld: self.			errorCode ~= 0 ifTrue: [ LGitWritingTreeFailed ].		^ id! !!LGitTreeEntry class methodsFor: 'libgit-finalization' stamp: ' 7/21/2017 17:44:56'!freeFunctionSelector	^ #tree_entry_free:! !!LGitTreeEntry class methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_entry_free: handle		^ self		call: #(void git_tree_entry_free #(void *handle))		options: #()! !!LGitTreeEntry methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:56'!= anObject	^ self == anObject or: [		self class == anObject class and: [ 			self isReady and: [ 				anObject isReady and: [ 					self compare: anObject ] ] ] ]! !!LGitTreeEntry methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!compare: aTreeEntry	^ (self		tree_entry_cmp: self		e2: aTreeEntry) isZero! !!LGitTreeEntry methodsFor: 'traversing' stamp: ' 7/21/2017 17:44:56'!entries	^ self object entries! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!entryByPath: aString 	^ self object entryByPath: aString! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!entryByPath: aString ifAbsent: aBlock	^ self object entryByPath: aString ifAbsent: aBlock! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fileMode	^ self tree_entry_filemode: self! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!filename	^ self tree_entry_name: self! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!object	| object |	object := (LGitObject classFor: self type) of: self repository.	self withReturnHandlerDo: [		self			tree_entry_to_object: object			repo: self repository			entry: self ].			^ object! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!objectId	^ LGitId fromExternalAddress: (self tree_entry_id: self)! !!LGitTreeEntry methodsFor: 'printing' stamp: ' 7/21/2017 17:44:56'!objectPrintOn: aStream 	aStream nextPutAll: self filename surroundedBySingleQuotes! !!LGitTreeEntry methodsFor: 'traversing' stamp: ' 7/21/2017 17:44:56'!subTreeEntries	^ self object subTreeEntries! !!LGitTreeEntry methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_entry_cmp: e1 e2: e2		^ self		call: #(int git_tree_entry_cmp #(self , LGitTreeEntry e2))		options: #()! !!LGitTreeEntry methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_entry_filemode: entry		^ self		call: #(LGitFilemodeEnum git_tree_entry_filemode #(self))		options: #()! !!LGitTreeEntry methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_entry_id: entry		^ self call: #(void * git_tree_entry_id #(self)) options: #()! !!LGitTreeEntry methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_entry_name: entry		^ self call: #(String git_tree_entry_name #(self)) options: #()! !!LGitTreeEntry methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_entry_to_object: object_out repo: repo entry: entry		^ self		call:			#(LGitReturnCodeEnum git_tree_entry_to_object #(LGitObject * object_out , LGitRepository repo , self))		options: #()! !!LGitTreeEntry methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!tree_entry_type: entry		^ self		call: #(LGitObjectTypeEnum git_tree_entry_type #(self))		options: #()! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!type	^ self tree_entry_type: handle! !!LGitWriteBackValue class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isAbstract	^ self == LGitWriteBackValue! !!LGitWriteBackValueInt class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!typeDecl	^ 'int'! !!LGitWriteBackValueSizeT class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!typeDecl	^ 'size_t'! !!LGitWriteBackValueUInt class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!typeDecl	^ 'uint'! !!LGitAbstractError class methodsFor: 'signalling' stamp: ' 7/21/2017 17:44:56'!signalWith: anObject	^ self new		object: anObject;		signal;		yourself! !!LGitAbstractError methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!initialize	super initialize.	self messageText: LGitError lastMessage! !!LGitAbstractError methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!object	^ object! !!LGitAbstractError methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!object: anObject	object := anObject! !!LGitCallError class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isAbstract	^ self == LGitCallError! !!LGitCallReturnHandler class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!canHandle: aReturnCode	^ self handledReturnCodes anySatisfy: [ :symbol | 		aReturnCode symbol = symbol ]! !!LGitCallReturnHandler class methodsFor: 'lookup' stamp: ' 7/21/2017 17:44:56'!for: aReturnCode	^ (self allSubclasses reject: #isAbstract)		detect: [ :class | class canHandle: aReturnCode ]		ifNone: [ LGitNoReturnCodeHandlerDefined signal ]! !!LGitCallReturnHandler class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!handledReturnCodes	^ { (self name allButFirst: 5) asLowercase asSymbol }! !!LGitCallReturnHandler class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isAbstract	^ self == LGitCallReturnHandler! !!LGitCallReturnHandler class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isError	^ true! !!LGitCallReturnHandler class methodsFor: 'signalling' stamp: ' 7/21/2017 17:44:56'!signalWith: anError	^ self new		messageText: anError message;		object: anError type;		signal;		yourself! !!LGit_GIT_ITEROVER methodsFor: 'signaling' stamp: ' 7/21/2017 17:44:56'!signal	"don't signal, everything is fine"	^ self! !!LGit_GIT_OK class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isError	^ false! !!LGit_GIT_OK methodsFor: 'signaling' stamp: ' 7/21/2017 17:44:56'!signal	"don't signal, everything is fine"	^ self! !!LGitIllegalArgument class methodsFor: 'signalling' stamp: ' 7/21/2017 17:44:56'!signalWith: anObject shouldBe: aClass	^ self new		object: anObject;		expectedClass: aClass;		signal;		yourself! !!LGitIllegalArgument methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!expectedClass	^ expectedClass! !!LGitIllegalArgument methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!expectedClass: anObject	expectedClass := anObject! !!LGitIllegalArgument methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!messageText	^ 'libgit2 ffi call expects a(n) {1} but instead received {2}'			format: {self expectedClass. self object}! !!ManifestLibGitCore class methodsFor: 'meta data' stamp: ' 7/21/2017 17:44:56'!rejectClasses^ #()! !!ManifestLibGitCore class methodsFor: 'meta data' stamp: ' 7/21/2017 17:44:56'!rejectRules^ #()! !!ManifestLibGitCore class methodsFor: 'meta data' stamp: ' 7/21/2017 17:44:56'!ruleIfTrueBlocksRuleV1FalsePositive^ #(#(#(#RGMethodDefinition #(#LGitExternalObject #ifNotReady: #false)) #'2014-11-14T16:52:32.831129+01:00') )! !!ManifestLibGitCore class methodsFor: 'meta data' stamp: ' 7/21/2017 17:44:56'!ruleIfTrueReturnsRuleV1FalsePositive^ #(#(#(#RGMethodDefinition #(#LGitReference #= #false)) #'2014-11-14T16:52:32.91457+01:00') #(#(#RGMethodDefinition #(#LGitReference #= #false)) #'2014-11-14T16:52:32.915066+01:00') )! !!ManifestLibGitCore class methodsFor: 'code-critics' stamp: ' 7/21/2017 17:44:56'!ruleRBAbstractClassRuleV1FalsePositive^ #(#(#(#RGMetaclassDefinition #(#'LGitExternalEnumerationUInt32 class' #LGitExternalEnumerationUInt32)) #'2015-07-18T14:21:49.402159+02:00') )! !!ManifestLibGitCore class methodsFor: 'code-critics' stamp: ' 7/21/2017 17:44:56'!ruleRBNoClassCommentRuleV1FalsePositive^ #(#(#(#RGClassDefinition #(#LGitPushOptions)) #'2015-07-17T12:59:06.388548+02:00') )! !!LGitBufferSignatureCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(int (void **out, LGitDiffFile *file, char *buf, size_t buflen, void *payload))! !!LGitCallback class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!null	^ self new initializeNull! !!LGitCallback class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:56'!on: aBlock	^ self 		signature: self fnSpec 		block: aBlock ! !!LGitCallback methodsFor: 'as yet unclassified' stamp: ' 7/21/2017 17:44:56'!initializeNull	thunk := ExternalAddress null! !!LGitCheckoutNotifyCallback class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (LGitCheckoutNotifyTypeEnum why, String path, LGitDiffFile *baseline, LGitDiffFile *target, LGitDiffFile *workdir, void *payload))! !!LGitCheckoutPerfDataCallback class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(void (LGitCheckoutPerfData *perfdata, void *payload))! !!LGitCheckoutProgressCallback class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(void (String path, size_t completed_steps, size_t total_steps, void *payload))! !!LGitCompletionCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (LGitRemoteCompletionTypeEnum type, void *argument))! !!LGitCredAcquireCallback class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (LGitCredentials **cred, String url, String username_from_url, uint allowed_types, void *data))! !!LGitCredAcquireCallback methodsFor: 'as yet unclassified' stamp: ' 7/21/2017 17:44:56'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitCredAcquireCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!wrapBlock: aBlock	^[ :credAddress :url :username_from_url :allowed_types :data |		aBlock valueWithArguments: (Array			with: (LGitCredentials fromHandle: credAddress) 			with: url			with: username_from_url			with: allowed_types 			with: data) ]! !!LGitDiffBinaryCallback class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (LGitDiffDelta *delta, LGitDiffBinary *binary, void *payload))! !!LGitDiffBinaryCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitDiffBinaryCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!wrapBlock: aThreeArgBlock	^[ :deltaAddress :binary :payload |		aThreeArgBlock 			value: (LGitDiffDelta fromHandle: deltaAddress) 			value: (LGitDiffBinary fromHandle: binary) 			value: payload ]! !!LGitDiffFileCallback class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (LGitDiffDelta * delta, float progress, void *payload))! !!LGitDiffFileCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitDiffFileCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!wrapBlock: aThreeArgBlock	^[ :deltaAddress :progress :payload |		aThreeArgBlock 			value: (LGitDiffDelta fromHandle: deltaAddress) 			value: progress			value: payload ]! !!LGitDiffHunkCallback class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (LGitDiffDelta *delta, LGitDiffHunk *hunk, void *payload))! !!LGitDiffHunkCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitDiffHunkCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!wrapBlock: aBlock	^[ :deltaAddress :hunkAddress :payload |		aBlock 			value: (LGitDiffDelta fromHandle: deltaAddress) 			value: (LGitDiffHunk fromHandle: hunkAddress)			value: payload ]! !!LGitDiffLineCallback class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (LGitDiffDelta *delta, LGitDiffHunk *hunk, LGitDiffLine *line, void *payload))! !!LGitDiffLineCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitDiffLineCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!wrapBlock: aFourArgBlock	^[ :deltaAddress :hunkAddress :lineAddress :payload |		aFourArgBlock 			value: (LGitDiffDelta fromHandle: deltaAddress) 			value: (LGitDiffHunk fromHandle: hunkAddress)			value: (LGitDiffLine fromHandle: lineAddress)			value: payload ]! !!LGitDiffNotifyCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (LGitDiff *diff_so_far, LGitDiffDelta *delta_to_add, String matched_pathspec, void *payload))! !!LGitFileSignatureCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(int (void **out, LGitDiffFile *file, String fullpath, void *payload))! !!LGitFreeSignatureCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(void (void *sig, void *payload))! !!LGitIndexMatchedPathCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(int (String path, String matched_pathspec, void *payload))! !!LGitPackbuilderForeachCallback class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (void *buffer, int length, void *payload))! !!LGitPackbuilderForeachCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitPackbuilderForeachCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!wrapBlock: aBlock	^[ :buffer :length :payload |		aBlock 			value: buffer 			value: length			value: payload ]! !!LGitPackbuilderProgressCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(int (int stage, uint32 current, uint32 total, void *payload))! !!LGitPushNegotiationCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(int (LGitPushUpdate **updates, size_t len, void *payload))! !!LGitPushStatusForeachCallback class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (char *arg1, char *arg2, void *arg3))! !!LGitPushTransferProgressCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(int (uint current, uint total, size_t bytes, void *payload))! !!LGitPushUpdateReferenceCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(int (String refname, String status, void *data))! !!LGitRemoteCreateCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(int (void **out, LGitRepository repo, String name, String url, void *payload))! !!LGitRepositoryCreateCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(int (LGitRepository **out, String path, Boolean bare, void *payload))! !!LGitSimilarityCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(int (int *score, void *siga, void *sigb, void *payload))! !!LGitStatusCallback class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (String path, uint status_flags, void *payload))! !!LGitTransferProgressCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (LGitTransferProgress *stats, void *payload))! !!LGitTransportCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int git_transport_cb(LGitTransport *out, LGitRemote owner, void *param))! !!LGitTransportCertificateCheckCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(int (void *cert, int valid, String host, void *payload))! !!LGitTransportMessageCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (String str, int len, void *payload))! !!LGitTreewalkCallback class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!fnSpec	^#(int (String name, LGitTreeEntry entry, void *payload))! !!LGitTreewalkCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitTreewalkCallback methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:56'!wrapBlock: aThreeArgBlock	^[ :rootPath :entryAddress :payload |		aThreeArgBlock 			value: rootPath 			value: (LGitTreeEntry fromHandle: entryAddress)			value: payload ]		! !!LGitUpdateTipsCallback class methodsFor: 'callback spec' stamp: ' 7/21/2017 17:44:56'!fnSpec	^ #(int (String refname, LGitId *a, LGitId *b, void * data))! !!LGitLibrary class methodsFor: 'class initialization' stamp: ' 7/21/2017 17:44:56'!initialize	"Required to reset the Initialized flag on image startup"	Smalltalk addToStartUpList: self! !!LGitLibrary class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:56'!isInitialized	"Answer true when git_libgit2_init has been called in the current session."	^ Initialized ifNil: [ false ]! !!LGitLibrary class methodsFor: 'system startup' stamp: ' 7/21/2017 17:44:56'!shutDown: quitting	quitting ifFalse: [ ^ self ].	self isInitialized ifFalse: [ ^self ].	self uniqueInstance shutdownLibGit2.! !!LGitLibrary class methodsFor: 'system startup' stamp: ' 7/21/2017 17:44:56'!startUp: isImageStarting	isImageStarting		ifTrue: [ Initialized := false ]! !!LGitLibrary methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!initializeLibGit2	self libgit2_init.	Initialized := true! !!LGitLibrary methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!libgit2_features	"Query compile time options for libgit2."		^self ffiCall: #(int git_libgit2_features())! !!LGitLibrary methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!libgit2_featuresAlt	"Query compile time options for libgit2."		| fnc |		fnc := ExternalLibraryFunction		name: 'git_libgit2_features'		module: 'libgit2.0.dylib'		callType: 0		returnType: FFIInt32 new externalTypeWithArity		argumentTypes: {}.			^fnc invokeWithArguments: { }! !!LGitLibrary methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!libgit2_init	^self ffiCall: #(int git_libgit2_init())! !!LGitLibrary methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!libgit2_shutdown	^self ffiCall: #(int git_libgit2_shutdown())! !!LGitLibrary methodsFor: 'libgit-calls' stamp: ' 7/21/2017 17:44:56'!libgit2_version: major minor: minor rev: rev	"Return the version of the libgit2 library being currently used."	^self ffiCall: #(void git_libgit2_version(LGitWriteBackValueInt major, LGitWriteBackValueInt minor, LGitWriteBackValueInt rev))! !!LGitLibrary methodsFor: 'accessing platform' stamp: ' 7/21/2017 17:44:56'!macModuleName	| pluginDir |	pluginDir := Smalltalk vm binary parent / 'Plugins'.	#('libgit2.dylib' 'libgit2.0.dylib')		detect: [ :each | (pluginDir / each) exists ] 		ifFound: [ :libName | ^ libName ].	self error: 'Module not found.'! !!LGitLibrary methodsFor: 'operations' stamp: ' 7/21/2017 17:44:56'!shutdownLibGit2	| initsRemaining |		initsRemaining := self libgit2_shutdown.	initsRemaining <= 0		ifTrue: [ Initialized := false ].	^ initsRemaining! !!LGitLibrary methodsFor: 'accessing platform' stamp: ' 7/21/2017 17:44:56'!unixModuleName	| pluginDir |	pluginDir := Smalltalk vm binary parent.	#('libgit2.so' 'libgit2.so.0')		detect: [ :each | (pluginDir / each) exists ] 		ifFound: [ :libName | ^ libName ].	self error: 'Module not found.'! !!LGitLibrary methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:56'!version	"self uniqueInstance version"	| major minor rev |		major := LGitWriteBackValueInt new.	minor := LGitWriteBackValueInt new.	rev := LGitWriteBackValueInt new.		self libgit2_version: major minor: minor rev: rev.	^Array with: major value with: minor value with: rev value! !!LGitLibrary methodsFor: 'accessing platform' stamp: ' 7/21/2017 17:44:56'!win32ModuleName	^ 'libgit2.dll'! !!LGitExternalStructureFieldParser methodsFor: 'parsing' stamp: ' 7/21/2017 17:44:56'!parseFields: fields structure: structClass	| stream type fieldName generator |		stream := fields readStream.	generator := FFICallout new requestor: structClass.	fieldSpec := FFIExternalStructureFieldSpec new.	[ stream atEnd ] whileFalse: [ | arity |		type := generator resolveType: stream next. 		arity := 0.		[stream peek = #* ] whileTrue: [			arity := arity + 1.			stream next ].		type pointerArity: arity.				fieldName := ('prim_', stream next) asSymbol.		fieldName isSymbol ifFalse: [ self error: 'invalid field name'].		(fieldSpec fieldNames includes: fieldName) ifTrue: [ self error: 'duplicate field name' ].		"align := type typeSize min: byteAlign." "if byte align == 1, struct is packed"		"add padding between fields, if needed"		"self sizeAlignedTo: align with: type." 		fieldSpec addField: fieldName type: type. 			stream peek == #';' ifTrue: [ stream next ]].		^ self fieldSpec! !!LGitSafeFFICalloutMethodBuilder methodsFor: 'private' stamp: ' 7/21/2017 17:44:56'!generateFFICallout: builder spec: functionSpec	"Before the actual ffi call generate a check to see if the object is ready."	builder 		pushReceiver;		send: #signalIfNotReady.	^ super generateFFICallout: builder spec: functionSpec! !!Trait method!call: fnSpec	^ (self ffiCalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec	^ (self ffiCalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec	^ (self ffiCalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec	^ (self ffiCalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibrary! !!Trait method!ffiLibrary	^LGitLibrary ! !!Trait method!ffiLibrary	^LGitLibrary ! !!Trait method!ffiLibrary	^LGitLibrary ! !!Trait method!ffiLibrary	^LGitLibrary ! !!Trait method!ffiLibraryName	^self ffiLibrary! !!Trait method!ffiLibraryName	^self ffiLibrary! !!Trait method!ffiLibraryName	^self ffiLibrary! !!Trait method!ffiLibraryName	^self ffiLibrary! !!Trait method!validate: anObject shouldBe: aClass	"I allow for nil values."	(anObject isNil or: [ anObject isKindOf: aClass ])		ifFalse: [ LGitIllegalArgument signalWith: anObject shouldBe: aClass ]! !!Trait method!validate: anObject shouldBe: aClass	"I allow for nil values."	(anObject isNil or: [ anObject isKindOf: aClass ])		ifFalse: [ LGitIllegalArgument signalWith: anObject shouldBe: aClass ]! !!Trait method!validate: anObject shouldBe: aClass	"I allow for nil values."	(anObject isNil or: [ anObject isKindOf: aClass ])		ifFalse: [ LGitIllegalArgument signalWith: anObject shouldBe: aClass ]! !!Trait method!validate: anObject shouldBe: aClass	"I allow for nil values."	(anObject isNil or: [ anObject isKindOf: aClass ])		ifFalse: [ LGitIllegalArgument signalWith: anObject shouldBe: aClass ]! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!call: fnSpec	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec options: options	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec options: options	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec options: options	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec options: options	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!callUnchecked: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!callUnchecked: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!callUnchecked: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!callUnchecked: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!ffiLibrary	^self class ffiLibrary! !!Trait method!ffiLibrary	^self class ffiLibrary! !!Trait method!ffiLibrary	^self class ffiLibrary! !!Trait method!ffiLibrary	^self class ffiLibrary! !!Trait method!ffiLibraryName	^self class ffiLibrary! !!Trait method!ffiLibraryName	^self class ffiLibrary! !!Trait method!ffiLibraryName	^self class ffiLibrary! !!Trait method!ffiLibraryName	^self class ffiLibrary! !!Trait method!ffiNull	^FFIExternalObject null! !!Trait method!ffiNull	^FFIExternalObject null! !!Trait method!ffiNull	^FFIExternalObject null! !!Trait method!ffiNull	^FFIExternalObject null! !!Trait method!ifNotReady: aBlock	"use extra block so compiler can optimize"	self isReady ifFalse: [ aBlock value ]! !!Trait method!ifNotReady: aBlock	"use extra block so compiler can optimize"	self isReady ifFalse: [ aBlock value ]! !!Trait method!ifNotReady: aBlock	"use extra block so compiler can optimize"	self isReady ifFalse: [ aBlock value ]! !!Trait method!ifNotReady: aBlock	"use extra block so compiler can optimize"	self isReady ifFalse: [ aBlock value ]! !!Trait method!isReady	^ true! !!Trait method!isReady	^ true! !!Trait method!isReady	^ true! !!Trait method!isReady	^ true! !!Trait method!safeFFICalloutIn: aContext	^ LGitSafeFFICalloutAPI inContext: aContext! !!Trait method!safeFFICalloutIn: aContext	^ LGitSafeFFICalloutAPI inContext: aContext! !!Trait method!safeFFICalloutIn: aContext	^ LGitSafeFFICalloutAPI inContext: aContext! !!Trait method!safeFFICalloutIn: aContext	^ LGitSafeFFICalloutAPI inContext: aContext! !!Trait method!signalIfNotReady	self ifNotReady: [ self signalNotReady ]! !!Trait method!signalIfNotReady	self ifNotReady: [ self signalNotReady ]! !!Trait method!signalIfNotReady	self ifNotReady: [ self signalNotReady ]! !!Trait method!signalIfNotReady	self ifNotReady: [ self signalNotReady ]! !!Trait method!signalNotReady	LGitObjectNotInitialized signalWith: self! !!Trait method!signalNotReady	LGitObjectNotInitialized signalWith: self! !!Trait method!signalNotReady	LGitObjectNotInitialized signalWith: self! !!Trait method!signalNotReady	LGitObjectNotInitialized signalWith: self! !!Trait method!validate: anObject shouldBe: aClass	self class validate: anObject shouldBe: aClass! !!Trait method!validate: anObject shouldBe: aClass	self class validate: anObject shouldBe: aClass! !!Trait method!validate: anObject shouldBe: aClass	self class validate: anObject shouldBe: aClass! !!Trait method!validate: anObject shouldBe: aClass	self class validate: anObject shouldBe: aClass! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!objectPrintOn: aStream! !!Trait method!objectPrintOn: aStream! !!Trait method!printOn: aStream	| title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: [ 'an ' ] ifFalse: [ 'a ' ]);		nextPutAll: title.			(self shouldContinuePrintingOn: aStream) ifFalse: [ ^ self ].		aStream nextPutAll: ' ('.	self objectPrintOn: aStream.	aStream nextPut: $)! !!Trait method!printOn: aStream	| title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: [ 'an ' ] ifFalse: [ 'a ' ]);		nextPutAll: title.			(self shouldContinuePrintingOn: aStream) ifFalse: [ ^ self ].		aStream nextPutAll: ' ('.	self objectPrintOn: aStream.	aStream nextPut: $)! !!Trait method!shouldContinuePrintingOn: aStream	^ true! !!Trait method!shouldContinuePrintingOn: aStream	^ true! !"LibGit-Core"!!TIceRepositoryBackend commentStamp: 'NicoPasserini 7/4/2016 17:39' prior: 0!Common functionality for Ice repository backends.!!IceMCVersionInfo commentStamp: 'NicoPasserini 9/7/2016 15:19' prior: 0!Adapter to produce an MCVersionInfo that knows how to (lazily) load ancestors from an Iceberg repository.!!ManifestIceberg commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!IceError commentStamp: 'NicoPasserini 8/3/2016 14:52' prior: 0!Base class for all errors in Iceberg.!!CannotIdentifyVersionForCommit commentStamp: 'NicoPasserini 7/26/2016 14:05' prior: 0!This error is signaled when looking for a version in a commit (and its ancestry) has found two versions and can not decide which of them is the desired one. This should not happen if the repository is consistent.!!IceDuplicatedRepository commentStamp: 'NicoPasserini 8/3/2016 14:50' prior: 0!When trying to create a repository I found another one with a conflicting location (i.e. the same director on disk).!!IceGitUsernameOrEmailNotFound commentStamp: '<historical>' prior: 0!I'm an error to be sent when the error that comes from external library can be guessed to be the absense of user.name and user.mail properties.!!IceLocalRepositoryMissing commentStamp: 'NicoPasserini 10/4/2016 17:44' prior: 0!The repository code directory does not exist, maybe because the image was moved. Default action is to clone the repository again, but signal an error and allow for other components to react accordingly.!!IceMergeAborted commentStamp: 'NicoPasserini 8/9/2016 16:35' prior: 0!Attempting to merge arised a conflict so merge was aborted.!!IceMissingRepositoryEntry commentStamp: 'NicoPasserini 11/28/2016 14:05' prior: 0!Directory does not exist in the specified version in the repository.!!IceNoRemoteBranch commentStamp: 'NicoPasserini 8/3/2016 14:51' prior: 0!The operation you tried (for example push) requires that your branch has a configured upstream (something like origin/branchName), but is has none.!!IceVersionDoesNotExist commentStamp: 'NicoPasserini 11/28/2016 14:39' prior: 0!Version does not exist, probably the package was created in a later commit or it was deleted.!!IceWrongUrl commentStamp: 'NicoPasserini 8/3/2016 14:52' prior: 0!We can not parse the origin URL you have introduced. Maybe you made a typo, or maybe we do not support that kind of URLs.!!IceRepositoryAnnouncement commentStamp: 'NicoPasserini 10/5/2016 15:53' prior: 0!Groupes different announcements that can happen in a repository.!!IceCommited commentStamp: 'NicoPasserini 10/5/2016 15:53' prior: 0!Announces when a repository has commited.!!IcePushed commentStamp: 'NicoPasserini 10/5/2016 15:53' prior: 0!Announces when a repository has been pushed.!!IceRepositoryModified commentStamp: 'NicoPasserini 10/5/2016 15:56' prior: 0!Announces an unspecified change to a repository.!!IceAbstractCommitWalk commentStamp: 'NicoPasserini 9/21/2016 14:25' prior: 0!Base class for shared code between different commit walk implementations.!!IceAbstractDiff commentStamp: 'NicoPasserini 5/12/2016 17:23' prior: 0!Parent class for any comparison between two versions of the code (working copy, commit or other) and comprising any level of granularity (a whole repository, a package, a class, etc.).!!IceChangeSet commentStamp: 'NicoPasserini 5/9/2016 18:11' prior: 0!I represent a (maybe unitary) set of changes to be handled by the Iceberg framework. I am the top class of a composite pattern.A change should be defined as1. the difference between two versions of the code (currently two MCSnapthots for an IcePackageChangeSet)2. a filter from a bigger change set (for example we can create a class change set which is a subset of a package change set, all other subclasses from IceStructuralChangeSet).3. an explicit set of changes (see IceSimpleChangeSet).Public API and Key Messages- elements: returns a set of change sets which are my children, for example the change set related to a package contains the change sets for each class in the package.- (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	elements:		<Object>    Implementation Points!!IcePackageChangeSet commentStamp: 'NicoPasserini 5/12/2016 17:32' prior: 0!Provides a filtered version of a diff, restricted to a package.!!IceDiff commentStamp: 'NicoPasserini 5/12/2016 17:10' prior: 0!I model (and track) the diff between the working copy and the last commit in a given repository.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!IceAbstractVersion commentStamp: 'NicoPasserini 10/20/2016 15:48' prior: 0!Base class for different types of versions, namely: IceVersion (normal versions) and IceForeignVersion (versions not managed by Ice).!!IceForeignVersion commentStamp: 'NicoPasserini 9/14/2016 18:01' prior: 0!Place holder for an Iceberg version. When you get an instance of me instead of a real ice package version, this means that we can not correlate the current version of the code loaded into the image with a version in the corresponding Iceberg repository.!!IceSavedPackageVersion commentStamp: 'NicoPasserini 9/26/2016 11:11' prior: 0!A version of a package as saved in a repository. We have one of this for each commit in a repository which modifies the specified package.Internal representation- commit is the commit from which I loaded this version. - originatingCommit is the commit in which this version was first introduced, it is useful for comparing this version to another one.!!IceTemporaryVersion commentStamp: 'NicoPasserini 11/28/2016 14:49' prior: 0!Temporary versions are created in two situations:1) As  a temporary place holder for a version. Someone asked for a version but the package is still being loaded, at some point a real version will replace me. In the meanwhile I can respond to some messages as a version would do.2) For packages that are added to the repository but not yet saved. In this case the version will be replaced with a real version on next commit.!!IceBackendWriterAdapter commentStamp: 'NicoPasserini 9/26/2016 15:01' prior: 0!Adapter for having MCFileTreeWriters being able to write into Iceberg backend repositories without introducing unpleasant modifications in them.!!IceClassReference commentStamp: 'NicoPasserini 5/18/2016 12:20' prior: 0!This class is just for organizing class references together in a hierarchy, see subclases for more info.!!IceRemovedClassReference commentStamp: 'NicoPasserini 5/18/2016 12:19' prior: 0!A reference to a class that has been removed, but can be handled polymorphically with references to existing classes (see IceSimpleClassReference)!!IceSimpleClassReference commentStamp: 'NicoPasserini 5/18/2016 12:18' prior: 0!Wraps a Pharo class, to allow to handle it polymorphicaly with other references to classes (see IceRemovedClassReference)!!IceCommitish commentStamp: 'NicoPasserini 9/16/2016 14:08' prior: 0!A commit-ish is some object that ultimately points to a commit in a repository: could be a real commit, a branch, a tag.!!IceBranch commentStamp: 'NicoPasserini 12/6/2016 11:40' prior: 0!This can be a local o remote branch, see subclasses. When I am used as a commitish, you must understand that the commit I point to can change over time.!!IceLocalBranch commentStamp: 'NicoPasserini 12/6/2016 11:40' prior: 0!Models a local branch in the repository.!!IceRemoteBranch commentStamp: 'NicoPasserini 12/6/2016 11:42' prior: 0!Models a remote tracking branch.Please note that a "remote tracking" branch is in fact in the local repository, but it is not intended to work on it, but just to mirror a branch in a remote repository. You can not really checkout this branch, neither commit on it, it is read only.When cheking out a branch, if it is a remote tracking branch, a local branch will be created.!!IceCommitInfo commentStamp: 'NicoPasserini 6/6/2016 17:30' prior: 0!Holds the information about a commit in a git repository.!!IceLoadedCode commentStamp: 'NicoPasserini 9/16/2016 14:14' prior: 0!The loaded code of a repository can have three different shapes:- Nothing is loaded yet (represented by an instance of me).- All loaded packages using versions from the same commit (should be the most common situation).- You cherry-picked versions comming from differents commits (not recomended but supported).As commitish, I point to the code as it was loaded from the repository. Notice that after that moment both the code in the image as well as the origin of the code could have changed (in case that I load a branch, the branch can have new commits after I loaded it).!!IceTag commentStamp: 'NicoPasserini 11/3/2016 17:20' prior: 0!Representation of a tag!!IceUnbornBranch commentStamp: 'NicoPasserini 12/5/2016 16:47' prior: 0!I represent the "HEAD commit" of a new repository, i.e. one without any branches or commits. Once you commit on me, your repository will have just one commit and one branch named 'master'.!!IceUnknownBranch commentStamp: 'EstebanLorenzano 7/19/2017 14:20' prior: 0!I'm an unknown branch. I implement an "null pattern" to provide correct output for non-existing local repositories.!!IceWorkingCopy commentStamp: 'NicoPasserini 9/16/2016 14:13' prior: 0!A commitish pointing to the current version of the code.!!IceCredentialsProvider commentStamp: 'NicoPasserini 11/7/2016 15:01' prior: 0!I am in charge of remembering credentials information, configuration and providing it as required by the different backend implementations.I have a counter to avoid for trying for ever with the same credentials.!!IceMetacelloRepositoryAdapter commentStamp: 'NicoPasserini 9/30/2016 15:01' prior: 0!Adapter for allowing metacello to use Iceberg to download packages and versions.!!IcePackageReference commentStamp: 'NicoPasserini 5/25/2016 12:00' prior: 0!I represent a package, that could be in an IceRepository or in the image.Public API and Key Messages- isLoaded tells if the package is currently loaded in the image.In the future we should add load/unload here.We could also add commit, but in general is better to commit at the project level and not at the package level.!!IcePlaintextCredentials commentStamp: 'NicoPasserini 11/22/2016 14:35' prior: 0!I keep a username and a password for connecting to a repository.!!IceRemote commentStamp: 'NicoPasserini 11/17/2016 12:30' prior: 0!I represent a reference to an upstream repository, i.e. the repository to which you want to push/pull. Usually I am called a  'remote' but I could also be local. Most frequently each repository has at least one remote named 'origin'.I am abstract, my subclasses provide access to different kinds of remotes.Right now I just provide information about the different parts of the url, I could get smarter in the future.Internal Representation and Key Implementation Points.    Instance Variables	url:		<String>!!IceFileRemote commentStamp: 'NicoPasserini 7/1/2016 11:41' prior: 0!I am a 'remote' repository which is stored locally in your machine and accessed through a 'file://' url.!!IceNetworkRemote commentStamp: 'NicoPasserini 11/18/2016 13:39' prior: 0!Base abstract class for SCP and HTTPS remotes.!!IceHttpRemote commentStamp: 'TorstenBergmann 2/23/2017 10:33' prior: 0!A remote repository created out of a HTTP  url, such as 'http://localhost/owner/repository.git'.!!IceHttpsRemote commentStamp: 'NicoPasserini 11/18/2016 12:39' prior: 0!A remote repository created out of a HTTPS  url, such as 'https://github.com/npasserini/iceberg.git'.!!IceScpRemote commentStamp: 'NicoPasserini 7/1/2016 11:40' prior: 0!A remote repository created out of a SCP url, such as 'git@github.com:npasserini/iceberg.git'.!!IceUndefinedRemote commentStamp: 'EstebanLorenzano 3/29/2017 17:32' prior: 0!I'm an undefined remote. I exist when a repository is created from scratch and then there is no remote assigned to it yet.!!IceRepository commentStamp: 'NicoPasserini 10/25/2016 15:10' prior: 0!I represent an interface to a git repository. My main responsibilities are:- Load/update both baselines and individual packages from the repository.- Commit changes to the local repository and publish them to a remote repository.- Browse other versions of the loaded packages.- Handle branchesFor the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- loadPackage: packageName- createBranch: newBranchNameSample usage:    Git new origin: 'git@github.com:npasserini/pharo-git-test.git'.    git loadPackage: 'Pharo-Git-Test'. Instance Variables- origin: A string representing the url of a remote git repository (used as origin)- repository:	An IceGitTreeGitRemoteRepository, which provides underlying git operations.- location: <FileReference> The directory of the local repository.- commitDictionary: <Dictionary of IceCommitInfo> Cached dictonary from commitId (hex string) to  all commits in the current branch (in the local repo).- subdirectory: <String> The subdirectory of the local repository which is handled by the underlying GitFileTree- versionDescriptors: <List of GitFileTreePackageEntry> cached list of all package versions saved in the (currently selected branch) of the (local) repository.- announcer: <Announcer>- branch: <IceBranch> currently selected branch. - loadedCode:  <IceLoadedCode> Contains information about the loaded code for each package in this repository. (TODO: maybe handle special cases about loading different versions loaded for different packages, see: https://github.com/npasserini/iceberg/issues/139).Implementation Points!!IceRepositoryCreator commentStamp: 'EstebanLorenzano 12/7/2016 18:46' prior: 0!I create repositories. I do this (trying in this order):- with a location and url defined, I check if it can be a repository and in positive case, I answer the repository, or I can do a clone+checkout (into location) and answer the resulting repository.- with a remote defined , I can take url and location and perform the correct actions.You can also define  branchName to checkout a specific branch.!!IceSavedPackage commentStamp: 'NicoPasserini 6/13/2016 15:57' prior: 0!Can give information about a package that is saved in a repository, for example: - isLoaded if the package has been loaded into the image.- isModified if the package has local changes to be commited- incommingCommigs information about commits in the repository that are newer than the version loaded into the image.!!IceSshCredentials commentStamp: 'NicoPasserini 11/22/2016 14:34' prior: 0!I am a container for the credentials needed for connecting to a git repository via ssh/scp.!!Iceberg commentStamp: 'NicoPasserini 4/28/2016 14:10' prior: 0!I am a cache providing access to several Ice objects, such as packages, repositories, working copies, etc.Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!TIceRepositoryBackend classTrait methodsFor: 'class initialization' stamp: ' 7/21/2017 17:44:57'!initialize	IceRepository defaultBackendType ifNil: [ 		IceRepository defaultBackend: self ]! !!TIceRepositoryBackend methodsFor: 'requirements' stamp: ' 7/21/2017 17:44:57'!basicCodeDirectory	^ self subdirectory isEmptyOrNil 		ifTrue: [ self repositoryDirectory ]		ifFalse: [ self repositoryDirectory / self subdirectory  ].! !!TIceRepositoryBackend methodsFor: 'requirements' stamp: ' 7/21/2017 17:44:57'!codeDirectory	"Code repository might have been deleted or image might have been moved."	self repositoryDirectory exists		ifTrue: [ ^ self basicCodeDirectory ]		ifFalse: [ IceLocalRepositoryMissing signalFor: self frontend ]! !!TIceRepositoryBackend methodsFor: 'descriptions' stamp: ' 7/21/2017 17:44:57'!description	"Use local directory as description, as Monticello uses this to determine if two repositories are the same. This allows for having multiple local clones of the same remote repositories, which in turn could allow for using standard Pharo tools, for example to compare versions."	^ self basicCodeDirectory pathString, ' (', self class description, ')'! !!TIceRepositoryBackend methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!iceCommitFrom: aCommitish	"The type of 'aCommitish' depends on how each backend internal representation. "	^ self frontend		commitAt: (self commitIdFrom: aCommitish )		ifAbsentPut: [ self class parseCommitInfo: aCommitish ]! !!TIceRepositoryBackend methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!isMissing	^ self repositoryDirectory isNil 		or: [ self repositoryDirectory exists not ]! !!TIceRepositoryBackend methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!isPackageEntry: entry	^ entry isDirectory and: [ self canReadFileNamed: entry name ]	! !!TIceRepositoryBackend methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!lookupPackages	^ (self packageEntries		collect: [ :entry |			entry packageName -> (IceSavedPackage 				named: entry packageName				repository: self frontend).		])		asDictionary! !!TIceRepositoryBackend methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!merge: aCommitId into: aBranchName	| currentBranchName |	currentBranchName := self branch name.	[ 		self checkoutBranch: aBranchName.		self merge: aCommitId ]	ensure: [ 		self checkoutBranch: currentBranchName ]! !!TIceRepositoryBackend methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!packageEntries	self codeDirectory exists ifFalse: [ ^ #() ].	^ self codeDirectory entries 		select: [ :entry | self isPackageEntry: entry ]	! !!LGitCredentialsSSH methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!readFrom: credentials	self username: credentials username.	self passphrase: credentials keyPassphrase.  	self publicKeyReference: credentials publicKey asFileReference.	self privateKeyReference: credentials privateKey asFileReference! !!MCWorkingCopy methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!loadedVersion	self ancestors do: [ :ancestor |		(self repositoryGroup 			versionWithInfo: ancestor			ifNone: [ MCRepositoryGroup default versionWithInfo: ancestor ifNone: [] ])			ifNotNil: [ :version | ^ version ]	].! !!IceMCVersionInfo class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!package: package message: commitMessage	^ self new fromPackage: package message: commitMessage! !!IceMCVersionInfo class methodsFor: 'utility' stamp: ' 7/21/2017 17:44:57'!uuidFromCommit: aCommit package: aPackage.	^ self uuidFromSHA: (SHA1 new hashStream: (ReadStream on: aCommit id, aPackage name))! !!IceMCVersionInfo class methodsFor: 'utility' stamp: ' 7/21/2017 17:44:57'!uuidFromSHA: cid	"Return an adequate uuid from a git commit ID. Copied from GitFileTree."	^ UUID nilUUID		in: [ :uuid |			1 to: 16 do: [ :i | uuid at: i put: (cid at: i) ].			uuid at: 9 put: (16r80 bitOr: ((uuid at: 9) bitAnd: 16r3F)).	"Type"			uuid at: 7 put: (16r50 bitOr: ((uuid at: 7) bitAnd: 16r0F)).	"Version 5 : SHA-1 Namespace (git)."			uuid ]! !!IceMCVersionInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commit	^ commit! !!IceMCVersionInfo methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!fromCommit: aCommit package: aPackage	"This method can be used for first initializing a version info or to update a partially initialized version info."	"See #fromPackage:message:"	commit := aCommit.	package := aPackage.	   	date := commit datetime asDate.   	time := commit datetime asTime.		name := ('{1}-{2}.{3}' format: {		package name. 		commit compatibleUsername. 		commit datetime asUnixTime 	}).		id := self class uuidFromCommit: aCommit package: aPackage.   	message := commit comment.   	author := commit compatibleUsername! !!IceMCVersionInfo methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!fromPackage: package message: commitMessage	"This creates a partial version info. Full version info can not be created until we commit into a repository, 	but current fileout tools require it, so we first create an incomplete info and after committing it will be completed	by sending #fromCommit:package:		To improve this implementation we should review the fileout process."	name := ('{1}-{2}.{3}' format: {package name. Author fullName. 'unknown'}).	message := commitMessage.! !!IceMCVersionInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!iceVersion	^ commit versionFor: package! !!IceMCVersionInfo methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!loadAncestorsAndStepChildren	self shouldBeImplemented ! !!IceMCVersionInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!package	^ package! !!MCClassDefinition methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!classCategory	"Avoid direct use of #category, because MCClassDefinitions and 	MCMethodDefinition use the same message for different things. "	^ self category! !!MCVersion methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!directoryName	^ (MCFileTreeRepository parseName: self info name) first , '.package'! !!ManifestIceberg class methodsFor: 'code-critics' stamp: ' 7/21/2017 17:44:57'!ruleRBReturnsBooleanAndOtherRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#IceRepositoryModel #canPush #false)) #'2016-10-25T18:44:14.262953+02:00') )! !!ManifestIceberg class methodsFor: 'code-critics' stamp: ' 7/21/2017 17:44:57'!ruleRBTempsReadBeforeWrittenRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#IceRepository #outgoingCommits #false)) #'2016-06-16T17:24:18.524965+02:00') #(#(#RGMethodDefinition #(#IceMCGitRepository #outgoingCommits #false)) #'2016-07-06T15:14:46.350843+02:00') )! !!ManifestIceberg class methodsFor: 'code-critics' stamp: ' 7/21/2017 17:44:57'!ruleRBUtilityMethodsRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#IceGitFileTreeCommitWalk)) #'2016-09-21T17:13:36.812598+02:00') )! !!IceMetadatalessStCypressWriter class methodsFor: 'writing' stamp: ' 7/21/2017 17:44:57'!on: aStream	^ self new stream: aStream! !!IceMetadatalessStCypressWriter methodsFor: 'writing' stamp: ' 7/21/2017 17:44:57'!writeClassDefinition: definition to: classPath	self		writeInDirectoryName: classPath		fileName: 'README'		extension: '.md'		visit: [ self writeClassComment: definition ].	self		writeInDirectoryName: classPath		fileName: 'properties'		extension: self propertyFileExtension		visit: [ self writeClassDefinition: definition ]! !!IceMetadatalessStCypressWriter methodsFor: 'writing' stamp: ' 7/21/2017 17:44:57'!writeDefinitions: aCollection	| classDirExtension extensionClasses extensionMethodDefinitions extensionMethodMap methodHolders |	self writeBasicDefinitions: aCollection.	extensionClasses := OrderedCollection new.	extensionMethodDefinitions := OrderedCollection new.	methodHolders := self classDefinitions , self traitDefinitions.	self methodDefinitions		keysAndValuesDo:			[ :className :extensionMethods | 			methodHolders				at: className				ifAbsent:					[ extensionClasses add: className.					extensionMethodDefinitions addAll: extensionMethods ] ].	extensionClasses		do: [ :className | self methodDefinitions removeKey: className ].	self		writeMethodHolderDefinitions: self traitDefinitions		extension: '.trait'		to: ''		do:			[ :definition :classPath | self writeTraitDefinition: definition to: classPath ].	self		writeMethodHolderDefinitions: self classDefinitions		extension: '.class'		to: ''		do:			[ :definition :classPath | self writeClassDefinition: definition to: classPath ].	classDirExtension := '.extension'.	extensionMethodMap := Dictionary new.	extensionMethodDefinitions		do:			[ :methodDefinition | 			| classPath |			(extensionMethodMap				at: methodDefinition className				ifAbsent:					[ extensionMethodMap						at: methodDefinition className						put: OrderedCollection new ]) add: methodDefinition.			classPath := methodDefinition className , classDirExtension				, self fileUtils pathNameDelimiter asString.			self writeExtensionClassDefinition: methodDefinition to: classPath ].	extensionMethodMap		keysAndValuesDo:			[ :className :classMethodDefinitions | 			| classPath filenameMetaMap |			filenameMetaMap := self fileNameMapFor: classMethodDefinitions.			classMethodDefinitions				do:					[ :methodDefinition | 					| filename methodPath |					filename := (filenameMetaMap at: methodDefinition classIsMeta)						at: methodDefinition selector.					classPath := methodDefinition className , classDirExtension						, self fileUtils pathNameDelimiter asString.					methodPath := classPath						,							(methodDefinition classIsMeta								ifTrue: [ 'class' ]								ifFalse: [ 'instance' ])						, self fileUtils pathNameDelimiter asString.					self						writeMethodDefinition: methodDefinition						to: methodPath						filename: filename ] ]! !!IceMetadatalessStCypressWriter methodsFor: 'writing' stamp: ' 7/21/2017 17:44:57'!writeMethodProperties: classMethodDefinitions	"We don't want to write that."	self shouldNotImplement! !!IceMetadatalessStCypressWriter methodsFor: 'writing' stamp: ' 7/21/2017 17:44:57'!writeTraitDefinition: definition to: classPath	self		writeInDirectoryName: classPath		fileName: 'README'		extension: '.md'		visit: [ self writeClassComment: definition ].	self		writeInDirectoryName: classPath		fileName: 'properties'		extension: self propertyFileExtension		visit: [ self writeTraitDefinition: definition ]! !!MCDefinition methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!addAnalysisToPackageChangeSet: aPackageChangeSet change: aChange	aPackageChangeSet addChange: aChange! !!MCDefinition methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!addToPackageChangeSet: anIcePackageChangeSet 	anIcePackageChangeSet addChangedClass: self iceClass! !!MCDefinition methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!iceClass	^ IceClassReference forDefinition: self! !!MCDefinition methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!icePackage	^ self iceClass ifNotNil: #package! !!MCPostscriptDefinition methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!addToPackageChangeSet: anIcePackageChangeSet 	"By doing nothing, this definition will not be shown in the changes tree."! !!MCMethodDefinition methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!classCategory	^ self actualClass ifNotNil: #category ifNil: [ RPackage defaultPackageName ]! !!MCMethodDefinition methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!icePackage	^ self isExtensionMethod 		ifTrue: [ Iceberg packageForCategoryNamed: (self protocol withoutPrefix: '*') ]		ifFalse: [ self iceClass package ] ! !!MCMethodDefinition methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!method	^ self actualClass >> self selector! !!IceMetadatalessFileTreeWriter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!snapshotWriterClass	^ IceMetadatalessStCypressWriter! !!IceMetadatalessFileTreeWriter methodsFor: 'visiting' stamp: ' 7/21/2017 17:44:57'!writeVersion: aVersion	"We have to do that to avoid writing the version info."	| members |	directory := (members := MCFileTreeRepository		parseName: aVersion info name) last.	self deleteExistingPackageStructureFor: members.	self fileUtils ensureDirectoryExists: self packageFileDirectory.	self initializePackageFileDirectoryCache.	self writeFormat.	self writePackage: aVersion package.	self writeDefinitions: aVersion.	aVersion dependencies do: [ :ea | self writeVersionDependency: ea ]! !!MCGitHubRepository class methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!commitIdFor: aWorkingCopy	^ aWorkingCopy repositoryGroup repositories 		detect: [ :repo | repo isKindOf: self ] 		ifFound: #commitId		ifNone: nil! !!MCGitHubRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!commitId	"This kind of repo is associated to a specific commit that was downloaded, 	sadly the only way to know it is to parse the directory name."	| repoRoot |	repoRoot := self repoPath isEmpty ifTrue: [ self directory ] ifFalse: [ self directory parent ].	^ repoRoot basename copyAfterLast: $-.! !!MCGitHubRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!commitIdFor: aMCWorkingCopy ifFound: aBlockClosure 	(aMCWorkingCopy repositoryGroup includes: self)		ifTrue: [ aBlockClosure value: self commitId ]! !!MCGitHubRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!getOrCreateIcebergRepository	| remoteUrl remote |	remoteUrl := self perform: Iceberg remoteTypeSelector.	remote := IceRemote url: remoteUrl.	^ IceRepository registry 		detect: [ :repo | repo origin referencesSameRemoteLocationAs: remote ]		ifNone: [			(IceRepositoryCreator new 				url: remoteUrl;				subdirectory: repoPath;				branchName: self projectVersion;				createRepository)				register ]! !!MCGitHubRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!httpsUrl	^ 'https://github.com/', projectPath, '.git'! !!MCGitHubRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!scpUrl	^ 'git@github.com:', projectPath, '.git'! !!MCRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!commitIdFor: aMCWorkingCopy ifFound: aBlockClosure 	"Do nothing. By default MCRepositories can not provide a commitId for you."! !!RPackage methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!iceRepository	^ Iceberg repositoryForPackage: self! !!MCClassTraitDefinition methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!classCategory	^ self category! !!LGitCommit methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!asIcebergObjectInRepository: backend	^ backend iceCommitFrom: self! !!LGitCommit methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!changesFileNamed: fileName	| lookup myVersion parentVersions |	lookup := [:commit | [ commit entryByPath: fileName ] on: Error do: [ nil ]].	myVersion := lookup value: self.	parentVersions := self parents collect: lookup.		^ (myVersion 		ifNil: [ parentVersions includes: nil ]		ifNotNil: [ parentVersions anySatisfy: [ :version | 				version notNil and: [ version objectId = myVersion objectId ]]]) not! !!FileSystemDirectoryEntry methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!packageName 	^ self asFileReference basenameWithoutExtension! !!LGitDiff methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!files	| deltaFiles |		deltaFiles := Set new.	self filesDo: [ :delta :ignored1 :ignored2 | 		deltaFiles add: delta newFile path.		0 "Continue" ].	^ deltaFiles! !!LGitDiff methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!filesDo: aBlockClosure 	^ self filesDo: aBlockClosure binaryFilesDo: aBlockClosure hunksDo: nil linesDo: nil		! !!LGitDiff methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!includesFileNamed: path	^ (self filesDo: [ :delta :second :third | 		| modifiedFileName |		modifiedFileName := delta newFile path.		(modifiedFileName beginsWith: path) asAlien	]) asBoolean.! !!LGitTreeEntry methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!name	^ self filename! !!LGitTreeEntry methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!readStreamDo: aBlock	aBlock value: (ReadStream on: self object contents asString)! !!LGitTreeEntry methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!tree	^ self object! !!LGitTag methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!asIcebergObjectInRepository: backend	^ IceTag named: self name inRepository: backend frontend! !!IceGitUsernameOrEmailNotFound class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!guessKind: anError ifNot: notBlock 	(anError messageText = 'Config value ''user.name'' was not found' 		or: [ anError messageText = 'Config value ''user.email'' was not found' 		or: [ anError messageText = 'Failed to parse signature - Signature cannot have an empty name or email' ] ])		ifTrue: [ self signal ].	notBlock value! !!IceLocalRepositoryMissing class methodsFor: 'exceptioninstantiator' stamp: ' 7/21/2017 17:44:57'!signalFor: repository	^ self new 		repository: repository;		signal! !!IceLocalRepositoryMissing methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceLocalRepositoryMissing methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!IceMissingRepositoryEntry methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!messageText	^ self name! !!IceMissingRepositoryEntry methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name	^ name! !!IceMissingRepositoryEntry methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name: anObject	name := anObject! !!IceMissingRepositoryEntry methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!owner	^ owner! !!IceMissingRepositoryEntry methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!owner: anObject	owner := anObject! !!IceVersionDoesNotExist methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!messageText	^ 'There is no version for package: {1} in  commit {2}' 		format: { 			self version packageName.			self version commit shortId		}! !!IceVersionDoesNotExist methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!version	^ version! !!IceVersionDoesNotExist methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!version: anObject	version := anObject! !!LGitReturnCodeEnum methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!asBoolean	^ self value = 0 ifTrue: false ifFalse: 		[ self value = 1 ifTrue: true ifFalse: 		[ self error: self printString, ' can''t be converted to a boolean' ]]! !!IcePackageLoaded class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!version: version 	^ self new loadedVersion: version! !!IcePackageLoaded methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!loadedVersion	^ loadedVersion! !!IcePackageLoaded methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!loadedVersion: anObject	loadedVersion := anObject! !!IceRepositoryAnnouncement class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!for: repository	^ self new repository: repository; yourself! !!IceRepositoryAnnouncement methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceRepositoryAnnouncement methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!IceRepositoryRegistryModified class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!repository: aRepository	^ self new repository: aRepository; yourself! !!IceRepositoryRegistryModified methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceRepositoryRegistryModified methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!LGitCredentialsPlaintext methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!readFrom: credentials	self username: credentials username.	self passphrase: credentials password.  ! !!MCOrganizationDefinition methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!addAnalysisToPackageChangeSet: aPackageChangeSet change: aChange	aPackageChangeSet addOrganisationChange: aChange! !!MCOrganizationDefinition methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!iceClass	^ nil! !!MCOrganizationDefinition methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!icePackage	"TODO: Refactor this, see https://github.com/npasserini/iceberg/issues/42"	self categories 		ifNotEmpty: [ ^ Iceberg packageForCategoryNamed: (self categories anyOne) ]	 	ifEmpty: nil! !!MCPatchOperation methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!addToPackageChangeSet: anIcePackageChangeSet 	self definition addToPackageChangeSet: anIcePackageChangeSet ! !!MCPatchOperation methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!asIceChangeSet	^ IceMethodChange new 		operation: self; 		yourself.! !!MCPatchOperation methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!iceClass	^ self definition iceClass! !!MCPatchOperation methodsFor: '*Iceberg-Core' stamp: ' 7/21/2017 17:44:57'!icePackage	^ self definition icePackage! !!IceAbstractCommitWalk class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!forRepository: repository	^ self new repository: repository; yourself! !!IceAbstractCommitWalk methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!commitFrom: result	^ self repository iceCommitFrom: result! !!IceAbstractCommitWalk methodsFor: 'walking' stamp: ' 7/21/2017 17:44:57'!commits	| commits |	commits := OrderedCollection new.	self commitsDo: [ :commit | commits add: commit ].	^ commits! !!IceAbstractCommitWalk methodsFor: 'walking' stamp: ' 7/21/2017 17:44:57'!commitsDo: aBlock 	self rawResultsDo: [ :result | aBlock value: (self commitFrom: result) ]! !!IceAbstractCommitWalk methodsFor: 'walking' stamp: ' 7/21/2017 17:44:57'!includesCommit: aCommit	self commitsDo: [ :commit | 		commit id = aCommit id ifTrue: [ ^ true ]].	^ false! !!IceAbstractCommitWalk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!maxNumber	^ maxNumber! !!IceAbstractCommitWalk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!maxNumber: anObject	maxNumber := anObject! !!IceAbstractCommitWalk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!modifyingPackage	^ modifyingPackage! !!IceAbstractCommitWalk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!modifyingPackage: anObject	modifyingPackage := anObject! !!IceAbstractCommitWalk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceAbstractCommitWalk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!IceAbstractCommitWalk methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!upto: aCommitish	aCommitish hideYourselfFromCommitWalk: self! !!IceAbstractCommitWalk methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!uptoBranch: anIceBranch 	self uptoCommit: anIceBranch lastCommit! !!IceAbstractCommitWalk methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!uptoBranches: branches	^ branches do: [ :branch | self uptoBranch: branch ]! !!IceAbstractCommitWalk methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!uptoCommits: commits	commits do: [ :commit | self uptoCommit: commit  ]! !!IceAbstractCommitWalk methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!uptoVersion: version	version hideYourselfFromCommitWalk: self! !!IceAbstractCommitWalk methodsFor: 'walking' stamp: ' 7/21/2017 17:44:57'!versionsFor: package	self modifyingPackage: package.	^ self commits collect: [ :commit | commit versionFor: package ]! !!IceAbstractCommitWalk methodsFor: 'walking' stamp: ' 7/21/2017 17:44:57'!versionsFor: package detect: selectBlock ifNone: ifNoneBlock	self modifyingPackage: package.	self commitsDo: [ :commit | 		| version | 		version := commit versionFor: package.		(selectBlock value: version) ifTrue: [ ^ version ]	].	^ ifNoneBlock value  ! !!IceAbstractDiff methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!announcer	^ announcer! !!IceAbstractDiff methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!description	^ self name! !!IceAbstractDiff methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!elements	^ elements ifNil: [ 		elements := self initialElements sorted: [ :a :b | a description < b description ] ]! !!IceAbstractDiff methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialElements	^ self subclassResponsibility ! !!IceAbstractDiff methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	super initialize.	announcer := Announcer new.! !!IceAbstractDiff methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!refresh	elements ifNotNil: [ elements do: #refresh ].	elements := nil.	announcer announce: IceChangeSetChanged new.! !!IceAbstractDiff methodsFor: 'events' stamp: ' 7/21/2017 17:44:57'!whenChangedDo: aBlock	announcer when: IceChangeSetChanged do: aBlock! !!IceChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!updateDiff: aDiffModel 	aDiffModel		contextClass: nil;		leftText: '';		rightText: ''.! !!IcePackageOrganizationChange methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!myVersion	^ self organizationDescription: self newOrganization! !!IcePackageOrganizationChange methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!newOrganization	^ newOrganization ifNil: #()! !!IcePackageOrganizationChange methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!newOrganization: anObject	newOrganization := anObject! !!IcePackageOrganizationChange methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!oldOrganization	^ oldOrganization ifNil: #()! !!IcePackageOrganizationChange methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!oldOrganization: anObject	oldOrganization := anObject! !!IcePackageOrganizationChange methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!organizationDescription: tags 	^ String streamContents: [ :stream |		stream nextPutAll:	'Package tags: '.		tags do: [ :elem | 			stream nextPutAll: String crlf;				nextPutAll: String tab;				nextPutAll: elem.	]]! !!IcePackageOrganizationChange methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!removedCategories	^ self oldOrganization difference: self newOrganization ! !!IcePackageOrganizationChange methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!theirVersion	^ self organizationDescription: self oldOrganization! !!IcePackageOrganizationChange methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!updateDiff: aDiffModel	aDiffModel		contextClass: nil;		leftText: (self organizationDescription: self newOrganization);		rightText: (self organizationDescription: self oldOrganization).! !!IceClassChangeSet class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!class: aClass parent: anIcePackageChangeSet 	^ self new 		targetClass: aClass; 		parent: anIcePackageChangeSet; 		yourself.! !!IceClassChangeSet methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!analyseChanges	| newChanges |	newChanges := self parent changes select: [ :operation | 		operation iceClass = self targetClass ].		newChanges		detect: [ :operation | operation definition isClassDefinition ]		ifFound: [ :classDef | 			classDefinition := classDef. 			changes := newChanges copyWithout: classDef.		]		ifNone: [ changes := newChanges ].! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!browse	self targetClass browse! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!browseReferences	self targetClass browseReferences! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!canBeBrowsed	^ self targetClass canBeBrowsed! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!canBrowseReferences	^ self targetClass canBrowseReferences! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!changes	^ changes ifNil: [ self analyseChanges. changes ]! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!classDefinition	^ classDefinition ifNil: [ self analyseChanges. classDefinition ]! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!description	^ self targetClass description! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!icon	^ self classDefinition 		ifNotNil: #icon		ifNil: [	self isExtension			ifTrue: [ Smalltalk ui icons iconNamed: #protocolExtension ] 			ifFalse: [ self targetClass icon ]]! !!IceClassChangeSet methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialElements	^ self changes collect: #asIceChangeSet! !!IceClassChangeSet methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!isExtension	^ parent package name ~= self packageName! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!myVersion	^ self classDefinition ifNotNil: #diffToSource! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!operation	^ self classDefinition! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!package	^ self targetClass package! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageName	^ self targetClass packageName! !!IceClassChangeSet methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream 		print: self class;		nextPut: $(;		nextPutAll: targetClass description;		nextPut: $)		! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!targetClass	^ targetClass! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!targetClass: anObject	targetClass := anObject! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!theirVersion	^ self classDefinition ifNotNil: #diffFromSource! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!updateDiff: aDiffModel	self classDefinition		ifNil: [ super updateDiff: aDiffModel ]		ifNotNil: [ :cd |			aDiffModel				contextClass: nil;				leftText: cd diffToSource;				rightText: cd diffFromSource		]! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!browse	self method browse! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!canBeBrowsed	^ self operation canBeBrowsed! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!canBrowseReferences	^ false! !!IceMethodChange methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!description	^ operation definition selector! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!icon	^ self operation icon! !!IceMethodChange methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialElements	^ {}! !!IceMethodChange methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!method	^ self operation definition method! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!myVersion	^ self operation diffToSource! !!IceMethodChange methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!operation	^ operation! !!IceMethodChange methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!operation: anObject	operation := anObject! !!IceMethodChange methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!package	^ self operation definition actualClass package! !!IceMethodChange methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageName	^ self package name! !!IceMethodChange methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream nextPutAll: self class name;		nextPut: $(;		nextPutAll: operation definition summary;		nextPut: $)! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!theirVersion	^ self operation diffFromSource! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!updateDiff: aDiffModel	aDiffModel		contextClass: self operation targetClass;		leftText: self operation diffToSource;		rightText: self operation diffFromSource.! !!IcePackageChangeSet class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!package: aPackage parent: anIceDiff 	^ self new 		package: aPackage;		parent: anIceDiff;		yourself! !!IcePackageChangeSet methodsFor: 'private dispatch' stamp: ' 7/21/2017 17:44:57'!addChange: change	changes add: change! !!IcePackageChangeSet methodsFor: 'visiting' stamp: ' 7/21/2017 17:44:57'!addChangedClass: anIceClassReference 	changedClasses add: anIceClassReference ! !!IcePackageChangeSet methodsFor: 'private dispatch' stamp: ' 7/21/2017 17:44:57'!addOrganisationChange: change	change isAddition ifTrue: [ ^ self newOrganization: change definition categories ].	change isRemoval ifTrue: [ ^ self oldOrganization: change definition categories ].	self error: 'Can not handle definition'.! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!analyseChanges	| newChanges |	newChanges := self basicChanges.	newChanges ifEmpty: [ 		(self package isLoaded 			and: [ self package isModified			and: [(self parent myVersion isKindOf: IceWorkingCopy) 			and: [ self parent theirVersion isKindOf: IceLoadedCode ]]])			ifTrue: [ self package workingCopy modified: false ]].		changes := OrderedCollection new.	newChanges do: [ :change | 		change definition 			addAnalysisToPackageChangeSet: self			change: change ]! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!basicChanges	| mine theirs |	self package isLoaded ifFalse: [ ^ #() ].	mine := self parent mySnapshot: self package.	theirs := (self package isExported 		ifTrue: [ self parent theirSnapshot: self package ]		ifFalse: [ MCSnapshot empty ]).	^ (mine notNil and: [ theirs notNil ]) 		ifTrue: [ (MCPatch fromBase: theirs target: mine) operations ]		ifFalse: [ #() ]! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!basicOrganizationChange	^ organizationChange ifNil: [ organizationChange := IcePackageOrganizationChange new. ]! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!browse	self package browse! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!canBeBrowsed	^ true! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!canBrowseReferences	^ false! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!changedClasses	^ (self changes collect: #iceClass as: Set) 		sorted: [ :a :b | a description > b description ]! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!changes	^ changes ifNil: [ 		self analyseChanges. 		changes ]! !!IcePackageChangeSet methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!description	^ self package packageName! !!IcePackageChangeSet methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!hasChanged	^ self changes notEmpty or: [ self organizationChange notNil ]! !!IcePackageChangeSet methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!hasChanges	^ self elements notEmpty! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!icon	^ Smalltalk ui icons iconNamed: 		(self hasChanges 			ifTrue: [ #dirtyMonticelloPackage ]			ifFalse: [ #emptyPackage  ])! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialElements	changedClasses := Set new.	self changes do: [ :change | change addToPackageChangeSet: self ].	^ changedClasses collect: [:class | IceClassChangeSet class: class parent: self ]! !!IcePackageChangeSet methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isExtension: changeSet	^  changeSet package ~= self package correspondingRPackage! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!myVersion	^ organizationChange ifNotNil: #myVersion! !!IcePackageChangeSet methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!newOrganization: aCollectionOfTags	self basicOrganizationChange newOrganization: aCollectionOfTags ! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!oldOrganization: aCollectionOfTags	self basicOrganizationChange oldOrganization: aCollectionOfTags ! !!IcePackageChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!operation	"This operation is not modeled in MC"	^ nil! !!IcePackageChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!organizationChange	^ organizationChange ifNil: [ self analyseChanges. organizationChange ]! !!IcePackageChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!package	^ package! !!IcePackageChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!package: anObject	package := anObject! !!IcePackageChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageName	^ self package name! !!IcePackageChangeSet methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream nextPutAll: self class name;		nextPut: $(;		nextPutAll: self package packageName;		nextPut: $)! !!IcePackageChangeSet methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!refresh	changes := nil.	organizationChange := nil.	super refresh.! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!theirVersion	^ organizationChange ifNotNil: #theirVersion! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!updateDiff: aDiffModel	organizationChange 		ifNotNil: [ :change | change updateDiff: aDiffModel ]		ifNil: [ super updateDiff: aDiffModel ]! !!IceStructuralChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!description	^ self asString! !!IceStructuralChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!operation	^ self subclassResponsibility! !!IceStructuralChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageName	^ self subclassResponsibility! !!IceStructuralChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!parent	^ parent! !!IceStructuralChangeSet methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!parent: anObject	parent := anObject! !!IceDiff class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!forRepository: aRepository 	^ self new 		repository: aRepository;		myVersion: IceCommitish image;		theirVersion: aRepository loadedCode;		yourself.! !!IceDiff class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!forRepository: aRepository commit: anIceCommitInfo	^ self new 		repository: aRepository;		theirVersion: anIceCommitInfo;		yourself.! !!IceDiff class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!from: myCommitish to: theirsCommitish	^ self new 		repository: myCommitish repository;		myVersion: myCommitish;		theirVersion: theirsCommitish;		yourself.! !!IceDiff methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!canRevertChanges	^ self myVersion canRevertChanges ! !!IceDiff methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!changedPackages	^ self elements select: #hasChanged thenCollect: #package! !!IceDiff methodsFor: 'private factory' stamp: ' 7/21/2017 17:44:57'!createChangeSetFor: package	^ IcePackageChangeSet package: package parent: self! !!IceDiff methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialElements	| changedPackages |	changedPackages := self myVersion changedPackagesTo: self theirVersion.	^ changedPackages collect: [ :package | self createChangeSetFor: package ]! !!IceDiff methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	super initialize.	myVersion := IceCommitish image.! !!IceDiff methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!mySnapshot: package	^ self myVersion snapshotFor: package	! !!IceDiff methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!myVersion	^ myVersion! !!IceDiff methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!myVersion: anObject	myVersion := anObject! !!IceDiff methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut: $(;		nextPutAll: self repository location pathString;		nextPut: $)! !!IceDiff methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!refresh	self repository refresh.	elements ifNotNil: [ elements do: #refresh ].	announcer announce: IceChangeSetChanged new.! !!IceDiff methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceDiff methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject.	repository announcer weak		subscribe: IceCommited send: #refresh to: self! !!IceDiff methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!revertChange: anIceMethodChange 	self myVersion revertChange: anIceMethodChange.	self refresh.! !!IceDiff methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!theirSnapshot: package 	^ theirVersion ifNotNil: [ 		theirVersion snapshotFor: package ]! !!IceDiff methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!theirVersion	^ theirVersion! !!IceDiff methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!theirVersion: anObject	theirVersion := anObject! !!IceAbstractVersion class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!forPackage: package	^ self new package: package; yourself! !!IceAbstractVersion methodsFor: 'as yet unclassified' stamp: ' 7/21/2017 17:44:57'!beCurrent	"By default do not to anything, version should have a package manager that makes them current without Iceberg intervention."! !!IceAbstractVersion methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!incomingCommits	^ #()! !!IceAbstractVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!package	^ package! !!IceAbstractVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!package: anObject	package := anObject! !!IceAbstractVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ self package repository! !!IceAbstractVersion methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!snapshot	^ [ self mcVersion snapshot ] on: IceVersionDoesNotExist do: [ MCSnapshot empty ]! !!IceAbstractVersion methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!updated	^ self! !!IceForeignVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commit	^ nil! !!IceForeignVersion methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!description	^ self package workingCopy gtDisplayString ! !!IceForeignVersion methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!hideYourselfFromCommitWalk: commitWalk	"Do nothing. I can't filter a commit walk because I do not know my commit."! !!IceForeignVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!mcVersion	^ mcVersion ifNil: [ mcVersion := self package workingCopy loadedVersion ]! !!IceForeignVersion methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream print: self class;		nextPut: $(;		nextPutAll: 			(mcVersion 				ifNotNil: [ mcVersion printString ] 				ifNil: [ self package name ]);		nextPut: $).! !!IceSavedPackageVersion class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!forPackage: package	"Use fromCommit:package: instead"	self shouldNotImplement ! !!IceSavedPackageVersion class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!fromCommit: commit package: package	^ self new		commit: commit;		package: package;		yourself! !!IceSavedPackageVersion methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!= another	self species = another species ifFalse: [ ^ false ].		"If I both load commits are equal, we are the same version."	self commit = another commit ifTrue: [ ^ true ]. 	"If not, look for actual origination commits and compare them."	^ self originatingCommit = another originatingCommit.! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!author	^ self info author! !!IceSavedPackageVersion methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!beCurrent 	"Ensure that the working copy points to the right info."	self package workingCopy versionInfo: self info.	! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commit	^ commit! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commit: anIceCommit	commit := anIceCommit ! !!IceSavedPackageVersion methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!description	^ self commit description ! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!entry	^ entry! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!entry: anObject	entry := anObject.	entry repository: self repository! !!IceSavedPackageVersion methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!hideYourselfFromCommitWalk: commitWalk	commitWalk uptoCommit: self commit! !!IceSavedPackageVersion methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!incomingCommits	"Returns only the commits modifying this package."	^ self repository newCommitWalk 		fromHead;		uptoVersion: self; 		versionsFor: self package! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!info	^ info ifNil: [ info := IceMCVersionInfo new fromCommit: self commit package: package ]! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!info: anObject	info := anObject! !!IceSavedPackageVersion methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!isAncestorOf: anotherVersion	^ self commit isAncestorOf: anotherVersion commit! !!IceSavedPackageVersion methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!isAncestorOfCommitId: anotherCommitId	^ self commit isAncestorOf: (self repository commitAt: anotherCommitId)! !!IceSavedPackageVersion methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!isNewerThan: another	^ self info timeStamp > another info timeStamp! !!IceSavedPackageVersion methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!load	self mcVersion load.	self repository versionLoaded: self.! !!IceSavedPackageVersion methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!mcVersion	^ self repository backend mcVersionFor: self! !!IceSavedPackageVersion methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!nextVersionName	^ ('{1}-{2}.{3}' format: {		self package packageName. 		self author. 		self info versionNumber + 1	})! !!IceSavedPackageVersion methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!originatingCommit	^ originatingCommit ifNil: [ originatingCommit := 		self repository newCommitWalk 			fromCommit: self commit;			modifyingPackage: self package;			firstCommit 		]! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageName	^ self package packageName! !!IceSavedPackageVersion methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!parent	^ (self repository newCommitWalk 		fromCommit: self commit; 		modifyingPackage: self package;		maxNumber: 2;		commits)		second "First commit will be my own commit, the second is my parent"		versionFor: self package.! !!IceSavedPackageVersion methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream print: self class;		nextPut: $(;		nextPutAll: self package name.	commit ifNotNil: [ 		aStream 		nextPutAll: ', loaded from: ';		nextPutAll: commit shortId ].			originatingCommit ifNotNil: [ 		aStream 			nextPutAll: ', committed in: ';			nextPutAll: originatingCommit shortId ].			aStream nextPut: $).! !!IceTemporaryVersion methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!commit	"I am a temporary version, I am not related to any commit or it is unknown. 	When computing a reference commit I must be ignored."	^ nil! !!IceTemporaryVersion methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!snapshot	"I am only a temporary version, I can't provide a meaningful snapshot"	^ MCSnapshot empty! !!IceTemporaryVersion methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!updated	| newVersion |	newVersion := self package computeLoadedVersion.	self package repository loadedCode versionLoaded: newVersion.	^ newVersion! !!IceBackendWriterAdapter class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!for: anIceBackend	^ self new backend: anIceBackend; yourself.! !!IceBackendWriterAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!backend	^ backend! !!IceBackendWriterAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!backend: anObject	backend := anObject! !!IceBackendWriterAdapter methodsFor: 'accesing' stamp: ' 7/21/2017 17:44:57'!directory	^ self backend codeDirectory ! !!IceBackendWriterAdapter methodsFor: 'acessing' stamp: ' 7/21/2017 17:44:57'!propertyFileExtension	^ MCFileTreeRepository defaultPropertyFileExtension! !!IceClassReference class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!forDefinition: anMCDefinition	^ anMCDefinition actualClass 		ifNil: [ IceRemovedClassReference for: anMCDefinition ]		ifNotNil: [:class | IceSimpleClassReference new targetClass: class ]! !!IceClassReference methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!= other	^ other class = self class and: [ other description = self description ]! !!IceClassReference methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!hash	^ self description hash! !!IceRemovedClassReference class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!for: aMCClassDefinition 	^ self new		targetClassName: aMCClassDefinition className;		packageName: aMCClassDefinition classCategory		yourself! !!IceRemovedClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!browse	IceTool uiManager 		abort: ('Class {1} was removed from the system' format: { self targetClassName })		title: 'Unable to browse class'! !!IceRemovedClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!canBeBrowsed	^ false! !!IceRemovedClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!canBrowseReferences	^ false! !!IceRemovedClassReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!description	^ self targetClassName ! !!IceRemovedClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!icon	^ Smalltalk ui icons iconNamed: #changeRemove ! !!IceRemovedClassReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageName	^ packageName! !!IceRemovedClassReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageName: anObject	packageName := anObject! !!IceRemovedClassReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!targetClassName	^ targetClassName! !!IceRemovedClassReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!targetClassName: anObject	targetClassName := anObject! !!IceSimpleClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!browse	self targetClass browse! !!IceSimpleClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!browseReferences	self systemNavigation browseAllCallsOnClass: self targetClass! !!IceSimpleClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!canBeBrowsed	^ true! !!IceSimpleClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!canBrowseReferences	^ true! !!IceSimpleClassReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!description	^ self targetClass name! !!IceSimpleClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!icon	^ Smalltalk ui icons iconNamed: #class! !!IceSimpleClassReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageName	^ self targetClass package name! !!IceSimpleClassReference methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream 		print: self class;		nextPut: $(;		print: self targetClass;		nextPut: $)! !!IceSimpleClassReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!targetClass	^ targetClass! !!IceSimpleClassReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!targetClass: anObject	targetClass := anObject! !!IceBranch class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isRemoteBranchName: branchName	^ ((branchName beginsWith: 'refs/remotes/') 		or: [ branchName beginsWith: 'remotes/' ])! !!IceBranch class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!named: branchName inRepository: repo	^ self 		named: branchName		local: (self isRemoteBranchName: branchName) not		inRepository: repo! !!IceBranch class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!named: branchName local: isLocal inRepository: repo	^ (isLocal ifTrue: IceLocalBranch ifFalse: IceRemoteBranch)		named: branchName inRepository: repo.! !!IceBranch methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!= anotherBranch	self species = anotherBranch species ifFalse: [ ^ false ].	self repository = anotherBranch repository ifFalse: [ ^ false ].	^ self name = anotherBranch name! !!IceBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!backend	^ self repository backend! !!IceBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!changedPackagesToCommitInfo: aCommitish	^ aCommitish changedPackagesToCommitInfo: self lastCommit! !!IceBranch methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!commits	^ self repository newCommitWalk fromBranch: self; commits! !!IceBranch methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!commitsNotIn: anotherBranch	^ self repository newCommitWalk		fromBranch: self;		uptoBranch: anotherBranch;		commits! !!IceBranch methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!includesCommit: commit	^ self lastCommit isDescendantOf: commit! !!IceBranch methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isLocal	^ false! !!IceBranch methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isRemote	^ false! !!IceBranch methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!lastCommit	"The first commit in the list was the last in time."	^ self repository newCommitWalk fromBranch: self; firstCommit! !!IceBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name	^ name! !!IceBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name: anObject	name := anObject! !!IceBranch methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut: $(;		nextPutAll: self name;		nextPut: $).! !!IceBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!IceBranch methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!snapshotFor: package	^ self lastCommit snapshotFor: package! !!IceBranch methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!versionsFor: package	"Will only produce versions for commits that have actual changes for the package"	^ self repository newCommitWalk 		fromBranch: self;		versionsFor: package! !!IceBranch methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!versionsFor: package detect: selectBlock ifNone: ifNoneBlock 	"Will only produce versions for commits that have actual changes for the package"	^ self repository newCommitWalk 		fromBranch: self;		versionsFor: package detect: selectBlock ifNone: ifNoneBlock ! !!IceLocalBranch class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!named: branchName inRepository: repo	^ self new 		name: (branchName withoutPrefix: 'refs/heads/'); 		repository: repo; 		yourself! !!IceLocalBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!basename	^ self name! !!IceLocalBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!committish	^ (self name includesSubstring: 'detached')		ifTrue: [ ('\(detached from ([0-9a-f]+)\)' asRegex) matches: self name; subexpression: 2 ]		ifFalse: [ self name ]! !!IceLocalBranch methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!incomingCommits	^ self upstream		ifNotNil: [ self upstream commitsNotIn: self ]		ifNil: [ #() ]! !!IceLocalBranch methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!incomingCommitsFrom: aRemote 	^ (self upstreamFor: aRemote) 		ifNotNil: [ :remoteUpstream | remoteUpstream commitsNotIn: self ]		ifNil: [ #() ]! !!IceLocalBranch methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isLocal	^ true! !!IceLocalBranch methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!outgoingCommits: aBlock	| walk | 	walk := self repository newCommitWalk fromBranch: self.	self upstream 		ifNotNil: [ walk uptoBranch: self upstream ]		ifNil: [ walk uptoBranches: (			self repository localBranches copyWithout: self) ].	aBlock cull: walk.	^ walk commits.! !!IceLocalBranch methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!outgoingCommitsTo: aRemote do: aBlock	| walk | 	walk := self repository newCommitWalk fromBranch: self.	(self upstreamFor: aRemote)		ifNotNil: [ :aRemoteBranch | walk uptoBranch: aRemoteBranch ].	aBlock cull: walk.	^ walk commits.! !!IceLocalBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!upstream	^ upstream ifNil: [ 		self backend upstream 			ifNotNil: [ :upstreamName |				upstream := (IceRemoteBranch named: upstreamName inRepository: self repository) ] ]! !!IceLocalBranch methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!upstreamFor: aRemote	^ aRemote 		upstreamForBranch: self		backend: self backend! !!IceRemoteBranch class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!named: branchName inRepository: repo	^ self new 		name: ((branchName withoutPrefix: 'refs/') withoutPrefix: 'remotes/'); 		repository: repo; 		yourself! !!IceRemoteBranch class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!remoteName: remoteName branchName: branchName inRepository: aRepository 	^ self new 		name: remoteName, '/', branchName; 		repository: aRepository; 		yourself! !!IceRemoteBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!basename	^ self name copyAfterLast: $/! !!IceRemoteBranch methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isRemote	^ true! !!IceRemoteBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remoteName	^ self name copyUpToLast: $/! !!IceCommitInfo class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!createFrom: aGitLogLine	^ self new 		initializeFrom: aGitLogLine;		yourself.! !!IceCommitInfo methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!= another	^ another species = self species and: [ self commitId = another commitId ]! !!IceCommitInfo methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!backend	^ self repository backend! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!changedPackagesTo: aCommitish	"If is first commit, it will have no parents. Answer all packages because 	 all are 'changed'"	aCommitish ifNil: [ ^ self repository savedPackages ].	^ aCommitish changedPackagesToCommitInfo: self ! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!changedPackagesToCommitInfo: aCommitInfo	| files packageNames |	files := self backend changedFilesBetween: self and: aCommitInfo.	packageNames := (files 		select: [ :each | each includesSubstring: '.package' ] 		thenCollect: [ :each | | packageName |			packageName := each copyFrom: 1 to: (each findString: '.package') - 1.			(packageName includesSubstring: '/') 				ifTrue: [ packageName copyAfterLast: $/ ]				ifFalse: [ packageName ] ])		asSet.	^ packageNames sorted		select: [ :each | self repository includesPackageNamed: each  ] 		thenCollect: [ :each | self repository packageNamed: each ]! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!comment	^ comment! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!comment: anObject	comment := anObject! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commitId	^ commitId! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commitId: anObject	commitId := anObject! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!compatibleUsername	"Timestamp of method has a very precise format that needs to be fulfiled: 				'FirstnameLastname MM/DD/YYYY HH/MM' 		Problem is that git username is different: Firstname Lastname.	To make this compatible, we remove spaces... but this can be a problem in the future... 	we'll see."	^ self username reject: [ :each | each = Character space ]	! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!datetime	^ datetime! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!datetime: anObject	datetime := anObject! !!IceCommitInfo methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!description	^ String streamContents: [ :stream | 		stream 			nextPutAll: self shortId; 			nextPutAll: ' (';			nextPutAll: self printShortTime;			nextPut: $) ]! !!IceCommitInfo methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!diffFromHead	^ IceDiff from: self repository headCommit to: self! !!IceCommitInfo methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!diffTo: aCommitInfo	^ IceDiff from: self to: aCommitInfo! !!IceCommitInfo methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!diffToParent	^ self diffTo: (self parents 			ifNotEmpty: #first			ifEmpty: [ nil ])! !!IceCommitInfo methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!hash	^ self id hash! !!IceCommitInfo methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!hideYourselfFromCommitWalk: commitWalk	commitWalk uptoCommit: self	! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!id	^ commitId! !!IceCommitInfo methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeFrom: aGitLogLine	"Reads commit info out of a git commit log line, such as: '|f659e2851cb84eb6812b19e5a820c06fb509b0d5|Nicolás Passerini|2016-05-27 09:20:49 +0200|ea6c151|Updated test method with version 2'. 	This lines are obtained with git log options: '--format=|%H|%an|%ai|%p|%s' as in IceRepository>>incomingCommits. "	| elements |	elements := $| split: aGitLogLine.	self		commitId: (elements at: 2);		username: (elements at: 3);		datetime: (DateAndTime readFrom: (elements at: 4) readStream );		parentIds: ((Character space split: (elements at: 5) trim) select: #notEmpty);		comment: (elements at: 6)! !!IceCommitInfo methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!isAncestorOf: anotherCommit	"Warning: this method considers that a commit is ancestor of itself."	^ self = anotherCommit 		or: [ anotherCommit isDescendantOf: self]! !!IceCommitInfo methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!isCurrent	^ repository loadedCode referenceCommit = self ! !!IceCommitInfo methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!isDescendantOf: aCommit	^ self repository newCommitWalk		fromCommit: self;		includesCommit: aCommit! !!IceCommitInfo methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!isLoaded	^ self isAncestorOf: repository loadedCode referenceCommit! !!IceCommitInfo methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!isMerged	^ repository branch includesCommit: self! !!IceCommitInfo methodsFor: 'detached head' stamp: ' 7/21/2017 17:44:57'!lastCommit	^ self! !!IceCommitInfo methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!load	(self changedPackagesTo: self repository loadedCode referenceCommit)		collect: [ :package | self versionFor: package ]		thenDo: [:version | version load ]! !!IceCommitInfo methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!merge	self repository merge: self! !!IceCommitInfo methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!mergeBaseWith: anotherCommit	^ self repository commitAt: 		(self repository backend mergeBaseBetween: self id and: anotherCommit id)! !!IceCommitInfo methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!mergeInto: aBranch	self repository 		merge: self		into: aBranch! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name	^ self shortId! !!IceCommitInfo methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!ownVersions	^ self repository savedPackages collect: [ :package | 		self versionFor: package ]! !!IceCommitInfo methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!packageNames	^ self repository backend packagesPresentOn: self! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!parentIds	^ parentIds! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!parentIds: anObject	parentIds := anObject! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!parents	^ parents ifNil: [ 		parents := parentIds 			collect: [ :parentId | self repository commitAt: parentId ] ]! !!IceCommitInfo methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream nextPutAll: self class name;		nextPut: $(;		nextPutAll: (self commitId first: 7);		nextPutAll: ', ';		print: self datetime;		nextPutAll: ', ';		nextPutAll: comment;		nextPut: $)		 ! !!IceCommitInfo methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printShortTime	^ self datetime asDate = Date today	ifTrue: [ self datetime asTime asString ]	ifFalse: [ self datetime asDate asString ]! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!shortId	^ commitId first: 7! !!IceCommitInfo methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!snapshotFor: package 	^ (self versionFor: package) ifNotNil: #snapshot! !!IceCommitInfo methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!status	self isCurrent ifTrue: [ ^ 'Current' ].	self isLoaded ifTrue: [ ^ 'Loaded' ].	self isMerged ifTrue: [ ^ 'Not loaded' ].	^ 'Not merged'! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!username	^ username! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!username: anObject	username := anObject! !!IceCommitInfo methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!versionFor: package	^ IceSavedPackageVersion fromCommit: self package: package! !!IceCommitInfo methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!versionsChangedSince: anotherCommit	| changes | 		changes := OrderedCollection new.	self repository loadedPackages do: [ :package | 		| myVersion theirVersion |		myVersion := self versionFor: package.		theirVersion := anotherCommit versionFor: package.		(myVersion = theirVersion)			ifFalse: (changes add: myVersion)	].		^ changes! !!IceCommitInfo methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!versionsFor: package	"Will only produce versions for commits that have actual changes for the package"	^ self repository newCommitWalk 		fromCommit: self;		versionsFor: package! !!IceCommitish class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!image	^ IceWorkingCopy instance! !!IceCommitish methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!canRevertChanges	^ false! !!IceCommitish methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!changedPackagesTo: aCommitish	"This method will implement a double dispatch, since the strategies to resolve deltas 	 change if you are comparing: 		- loaded code -> working copy		- a commit -> a branch 		- a commit -> a commit	 and they need to be treated differently"	^ self subclassResponsibility! !!IceCommitish methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!diffWith: aCommitish	^ IceDiff from: self to: aCommitish ! !!IceCommitish methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!incomingCommits	^ #()! !!IceCommitish methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!incomingCommitsFrom: aRemote	^ #()! !!IceCommitish methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!outgoingCommits	^ self outgoingCommits: []! !!IceCommitish methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!outgoingCommits: aBlockClosure 	^ #()! !!IceCommitish methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!outgoingCommitsTo: aRemote 	^ self outgoingCommitsTo: aRemote do: []! !!IceCommitish methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!outgoingCommitsTo: aRemote do: aBlock	^ #()! !!IceCommitish methodsFor: 'detached head' stamp: ' 7/21/2017 17:44:57'!refresh	"Do nothing. This provides polymorphism with IceBranches, in a repo with a detached head."! !!IceLoadedCode class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!repository: repository	^ self basicNew 		repository: repository; 		initialize; 		yourself! !!IceLoadedCode methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!changedPackagesToWorkingCopy: aWorkingCopy	| lastCommit commitPackageNames loadedPackageNames added removed |		lastCommit := self repository branch lastCommit.	commitPackageNames := lastCommit packageNames.	loadedPackageNames := self repository loadedPackages collect: #name.	added := (loadedPackageNames \ commitPackageNames) 		collect: [ :each | self repository packageNamed: each ]. 	"this will give me the removals, but I'm still don't know what to do with them	 (because if I just add it it will show them as added not as removed)"	"removed := (commitPackageNames \ loadedPackageNames)		reject: [ :each | self repository includesPackageNamed: each ]		thenCollect: [ :each | IceSavedPackage named: each repository: self repository ]."	^ added, (self loadedVersions keys select: #isModified)! !!IceLoadedCode methodsFor: 'events' stamp: ' 7/21/2017 17:44:57'!commited: newCommit changingPackages: packages	self repository addCommit: newCommit.	packages do: [ :package | self versionLoaded: (newCommit versionFor: package) ].	referenceCommit := newCommit.	repository announcer announce: IceCommited new.! !!IceLoadedCode methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!commitsNotLoaded	^ self repository newCommitWalk		fromHead;		upto: self referenceCommit;		commits ! !!IceLoadedCode methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!computeReferenceCommit	| candidates |		"1. If no code has been loaded, take HEAD commit as reference."	self loadedVersions isEmpty ifTrue: [ ^ self repository headCommit ].			"2. Happy path: see if all loaded code has the same updation commit. 	If we can't compute an updation commit for some loaded code, it means that it has been 	probably loaded from another kind of repository, we just ignore it."	candidates := (self loadedVersions collect: [:version | version commit] as: Set) reject: #isNil.	candidates size = 1 ifTrue: [ ^ candidates anyOne ].	"3. None of the loaded versions produced a non nil candidate, just use the HEAD commit"		candidates isEmpty ifTrue: [ ^ self repository headCommit ].	"4. We could try other strategies... but this should be good for now."		^ candidates detectMax: #datetime! !!IceLoadedCode methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!description	^ self loadedVersions 		ifEmpty: ['No package loaded']		ifNotEmpty: [ self referenceCommit description ] ! !!IceLoadedCode methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!loadedVersions	^ loadedVersions ifNil: [ 		loadedVersions := Dictionary new.		repository loadedPackages do: [ :pkg | self versionLoaded: pkg computeLoadedVersion ].			loadedVersions 	]! !!IceLoadedCode methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!mergeBaseWith: aCommit	^ self referenceCommit mergeBaseWith: aCommit! !!IceLoadedCode methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!referenceCommit	^ referenceCommit ifNil: [ referenceCommit := self computeReferenceCommit ]! !!IceLoadedCode methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!refresh	loadedVersions := nil.	referenceCommit := nil.! !!IceLoadedCode methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceLoadedCode methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!IceLoadedCode methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!snapshotFor: package	^ (self versionFor: package) snapshot! !!IceLoadedCode methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!versionFor: package 	^ self loadedVersions 		at: package 		ifPresent: #updated		ifAbsent: [ self loadedVersions at: package put: package computeLoadedVersion ]		! !!IceLoadedCode methodsFor: 'events' stamp: ' 7/21/2017 17:44:57'!versionLoaded: version	self loadedVersions at: version package put: version.	version beCurrent.	"Reset reference commit so that it gets recomputed the next time it is needed"	referenceCommit := nil.! !!IceTag class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!named: aTagName inRepository: anIceRepository 	^ self new name: aTagName; repository: anIceRepository; yourself! !!IceTag methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!commit	^ commit ifNil: [ commit := self repository newCommitWalk fromTag: self; firstCommit ]! !!IceTag methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!lastCommit	^ self repository backend revparseCommit: self name! !!IceTag methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name	^ name! !!IceTag methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name: anObject	name := anObject! !!IceTag methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceTag methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!IceTag methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!versionFor: package	^ self commit versionFor: package! !!IceTag methodsFor: 'as yet unclassified' stamp: ' 7/21/2017 17:44:57'!versionsFor: package 	^ self commit versionsFor: package! !!IceUnbornBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!description	^ self name! !!IceUnbornBranch methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!hideYourselfFromCommitWalk: commitWalk 	"Do nothing, I do not have commits."! !!IceUnbornBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!lastCommit	^ self ! !!IceUnbornBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name	^ '<New branch>'! !!IceUnbornBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!nameForFirstCommit	"When doing 'first commit' of an unborn branch, we need to declare the branch name, 	 we take by default 'master', because this is what most people do."	^ 'master'! !!IceUnbornBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageNames	^ #()! !!IceUnbornBranch methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!versionsFor: aPackage 	^ #()! !!IceUnknownBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!description	^ self name! !!IceUnknownBranch methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!hideYourselfFromCommitWalk: commitWalk 	"Do nothing, I do not have commits."! !!IceUnknownBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!lastCommit	^ self ! !!IceUnknownBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name	^ '<Unknown>'! !!IceUnknownBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!nameForFirstCommit	"When doing 'first commit' of an unborn branch, we need to declare the branch name, 	 we take by default 'master', because this is what most people do."	^ 'master'! !!IceUnknownBranch methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageNames	^ #()! !!IceUnknownBranch methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!versionsFor: aPackage 	^ #()! !!IceWorkingCopy class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!instance	^ Instance ifNil: [ Instance := self new ]! !!IceWorkingCopy methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!canRevertChanges	^ true! !!IceWorkingCopy methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!changedPackagesTo: aCommitish	^ aCommitish changedPackagesToWorkingCopy: self! !!IceWorkingCopy methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!revertChange: anIceMethodChange	| loader |	loader := MCPackageLoader new.	anIceMethodChange operation inverse applyTo: loader.	loader load.! !!IceWorkingCopy methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!snapshotFor: package	^ package workingCopy snapshot! !!IceCredentialsProvider class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!default	^ self providerType new! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!plaintextCredentials	^ PlaintextCredentials ifNil: [ PlaintextCredentials := IcePlaintextCredentials new ]! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!plaintextCredentials: anObject	PlaintextCredentials := anObject! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!providerType	^ ProviderType ifNil: [ ProviderType := IceCredentialsProvider ]! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!providerType: anObject	ProviderType := anObject! !!IceCredentialsProvider class methodsFor: 'settings' stamp: ' 7/21/2017 17:44:57'!settingsOn: aBuilder 	<systemsettings>	(aBuilder setting: #useCustomSsh)		parent: #Iceberg;		noOrdering;		target: self;		label: 'Use custom SSH keys';		description: 'Check if you want to have your own pair of keys (id_rsa and id_rsa.pub), without using the ssh-agent';		with: [			(aBuilder setting: #username)				target: self;				targetSelector: #sshCredentials;				label: 'SSH Username';				description: 'If you are trying to connect to github through ssh (something like git@github.com:owner/projectName), the username should be `git`'.			(aBuilder setting: #publicKey)				target: self;				targetSelector: #sshCredentials;				type: #FilePathEncoder;				label: 'Public SSH key';				description: 'The path to your private ssh key, probably /home/<userName>/.ssh/id_rsa.pub'.			(aBuilder setting: #privateKey)				target: self;				targetSelector: #sshCredentials;				type: #FilePathEncoder;				label: 'Private SSH key';				description: 'The path to your private ssh key, probably /home/<userName>/.ssh/id_rsa'.			(aBuilder setting: #keyPassphrase)				target: self;				targetSelector: #sshCredentials;				label: 'Passphrase of your SSH key'.		].		(aBuilder group: #'Plaintext Credentials')		parent: #Iceberg;		noOrdering;		with: [ 			(aBuilder setting: #username)				target: self;				targetSelector: #plaintextCredentials;				label: 'Github username';				description: 'Your github username'.			(aBuilder setting: #password)				target: self;				targetSelector: #plaintextCredentials;				type: #Password;				label: 'Your github password, if you want Iceberg to remember it, but be aware that this does not pretend to be safe.'.		]! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!sshCredentials	^ SshCredentials ifNil: [ SshCredentials := IceSshCredentials new ]! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!sshCredentials: anObject	SshCredentials := anObject! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!sshCredentialsClass	self useCustomSsh ifTrue: [ ^ LGitCredentialsSSH ].	^ LGitCredentialsSSHAgent	! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!useCustomSsh	^ UseCustomSsh ifNil: [ UseCustomSsh := false ]! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!useCustomSsh: aBoolean	UseCustomSsh := aBoolean! !!IceCredentialsProvider methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	tries := 0.! !!IceCredentialsProvider methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!plaintextCredentials	^ self class plaintextCredentials! !!IceCredentialsProvider methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!sshCredentials	^ self class sshCredentials! !!IceCredentialsProvider methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!sshCredentialsClass	^ self class sshCredentialsClass! !!IceMetacelloRepositoryAdapter class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!for: anIceRepository 	^ self new repository: anIceRepository; yourself! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!addTo: aMCRepositoryGroup 	^ aMCRepositoryGroup addBasicRepository: self! !!IceMetacelloRepositoryAdapter methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!canUpgradeTo: anMCGitBasedRepository 	"Copied from MCGitBasedNetworkRepository"  (anMCGitBasedRepository isKindOf: self class) ifFalse: [ ^ false ].  ^ self projectPath = anMCGitBasedRepository projectPath 	and: [ self repoPath = anMCGitBasedRepository repoPath ]! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commitIdFor: aWorkingCopy ifFound: aBlock	self flag: #todo. "Do nothing?"! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!description	^ self repository backend description! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!getOrCreateIcebergRepository	^ self repository! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!goferPriority	^ 8! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!goferReferences	^ self repository savedPackages collect: [ :package | 		GoferResolvedReference name: package latestVersion info name repository: self ]! !!IceMetacelloRepositoryAdapter methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!hasNoLoadConflicts: anMCGitBasedRepository	"Copied from MCGitBasedNetworkRepository"  	(anMCGitBasedRepository isKindOf: self class) ifFalse: [ ^ false ].	^ self projectPath = anMCGitBasedRepository projectPath and: [		self repoPath = anMCGitBasedRepository repoPath and: [ 			self projectVersion = anMCGitBasedRepository projectVersion ] ]! !!IceMetacelloRepositoryAdapter methodsFor: 'compatibility' stamp: ' 7/21/2017 17:44:57'!isCache	"User for Kommiter and Versionner"	^ false! !!IceMetacelloRepositoryAdapter methodsFor: 'compatibility' stamp: ' 7/21/2017 17:44:57'!isRemote	"User for Komitter"	^ false! !!IceMetacelloRepositoryAdapter methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isValid	^ true! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!projectPath	^ self repository origin projectPath! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!projectVersion	^ self repository branchName! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repoPath	^ self repository subdirectory ! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repositoryDescription	^ self repository description! !!IceMetacelloRepositoryAdapter methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!repositoryVersionString	^ self repository headCommit id! !!IceMetacelloRepositoryAdapter methodsFor: 'versions' stamp: ' 7/21/2017 17:44:57'!versionFrom: aVersionName 	| packageName package version |	packageName := (MCFileTreeRepository parseName: aVersionName) first.	package := self repository packageNamed: packageName.		version := package latestVersion.	version info name = aVersionName ifFalse: [		version := package versions detect: [ :ver | ver info name = aVersionName ]].		^ version mcVersion				! !!IcePackageReference class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!named: aPackageName	^ self new 		packageName: aPackageName;		yourself! !!IcePackageReference methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!= anotherPackage	^ anotherPackage species = self species 	and: [ self packageName = anotherPackage packageName ]! !!IcePackageReference methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!browse	(RPackageOrganizer default packageNamed: self name) browse! !!IcePackageReference methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!changesIn: commitish comparedToBase: baseCommitish	^ (MCPatch 		fromBase: (baseCommitish snapshotFor: self)		target: (commitish snapshotFor: self))		operations! !!IcePackageReference methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!isLoaded	^ RPackageOrganizer default includesPackageNamed: packageName! !!IcePackageReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name	^ packageName! !!IcePackageReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageName	^ packageName! !!IcePackageReference methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageName: anObject	packageName := anObject! !!IcePackageReference methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printDescriptionOn: aStream	aStream nextPut: $(;		nextPutAll: packageName;		nextPutAll: ', ';		nextPutAll: (self isLoaded ifTrue: 'loaded' ifFalse: 'not loaded');		nextPut: $)		! !!IcePackageReference methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream nextPutAll: self class name.	self printDescriptionOn: aStream! !!IcePackageReference methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!workingCopy	^ self isLoaded ifTrue: [		MCWorkingCopy forPackage: (MCPackage named: self packageName)]! !!IcePlaintextCredentials methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isPresent	^ self username isEmpty not and: [ self password isEmpty not ]! !!IcePlaintextCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!password	^ password ifNil: [ password := '' ]! !!IcePlaintextCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!password: anObject	password := anObject! !!IcePlaintextCredentials methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!readFrom: credentials	self username: credentials username.	self password: credentials password! !!IcePlaintextCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!username	^ username ifNil: [ username := '' ]! !!IcePlaintextCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!username: anObject	username := anObject! !!IceFileRemote class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!canHandleUrl: aRepositoryUrl	^ aRepositoryUrl beginsWith: 'file:'! !!IceFileRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!detailedInfo	^ { 'Origin' -> path pathString }! !!IceFileRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!host	^ 'local filesystem'! !!IceFileRemote methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!organizer	^ 'local'! !!IceFileRemote methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!parseUrl	| matcher |	matcher := 'file\://(.*)' asRegex.	(matcher matches: url) 		ifTrue: [ 			path := (matcher subexpression: 2) asFileReference.			projectName := path basename.		]		ifFalse: [ IceWrongUrl signal: 'Could not parse  "file:" url: ', url ]! !!IceFileRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!projectName	^ path basename! !!IceHttpRemote class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!canHandleUrl: aRepositoryUrl	^ (aRepositoryUrl beginsWith: self protocolID, '://') ! !!IceHttpRemote class methodsFor: 'defaults' stamp: ' 7/21/2017 17:44:57'!defaultPort	"Returns the HTTP default port"		^80! !!IceHttpRemote class methodsFor: 'defaults' stamp: ' 7/21/2017 17:44:57'!protocolID	"Return the protocol identifier"		^'http'! !!IceHttpRemote methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!parseUrl	| matcher |	matcher := '((http|https)\://)(([\w]+)@)*([\w.]+)(\:([\d]+))*(/[\w]+)*/([\w\-]+)/([\w\-.]+(.git)?)' asRegex.	(matcher matches: url) 		ifTrue: [					user := matcher subexpression: 5.			host := matcher subexpression: 6.			port := (matcher subexpression: 8)				ifNotNil: [: x | x asInteger ] 				ifNil: [ self class defaultPort ].				 			path := (matcher subexpressions: 9)				inject: OrderedCollection new 				into: [:coll :each  | coll add: each allButFirst. coll ]. 			owner := matcher subexpression: 10.			projectName := self stripPossibleExtension: (matcher subexpression: 11) ]		ifFalse: [ IceWrongUrl signal: 'Could not parse URL: ', url ]! !!IceHttpRemote methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!stripPossibleExtension: aString	^ (aString endsWith: '.git')		ifTrue: [ aString allButLast: 4 ]		ifFalse: [ aString ]! !!IceHttpsRemote class methodsFor: 'defaults' stamp: ' 7/21/2017 17:44:57'!defaultPort	"Returns the HTTPS default port"		^443! !!IceHttpsRemote class methodsFor: 'defaults' stamp: ' 7/21/2017 17:44:57'!protocolID	"Return the protocol identifier"		^'https'! !!IceHttpsRemote methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!referencesSameRemoteLocationAs: aRemote	^ (super referencesSameRemoteLocationAs: aRemote)		or: [ self url = aRemote httpsUrl ] ! !!IceNetworkRemote class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!canHandleUrl: aString 	"I am abstract I can't handle any url."	^ false! !!IceNetworkRemote class methodsFor: 'defaults' stamp: ' 7/21/2017 17:44:57'!defaultPort	^self subclassResponsibility! !!IceNetworkRemote methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!basicUrl: aString	url := (aString endsWith: '.git') 		ifTrue: [ aString ]		ifFalse: [ aString, '.git' ]! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!detailedInfo	^ { 		'Origin' -> self url.		'Remote User' -> self userName.		'Remote host' -> (self port = self class defaultPort ifTrue: [ self host ] ifFalse: [self host, ':', self portName]).		'Repo Owner' -> self owner.	} ! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!host	^ host! !!IceNetworkRemote methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!organizer	^ self owner! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!owner	 ^ owner! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!path	^path ifNil: [ path := OrderedCollection new ].! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!port	^port ifNil: [ self class defaultPort ]! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!portName	^self port asString! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!projectPath	^ self owner, '/', self projectName! !!IceNetworkRemote methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!referencesSameRemoteLocationAs: another	^ (self url withoutSuffix: '.git') = (another url withoutSuffix: '.git')! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!user	^user! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!userName	^user ifNil: [ '' ]	! !!IceScpRemote class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!canHandleUrl: aRepositoryUrl	"Very simplistic implementation that does not cover all cases"	^ (aRepositoryUrl beginsWith: 'git@' )		or: [aRepositoryUrl beginsWith: 'ssh://']! !!IceScpRemote class methodsFor: 'defaults' stamp: ' 7/21/2017 17:44:57'!defaultPort	^ 22! !!IceScpRemote methodsFor: 'private - patches' stamp: ' 7/21/2017 17:44:57'!httpsUrl	^ 'https://{1}/{2}.git' format: { self host . self projectPath }! !!IceScpRemote methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!parseUrl	| matcher |	matcher := '(ssh\://)?(git@)?([\w.]+)(\:|/)/?([\w\-]+)/([\w\-]+)(\.git)?' asRegex.	(matcher matches: url) 		ifTrue: [			host := matcher subexpression: 4.			owner := matcher subexpression: 6.			projectName := matcher subexpression: 7.		]		ifFalse: [ IceWrongUrl signal: 'Could not parse URL: ', url ]! !!IceScpRemote methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!referencesSameRemoteLocationAs: aRemote	^ ((super referencesSameRemoteLocationAs: aRemote)		or: [ self httpsUrl = aRemote httpsUrl ])			! !!IceRemote class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!canHandleUrl: aRepositoryUrl	^ self subclassResponsibility ! !!IceRemote class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!name: aName url: anUrl	^ (self url: anUrl)		remoteName: aName;		yourself! !!IceRemote class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!url: aRepositoryUrl	self allSubclasses  		detect: [ :subclass | subclass canHandleUrl: aRepositoryUrl ]		ifFound: [ :subclass | ^ subclass new url: aRepositoryUrl ]		ifNone: [ IceWrongUrl signal: 'Remote repository scheme not supported: ', aRepositoryUrl ]! !!IceRemote methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!= another	^ self species = another species and: [ self referencesSameRemoteLocationAs: another ]	! !!IceRemote methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!basicUrl: aString	url := aString! !!IceRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!detailedInfo	^ #()! !!IceRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!host	^ self subclassResponsibility! !!IceRemote methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!httpsUrl	"This method is used to compare exchangeable addresses (https:// and git@). 	 So it has sense in my children, and is notably used on #isSameUrl: 	 implementations"	^ self url! !!IceRemote methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isOrigin	^ self remoteName = 'origin'! !!IceRemote methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isSame: aRemote	^ (self referencesSameRemoteLocationAs: aRemote)		and: [ self remoteName = aRemote remoteName ]! !!IceRemote methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!parseUrl	^ self subclassResponsibility ! !!IceRemote methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: stream	stream 		<< (self remoteName ifNil: [ 'noname' ]) 		<< ' (' << self url << ')'! !!IceRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!projectBasename	^ self projectName withoutSuffix: '.git'! !!IceRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!projectName	^ projectName! !!IceRemote methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!referencesSameRemoteLocationAs: another	"Base/trivial implementation is that two urls are the same if they are equal, 	but some subclasses have more complicated logic to detect two urls pointing to the same remote"	^ self url = another url	! !!IceRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remoteName	^ remoteName! !!IceRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remoteName: anObject	remoteName := anObject! !!IceRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!upstreamForBranch: aBranch backend: backend	^ backend 		lookupBranchNamed: aBranch name 		inRemote: self remoteName! !!IceRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!url	^ url! !!IceRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!url: aString	self basicUrl: aString.	self parseUrl! !!IceUndefinedRemote class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!canHandleUrl: aRepositoryUrl	^ false! !!IceUndefinedRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!host	^ nil! !!IceUndefinedRemote methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	super initialize.	url := 'No remote url'.	projectName := 'No name'.	remoteName := 'No remote'! !!IceUndefinedRemote methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!upstreamForBranch: aBranch backend: backend	^ nil! !!IceRepository class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!backend: aBackend	"This should be the only way to create a repository. Usually, this creator is called on 	 IceRepositoryCreator>>#createRepository."	^ self new 		backend: aBackend;		yourself! !!IceRepository class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultBackend	^ self defaultBackendType		ifNotNil: [ :className | 			Smalltalk				at: className				ifAbsent: [ IceError signal: 'Selected Iceberg backend is missing: ', className ] ]				ifNil: [ 			| backend | 			backend := self detectDefaultBackend.			self defaultBackend: backend.			backend ]! !!IceRepository class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultBackend: class	self defaultBackendType: class name! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/21/2017 17:44:57'!defaultBackendType	^ DefaultBackendType ifNil: [ DefaultBackendType := #IceLibgitLocalRepository ]! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/21/2017 17:44:57'!defaultBackendType: anObject	DefaultBackendType := anObject! !!IceRepository class methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!detectDefaultBackend	"Error if not backend"	TIceRepositoryBackend traitUsers 		ifEmpty: [ ^ IceError signal: 'There are no configured backend type' ].		"Detect default backend"	Smalltalk globals 		at: #IceLibgitLocalRepository		ifPresent: [ :class | ^ class ].		^ TIceRepositoryBackend traitUsers anyOne! !!IceRepository class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!localRepositoriesLocation	^ ((FileLocator respondsTo: #localDirectory) 		ifTrue: [ FileLocator localDirectory / #iceberg ]		ifFalse: [ FileLocator imageDirectory / #'iceberg-cache' ]) asFileReference! !!IceRepository class methodsFor: 'registry' stamp: ' 7/21/2017 17:44:57'!registerRepository: aRepository	^ self registry add: aRepository! !!IceRepository class methodsFor: 'registry' stamp: ' 7/21/2017 17:44:57'!registry	^ Registry ifNil: [ Registry := OrderedCollection new ]! !!IceRepository class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repositoriesLocation 	^ self shareRepositoriesBetweenImages 		ifTrue: [ self sharedRepositoriesLocation ]		ifFalse: [ self localRepositoriesLocation ] ! !!IceRepository class methodsFor: 'registry' stamp: ' 7/21/2017 17:44:57'!reset	Registry := nil.	Iceberg announcer announce: IceRepositoryForgotten new.! !!IceRepository class methodsFor: 'settings' stamp: ' 7/21/2017 17:44:57'!settingsOn: aBuilder 	<systemsettings>	(aBuilder pickOne: #'defaultBackendType')		parent: #Iceberg;		target: self;		label: 'Backend type';		description: 'Select your preferred way to access git repositories from Iceberg: the git command line (OSSubprocess) or the libgit2 library';		domainValues: 			((TIceRepositoryBackend traitUsers collect: [:class | class description -> class name ]) 				ifEmpty: { 'No backend' -> nil }).		(aBuilder setting: #shareRepositoriesBetweenImages)		parent: #Iceberg;		target: self;		label: 'Share repositories between images';		description: 'Check if you want to have your git repositories cloned by default in a single location that is shared between all your Pharo images';		with: [			(aBuilder setting: #sharedRepositoriesLocationString)				target: self;				type: #Directory;				label: 'Location for shared repositories';				description: 'A directory where you have your git repositories'.		].		! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/21/2017 17:44:57'!shareRepositoriesBetweenImages	^ ShareRepositoriesBetweenImages ifNil: [ ShareRepositoriesBetweenImages := false ]! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/21/2017 17:44:57'!shareRepositoriesBetweenImages: anObject	ShareRepositoriesBetweenImages := anObject! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/21/2017 17:44:57'!sharedRepositoriesLocation	^ SharedRepositoriesLocation ifNil: [ 		SharedRepositoriesLocation := (FileLocator home / #iceberg) asFileReference ]! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/21/2017 17:44:57'!sharedRepositoriesLocation: anObject	SharedRepositoriesLocation := anObject! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/21/2017 17:44:57'!sharedRepositoriesLocationString	^ self sharedRepositoriesLocation fullName! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/21/2017 17:44:57'!sharedRepositoriesLocationString: aString	SharedRepositoriesLocation := aString asFileReference! !!IceRepository class methodsFor: 'registry' stamp: ' 7/21/2017 17:44:57'!unregisterRepository: aRepository ifAbsent: aBlock	^ self registry 		remove: aRepository 		ifAbsent: aBlock ! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!addCommit: newCommit	newCommit repository: self.	self commitDictionary 		at: newCommit id 		put: newCommit! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!addFilesToIndex: aListOfPaths	^ self backend 		addFilesToIndex: aListOfPaths! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!addPackage: aWorkingCopy	^ self savedPackagesDictionary		at: aWorkingCopy packageName		ifAbsentPut: [			IceSavedPackage 				named: aWorkingCopy packageName 				repository: self ]! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!addPackageNamed: packageName	^ self savedPackagesDictionary		at: packageName		ifAbsentPut: [ IceSavedPackage named: packageName repository: self ]! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/21/2017 17:44:57'!addRemote: aRemote  	^ self backend addRemote: aRemote! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!allBranches	^ self backend allBranches	! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!announcer	^ announcer! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!announcer: anObject	announcer := anObject! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!backend	^ backend! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!backend: aBackend	aBackend validate.	aBackend frontend: self.	backend := aBackend! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!basicMerge: aCommitish	"Try automatic merge handled by the (git?) repository itself. 	Will raise an IceMergeAborted in case that automatic merge 	detects conflicts that have to be solved manually."	| currentCommit |	currentCommit := self loadedCode referenceCommit.	self backend merge: aCommitish id.	(self headCommit changedPackagesTo: currentCommit) do: #loadLatest! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!basicOrigin	self isValid ifFalse: [ ^ nil ].	^ [ self backend origin ]		on: LGit_GIT_ENOTFOUND 		do: [ :e | nil ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!beSystemRepository	system := true! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branch	self isValid ifFalse: [ ^ IceUnknownBranch new ].	^ self backend branch! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branchName	^ self branch name! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!branchesForCheckout	"Returns a list of the most useful branches for being checked out"	| branches |	branches := self backend allBranches.	^ branches select: [ :br |		br isLocal or: [ branches noneSatisfy: [:b | b isLocal and: [ b basename = br basename ]]]	].! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!branchesForMerge: aCommit	"Returns a list of local branches to which we could merge the received commit"	^ self allBranches		select: [:each | (each includesCommit: aCommit) not ].! !!IceRepository methodsFor: 'repository handling' stamp: ' 7/21/2017 17:44:57'!checkForRegistryConflicts	self class registry 		detect: [ :repo | repo location = self location ]		ifFound: [ :repo | self origin = repo origin			ifTrue: [ 				IceDuplicatedRepository signal: 					('You already have an Iceberg repository at {1} and with the same origin URL. If you really whant create another one, please locate it in a different directory.'					 format: {self location pathString}) ]			ifFalse: [				IceDuplicatedRepository signal: 					('You already have an Iceberg repository at {1} but with a different origin URL.You provided {2} and the original repository''s url is {3}.'					 format: {self location. self origin. repo origin}) ]].! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!checkoutBranch: branchName	self backend checkoutBranch: branchName! !!IceRepository methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!commitAt: commitId	commitId size = 40 		ifTrue: [ 			^ self commitDictionary 				at: commitId				ifAbsent: [ self lookupCommit: commitId ]].	"Commit id is an abbreviation, sequential search"		(self commitDictionary keys 		select: [ :key | key beginsWith: commitId ]) 		in: [ :possibleKeys | 			possibleKeys size = 1 				ifTrue: [ ^ self commitDictionary at: possibleKeys anyOne ] 				ifFalse: [ possibleKeys isEmpty 					ifTrue: [ ^ self lookupCommit: commitId ] 					ifFalse: [ self error: 'Ambiguous commit hexString: ', commitId  ]]		]! !!IceRepository methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!commitAt: commitId ifAbsentPut: aBlock	^ self commitDictionary at: commitId ifAbsentPut: [ 		| newCommit |		newCommit := aBlock value.		newCommit repository: self; yourself 	]! !!IceRepository methodsFor: 'actions - utility' stamp: ' 7/21/2017 17:44:57'!commitCherryPick: pickedCollection withMessage: message	^ self 		commitCherryPick: pickedCollection		withMessage: message		andParents: { self headCommit }! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!commitCherryPick: pickedCollection withMessage: message andParents: parentCommitishList	"Commits a snapshot of definitions (can be a cherry-pick). 	 I need to group definitions in packages and create new versions for those packages, 	 which is annoying but is the price of using MC definitions :)"	| changesByPackage versions |		versions := OrderedCollection new.	changesByPackage := SmallDictionary new.	"Collect changes by package"	pickedCollection 		do: [ :each | (changesByPackage at: each packageName ifAbsentPut: [ Set new ]) add: each ].		"Create patched versions for each package"	changesByPackage 		keysAndValuesDo: [ :packageName :changes | | workingCopy snapshot patcher |			workingCopy := (RPackageOrganizer default packageNamed: packageName) mcWorkingCopy.			snapshot := (self packageNamed: packageName) loadedVersion snapshot.			patcher := MCPatcher snapshot: snapshot.			pickedCollection 				select: [ :each | each operation notNil ]				thenDo: [ :each | each operation applyTo: patcher ].			versions add: (MCVersion new				setPackage: workingCopy package				info: (IceMCVersionInfo package: workingCopy package message: message)				snapshot: patcher patchedSnapshot				dependencies: #()) ].		"save versions"	versions do: [ :each | self backend internalStoreVersion: each ].	"now perform commit"	self doCommitMcVersions: versions withMessage: message andParents: parentCommitishList! !!IceRepository methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!commitDictionary	^ commitDictionary! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!commitIndexWithMessage: message andParents: parentCommitishList	| packages newCommit |	packages := self stagedPackages.	newCommit := self backend		commitIndexWithMessage: message andParents: parentCommitishList.	self loadedCode 		commited: newCommit changingPackages: packages.	^ newCommit! !!IceRepository methodsFor: 'actions - utility' stamp: ' 7/21/2017 17:44:57'!commitPackages: packagesToCommit withMessage: message	^ self 		commitPackages: packagesToCommit		withMessage: message		andParents: { self headCommit }! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!commitPackages: packagesToCommit withMessage: message andParents: parentCommitishList	| savedVersions |		savedVersions := packagesToCommit collect: [ :package | 		self internalSavePackage: package withMessage: message ].		self		doCommitMcVersions: savedVersions 		withMessage: message 		andParents: parentCommitishList! !!IceRepository methodsFor: 'actions - utility' stamp: ' 7/21/2017 17:44:57'!commitPackagesAndMarkAsMerged: aCommitish	^ self 		commitPackages: self modifiedPackages		withMessage: 'Merging with ', aCommitish id		andParents: { self headCommit . aCommitish }! !!IceRepository methodsFor: 'actions - utility' stamp: ' 7/21/2017 17:44:57'!commitPackagesWithMessage: message	self modifiedPackages 		ifEmpty: [ NothingToCommitException signal ]		ifNotEmpty: [ :packages |			self 				commitPackages: packages				withMessage: message ]! !!IceRepository methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!commitsNotLoaded	self backend isUnborn ifTrue: [ ^ #() ].	^ self loadedCode commitsNotLoaded! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!contentOfFileNamed: aPathString commit: aCommitId	^ self backend 		contentOfFileNamed: aPathString		commit: aCommitId! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!createBranch: branchName	self backend createBranch: branchName.! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!description	^ self origin url, '[', self branchName, ']'! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!detachRemote: aRemote	(self pushRemote isSame: aRemote) ifTrue: [ self pushRemote: nil ].	(self pullRemote isSame: aRemote) ifTrue: [ self pullRemote: nil ]! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!directoryForPackage: mcPackage	| package |	package := self packageNamed: mcPackage name.	^ self subdirectory isEmptyOrNil		ifTrue: [ package directoryName ]		ifFalse: [ self subdirectory, '/', package directoryName ]! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!doCommitMcVersions: versions withMessage: message andParents: parentCommitishList	self addFilesToIndex: (versions collect: [ :version | self directoryForPackage: version package ]).	^ self commitIndexWithMessage: message andParents: parentCommitishList! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!ensureBranch: branchName	(self hasLocalBranchNamed: branchName)		ifFalse: [ self createBranch: branchName ]! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!fetch	self fetchFrom: self pullRemote! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!fetchFrom: aRemote		self backend fetchFrom: aRemote.	self refresh.! !!IceRepository methodsFor: 'repository handling' stamp: ' 7/21/2017 17:44:57'!forget	(self class unregisterRepository: self ifAbsent: [ nil ])		ifNotNil: [ Iceberg announcer announce: (IceRepositoryForgotten repository: self) ]! !!IceRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!hasLocalBraches	^ self localBranches isNotEmpty! !!IceRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!hasLocalBranchNamed: aString	^ self backend localBranchNames includes: aString! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!headCommit	^ self branch lastCommit! !!IceRepository methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!includesCommit: anIceCommit	^ [ self commitAt: anIceCommit id. true ] 		on: LGit_GIT_ENOTFOUND do: [ false ]! !!IceRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!includesPackageNamed: aString	^ self savedPackagesDictionary includesKey: aString! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!incomingCommits	self pullRemote ifNil: [ ^ #() ].	^ self incomingCommitsFrom: self pullRemote! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!incomingCommitsFrom: aRemote	^ (SortedCollection sortBlock: [ :a :b | a datetime > b datetime ])		addAll: self commitsNotLoaded;		addAll: (self branch incomingCommitsFrom: aRemote);		yourself! !!IceRepository methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	super initialize.	system := false. "by default, this is not a system repository"	commitDictionary := Dictionary new.	self initializeAnnouncer.	loadedCode := IceLoadedCode repository: self.! !!IceRepository methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeAnnouncer	announcer 		ifNil: [ announcer := Announcer new ]		ifNotNil: [	announcer subscriptions reset ].	announcer weak		when: IceCommited, IcePackageLoaded 		send: #refresh 		to: self! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!internalSavePackage: package withMessage: commitMessage	"Save a package to the underlying store but do not commit"	| workingCopy newVersion |	workingCopy := 	package workingCopy.	"This hack is copied from MCWorkingCopy code, I do not know why it is necessary."	workingCopy modified: true; modified: false.		(workingCopy repositoryGroup includes: self backend) 		ifFalse: [ workingCopy repositoryGroup addRepository: self backend ].	newVersion := MCVersion new		setPackage: workingCopy package		info: (IceMCVersionInfo package: package message: commitMessage)		snapshot: workingCopy package snapshot		dependencies: #(). "Note we do not track Monticello dependencies."	self backend internalStoreVersion: newVersion.	SystemAnnouncer uniqueInstance		announce: (MCVersionSaved version: newVersion repository: self backend).		^ newVersion ! !!IceRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isCodeMissing	^ self backend isCodeMissing! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!isFilePartOfAPackage: aFileReferenceRelativeToRepositoryDirectory	| packageSuffix segments |	packageSuffix := '.package'.	segments := aFileReferenceRelativeToRepositoryDirectory path segments.	^ self subdirectory isEmptyOrNil		ifTrue: [ segments first endsWith: packageSuffix ]		ifFalse: [  (segments first = self subdirectory) and: [ segments second endsWith: packageSuffix ] ]! !!IceRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isMissing	^ self backend isMissing ! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!isModified	^ self loadedPackages anySatisfy: #isModified! !!IceRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isPullRemote: aRemote	^ self pullRemote isSame: aRemote! !!IceRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isPushRemote: aRemote	^ self pushRemote isSame: aRemote! !!IceRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isSystemRepository	"Indicated if this repository is a system repository (for example, 'pharo' itself).	 This is useful because we do not want to treat all repositories the same. System 	 repositories, although present, shouldn't be visible by default (unless desired), 	 for example"	^ system! !!IceRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isValid	self flag: #todo. "Make this tests more solid"	^ self isMissing not		and: [ self isCodeMissing not ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!loadedCode	^ loadedCode! !!IceRepository methodsFor: 'working copies' stamp: ' 7/21/2017 17:44:57'!loadedPackages	^ self savedPackages select: #isLoaded! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!localBranches	^ self backend localBranchNames collect: [ :branchName | 		IceLocalBranch named: branchName inRepository: self ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location	^ self backend location! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location: aFileReference	self backend location: aFileReference.	aFileReference ifNil: [ ^ self ].	name := nil. "New location may mean new repository with new name"	self refresh.	! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!lookupCommit: commitId	^ self backend newCommitWalk 		fromCommitId: commitId; 		firstCommit! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!merge: aCommitish	"Currently a commitish can only be an IceCommitInfo, but we should be prepared for other types of commitish."	[ self basicMerge: aCommitish ]		on: IceMergeAborted		do: [ :error | self mergeConflictsWith: aCommitish ] ! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!merge: aCommitish into: aBranch	"Currently a commitish can only be an IceCommitInfo, but we should be prepared for other 	 types of commitish."	self backend 		merge: aCommitish id 		into: aBranch basename! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!mergeBaseWith: aCommitInfo	^ self loadedCode mergeBaseWith: aCommitInfo! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!mergeConflictsWith: aCommitish	"Use version merger to create a new version. 	If all conflicts are resolved, commit it to the repository, 	marking it as parent to the received commitish."	| versionsChangedInCommit |	versionsChangedInCommit := aCommitish versionsChangedSince: (self mergeBaseWith: aCommitish).	(MCVersionMerger new		addVersions: (versionsChangedInCommit collect: #mcVersion);		merge)		ifTrue: [ self commitPackagesAndMarkAsMerged: aCommitish ]! !!IceRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!metacelloAdapter	^ IceMetacelloRepositoryAdapter for: self! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!modifiedPackages	^ self loadedPackages 		select: [ :package | package workingCopy needsSaving ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name	^ name ifNil: [ name := self origin projectBasename ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name: aString	"Change the name of the repository as is seen inside image (real project name resides 	 externally, in repository). This can be confusing, but some times you need it to create new 	 repositories from image (before creating repository externally... which means no remote)"	name := aString! !!IceRepository methodsFor: 'commits' stamp: ' 7/21/2017 17:44:57'!newCommitWalk	^ self backend newCommitWalk! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/21/2017 17:44:57'!origin	^ self basicOrigin 		ifNil: [ IceUndefinedRemote new ]! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!outgoingCommits	^ self branch outgoingCommits ! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!outgoingCommitsTo: aRemote	^ self branch outgoingCommitsTo: aRemote! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!packageNamed: packageName	^ self savedPackagesDictionary at: packageName! !!IceRepository methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream nextPutAll: self class name;		nextPut: $(;		nextPutAll: self origin url;		nextPut: $)! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!pull	self pullFrom: self pullRemote! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!pullFrom: aRemote	| currentCommit |	currentCommit := self loadedCode referenceCommit.	self backend pullFrom: aRemote.	self refresh.	(self headCommit changedPackagesTo: currentCommit) do: #loadLatest! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/21/2017 17:44:57'!pullRemote	^ pullRemote ifNil: [ pullRemote := self pushRemote ]! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/21/2017 17:44:57'!pullRemote: aRemote	pullRemote := aRemote! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!push	self pushTo: self pushRemote! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/21/2017 17:44:57'!pushRemote	^ pushRemote ifNil: [ pushRemote := self basicOrigin ]! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/21/2017 17:44:57'!pushRemote: aRemote	pushRemote := aRemote! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!pushTo: aRemote		self backend pushTo: aRemote.	self refresh.	self announcer announce: IcePushed new! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!refresh	self branch refresh.	self loadedCode refresh.	commitDictionary := Dictionary new.	savedPackages := nil.	self announcer announce: (IceRepositoryModified for: self)! !!IceRepository methodsFor: 'repository handling' stamp: ' 7/21/2017 17:44:57'!register	self checkForRegistryConflicts.	self class registerRepository: self.	Iceberg announcer announce: (IceRepositoryCreated repository: self).	^ self ! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/21/2017 17:44:57'!remotes	self isValid ifFalse: [ ^ #() ].	^ self backend remotes ! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/21/2017 17:44:57'!removeRemote: aRemote	self backend removeRemote: aRemote.	self detachRemote: aRemote! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!revparse: aString 	"Right now this is necessary because Metacello provides a tag objectId instead of a commitId"	^ self backend revparse: aString! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!saveContent: aString inWorkingCopyFile: aRelativePathString	| outputFile |	outputFile := (self backend repositoryDirectory fullName , '/' , aRelativePathString) asFileReference.	outputFile writeStreamDo: 		[ :stream |		stream nextPutAll: aString ].	self addFilesToIndex: { aRelativePathString }.	^ outputFile! !!IceRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!savedPackages	^ self savedPackagesDictionary values! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!savedPackagesDictionary	^ savedPackages ifNil: [ savedPackages := self backend lookupPackages ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!stagedFiles	^ self backend stagedFiles! !!IceRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!stagedPackageNames	^ self stagedFiles 		select: [ :fileRef | self isFilePartOfAPackage: fileRef ]		thenCollect: [ :fileRef | 			self subdirectory isEmptyOrNil 				ifTrue: [ fileRef path segments first asFileReference basenameWithoutExtension ] 				ifFalse: [ fileRef path segments second asFileReference basenameWithoutExtension ] ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!stagedPackages	^ self stagedPackageNames		select: [ :each | self includesPackageNamed: each ]		thenCollect: [ :packageName | self packageNamed: packageName ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!subdirectory	^ self backend subdirectory! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!subdirectory: aString	self backend subdirectory: aString.	self refresh! !!IceRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!updatePackage: packageName 	self backend pull.	(self packageNamed: packageName) loadLatest.! !!IceRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!username: aName email: anEmail global: globalBoolean	^ self backend 		username: aName 		email: anEmail 		global: globalBoolean! !!IceRepository methodsFor: 'versions handling' stamp: ' 7/21/2017 17:44:57'!versionLoaded: version 	loadedCode versionLoaded: version.	self announcer announce: (IcePackageLoaded version: version).	self refresh! !!IceRepository methodsFor: 'working copies' stamp: ' 7/21/2017 17:44:57'!workingCopies	^ self loadedPackages collect: #workingCopy! !!IceRepository methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!workingCopyDiff	^ IceDiff forRepository: self! !!IceRepository methodsFor: '*Iceberg-Changes' stamp: ' 7/21/2017 17:44:57'!workingCopyDiffToCommit: anIceCommitInfo	^ IceDiff forRepository: self commit: anIceCommitInfo! !!IceRepositoryCreator class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultSubdirectory	^ ''! !!IceRepositoryCreator class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isGitRoot: aReference	self flag: #todo. "This does not understand submodules"	^ aReference isDirectory 		and: [ (aReference directoriesMatching: '.git') notEmpty		and: [ (aReference / '.git' / 'config') exists ] ]! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branchName	^ branchName! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branchName: anObject	branchName := anObject! !!IceRepositoryCreator methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!createNewRepositoryNamed: aString	| backend locationToUse |		self validate.	locationToUse := self locationToUse.	(locationToUse exists 		and: [ locationToUse hasChildren ])		ifTrue: [ IceError signal: ('{1} is not empty.' format: {locationToUse fullName}) ].			locationToUse ensureCreateDirectory.	self subdirectory  		ifNotEmpty: [ (locationToUse / self subdirectory) ensureCreateDirectory ].	backend := self storageClass 		newRepositoryAt: locationToUse		subdirectory: self subdirectory.	backend init.	^ (IceRepository backend: backend)		name: aString;		yourself! !!IceRepositoryCreator methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!createRepository	| backend locationToUse |		self validate.	locationToUse := self locationToUse.	backend := self storageClass 		newRepositoryAt: locationToUse		subdirectory: self subdirectory.	(locationToUse exists not or: [ locationToUse hasChildren not ])		ifTrue: [ 			backend 				cloneRepositoryFrom: self remoteToUse 				branch: self branchName ].	^ IceRepository backend: backend! !!IceRepositoryCreator methodsFor: 'private accessing' stamp: ' 7/21/2017 17:44:57'!defaultLocation	| remoteToUse |	remoteToUse := self remoteToUse.	^ IceRepository repositoriesLocation 		/ remoteToUse organizer 		/ remoteToUse projectName! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location	^ location! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location: anObject	location := anObject! !!IceRepositoryCreator methodsFor: 'private accessing' stamp: ' 7/21/2017 17:44:57'!locationToUse	^ self location ifNil: [ self defaultLocation ]! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote	^ remote! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote: anObject	remote := anObject! !!IceRepositoryCreator methodsFor: 'private accessing' stamp: ' 7/21/2017 17:44:57'!remoteToUse	self remote ifNotNil: [ ^ self remote ].	self url ifNotNil: [ ^ IceRemote url: self url ]. 	^ nil! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!storageClass	^ storageClass ifNil: [ storageClass := IceRepository defaultBackend ]! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!storageClass: aClass	storageClass := aClass! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!subdirectory	^ subdirectory ifNil: [ self class defaultSubdirectory ]! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!subdirectory: anObject	subdirectory := anObject! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!url	^ url! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!url: anObject	url := anObject! !!IceRepositoryCreator methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!validate	"Validate something is provided to create the repo (I need url OR location OR remote), 	 but the 3 cannot be nil"	(self location isNil 		and: [ self remoteToUse isNil ])		ifTrue: [ IceError signal: 'No location/url or remote defined.' ].			"Validate if I will add a local repository (url isNil and location isNotNil)... testing the 	 local directory actually exists"	(self remoteToUse isNil 		and: [ self location notNil 		and: [ self location exists 		and: [ (self class isGitRoot: self location) not ] ] ])		ifTrue: [ IceError signal: ('"{1}" is not a git directory' format: { self location fullName }) ]! !!IceSavedPackage class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!named: packageName repository: repository	^ self new 		package: (IcePackageReference named: packageName); 		repository: repository; 		yourself! !!IceSavedPackage methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!= another	^ self species = another species 		and: [ self repository = another repository 		and: [ self name = another name ]]! !!IceSavedPackage methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!browse	^ self package browse! !!IceSavedPackage methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!computeLoadedVersion	| workingCopyAncestors |	workingCopyAncestors := self package workingCopy ancestors.	workingCopyAncestors ifEmpty: [ ^ IceTemporaryVersion forPackage: self ].	self workingCopy ancestors		detect: [ :ancestor | 			(ancestor respondsTo: #iceVersion) and: [ 			(ancestor commit notNil) and: [			self repository includesCommit: ancestor commit ]]]		ifFound: [ :ancestor | ^ ancestor iceVersion ].	self workingCopy repositoryGroup repositories do: [ :mcRepo |		mcRepo 			commitIdFor: self workingCopy 			ifFound: [ :commitish | 				[ 					| commit |					commit := (self repository revparse: commitish).					^ commit versionFor: self 				] 				on: LGit_GIT_ENOTFOUND 				do: [					"If we cannot parse commitish, we asume that it is a commit ID which is unknown for this repo, 					so we just ignore it. Maybe we should consider other cases and handle them adecquately."				]]	].			^ IceForeignVersion forPackage: self.! !!IceSavedPackage methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!directoryName	^ package packageName, '.package'! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!directoryPathString	^ self repository subdirectory isEmptyOrNil 		ifTrue: [ self directoryName ]		ifFalse: [ self repository subdirectory, '/',  self directoryName ].! !!IceSavedPackage methodsFor: 'comparing' stamp: ' 7/21/2017 17:44:57'!hash	^ self name hash! !!IceSavedPackage methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!incomingCommits	^ self loadedVersion incomingCommits ! !!IceSavedPackage methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isExported	| location |	location := self location.	^ location exists and: [ location hasChildren ]! !!IceSavedPackage methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isLoaded	^ self package isLoaded! !!IceSavedPackage methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isModified	^ self package workingCopy modified! !!IceSavedPackage methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!latestVersion	^ self repository headCommit versionFor: self! !!IceSavedPackage methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!loadLatest	self latestVersion load.	! !!IceSavedPackage methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!loadedVersion	^ self repository loadedCode versionFor: self! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location	| location |	 	location := self repository location.	(self directoryPathString substrings: '/')		do: [ :each | location := location / each ].	^ location! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!name	^ self package packageName! !!IceSavedPackage methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!outgoingCommits	^ self repository branch outgoingCommits: [ :walk | walk modifyingPackage: self ]! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!package	^ package! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!package: anObject	package := anObject! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageName	^ self package packageName! !!IceSavedPackage methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream nextPutAll: self class name.	self package printDescriptionOn: aStream! !!IceSavedPackage methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!reload	self latestVersion load.	! !!IceSavedPackage methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!removeFromDisk	self isLoaded ifTrue: [ 		IceError signal: 'You can''t remove a loaded package.' ].	self location ensureDeleteAll.	self repository refresh.! !!IceSavedPackage methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!removeFromDisk: force	(self isLoaded and: [ force not ]) ifTrue: [ 		IceError signal: 'You can''t remove a loaded package.' ].	self location ensureDeleteAll.	self repository refresh.! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!IceSavedPackage methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!unload	self workingCopy unload.	self repository announcer 		announce: IcePackageUnloaded new.	self repository refresh! !!IceSavedPackage methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!versionFor: aCommitId	^ (self repository commitAt: aCommitId) versionFor: self! !!IceSavedPackage methodsFor: 'versions' stamp: ' 7/21/2017 17:44:57'!versionLike: selectBlock ifNone: ifNoneBlock	"Return all versions of this package in the current branch, latest first. 	Containing info in the repo makes it easier to refresh."	^ self repository branch 		versionsFor: self 		detect: selectBlock 		ifNone: ifNoneBlock ! !!IceSavedPackage methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!versions	"Return all versions of this package in the current branch, latest first. 	Containing info in the repo makes it easier to refresh."	^ self repository branch versionsFor: self! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!workingCopy	^ self package workingCopy! !!IceSshCredentials class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultPrivateKey 		self flag: #todo. "In fact this is different for windows. We need to change this."	^ (FileLocator home asFileReference / '.ssh' / 'id_rsa') pathString! !!IceSshCredentials class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultPublicKey	self flag: #todo. "In fact this is different for windows. We need to change this."	^ (FileLocator home asFileReference / '.ssh' / 'id_rsa.pub') pathString! !!IceSshCredentials class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultUsername	^ 'git'! !!IceSshCredentials methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isPresent	^ self username notEmpty 		and: [ self publicKey notEmpty 		and: [ self privateKey notEmpty ] ]! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!keyPassphrase	^ keyPassphrase ifNil: [ keyPassphrase := '' ]! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!keyPassphrase: anObject	keyPassphrase := anObject! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!privateKey	^ privateKey ifNil: [ privateKey := self class defaultPrivateKey ]! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!privateKey: anObject	privateKey := anObject! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!publicKey	^ publicKey ifNil: [ publicKey := self class defaultPublicKey ]! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!publicKey: anObject	publicKey := anObject! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!username	^ username ifNil: [ username := self class defaultUsername ]! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!username: anObject	username := anObject! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!announcer	^ icebergAnnouncer ifNil: [ icebergAnnouncer := Announcer new ]! !!Iceberg class methodsFor: 'settings' stamp: ' 7/21/2017 17:44:57'!enableMetacelloIntegration	^ EnableMetacelloIntegration ifNil: [ EnableMetacelloIntegration := true ]! !!Iceberg class methodsFor: 'settings' stamp: ' 7/21/2017 17:44:57'!enableMetacelloIntegration: anObject	EnableMetacelloIntegration := anObject! !!Iceberg class methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!icebergRepositoriesURLs	^ {		'git@github.com:npasserini/iceberg.git'. 		'git@github.com:npasserini/filetree.git'.		'git@github.com:npasserini/LibGit.git'	}! !!Iceberg class methodsFor: 'class initialization' stamp: ' 7/21/2017 17:44:57'!initialize	| tree nodes |	tree := SystemSettingsPersistence default settingTree.	nodes := tree deeplySelect: [ :node | node receiverPackage name beginsWith: 'Iceberg' ].	SystemSettingsPersistence updateSettingNodes: nodes.! !!Iceberg class methodsFor: '*Iceberg-Adapters' stamp: ' 7/21/2017 17:44:57'!mcRepositoryFor: aLocationString	^ (IceMetacelloRepositoryType for: aLocationString) mcRepository ! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageForCategoryNamed: categoryName	| systemPackage |	systemPackage := RPackageOrganizer default packageMatchingExtensionName: categoryName.	^ self packageNamed: systemPackage name! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageNamed: packageName	^ IcePackageReference named: packageName! !!Iceberg class methodsFor: 'maintenance' stamp: ' 7/21/2017 17:44:57'!rebuildRepositories	IceRepository registry do: [ :repo | 		repo initialize.		"repo branch: nil."		repo commitDictionary.		repo loadedPackages do: [ :pkg | repo versionLoaded: pkg computeLoadedVersion ] ]! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remoteTypeSelector	"Should be #scpURL or #httpsURL"	^ RemoteTypeSelector ifNil: [ RemoteTypeSelector := #scpUrl ]! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remoteTypeSelector: anObject	RemoteTypeSelector := anObject! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repositoryForPackage: anRPackage 	| existingRepositories possibleRepositoryTypes |		existingRepositories := (MCWorkingCopy forPackage: anRPackage mcPackage) repositoryGroup repositories.	possibleRepositoryTypes := TIceRepositoryBackend traitUsers, 		{ IceMetacelloRepositoryAdapter. 		  MCGitHubRepository }.		possibleRepositoryTypes do: [ :class |		existingRepositories 			detect: [ :repo | repo isKindOf: class ]			ifFound: [ : repo |  ^ repo getOrCreateIcebergRepository ] ].	self error: ('Could not find a git repository for {1}' format: {anRPackage name})	! !!Iceberg class methodsFor: 'settings' stamp: ' 7/21/2017 17:44:57'!settingsOn: aBuilder 	<systemsettings>	(aBuilder group: #Iceberg)		parent: #SCM;		with: [ 			(aBuilder setting: #enableMetacelloIntegration)				target: self;				order: 0.1;				label: 'Enable Metacello integration';				description: 'If selected, Metacello github// repositories will be loaded using iceberg';"				icon: (Smalltalk ui icons iconNamed: #smallConfigurationIcon);"				with: [ 					(aBuilder pickOne: #remoteTypeSelector)						label: 'Remote type';						description: 'When creating an Iceberg repository out of a github:// URL choose whether you want to user an SCP URL (i.e. with the form ''git@github.com:<username>/<project>.git'') or an HTTPS URL (i.e. with the form ''https://github.com/<username>/<project>.git''';						domainValues: {							'SCP (git@github.com:<username>/<project>.git)' -> #scpUrl.							'HTTPS (https://github.com/<username>/<project>.git)' -> #httpsUrl						}.				].			(aBuilder setting: #showSystemRepositories) 				order: 0.2;				label: 'Include system repositories by default';				description: 'If checked then system repositories (like ''pharo'') will be shown in repositories list by default';				target: self.		]! !!Iceberg class methodsFor: 'settings' stamp: ' 7/21/2017 17:44:57'!showSystemRepositories	^ ShowSystemRepositories ifNil: [ ShowSystemRepositories := false ]! !!Iceberg class methodsFor: 'settings' stamp: ' 7/21/2017 17:44:57'!showSystemRepositories: aBoolean	ShowSystemRepositories := aBoolean! !!Iceberg class methodsFor: 'updating' stamp: ' 7/21/2017 17:44:57'!update	#(Iceberg LGitRepository MCFileTreeGitRepository) do: [:className | 		Smalltalk 			at: className 			ifPresent: [ :class | class package iceRepository pull ] ]! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!workingCopyForPackageNamed: packageName	^ (self packageNamed: packageName) workingCopy! !"Iceberg"!!IcePlugin commentStamp: '<historical>' prior: 0!I'm a base for all kind of plugins. I can define - repositoryActions (actions that will be added to IceRepositoriesBrowser, repositories section)- ... (TBD)!!IceBaselineInstallerPlugin commentStamp: 'EstebanLorenzano 4/7/2017 12:36' prior: 0!I'm a plugin who allows Baselines to be installed from Iceberg (just right-click and install).It adds two options to packages tab of repositories browser: - Install baseline (default)- Install baseline...2nd one allows to pick groups to install!!IcePharoFogbugzPlugin commentStamp: 'EstebanLorenzano 2/13/2017 16:59' prior: 0!I'm a pluging to handle fogbugz issues integration. It just add options to easily handle the creation of branchs with the "convention" issue naming format (number-plus-normalised-title): 12345-a-sample-of-issue-branchNOTE: In the future we can add other fogbugz elements (like list issues, etc.), but since API is very slow we will consider it very carefully. !!IcePluginManager commentStamp: '<historical>' prior: 0!I keep plugins configured for a repository. WARNING: Managers are kept in a week dictionary with Repository as a key, reason why plugins can't have any kind of reference that could cause a memory leak. Consider using stateless plugins or instance copies of relevant information instead.!!IcePharoFogbugzModel commentStamp: '<historical>' prior: 0!I'm a dialog to ask for issue number to create correct branchs for Pharo Development.!!IceRepository methodsFor: '*Iceberg-Plugin' stamp: ' 7/21/2017 17:44:57'!pluginManager	^ IcePluginManager managerFor: self! !!IceBaselineInstallerPlugin class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!baselinePrefix	^ 'BaselineOf'! !!IceBaselineInstallerPlugin class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isAvailableFor: aRepository	^ true! !!IceBaselineInstallerPlugin methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!installBaseline: icePackage groups: anArray	| packageDir baselineName |		packageDir := icePackage location parent fullName.	baselineName := icePackage name allButFirst: self class baselinePrefix size.	Metacello new		repository: 'gitlocal://', packageDir;		baseline: baselineName;		load: anArray! !!IceBaselineInstallerPlugin methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!installBaselineGroups: icePackage	| groupsString groups |		groupsString := self pickGroupsOnCancel: [ ^ self ].	groups := groupsString 		ifNotNil: [ (groupsString substrings: ',') collect: #trimBoth as: Array ]		ifNil: [ #() ].	self installBaseline: icePackage groups: groups! !!IceBaselineInstallerPlugin methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!installDefaultBaseline: icePackage	self installBaseline: icePackage groups: #()! !!IceBaselineInstallerPlugin methodsFor: 'private actions' stamp: ' 7/21/2017 17:44:57'!installDefaultBaselineAction	^ GLMGenericAction new		action: [ :presentation | self installDefaultBaseline: presentation selection entity ];		showTitle: 'Install baseline (default)'; 		yourself	! !!IceBaselineInstallerPlugin methodsFor: 'private actions' stamp: ' 7/21/2017 17:44:57'!installGroupsBaselineAction	^ GLMGenericAction new		action: [ :presentation | self installBaselineGroups: presentation selection entity ];		showTitle: 'Install baseline...'; 		yourself	! !!IceBaselineInstallerPlugin methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageActionsFor: icePackage	^ (icePackage packageName beginsWith: self class baselinePrefix) 		ifTrue: [ { self installDefaultBaselineAction. self installGroupsBaselineAction } ]		ifFalse: [ #() ]! !!IceBaselineInstallerPlugin methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!pickGroupsOnCancel: aBlock	| result |	result := UIManager default 		request: 'Groups to install (a comma separated string)' 		initialAnswer: '' 		title: 'Enter groups to install'.	result ifNil: [ ^ aBlock value ].	^ result! !!IcePharoFogbugzPlugin class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isAvailableFor: aRepository	"ATTENTION: Bad practice!!		We cannot resolve remotes during repository creation so we unfortunately need this	pluggin enabled for all repositories. Please do not create own pluggins enabled for all	repositories unless you have a very, very, very good reason."		^ true! !!IcePharoFogbugzPlugin methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!hasPharoInOrigin: aRepository	| origin |	origin := aRepository origin.	^ (origin host = 'github.com')		and: [ origin owner = 'pharo-project'		and: [ origin projectName = 'pharo' ] ]! !!IcePharoFogbugzPlugin methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!hasPharoInRemotes: aRepository	^ aRepository remotes anySatisfy: [ :aRemote |		self pharoURLs includes: aRemote url ].! !!IcePharoFogbugzPlugin methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isAvailableFor: aRepository	^ (self hasPharoInOrigin: aRepository) or: [ self hasPharoInRemotes: aRepository ]! !!IcePharoFogbugzPlugin methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!newFogbugzIssue: aRepository then: aBlock	IcePharoFogbugzModel new 		onAccept: [ :branchName | 			aRepository createBranch: branchName.			aBlock value ];		openWithSpec.! !!IcePharoFogbugzPlugin methodsFor: 'private actions' stamp: ' 7/21/2017 17:44:57'!newIssueFixAction	^ GLMGenericAction new		action: [ :presentation | 			self 				newFogbugzIssue: presentation selection repository				then: [ presentation pane browser update ] ];		category: 'Pharo';		showTitle: 'Create new branch from FogBugz issue...'; 		condition: [ :presentation | self isAvailableFor: presentation selection repository]		yourself	! !!IcePharoFogbugzPlugin methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!newPullRequest: aRepository	"(IceGitHubNewPullRequestCommand repository: aRepository) 		remote: aRepository pushRemote;		execute"! !!IcePharoFogbugzPlugin methodsFor: 'private actions' stamp: ' 7/21/2017 17:44:57'!newPullRequestAction	"This actions are copied from GitHub plugin, but presented here to make it easier"	^ GLMGenericAction new		action: [ :presenter | self newPullRequest: presenter selection repository ];		category: 'Pharo';		showTitle: 'Create pull request...'; 		condition: [ :presentation | self isAvailableFor: presentation selection repository]		yourself! !!IcePharoFogbugzPlugin methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!pharoURLs	"list of repository URLs for official Pharo upstream"	^ #(		'git@github.com:pharo-project/pharo.git' 		'https://github.com/pharo-project/pharo.git'	)! !!IcePharoFogbugzPlugin methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repositoryActions	^ { 	self newIssueFixAction.	}! !!IcePlugin class methodsFor: 'as yet unclassified' stamp: ' 7/21/2017 17:44:57'!allAvailableFor: aRepository	^ self allSubclasses select: [ :each | each isAvailableFor: aRepository ]! !!IcePlugin class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isAvailableFor: aRepository	^ self subclassResponsibility! !!IcePlugin methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageActionsFor: aPackage	"answer a list of glamour actions (GLMAction) that defines operations in the packages panel	 (in IceRepositoriesBrowser)"	^ #()! !!IcePlugin methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remoteActionsFor: aRemote	"answer a list of glamour actions (GLMAction) that defines operations in the remotes tab panel	 (in IceRepositoriesBrowser)"	^ #()! !!IcePlugin methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repositoryActions	"answer a list of glamour actions (GLMAction) that defines operations in the repository panel	 (in IceRepositoriesBrowser)"	^ #()! !!IcePluginManager class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!managerFor: aRepository	^ self managers 		at: aRepository 		ifAbsentPut: [ self basicNew initializeRepository: aRepository ].! !!IcePluginManager class methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!managers 	^ Managers ifNil: [ Managers := WeakKeyDictionary new ]! !!IcePluginManager class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!new	self error: 'Use #managerFor:'! !!IcePluginManager methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!addPlugin: aPlugin 	plugins := plugins copyWith: aPlugin! !!IcePluginManager methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!availablePluginsFor: aRepository	^ (IcePlugin allAvailableFor: aRepository) 		collect: #new		as: Array! !!IcePluginManager methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeRepository: aRepository.	self initialize.	plugins := self availablePluginsFor: aRepository! !!IcePluginManager methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!packageActionsFor: aPackage	^ self plugins		inject: #() 		into: [ :all :each | all, (each packageActionsFor: aPackage) ]! !!IcePluginManager methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!plugins 	^ plugins! !!IcePluginManager methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!remoteActionsFor: aRemote	^ self plugins 		inject: #() 		into: [ :all :each | all, (each remoteActionsFor: aRemote) ]! !!IcePluginManager methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!repositoryActions	^ self plugins 		inject: #() 		into: [ :all :each | all, (each repositoryActions) ]			! !!IcePharoFogbugzModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultExtent	^ 660@35! !!IcePharoFogbugzModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec	<spec>		^ SpecLayout composed		newRow: [ :row |			row 				add: #issueNumberText width: 50;				add: #issueText;				add: #createButton width: 80 ] height: self inputTextHeight! !!IcePharoFogbugzModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ 'New branch from FogBugz issue'! !!IcePharoFogbugzModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!unknownTitle	^ 'INVALID-ISSUE'! !!IcePharoFogbugzModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!createBranch	| branchName |		branchName := '{1}-{2}' format: { 		issueNumberText text trim. 		issueText text trim }.	acceptBlock ifNotNil: [ acceptBlock value: branchName ].	self window delete! !!IcePharoFogbugzModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!createButton	^ createButton! !!IcePharoFogbugzModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!createButton: anObject	createButton := anObject! !!IcePharoFogbugzModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ self class defaultExtent! !!IcePharoFogbugzModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	issueNumberText := self newTextInput autoAccept: true.	issueText := self newTextInput autoAccept: true.	createButton := self newButton.			issueNumberText whenBuiltDo: [ :w | w widget wrapFlag: false ]. 	issueText whenBuiltDo: [ :w | w widget wrapFlag: false ]. 	issueNumberText textHolder 		whenChangedDo: [ :text | self validateIssue: text ].		createButton 		label: 'Create';		icon: #add asIcon;		action: [ self createBranch ].			self focusOrder 		add: issueNumberText;		add: issueText;		add: createButton! !!IcePharoFogbugzModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!issueNumberText	^ issueNumberText! !!IcePharoFogbugzModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!issueNumberText: anObject	issueNumberText := anObject! !!IcePharoFogbugzModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!issueText	^ issueText! !!IcePharoFogbugzModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!issueText: anObject	issueText := anObject! !!IcePharoFogbugzModel methodsFor: 'events' stamp: ' 7/21/2017 17:44:57'!onAccept: aBlock 	acceptBlock := aBlock! !!IcePharoFogbugzModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!sanitizeTitle: aString	| separators safeSeparator |		aString isEmptyOrNil ifTrue: [ ^ self class unknownTitle ].		safeSeparator := $-.	separators := { Character space. Character tab. $_. safeSeparator }.	^ String streamContents: [ :str | 		aString do: [ :c |			(separators includes: c) ifTrue: [ str nextPut: safeSeparator ].			c isAlphaNumeric ifTrue: [ str nextPut: c ] ] ]! !!IcePharoFogbugzModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!title	^ self class title! !!IcePharoFogbugzModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!updateText: aString 	issueText text: aString! !!IcePharoFogbugzModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!validateIssue: aString	| number |	aString size = 5 ifFalse: [ ^ self ].	aString isAllDigits ifFalse: [ ^ self ].	number := aString asNumber.		(issue isNil or: [ issue number ~= number ])		ifTrue: [ 			issue := PharoIssue number: number.			[ 	"Fork to allow UI to continue"				issue downloadTitle.				World defer: [ self updateText: (self sanitizeTitle: issue title) ] ] fork ]	! !"Iceberg-Plugin"!!IceMetacelloRepositoryType commentStamp: '<historical>' prior: 0!I'm a base class to provide different type of MCRepositories from iceberg, so metacello can do his work of installing packages.My children define specific types, visit them to have more details of what you can do.!!IceGitLocalRepositoryType commentStamp: 'EstebanLorenzano 12/12/2016 10:43' prior: 0!I resolve git local repositories (repositories already existing on your disk).A gitlocal repositoy is composed of: gitlocal://full/path/to/repositorygitlocal  		- The git local identifierfull/path/...	- This is a path to the place where the sources are. 	For example, if you have a  repository in '/dev/voyage', which also has sources in subdirectory 'mc', your full path will be: '/dev/voyage/mc'. A part of my responsibilities is to find the git root  in the path provided.Example: ------------A script to install voyage using this would like more or less like this:Metacello new	repository: 'gitlocal://Users/esteban/Dev/Repository/voyage/mc';	baseline: 'Voyage';	load: 'mongo tests'.!!IceGithubRepositoryType commentStamp: 'EstebanLorenzano 12/12/2016 10:44' prior: 0!I resolve Github repositories.A github repositoy is composed of: github://username/repository[:commitish][/subdir]github  		- The github identifierusername 	- The github userrepository	- The guthub repositorycommitish	- an optional commitish (a branch, a tag, a commit id)subdir		- an optional subdirectory where the packages exist.		Example: ------------A script to install voyage using this would like more or less like this:Metacello new	repository: 'github://pharo-nosql/voyage:master/mc';	baseline: 'Voyage';	load: 'mongo tests'.!!IceMetacelloPharoPlatform commentStamp: '<historical>' prior: 0!I'm a class to add support for iceberg to metacello.!!IceGitLocalRepositoryType class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!type	^ 'gitlocal'! !!IceGitLocalRepositoryType methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isGitRoot: aReference	^ IceRepositoryCreator isGitRoot: aReference! !!IceGitLocalRepositoryType methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!mcRepository	| repository tuple extractedLocation |		tuple := self splitRootAndSubdirectoryFromLocation.	extractedLocation := tuple first asFileReference asAbsolute.	repository := IceRepository registry 		detect: [ :each | each location asAbsolute = extractedLocation ]		ifNone: [ 			(IceRepositoryCreator new 				location: tuple first;				subdirectory: tuple second;				createRepository)				register ].				^ repository metacelloAdapter! !!IceGitLocalRepositoryType methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!splitRootAndSubdirectoryFromLocation	| root subDir |		(self location beginsWith: (self class type, '://'))			ifFalse: [ self error: 'Invalid URL (It should be ', self class type, '://...)' ].	root := (self location allButFirst: self class type size + 3) asFileReference.	subDir := #().	[ root isNil or: [ self isGitRoot: root ] ] 		whileFalse: [ 			subDir := subDir copyWithFirst: root basename.			root := root parent ].	root ifNil: [ self error: 'I can''t find a .git/config file.' ].		^ { 		root. "a FileReference"		String streamContents: [ :stream | subDir asStringOn: stream delimiter: '/' ] "a String" }! !!IceGithubRepositoryType class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!type	^ 'github'! !!IceGithubRepositoryType methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!mcRepository	| baseRepo |		baseRepo := MCGitHubRepository location: self location.	(Iceberg icebergRepositoriesURLs includes: baseRepo scpUrl)		ifTrue: [ 			"Do not use Iceberg to load iceberg code, 			see https://github.com/npasserini/iceberg/issues/168"			^ baseRepo ]		ifFalse: [  			Transcript 				show: 'Creating iceberg-metacello adapter for: ';				show: self location; 				cr.			^ baseRepo getOrCreateIcebergRepository metacelloAdapter ]		! !!IceMetacelloRepositoryType class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!allTypes	^ self allSubclasses ! !!IceMetacelloRepositoryType class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!canHandleType: aType 	^ self allTypes		anySatisfy: [ :each | each isSuitableForType: aType ]  	! !!IceMetacelloRepositoryType class methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!extractTypeOf: aString 	^ aString copyUpTo: $:! !!IceMetacelloRepositoryType class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!for: aLocationString	^ (self allSubclasses		detect: [ :each | each isSuitableForLocation: aLocationString ])		location: aLocationString! !!IceMetacelloRepositoryType class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isSuitableForLocation: aLocationString	^ self isSuitableForType: (self extractTypeOf: aLocationString) ! !!IceMetacelloRepositoryType class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isSuitableForType: aType	^ self type = aType! !!IceMetacelloRepositoryType class methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!location: aLocationString	self = IceMetacelloRepositoryType 		ifTrue: [ self error: 'I''m an abstract class, use one of my children instead.' ].		^ self basicNew		initializeLocation: aLocationString;		yourself! !!IceMetacelloRepositoryType class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!type	^ self subclassResponsibility! !!IceMetacelloRepositoryType methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeLocation: aString	location := aString.	self initialize! !!IceMetacelloRepositoryType methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location	^ location! !!IceMetacelloRepositoryType methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!mcRepository	self subclassResponsibility! !!IceMetacelloPharoPlatform class methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	 self select! !!IceMetacelloPharoPlatform methodsFor: 'repository creation' stamp: ' 7/21/2017 17:44:57'!createRepository: aRepositorySpec	| type |	type := aRepositorySpec type.	type = 'ftp' ifTrue: [ | description headerSize index host directory |		description := aRepositorySpec description.		headerSize := 'ftp://' size.		index := description indexOf: $/ startingAt: headerSize + 1.		host := description copyFrom: headerSize + 1 to: index - 1.		directory := description copyFrom: index + 1 to: description size.		^ MCFtpRepository			host: host 			directory: directory 			user: aRepositorySpec username			password: aRepositorySpec password ].				(Iceberg enableMetacelloIntegration 		and: [ IceMetacelloRepositoryType canHandleType: type ])		ifTrue: [ ^ Iceberg mcRepositoryFor: aRepositorySpec description ].				^ super createRepository: aRepositorySpec! !!IceMetacelloPharoPlatform methodsFor: 'repository creation' stamp: ' 7/21/2017 17:44:57'!extractTypeFromDescription: description	(description beginsWith: 'ftp://') ifTrue: [ ^'ftp' ].	IceMetacelloRepositoryType allTypes 		detect:  [ :each | each isSuitableForLocation: description  ] 		ifFound: [ :class | ^ class type ].	^ super extractTypeFromDescription: description! !"Iceberg-Metacello-Integration"!!TIceTool commentStamp: 'NicoPasserini 9/2/2016 15:27' prior: 0!Utilities for Iceberg GUI tools.!!IceAskForPlaintextCredentialsModel commentStamp: 'NicoPasserini 11/15/2016 15:25' prior: 0!A dialog for asking plaintext credentials (username and password) to the user.!!IceAskForSshCredentialsModel commentStamp: 'EstebanLorenzano 2/8/2017 17:52' prior: 0!A dialog for asking ssh credentials to the user.!!IceAskForUsernameAndEmailModel commentStamp: '<historical>' prior: 0!I'm a dialog for asking "user.name" and "user.email" .!!IceCommitInfoModel commentStamp: '<historical>' prior: 0!I'm a simple spec model to show IceCommitInfo details. (self for: aCommitInfo) openWithSpec.!!IceCommitModel commentStamp: 'NicoPasserini 8/25/2016 14:47' prior: 0!Spec model for commit (and related) operations.!!IceCherryPickCommitModel commentStamp: '<historical>' prior: 0!Spec model for commit (and related) operations using cherry-pick.!!IceCreateRepositoryModel commentStamp: 'NicoPasserini 8/3/2016 17:51' prior: 0!Base class for avoiding code duplications between dialogs that create repositories. !!IceCloneRepositoryModel commentStamp: 'NicoPasserini 8/3/2016 18:44' prior: 0!Dialog for cloning a repository from a remote URL!!IceEditRepositoryModel commentStamp: '<historical>' prior: 0!I'm an edition dialog. I allow users to edit what is editable on an IceRepository. !!IceImportLocalRepositoryModel commentStamp: 'NicoPasserini 8/3/2016 18:45' prior: 0!Dialog for creating an Iceberg repository out of an existing local git repository.!!IceNewRepositoryModel commentStamp: '<historical>' prior: 0!I'm a repository creation dialog. I allow users to create a repository from scratch. !!IceLocationModel commentStamp: '<historical>' prior: 0!I'm an abstract model to provide locations (directories or files). I need to be included in other components (search references to my children for examples)!!IceDirectoryModel commentStamp: '<historical>' prior: 0!I'm a model to choose directories.!!IceFileModel commentStamp: '<historical>' prior: 0!I'm a model to choose files.!!IceRemoteModel commentStamp: '<historical>' prior: 0!I'm a dialog for adding remotes to repositories.!!IceGlamourSynchronizer commentStamp: 'EstebanLorenzano 2/2/2017 16:22' prior: 0!I am the syncronizer window. I am called to perform any of the basic operations of iceberg: - commit (save changes)- update (load new changes from incomming commit versions)- publish (send to central repository local commits)usually I'm called from the repositories browser, when selecting the "syncronize" option from contextual menu.!!IceTool commentStamp: 'NicoPasserini 9/2/2016 15:26' prior: 0!Utility base class for building Iceberg GUI tools.It might be better to use TIceTool instead.!!IceGlamourCommitBrowser commentStamp: '<historical>' prior: 0!I allow userts to commit current changes.!!IceGlamourPublishBrowser commentStamp: '<historical>' prior: 0!I allow users to see and publish existing local commits.!!IceGlamourUpdateBrowser commentStamp: 'NicoPasserini 10/13/2016 17:28' prior: 0!This browser allows you to see the new commits  in your [upstream](../../../wiki/Some-keys-to-understand-Git-nomenclature#upstream), browse the changes and merge them into your current branch (or load them without merging).!!IceHistoryBrowser commentStamp: 'NicoPasserini 8/23/2016 14:34' prior: 0!Shows information about branches, history of commits and the changes in each commit.!!IceBranchBrowser commentStamp: '<historical>' prior: 0!I'm a browser to compare a branch with current installed sources.!!IceRepositoriesBrowser commentStamp: 'NicoPasserini 7/24/2016 20:12' prior: 0!Main entry point to the Iceberg UI tools, shows the list of the known repositories, allows to see a resume of the status of each of them and to open the repository synchronizer.Shows- all known repositorires- resume of the status of each package in each repositoryActions - create and forget repositories- refresh repository status- synchronize a repository- load / unload packages in a repository!!IceInteractiveCredentialsProvider commentStamp: 'NicoPasserini 11/15/2016 12:15' prior: 0!A credentials provider that asks the user for credentials.!!IceRemoteAdded commentStamp: 'EstebanLorenzano 1/6/2017 09:12' prior: 0!I'm an announce that happens  when a remote has been added.!!SwappedColorDiffMorph commentStamp: 'YuriyTymchuk 4/7/2017 11:32' prior: 0!I swap colors for the original giff morph, so the additions are green and removals are red!!GLMSwappedColorDiffPresentation commentStamp: 'EstebanLorenzano 5/8/2017 13:57' prior: 0!A glamour presentation  for the swapped diff morph!!IceAbstractBranchModel commentStamp: 'CyrilFerlicot 7/9/2017 03:25' prior: 0!Description--------------------I am an abstract class to define a common API for my subclasses that will manage some actions for some branch view of Iceberg. My subclasses will encapsulate a branch or a remote.I am use in the branch view of the main browser of Iceberg.Public API and Key Messages--------------------- #children				It should return the children of my element. It will probably return the branches of a remote for the remotes and nothing for the branches.- #nameToDisplay		String to show to the user.- #status 				Status to show to the user about incomming/unpublished commits.!!IceBranchGroupModel commentStamp: 'CyrilFerlicot 7/9/2017 03:35' prior: 0!Description--------------------I represent a group of branches. I am used in two principal cases. 1) We want to group the branches of a remote2) We want to group the local branchesExamples--------------------	"For a remote"	IceBranchGroupModel repository: anIceRepository remote: anIceRemote.		"For local branches"	IceBranchGroupModel localFromRepository: anIceRepository Internal Representation and Key Implementation Points.--------------------    Instance Variables	branches:		<aBlockOrSymbol>	This block takes the repository as parameter and should return the branches of the group	groupName:		<aString>			Name of the group. In case I represent a remote it will be the remote name, else it will probably be "Local"	repository:		<anIceRepository>	The repository where to get the branches!!IceBranchModel commentStamp: 'CyrilFerlicot 7/9/2017 03:36' prior: 0!Description--------------------I represent an unique branch. I should be contained in an IceBranchGroupModel.Examples--------------------	IceBranchModel parent: anIceBranchGroupModel branch: anIceBranch Internal Representation and Key Implementation Points.--------------------    Instance Variables	branch:				<anIceBranch>				The branch I should display info for.	parentGroup:		<anIceBranchGroupModel>	The branch group inside of which I am.!!IceChangesTreeResetSelectionHelper commentStamp: '<historical>' prior: 0!I am a helper to reset selections on changes tree browser.My purpose is to allow weaks to work properly, since the browser needs to do something like this: 		onChangeOfPort: #entity act: [ :presentation :diff | 			diff ifNotNil: [ 				diff announcer weak 					subscribe: IceChangeSetChanged 					do: [ presentation selection: nil ] ] ]... but the problem is that blocks and weak announcements do not work well, because when declaring a block you take all the outer context with you, hence creating a de-facto strong reference . So we need a replacement, and I'm that replacement :)Then, that code will look like this: 	onChangeOfPort: #entity act: [ :presentation :diff | 			diff ifNotNil: [ 				diff announcer weak 					subscribe: IceChangeSetChanged 					send: #execute:					to: (IceChangesTreeResetSelectionHelper for: presentation) ] ]removing the outer context problems .!!IceDiffChangeTreeBuilder commentStamp: '<historical>' prior: 0!I'm a builder to help users to build reusable diff-changes-tree elements.I'm used in several parts, notable in the syncronize window and in th e history browser.!!IceMergeTool commentStamp: 'NicoPasserini 12/13/2016 11:44' prior: 0!This is a very basic merge tool, just for keeping some state and coordinating interation between the 'real' merge tools. Internal Representation- source: <IceCommit> indicating the source of the changes to be merged (TODO: should be a commitish).- targetBranch: <IceBranch> where we want to merge the commits. If not provided the tool will raise a dialog to ask for it.- onMerge: <block or symbol> will be executed after a successfull merge.!!IceRepositoryUpdateHelper commentStamp: 'EstebanLorenzano 12/23/2016 15:50' prior: 0!I am a helper to create update cycles on repositories browser.My purpose is to allow weaks to work properly, since the browser needs to do something like this: 		Iceberg announcer weak 		subscribe: IceRepositoryCreated 		do: [ :ann | 			table 				updateOn: IceRepositoryAnnouncement 				from: ann repository announcer ].... but the problem is that blocks and weak announcements do not work well, because when declaring a block you take all the outer context with you, hence creating a de-facto strong reference . So we need a replacement, and I'm that replacement :)Then, that code will look like this: 	Iceberg announcer weak 		subscribe: IceRepositoryCreated 		send: #execute:		to: (IceRepositoryUpdateHelper for: table).removing the outer context problems :)!!GLMMorphicSwappedColorDiffRenderer commentStamp: 'EstebanLorenzano 5/5/2017 12:19' prior: 0!A glamour renderer for the swapped diff morph!!TIceTool classTrait methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!uiManager	^ UIManager default! !!TIceTool methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!mergeIntoAnotherBranch: aCommit andThen: aBlock	"Merge selected commit into another branch"	| branches selection repository |	repository := aCommit repository.		repository isModified ifTrue: [ 		(self uiManager			confirm:'Your repository has uncommited changes. Merge will change your current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.'			label: 'You might loose your current changes!!'			trueChoice: 'Proceed anyway'			falseChoice: 'Cancel'			cancelChoice: nil			default: false) 			ifFalse: [ ^ self ].	 ].		branches := repository branchesForMerge: aCommit.	selection := self uiManager		chooseFrom: (branches collect: #name)		values: branches		message: ('Select the branch into you want to merge commit {1}' format: { aCommit shortId })		title: 'Merge your changes into another branch'.	selection ifNotNil: [ 		[ aCommit mergeInto: selection ]			on: IceMergeAborted			do: [ 				selection name = repository branchName 					ifTrue: [ repository mergeConflictsWith: aCommit ]					ifFalse: [ 						self uiManager 						abort: 'Automatic (fast-forward) merge is not possible, to merge manually please first checkout branch ', selection name, ' and then retry.' 						title: 'Automatic merge failed' ]			].		aBlock value 	]! !!TIceTool methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!pushRepository: repository andThen: aBlock	[ UIManager default informUserDuring: [ :bar | | remote |		remote := repository pushRemote.		bar label: ('Publishing local commits to {1}' format: {remote}).		repository pushTo: remote. 		aBlock value.	]] 	on: YouShouldPullBeforePush	do: [ 		self uiManager			abort: 'Publish operation is not possible because your repository is out of date. Please update your local repository and retry.'			title: 'Publishing aborted' 	]! !!TIceTool methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!uiManager	^ self class uiManager! !!MCModification methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!icon	^ Smalltalk ui icons iconNamed: #changeUpdate! !!GLMGenericAction methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!selectionAction: actionSelector	"action selector will be sent to the presentation selection. 	If it accepts one argument, the presentation will be sent."	^ self		action: [ :presentation | 			presentation selection				ifNotNil: [ :sel | (MessageSend receiver: sel selector: actionSelector) cull: presentation ] ];		enabledCondition:				[ :presentation | "This is a minimal condition, that can be overriden (refined) later" presentation selection notNil ]! !!GLMGenericAction methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!selectionCondition: selectionCondition	"selectionCondition can be anything that can respond #cull: such as a block or unary symbol.	It will only be evaluated if the presentation has a (not nil) selected element."		^ self enabledCondition: [ :presentation | 		presentation selection notNil and: [ 			selectionCondition cull: presentation selection ]]! !!GLMGenericAction methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!showTitle: aTitle	^ self title: aTitle; showTitle! !!GLMMorphicCherryPickTreeRenderer methodsFor: 'callbacks' stamp: ' 7/21/2017 17:44:57'!actOnPresentationRefreshRequest: anAnnouncement	tableMorph window ifNil: [ ^ self ].	tableMorph window isActive ifFalse: [ ^ self ].	(tableMorph window boundsInWorld containsRect: tableMorph boundsInWorld) ifFalse: [ ^ self ].  " tableModel resetElements."	tableModel resetDataCache.	tableMorph refresh! !!GLMMorphicCherryPickTreeRenderer methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!createDataSourceFrom: aPresentation	^ GLMCherryPickTreeDataSource new! !!GLMMorphicCherryPickTreeRenderer methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!specificTableMorphInitializiation	super specificTableMorphInitializiation.	tableModel glamourPresentation isAllSelected		ifTrue: [ tableModel selectAll ]! !!IceAskForPlaintextCredentialsModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec	<spec: #default>	^ SpecLayout composed newColumn: [ :col |		col newRow: [:row | row add: #usernameLabel width: 80; add: #usernameInput ] height: self inputTextHeight;			newRow: [:row | row add: #passwordLabel width: 80; add: #passwordInput ] height: self inputTextHeight;			add: #storeCheckbox height: self inputTextHeight	]! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!acceptButton	^ acceptButton! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!credentials	^ IcePlaintextCredentials new 		username: self username;		password: self password;		yourself.! !!IceAskForPlaintextCredentialsModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ (350@(		self class inputTextHeight * 3 		+ self class buttonHeight 		+ 50 "Yes, a magic number"		))! !!IceAskForPlaintextCredentialsModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	usernameLabel := self newLabel label: 'Username: '.	usernameInput := self newTextInput autoAccept: true.		passwordLabel := self newLabel label: 'Password: '.	passwordInput := self newTextInput beEncrypted; autoAccept: true.	storeCheckbox := self newCheckBox		label: 'Do you want this credentials to be stored for future use?';		help: 'Please note that storing your credentials is handy but unsafe';		state: true.		self focusOrder		add: usernameInput;		add: passwordInput;		add: storeCheckbox! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!password 	^ passwordInput text! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!passwordInput	^ passwordInput! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!passwordLabel	^ passwordLabel! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!storeCheckbox	^ storeCheckbox ! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!storeCredentials	^ storeCheckbox state ! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ 'Please log in to git'! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!username	^ usernameInput text! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!usernameInput	^ usernameInput! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!usernameLabel	^ usernameLabel! !!IceAskForSshCredentialsModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec	<spec: #default>	^ SpecLayout composed newColumn: [ :col |		col 			newRow: [:row | row add: #usernameLabel width: 100; add: #usernameInput ] height: self inputTextHeight;			newRow: #publicKeyLocation height: self inputTextHeight;			newRow: #privateKeyLocation  height: self inputTextHeight;			newRow: [:row | row add: #passwordLabel width: 100; add: #passwordInput ] height: self inputTextHeight;			add: #storeCheckbox height: self inputTextHeight ]! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!acceptButton	^ acceptButton! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!acceptButton: anObject	acceptButton := anObject! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!credentials	^ IceSshCredentials new 		username: self username;		publicKey: self publicKey;		privateKey: self privateKey;		keyPassphrase: self password;		yourself.! !!IceAskForSshCredentialsModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ (500@(		self class inputTextHeight * 5		+ self class buttonHeight 		+ 50 "Yes, a magic number"		))! !!IceAskForSshCredentialsModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	usernameLabel := self newLabel label: 'SSH Username: '.	usernameInput := self newTextInput autoAccept: true.		publicKeyLocation := self instantiate: IceFileModel.	publicKeyLocation 		label: 'Public SSH Key: ';		chooseTitle: 'Public SSH Key (id_rsa.pub)'.	privateKeyLocation := self instantiate: IceFileModel.	privateKeyLocation 		label: 'Private SSH Key: ';		chooseTitle: 'Private SSH Key (id_rsa)'.	passwordLabel := self newLabel label: 'SSH Passphrase: '.	passwordInput := self newTextInput beEncrypted; autoAccept: true.	storeCheckbox := self newCheckBox		label: 'Do you want this credentials to be stored for future use?';		state: true.		self focusOrder		add: usernameInput;		add: publicKeyLocation;		add: privateKeyLocation;		add: passwordInput;		add: storeCheckbox! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!password 	^ passwordInput text! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!passwordInput	^ passwordInput! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!passwordInput: anObject	passwordInput := anObject! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!passwordLabel	^ passwordLabel! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!passwordLabel: anObject	passwordLabel := anObject! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!privateKey	^ privateKeyLocation location! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!privateKeyLocation	^ privateKeyLocation! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!privateKeyLocation: anObject	privateKeyLocation := anObject! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!publicKey	^ publicKeyLocation location! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!publicKeyLocation	^ publicKeyLocation! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!publicKeyLocation: anObject	publicKeyLocation := anObject! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!storeCheckbox	^ storeCheckbox ! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!storeCredentials	^ storeCheckbox state ! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ 'Please provide SSH keys'! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!username	^ usernameInput text! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!usernameInput	^ usernameInput! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!usernameLabel	^ usernameLabel! !!IceAskForUsernameAndEmailModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec	<spec: #default>	^ SpecLayout composed newColumn: [ :col |		col 			newRow: [:row | row add: #nameLabel width: 100; add: #nameInput ] height: self inputTextHeight;			newRow: [:row | row add: #emailLabel width: 100; add: #emailInput ] height: self inputTextHeight;			add: #globalCheckbox height: self inputTextHeight;			add: #acceptButton height: self buttonHeight  ]! !!IceAskForUsernameAndEmailModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!accept	self username isEmptyOrNil ifTrue: [ ^ UIManager default alert: 'user.name is required.' ].	self email isEmptyOrNil ifTrue: [ ^ UIManager default alert: 'user.email is required.' ].			acceptBlock 		value: self username 		value: self email		value: self isGlobal.		self window delete.! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!acceptButton	^ acceptButton! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!acceptButton: anObject	acceptButton := anObject! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!email	^ self emailInput text trimBoth! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!emailInput	^ emailInput! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!emailInput: anObject	emailInput := anObject! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!emailLabel	^ emailLabel! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!emailLabel: anObject	emailLabel := anObject! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!globalCheckbox	^ globalCheckbox! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!globalCheckbox: anObject	globalCheckbox := anObject! !!IceAskForUsernameAndEmailModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ (400@(		self class inputTextHeight * 3		+ self class buttonHeight 		+ 50 "Yes, a magic number"		))! !!IceAskForUsernameAndEmailModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	nameLabel := self newLabel label: 'user.name'.	nameInput := self newTextInput 		ghostText: 'John Doe';		autoAccept: true.	emailLabel := self newLabel label: 'user.email'.	emailInput := self newTextInput 		ghostText: 'johndoe@mail.net';				autoAccept: true.	globalCheckbox := self newCheckBox		label: 'Save properties as global?';		state: false.	acceptButton := self newButton		label: 'Set properties';		action: [ self accept ];		yourself.					self focusOrder		add: nameInput;		add: emailInput;		add: globalCheckbox;		add: acceptButton! !!IceAskForUsernameAndEmailModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isGlobal	^ self globalCheckbox state! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!nameInput	^ nameInput! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!nameInput: anObject	nameInput := anObject! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!nameLabel	^ nameLabel! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!nameLabel: anObject	nameLabel := anObject! !!IceAskForUsernameAndEmailModel methodsFor: 'events' stamp: ' 7/21/2017 17:44:57'!onAccept: aBlock	"aBlock will receive 3 arguments: name, email, global flag"	acceptBlock := aBlock! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ 'Please provide required properties'! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!username	^ self nameInput text trimBoth! !!IceCommitInfoModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec 	<spec>	^ SpecLayout composed		newColumn: [ :c |			c 				newRow: [:row | row add: #dateLabel width: 80; add: #datePanel ] height: 25;				newRow: [:row | row add: #idLabel width: 80; add: #idPanel ] height: 25;				newRow: [:row | row add: #parentsLabel width: 80; add: #parentsPanel ] height: 25;				newRow: [:row | row add: #authorLabel width: 80; add: #authorPanel ] height: 25;				newRow: [:row | row add: #commentLabel width: 80; add: #commentPanel ] ];		yourself! !!IceCommitInfoModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!for: aCommit	^ self basicNew 		initializeCommit: aCommit;		yourself! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!authorLabel	^ authorLabel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!authorLabel: anObject	authorLabel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!authorPanel	^ authorPanel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!authorPanel: anObject	authorPanel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commentLabel	^ commentLabel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commentLabel: anObject	commentLabel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commentPanel	^ commentPanel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commentPanel: anObject	commentPanel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commit	^ commit! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!dateLabel	^ dateLabel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!dateLabel: anObject	dateLabel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!datePanel	^ datePanel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!datePanel: anObject	datePanel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!idLabel	^ idLabel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!idLabel: anObject	idLabel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!idPanel	^ idPanel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!idPanel: anObject	idPanel := anObject! !!IceCommitInfoModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeCommit: aCommit	commit := aCommit.	self initialize! !!IceCommitInfoModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	idLabel := self newLabel.	idPanel := self newTextInput enabled: false.	dateLabel := self newLabel.	datePanel := self newTextInput enabled: false.	authorLabel := self newLabel.	authorPanel := self newTextInput enabled: false.	commentLabel := self newLabel.	commentPanel := self newText enabled: false.	parentsLabel := self newLabel.	parentsPanel := self newTextInput enabled: false.		idLabel label: 'Commit Id'.	idPanel text: self commit id asString, ' [', self commit shortId, ']'.	dateLabel label: 'Date & time'.	datePanel text: self commit datetime asLocalStringYMDHM.	authorLabel label: 'Author'.	authorPanel text: self commit username.	commentLabel label: 'Comment'.	commentPanel text: self commit comment.	parentsLabel label: 'Parent(s)'.	parentsPanel text: (self commit parents collect: #shortId) asCommaString	! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!parentsLabel	^ parentsLabel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!parentsLabel: anObject	parentsLabel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!parentsPanel	^ parentsPanel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!parentsPanel: anObject	parentsPanel := anObject! !!IceCherryPickCommitModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!basicCommitWithMessage: aString	| picked |	self flag: #todo. "I need to check if picked = all changes (in that case, is not 	needed the pick and I can just go 'business as usual')"	cherryPickBlock ifNotNil: [ picked := cherryPickBlock value ].	"Nothing was picked, continue as usual"	picked ifNil: [ ^ super basicCommitWithMessage: aString ].	self repository 		commitCherryPick: picked  		withMessage: aString! !!IceCherryPickCommitModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!withSelectedCherryPick: aBlock	cherryPickBlock := aBlock! !!IceCommitModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec	<spec: #default>	^ SpecLayout composed newColumn:		[ :col | col			add: #message;			newRow: [ :row | row				add: #commitButton;				add: #commitPushButton			] height: self toolbarHeight		]! !!IceCommitModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!messageGhostText	^ 'Please enter commit message.'! !!IceCommitModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!basicCommitWithMessage: aString	self repository 		commitPackages: self model changedPackages		withMessage: aString! !!IceCommitModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!basicCommitWithMessage: text ifCancel: cancelBlock	[		[ self basicCommitWithMessage: text asString ]		on: IceGitUsernameOrEmailNotFound 		do: [ :e |			self configGitUsernameAndEmailOnCancel: cancelBlock.			e retry ].		self resetText ]	on: NothingToCommitException 	do: [ :e | UIManager default inform: 'There is nothing to commit.' ]! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branchName	^ self model repository branchName! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commitButton	^ commitButton! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commitPushButton	^ commitPushButton! !!IceCommitModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!commitPushing: pushBoolean	| text |		(text := self messageText) ifEmpty: [ ^ self ].	UIManager default		informUserDuring: [ :bar | 			bar label: ('Commiting changes to {1}' format: {self repository}).			self basicCommitWithMessage: text ifCancel: [ ^ self ].			pushBoolean ifTrue: [ | remote |				remote := self repository pushRemote.				bar label: ('Pushing changes to {1}' format: {remote}).				self pushRepository: self repository andThen: [ ]. 				UIManager default inform: ('Uploaded changes to {1}' format: {remote}) ] ]! !!IceCommitModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!configGitUsernameAndEmailOnCancel: cancelBlock	| passed |	passed := false.	(IceAskForUsernameAndEmailModel new 		onAccept: [ :username :email :global |			self repository 				username: username				email: email				global: global.			passed := true ];			openWithSpec)		modalRelativeTo: World.			passed ifFalse: cancelBlock! !!IceCommitModel methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!contractedNameFor: diff	"If the name of a branch is too long it is better to contract it in order to limit the UI glitches."	^ diff repository branchName contractTo: 20! !!IceCommitModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	model := nil asValueHolder.	model whenChangedDo: [ :diff | commitButton label: 'Commit onto ' , (self contractedNameFor: diff) ].	model whenChangedDo: [ :diff | commitPushButton label: 'Commit and Push onto ' , (self contractedNameFor: diff) ].	super initialize! !!IceCommitModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializePresenter	commitButton action: [ self commitPushing: false ].	commitPushButton action: [ self commitPushing: true ]! !!IceCommitModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	message := self newText		autoAccept: true;		whenBuiltDo: [ :this | this widget withGhostText: self class messageGhostText ];		whenTextChanged: [ | enable |			enable := self messageText notEmpty.			commitButton enabled: enable.			commitPushButton enabled: enable ];		yourself.	commitButton := self newButton		label: 'Commit';		enabled: false;		yourself.	commitPushButton := self newButton		label: 'Commit and push';		enabled: false;		yourself.			self focusOrder 		add: message;		add: commitButton;		add: commitPushButton! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!message	^ message! !!IceCommitModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!messageText	^ self message text! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!model	^ model value! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!model: aDiff	model value: aDiff ! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ self model repository! !!IceCommitModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!resetText	self message text: ''! !!IceCloneRepositoryModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!buildDefaultSpec: col	col		newRow: [:row | row			add: #remoteUrlLabel width: 100;			add: #remoteUrl ]		height: self inputTextHeight.			super buildDefaultSpec: col! !!IceCloneRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!createRepository	[		| repository |				repository := IceRepositoryCreator new 			remote: (IceRemote url: remoteUrl text trim);			location: self location;			subdirectory: subdirectory text;			createRepository.		repository register.					self window delete. 	]	on: IceError 	do: [ :error | 		UIManager default 			abort: error messageText 			title: 'Could not create repository' ]! !!IceCloneRepositoryModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ (500@(		self class inputTextHeight * 3 		+ self class buttonHeight 		+ 37 "Yes, a magic number"		))! !!IceCloneRepositoryModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	remoteUrlLabel := self newLabel label: 'Remote URL'.	remoteUrl := self newTextInput ghostText: 'git@github.com:user/project.git'; autoAccept: true.	self focusOrder add: remoteUrl.	super initializeWidgets.	! !!IceCloneRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!remoteUrl	^ remoteUrl! !!IceCloneRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!remoteUrlLabel	^ remoteUrlLabel! !!IceCloneRepositoryModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!title	^ 'Clone repository by URL'! !!IceCreateRepositoryModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!buildDefaultSpec: col	col		newRow: #localDirectoryLocation		height: self inputTextHeight;				newRow: [:row | row 			add: #subdirectoryLabel width: 100;			add: #subdirectory ]		height: self inputTextHeight;					add: #createButton height: self buttonHeight ! !!IceCreateRepositoryModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!buttonLabel	^ 'Create repository'! !!IceCreateRepositoryModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec	<spec: #default>	^ SpecLayout composed newColumn:		[ :col | self buildDefaultSpec: col ]! !!IceCreateRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!createButton	^ createButton! !!IceCreateRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!createButton: anObject	createButton := anObject! !!IceCreateRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!createRepository	self subclassResponsibility! !!IceCreateRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultLocation	^ IceRepository repositoriesLocation pathString! !!IceCreateRepositoryModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializePresenter	createButton action: [ self createRepository ]! !!IceCreateRepositoryModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	localDirectoryLocation := self instantiate: IceDirectoryModel.	localDirectoryLocation 		label: 'Local directory';		chooseTitle: 'Choose local repository';		location: self defaultLocation.		subdirectoryLabel := self newLabel label: 'Code subdirectory'.	subdirectory := self newTextInput autoAccept: true.		createButton := self newButton		label: self class buttonLabel;		yourself.		self focusOrder 		add: localDirectoryLocation;		add: subdirectory;		add: createButton! !!IceCreateRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!localDirectoryLocation	^ localDirectoryLocation! !!IceCreateRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!localDirectoryLocation: anObject	localDirectoryLocation := anObject! !!IceCreateRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location	| location |	location := localDirectoryLocation location.	^ (location notNil and: [ location pathString ~= self defaultLocation ])		ifTrue: [ ^ location ]		ifFalse: [ nil ]! !!IceCreateRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location: anObject	localDirectoryLocation location: anObject! !!IceCreateRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!subdirectory	^ subdirectory! !!IceCreateRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!subdirectoryLabel	^ subdirectoryLabel! !!IceEditRepositoryModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!buttonLabel	^ 'Edit repository'! !!IceEditRepositoryModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!new 	self error: 'Use #repository:'! !!IceEditRepositoryModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!repository: aRepository	^ self basicNew		initializeRepository: aRepository;		yourself! !!IceEditRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!codeDirectory	^ self subdirectory text	! !!IceEditRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!codeDirectory: aString	self subdirectory text: aString	! !!IceEditRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!createRepository	self repository location = self location 		ifFalse: [ self repository location: self location ].	self repository subdirectory = self codeDirectory		ifFalse: [ self repository subdirectory: self codeDirectory ].	self window delete. 	acceptBlock ifNotNil: [ acceptBlock cull: self ]! !!IceEditRepositoryModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ (500@(		self class inputTextHeight * 2		+ self class buttonHeight 		+ 37 "Yes, a magic number"		))! !!IceEditRepositoryModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializePresenter	super initializePresenter.	self location: (self repository location ifNil: [ IceRepository repositoriesLocation ]).	self codeDirectory: self repository subdirectory.! !!IceEditRepositoryModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeRepository: aRepository	repository := aRepository.	self initialize! !!IceEditRepositoryModel methodsFor: 'events' stamp: ' 7/21/2017 17:44:57'!onAccept: aBlock 	acceptBlock := aBlock! !!IceEditRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceEditRepositoryModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!title	^ 'Edit repository'! !!IceImportLocalRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!createRepository	self location ifNil: [ 		UIManager default 			abort: 'Please select a repository location'			title: 'Could not create repository'. 		^ self ].	[		| repository |				repository := IceRepositoryCreator new 			location: self location;			subdirectory: subdirectory text;			createRepository.		repository register.					self window delete. 	]	on: IceError 	do: [ :error | 		UIManager default 			abort: error messageText 			title: 'Could not create repository' ]! !!IceImportLocalRepositoryModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ (500@(		self class inputTextHeight * 2		+ self class buttonHeight 		+ 37 "Yes, a magic number"		))! !!IceImportLocalRepositoryModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!title	^ 'Import local repository into Iceberg'! !!IceNewRepositoryModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!buildDefaultSpec: col	col		newRow: [:row | row			add: #projectNameLabel width: 100;			add: #projectNameInput ]		height: self inputTextHeight.			super buildDefaultSpec: col! !!IceNewRepositoryModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!buttonLabel	^ 'Create repository'! !!IceNewRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!createRepository	[		| repository |			self projectName isEmptyOrNil 		ifTrue: [ Error signal: 'Project name is required' ].		repository := IceRepositoryCreator new 			location: self location / self projectName;			subdirectory: subdirectory text;			createNewRepositoryNamed: self projectName.		repository register.		self window delete.		acceptBlock ifNotNil: [ acceptBlock cull: self ] ]	on: IceError 	do: [ :error | 		UIManager default 			abort: error messageText 			title: 'Could not create repository' ].! !!IceNewRepositoryModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ (500@(		self class inputTextHeight * 3		+ self class buttonHeight 		+ 37 "Yes, a magic number"		))! !!IceNewRepositoryModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	projectNameLabel := self newLabel label: 'Project name'.	projectNameInput := self newTextInput 		ghostText: 'project'; 		autoAccept: true.	self focusOrder add: projectNameInput.	super initializeWidgets! !!IceNewRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location	^ localDirectoryLocation location! !!IceNewRepositoryModel methodsFor: 'events' stamp: ' 7/21/2017 17:44:57'!onAccept: aBlock	acceptBlock := aBlock! !!IceNewRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!projectName	^ self projectNameInput text! !!IceNewRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!projectNameInput	^ projectNameInput! !!IceNewRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!projectNameInput: anObject	projectNameInput := anObject! !!IceNewRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!projectNameLabel	^ projectNameLabel! !!IceNewRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!projectNameLabel: anObject	projectNameLabel := anObject! !!IceNewRepositoryModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!title	^ 'New repository'! !!IceDirectoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!chooseReference	^ UIManager default 		chooseDirectory: self chooseTitle 		path: self location! !!IceFileModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!chooseReference	^ (UIManager default 		chooseFileName: self chooseTitle 		extensions: nil 		path: self location 		preview: nil)		ifNotNil: [ :file | file asFileReference  ]! !!IceLocationModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultChooseDialogTitle	^ 'Choose directory'! !!IceLocationModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultLabel	^ 'Directory'! !!IceLocationModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec 	<spec>	^ SpecLayout composed		newRow: [ :row | 			row 				add: #locationLabel width: 100; 			 	add: #locationInput; 				add: #chooseButton width: self iconWidth ]! !!IceLocationModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!iconWidth	^ 24! !!IceLocationModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!choose	self chooseReference ifNotNil: [ :reference | 		self location: reference.		self locationInput text: reference pathString ]! !!IceLocationModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!chooseButton	^ chooseButton! !!IceLocationModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!chooseButton: anObject	chooseButton := anObject! !!IceLocationModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!chooseReference 	self subclassResponsibility! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!chooseTitle	^ chooseTitle ifNil: [ self class defaultChooseDialogTitle ]! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!chooseTitle: aString	chooseTitle := aString! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!icon	^ #open asIcon! !!IceLocationModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	locationLabel := self newLabel label: self label.	locationInput := self newTextInput autoAccept: true.	chooseButton := self newButton icon: self icon.		locationInput whenBuiltDo: [ :w | w widget wrapFlag: false ]. 	chooseButton action: [ self choose ].		self focusOrder add: locationInput	! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!label	^ label ifNil: [ self class defaultLabel ]! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!label: aString	label := aString.	self locationLabel label: aString	! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location	^ locationInput text trim 		ifNotEmpty: [ :value | value asFileReference ]		ifEmpty: [ nil ]! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location: aReferenceOrString	locationInput text: aReferenceOrString asFileReference pathString! !!IceLocationModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!locationInput	^ locationInput! !!IceLocationModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!locationInput: anObject	locationInput := anObject! !!IceLocationModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!locationLabel	^ locationLabel! !!IceLocationModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!locationLabel: anObject	locationLabel := anObject! !!IceRemoteModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec 	<spec>	^ SpecLayout composed		newColumn: [ :c |			c 				newRow: [:row | row add: #nameLabel width: 80; add: #namePanel ] height: 25;				newRow: [:row | row add: #urlLabel width: 80; add: #urlPanel ] height: 25;				add: #addButton height: self buttonHeight ];		yourself! !!IceRemoteModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!title	^ 'Add remote'! !!IceRemoteModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!accept	| remoteName remoteUrl |		remoteName := self namePanel text trim.	remoteName ifEmpty: [ 		UIManager default alert: 'You need to specify a remote name.' title: 'Error'. ^ self ].	remoteUrl := self urlPanel text trim.	remoteUrl ifEmpty: [		UIManager default alert: 'You need to specify a remote url.' title: 'Error'. ^ self ].		self window delete.	acceptBlock ifNotNil: [ 		acceptBlock cull: (IceRemote name: remoteName url: remoteUrl) ]! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!addButton	^ addButton! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!addButton: anObject	addButton := anObject! !!IceRemoteModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ (500@(		self class inputTextHeight * 2		+ self class buttonHeight 		+ 37 "Yes, a magic number"		))! !!IceRemoteModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	nameLabel := self newLabel. 	namePanel := self newTextInput ghostText: 'user-remote'; autoAccept: true.	urlLabel := self newLabel.	urlPanel := self newTextInput ghostText: 'git@github.com:user/project.git'; autoAccept: true.	addButton := self newButton.		nameLabel label: 'Remote name'.	urlLabel label: 'Remote URL'.	addButton label: 'Add remote'.	addButton action: [ self accept ].		self focusOrder 		add: namePanel;		add: urlPanel;		add: addButton! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!nameLabel	^ nameLabel! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!nameLabel: anObject	nameLabel := anObject! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!namePanel	^ namePanel! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!namePanel: anObject	namePanel := anObject! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!onAccept: aBlock 	acceptBlock := aBlock! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!urlLabel	^ urlLabel! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!urlLabel: anObject	urlLabel := anObject! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!urlPanel	^ urlPanel! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!urlPanel: anObject	urlPanel := anObject! !!ToolShortcutsCategory methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!openIceberg	<shortcut>	^ KMKeymap shortcut: PharoShortcuts current openIcebergShortcut action: [ IceRepositoriesBrowser  open ]! !!IceRemote methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!branchesFrom: aRepository	"I return all the branches of my remote from a repository"	^ aRepository branches		select: [ :branch | branch isRemote and: [ branch remoteName = self remoteName ] ]! !!DateAndTime methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!asLocalStringYMDHM	^ self asLocal asStringYMDHM! !!DateAndTime methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!asStringYMDHM	^ String streamContents: [ :aStream |		self printYMDOn: aStream.		aStream nextPut: Character space.		self hour printOn: aStream base: 10 length: 2 padded: true.		aStream nextPut: $:.		self minute printOn: aStream base: 10 length: 2 padded: true ]! !!GLMMorphicRenderer methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!renderCherryPickTreePresentation: aPresentation 	^ GLMMorphicCherryPickTreeRenderer render: aPresentation from: self! !!GLMMorphicRenderer methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!renderSwappedColorDiffPresentation: aPresentation	^ GLMMorphicSwappedColorDiffRenderer render: aPresentation from: self! !!GLMCherryPickTreePresentation methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!allSelected	allSelected := true! !!GLMCherryPickTreePresentation methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!cherryPick	^ (self pane port: #cherryPick) value! !!GLMCherryPickTreePresentation methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!cherryPick: aValuable	^ (self pane port: #cherryPick) value: aValuable! !!GLMCherryPickTreePresentation methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	super initialize.	allSelected := false! !!GLMCherryPickTreePresentation methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isAllSelected	^ allSelected! !!GLMCherryPickTreePresentation methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!onChangeOfCherryPick: aBlock	self onChangeOfPort: #cherryPick act: aBlock! !!GLMCherryPickTreePresentation methodsFor: 'rendering' stamp: ' 7/21/2017 17:44:57'!renderGlamorouslyOn: aRenderer 	self registerAnnouncements.	^ aRenderer renderCherryPickTreePresentation: self! !!GLMCompositePresentation methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!cherryPickTree	^ self custom: GLMCherryPickTreePresentation new! !!GLMCompositePresentation methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!swappedColorDiff	^ self custom: GLMSwappedColorDiffPresentation new	! !!IceGlamourSynchronizer class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultExtent	^ 850@600! !!IceGlamourSynchronizer class methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!synchronize: anIceRepository	self new openOn: anIceRepository.! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branch	^ self repository branch! !!IceGlamourSynchronizer methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!compose	(self custom: GLMStacker new) with: [ :browser |		browser initialExtent: self initialExtent.		browser updateOn: Announcement from: [ :repo | repo announcer weak ].		browser aPane: #commit.		browser transmit 			transformed: #workingCopyDiff; 			to: #commit;			andShow: [ :a | a 				title: 'Commit your changes'; 				custom: IceGlamourCommitBrowser new ].		browser aPane: #update.		browser transmit 			to: #update;			andShow: [ :a | a 				title: 'Update'; 				custom: IceGlamourUpdateBrowser new ].		browser aPane: #publish.		browser transmit 			to: #publish;			andShow: [ :a | a 				title: 'Push'; 				custom: IceGlamourPublishBrowser new ].	]! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ self class defaultExtent! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location	^ self repository location! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote	^ remote ifNil: [ self repository pushRemote ]! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote: aRemote	remote := aRemote! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ (self pane port: #entity) value! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ 'Synchronizing {1} -- branch: {2} -- remote: {3}' 		format: {			self location gtDisplayString.			self branch.			self remote }		! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!titleIcon	^ IceTool icon! !!IceAbstractBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!addCommitInfoTo: browser	browser transmit 		from: #commits; 		to: #diff; 		andShow: [ :a |			a morph				title: 'Commit info';				display: [ :commitInfo | (IceCommitInfoModel for: commitInfo) buildWithSpec ] ].! !!IceAbstractBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!addDiffTo: browser withTitle: diffTitle	browser transmit 		from: #changes; 		to: #diff; 		andShow: [ :a | 			a swappedColorDiff				title: diffTitle;				display: [:change | self buildDiffInput: change ]]! !!IceAbstractBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!buildDiffInput: change	^ { 		change myVersion ifNil: ''. 		change theirVersion ifNil: ''	}! !!IceEmbeddedBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!configureBrowser: browser	"Do nothing, since the purpose of this browsers is to be embedded"! !!IceEmbeddedBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!titleIcon	"Do nothing, since the purpose of this browsers is to be embedded"	^ nil! !!IceGlamourCommitBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeBrowserOn: browser	browser		row: [ :row | 			row				column: #changes; 				column: #commit ];		row: #diff.	browser transmit 		to: #changes;  		andShow: [ :a :diff |			self selectedElements: nil.			(IceDiffCherryPickChangeTreeBuilder new 				diff: diff;				onSelectCherryPick: [ :aSet | self selectedElements: aSet ];				buildOn: a)				title: 'Local changes' ].	browser transmit 		to: #commit;		andShow: [ :a :diff | 			a morph				title: 'Commit changes';				morph: [					IceCherryPickCommitModel new 						model: diff;						withSelectedCherryPick: [ self selectedElements ];						buildWithSpec ] ].	self addDiffTo: browser withTitle: 'Left: working copy / Right: local repository'! !!IceGlamourCommitBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!selectedElements	^ selectedElements! !!IceGlamourCommitBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!selectedElements: anObject	selectedElements := anObject! !!IceGlamourPublishBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!addDiffTo: browser	browser transmit 		from: #commits; 		from: #changes; 		to: #diff; 		andShow: [ :a | 			a swappedColorDiff 				title: 'Left: working copy / Right: incoming updates';				display: [ :commitInfo :change | self buildDiffInput: change ]. 			a morph 				title: 'Commit info';				display: [ :commitInfo | (IceCommitInfoModel for: commitInfo) buildWithSpec ] ]! !!IceGlamourPublishBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeBrowserOn: browser	browser		row: [ :top | top			column: #commits; 			column: #changes ];		row: #diff.	browser transmit		to: #commits;		andShow: [ :a | self composeCommitsListIn: a ].	browser transmit		fromOutsideEntityPort;		from: #commits; 		to: #changes; 		andShow: [ :a :repo :commitInfo | 			(IceDiffChangeTreeBuilder new				entity: commitInfo; 				diff: (commitInfo ifNotNil: [ commitInfo diffWith: repo branch upstream ]);				buildOn: a)				title: 'Outgoing changes' ].	self addDiffTo: browser.	self addCommitInfoTo: browser 	! !!IceGlamourPublishBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeCommitsListIn: composite	composite fastTable		title: 'New local commits to be published';		display: #outgoingCommits;		column: 'User' evaluated: #username width: 120;		column: 'Date & time' evaluated: [:commit | commit datetime asLocal asStringYMDHM ] width: 120;		column: 'Comment' evaluated: #comment;		updateOn: IceCommited, IcePushed from: #announcer;		addAction: self pushAction;		addSelectionAction: self mergeIntoAction! !!IceGlamourPublishBrowser methodsFor: 'action creators' stamp: ' 7/21/2017 17:44:57'!mergeIntoAction	^ GLMGenericAction new		action: [ :presentation |			self 				mergeIntoAnotherBranch: presentation selection				andThen: [					presentation selection: nil.					presentation pane browser update 				]];		icon: GLMUIThemeExtraIcons glamorousLeftSide;		shortcut: $m;		title: 'Merge into another branch...'; 		showTitle! !!IceGlamourPublishBrowser methodsFor: 'action creators' stamp: ' 7/21/2017 17:44:57'!pushAction	 ^ GLMGenericAction new			action: [ :presentation :repository | 				self 					pushRepository: repository					andThen: [ presentation selection: nil ]];			icon: GLMUIThemeExtraIcons glamorousRightSide;			shortcut: $p;			showTitle: 'Publish all'				! !!IceGlamourUpdateBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!addDiffTo: browser	browser transmit 		from: #commits; 		from: #changes; 		to: #diff; 		andShow: [ :a | 			a swappedColorDiff 				title: 'Left: working copy / Right: incoming updates';				display: [ :commitInfo :change | self buildDiffInput: change ]. 			a morph 				title: 'Commit info';				display: [ :commitInfo | (IceCommitInfoModel for: commitInfo) buildWithSpec ] ]	! !!IceGlamourUpdateBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!buildDiffInput: change	"The diff from an incoming change comes with the versions switched, 	so I have to switch them again."	^ { 		change theirVersion ifNil: ''.		change myVersion ifNil: ''. 	}! !!IceGlamourUpdateBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeBrowserOn: browser	browser		row: [ :top | top			column: #commits; 			column: #changes ];		row: #diff.	browser transmit		to: #commits;		andShow: [ :a | self composeCommitsListIn: a ].	browser transmit		fromOutsideEntityPort;		from: #commits; 		to: #changes; 		andShow: [ :a :repo :commitInfo |.			(IceDiffChangeTreeBuilder new				entity: commitInfo;				diff: (commitInfo ifNotNil: [ commitInfo diffWith: (repo mergeBaseWith: commitInfo) ]); 				buildOn: a)				title: 'Incoming changes' ].	self addDiffTo: browser.	self addCommitInfoTo: browser ! !!IceGlamourUpdateBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeCommitsListIn: composite	composite fastTable		title: 'New commits to be imported';		display: #incomingCommits;		column: 'User' evaluated: #username width: 120;		column: 'SHA' evaluated: #shortId width: 60;		column: 'Date & time' evaluated: [:commit | commit datetime asLocalStringYMDHM ] width: 100;		column: 'Status' evaluated: #status width: 80;		column: 'Comment' evaluated: #comment;		updateOn: IcePackageLoaded from: #announcer;		addAction: self fetchAction;		addAction: self pullAction;		addSelectionAction: self loadAction;		addSelectionAction: self mergeAction! !!IceGlamourUpdateBrowser methodsFor: 'action creators' stamp: ' 7/21/2017 17:44:57'!fetchAction	^ GLMGenericAction new		action: [ :presentation :repository | 			repository fetch.			presentation update ];		icon: #glamorousLeftSide asIcon;		shortcut: $f;		title: 'Fetch new versions'; 		showTitle! !!IceGlamourUpdateBrowser methodsFor: 'action creators' stamp: ' 7/21/2017 17:44:57'!loadAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection load. 			presentation selection: nil ];		condition: [ :presentation | 			presentation selection notNil 				and: [ presentation selection isMerged ]];		icon: #changeBlock asIcon;		shortcut: $l;		title: 'Load'; showTitle! !!IceGlamourUpdateBrowser methodsFor: 'action creators' stamp: ' 7/21/2017 17:44:57'!mergeAction	^ GLMGenericAction new		action: [ :presentation |			presentation selection merge.			presentation selection: nil.			presentation pane browser update. ];		condition: [ :presentation | 			presentation selection notNil 				and: [ presentation selection isMerged not ] ];		icon: GLMUIThemeExtraIcons glamorousLeftSide;		shortcut: $m;		title: 'Merge and load'; showTitle! !!IceGlamourUpdateBrowser methodsFor: 'action creators' stamp: ' 7/21/2017 17:44:57'!pullAction	^ GLMGenericAction new		action: [ :presentation :repository | 			repository pull.			presentation update ];		icon: #glamorousLeftSide asIcon;		shortcut: $p;		title: 'Pull'; 		showTitle! !!IceBranchBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeBrowserOn: browser	browser 		row: [:row | 			row 				column: #commits; 				column: #changes ]; 		row: #diff.		browser transmit to: #commits; andShow: [ :a | self composeCommitsIn: a ].	self addChangesTreesTo: browser.	self addDiffTo: browser.	self addCommitInfoTo: browser! !!IceBranchBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ 'Branch browser'! !!IceHistoryBrowser class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultExtent	^ 850@600! !!IceHistoryBrowser class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ 'History browser'! !!IceHistoryBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!addChangesTreeTo: a with: commitInfo	(IceDiffChangeTreeBuilder new 		entity: commitInfo;		diff: (commitInfo ifNotNil: [ commitInfo diffFromHead ]); 		buildOn: a)		title: 'Changes since selection'.	(IceDiffChangeTreeBuilder new		entity: commitInfo;		diff: (commitInfo ifNotNil: [ commitInfo diffToParent ]);		buildOn: a)		title: 'Changes vs. parent' ! !!IceHistoryBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!addChangesTreesTo: browser	browser transmit 		from: #commits;		to: #changes; 		andShow: [ :a :commitInfo |			self addChangesTreeTo: a with: commitInfo ].! !!IceHistoryBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!addDiffTo: browser	browser transmit 		from: #commits; 		from: #changes; 		to: #diff; 		andShow: [ :a | 			a swappedColorDiff 				title: 'Left: working copy / Right: incoming updates';				display: [ :commitInfo :change | self buildDiffInput: change ]. 			a morph 				title: 'Commit info';				display: [ :commitInfo | (IceCommitInfoModel for: commitInfo) buildWithSpec ] ]	! !!IceHistoryBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeBranchesIn: composite	composite fastTable		title: 'Branches';		display: #branchesForCheckout;		column: 'Name' evaluated: [ :branch :repo | 			self 				descriptionTextForBranch: branch				repository: repo ]		! !!IceHistoryBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeBrowserOn: browser	browser 		row: [:row | 			row 				column: #branches span: 2; 				column: #commits span: 3; 				column: #changes span: 3]; 		row: #diff.		browser transmit to: #branches; andShow: [ :a | self composeBranchesIn: a ].	browser transmit from: #branches; to: #commits; andShow: [ :a | self composeCommitsIn: a ].	self addChangesTreesTo: browser.	self addDiffTo: browser.	self addCommitInfoTo: browser! !!IceHistoryBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeCommitsIn: composite	composite fastTable		title: 'Commits';		display: #commits;		column: 'Date & time' 			evaluated: [:commit | 				commit datetime asLocalStringYMDHM asText 					in: [ :text | 						commit isLoaded 							ifTrue: [ text ] 							ifFalse: [ text allBold ] ] ] 			width: 120;		column: 'Id' evaluated: #shortId width: 50;		column: 'User' evaluated: #username width: 120;		column: 'Parents' evaluated: [ :commit | ', ' join: (commit parents collect: #shortId) ] width: 100;		column: 'Comment' evaluated: #comment width: 300;				addSelectionAction: self inspectAction;		addSelectionAction: self mergeIntoCurrentBranchAction;		addSelectionAction: self mergeIntoAction.! !!IceHistoryBrowser methodsFor: 'private accessing' stamp: ' 7/21/2017 17:44:57'!descriptionTextForBranch: aBranch repository: repo	| text |		self flag: #todo. "This is a duplication of IceRepositoryModel>>descriptionTextForBranch:. 	This can be solved by using an IceBranchModel instead the branch directly"	text := aBranch name asText.	(repo branch = aBranch)		ifTrue: [ text allBold ].			^ text! !!IceHistoryBrowser methodsFor: 'action creations' stamp: ' 7/21/2017 17:44:57'!inspectAction	^ GLMGenericAction new		action: [ :presentation | presentation selection inspect ]; 		shortcut: $i; 		title: 'Inspect'; 		yourself! !!IceHistoryBrowser methodsFor: 'action creations' stamp: ' 7/21/2017 17:44:57'!mergeIntoAction	^ GLMGenericAction new		action: [ :presentation |			self 				mergeIntoAnotherBranch: presentation selection				andThen: [					presentation selection: nil.					presentation pane browser update 				]];		icon: GLMUIThemeExtraIcons glamorousLeftSide;		shortcut: $m;		title: 'Merge into another branch...'; 		showTitle! !!IceHistoryBrowser methodsFor: 'action creations' stamp: ' 7/21/2017 17:44:57'!mergeIntoCurrentBranchAction	^ GLMGenericAction new		action: [ :presentation |			IceMergeTool new 				source: presentation selection;				targetBranch: presentation selection repository branch;				onMerge: [					presentation selection: nil.					presentation pane browser update ];				run ];		icon: GLMUIThemeExtraIcons glamorousLeftSide;		shortcut: $M;		title: 'Merge into current branch'; 		showTitle! !!IceRepositoriesBrowser class methodsFor: 'world menu' stamp: ' 7/21/2017 17:44:57'!icon	^ #komitterSmalltalkhubRemote asIcon! !!IceRepositoriesBrowser class methodsFor: 'world menu' stamp: ' 7/21/2017 17:44:57'!menuCommandOn: aBuilder 	"Add a custom menu item to the world menu"		<worldMenu> 		(aBuilder item: #'Iceberg')		order: 0.18; 		icon: self icon;  		parent: #'Tools';		keyText: 'o, i';		action: [ self open ].! !!IceRepositoriesBrowser class methodsFor: 'opening' stamp: ' 7/21/2017 17:44:57'!open	"self open"	^ self new open! !!IceRepositoriesBrowser class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ 'Iceberg repositories'! !!IceRepositoriesBrowser methodsFor: 'private utilities' stamp: ' 7/21/2017 17:44:57'!abort: message	self uiManager		abort: message		title: 'Iceberg Repositories Browser'! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!addGlobalMenu	self		act: [ 			SettingBrowser new 				changePackageSet: { (RPackageOrganizer default packageNamed: 'Iceberg') }; 				open; 				expandAll ] 		icon: #configuration asIcon		entitled: 'Global Settings'! !!IceRepositoriesBrowser methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!addLocalRepository	IceImportLocalRepositoryModel new openWithSpec! !!IceRepositoriesBrowser methodsFor: 'menu actions - repositories list' stamp: ' 7/21/2017 17:44:57'!addLocalRepositoryAction	^ GLMGenericAction new		action: [ self addLocalRepository ];		icon: #packageAdd asIcon;		shortcut: $a;		title: 'Add local repository'; showTitle! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/21/2017 17:44:57'!addPackageAction	^ GLMGenericAction new		action: [ :presentation :repo | 			self addPackageToRepository: repo repository.			presentation update ];		icon: #add asIcon;		shortcut: $a;		title: 'Add package'; showTitle! !!IceRepositoriesBrowser methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!addPackageToRepository: repo	| options descriptionBlock |		descriptionBlock := [ :wc | 		wc modified 			ifTrue: ['* ', wc packageName]			ifFalse: [ wc packageName ]].	options := MCWorkingCopy allManagers difference: repo workingCopies.	(self class chooseFrom: options displaying: descriptionBlock) 		ifNotNil: [ :workingCopy | repo addPackage: workingCopy ]! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!addRemoteAction	^ GLMGenericAction new		action: [ :presenter | 			presenter selection addRemoteThen: [ :remote | 				self announce: (IceRemoteAdded remote: remote) ] ];		selectionCondition: #isOperative;		showTitle: 'Add remote...'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!addRepositoryBranchesTo: composite	| branches |	(branches := composite fastTreeTable)		title: 'Branches';		display: [ :repository | 			| localisations |			localisations := repository remotes collect: [ :remote | IceBranchGroupModel repository: repository remote: remote ] as: OrderedCollection.			repository hasLocalBraches				ifTrue: [ localisations addFirst: (IceBranchGroupModel localFromRepository: repository) ].			localisations ];		children: #children;		column: 'Name' evaluated: #nameToDisplay;		column: 'Status' evaluated: #status;		allExpanded.	"actions"	branches addAction: self branchCreateNewAction.		"selection actions"	branches		addSelectionAction: self branchSwitchAction;		addSelectionAction: self branchCompareWithCurrentAction! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!addRepositoryInfoTo: composite	composite fastTable		title: 'General';		display: #detailedInfo;		column: 'Name' evaluated: #key width: 80;		column: 'Value' evaluated: #value! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!addRepositoryRemotesTo: composite	| remotes |		(remotes := composite fastTable)		title: 'Remotes';		display: #remotes;		column: 'Name' evaluated: [ :remote :model | model descriptionTextForRemote: remote] width: 80;		column: 'URL' evaluated: #url width: 380;		column: 'Status' evaluated: [ :remote :model | model statusForRemote: remote ];		updateOn: IceRemoteAdded from: #announcer.			"actions"	remotes addAction: self remoteAddAction.	"selection actions"	remotes 		addSelectionAction: self remoteMakePullingAction;		addSelectionAction: self remoteMakePushingAction;		addSelectionAction: self remoteFetchAction;		addSelectionAction: self remotePullAction;		addSelectionAction: self remotePushAction;		addSelectionAction: self remoteRemoveAction.	"Plugin actions"	remotes dynamicActionsOnSelection: [ :presentation | 		presentation entity pluginRemoteActionsFor: presentation selection ]! !!IceRepositoriesBrowser methodsFor: 'private utilities' stamp: ' 7/21/2017 17:44:57'!alert: message	self uiManager		abort: message		title: 'Iceberg Repositories Browser'! !!IceRepositoriesBrowser methodsFor: 'menu actions - branches' stamp: ' 7/21/2017 17:44:57'!branchCompareWithCurrentAction	^ GLMGenericAction new		action: [ :presentation :model | 			presentation selection compareCurrentToMe.			presentation pane browser update ];		enabledCondition: [ :presentation :model | (model isCurrentBranch: presentation selection branch) not ];		condition: [ :presentation | presentation selection ifNil: [ false ] ifNotNil: #isBranchModel ];		showTitle: 'Compare with current branch';		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - branches' stamp: ' 7/21/2017 17:44:57'!branchCreateNewAction	^ GLMGenericAction new		action: [ :presentation :model | 			model createNewBranchThen: [ presentation pane browser update ] ];		icon: #add asIcon;		showTitle: 'Create branch'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - branches' stamp: ' 7/21/2017 17:44:57'!branchSwitchAction	^ GLMGenericAction new		action: [ :presentation :model | 			presentation selection switchToMe.			presentation pane browser update ];		showTitle: 'Switch to this branch';		enabledCondition: [ :presentation :model | (model isCurrentBranch: presentation selection branch) not ];		condition: [ :presentation | presentation selection ifNil: [ false ] ifNotNil:  #isBranchModel ];		shortcut: $b;		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/21/2017 17:44:57'!browsePackageAction	^ GLMGenericAction new		selectionAction: #browse;		selectionCondition: #isLoaded;		showTitle: 'Browse package';		shortcut: $b;		yourself! !!IceRepositoriesBrowser methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!cloneRepository	IceCloneRepositoryModel new openWithSpec! !!IceRepositoriesBrowser methodsFor: 'menu actions - repositories list' stamp: ' 7/21/2017 17:44:57'!cloneRepositoryAction	^ GLMGenericAction new		action: [ self cloneRepository ];		icon: #add asIcon;		shortcut: $c;		title: 'Clone repository'; showTitle! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!cloneRepositoryAgainAction	^ GLMGenericAction new		selectionAction: #restore;		selectionCondition: #isMissing;		showTitle: 'Clone repository again';		shortcut: $R;		yourself! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!compose	self addGlobalMenu.	super compose! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeBrowserOn: browser	browser 		row: #repositories; 		row: #info.	browser transmit 		to: #repositories; 		andShow: [ :presentation | 			self composeRepositoriesIn: presentation ].	browser transmit 		from: #repositories; 		to: #info; 		andShow: [ :a |			(a custom: GLMWrapper new)				show: [ :wrapper | self composeRepositoryInfoIn: wrapper ];				when: [ :model | model isValid ].			(a custom: GLMWrapper new) 				show: [ :wrapper | self composeNotValidIn: wrapper ];				when: [ :model | model isValid not ] ].		! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeNotValidIn: composite	composite actionList		title: [ :repo | 'Repository {1} is invalid.' format: { repo descriptionText } ];		beVertical;		act: [ :presentation :model | 			model editRepositoryThen: [ 				"scale to top browser"				presentation pane browser pane browser update ] ] entitled: 'Edit...';		act: [ :presentation :model | 				model restore. 				presentation pane browser pane browser update ] entitled: 'Clone';		act: [ :presentation :model | 			model forgetThen: [ 				presentation pane browser pane browser update ] ] entitled: 'Forget'! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composePackagesListIn: composite	composite fastTable		title: 'Packages';		display: #savedPackages;		column: 'Name' evaluated: #nameText width: 200;		column: 'Status' evaluated: #status;		addAction: self reloadAllPackagesAction;		addAction: self addPackageAction;		addSelectionAction: self browsePackageAction;		addSelectionAction: self loadPackageAction;		addSelectionAction: self unloadPackageAction;		addSelectionAction: self reloadPackageAction;		addSelectionAction: self unloadAndRemovePackageAction;		addSelectionAction: self removePackageAction;		addSelectionAction: self removePackageFromDiskAction;		enableFilter: [ :packageModel :pattern | packageModel packageName includesSubstring: pattern caseSensitive: false ];		"Plugin actions"		dynamicActionsOnSelection: [ :presentation | 			presentation selection ifNotNil: [ 				presentation entity pluginPackageActionsFor: presentation selection entity ]];		updateOn: IceCommited from: #announcer! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeRepositories: repositories in: composite	| table |	table := composite fastTable.	table		title: 'Repositories';		display: [ self visibleRepositoryModels  ];		column: 'Name' evaluated: #descriptionText width: 200;		column: 'Current branch' evaluated: #branchName width: 120;		column: 'Loaded version' evaluated: #loadedCodeDescription width: 200;		column: 'Status' evaluated: #status width: 150.	table updateOn: IceRepositoryRegistryModified from: [ Iceberg announcer weak ].	repositories do: [ :repo | 		table updateOn: IceRepositoryAnnouncement from: repo announcer ].	table updateOn: MCPackageModified from: MCPackageManager announcer.		Iceberg announcer weak 		subscribe: IceRepositoryCreated 		send: #execute:		to: (IceRepositoryUpdateHelper for: table).	table				"Task bar menu"		addAction: self newRepositoryAction;		addAction: self cloneRepositoryAction;		addAction: self addLocalRepositoryAction;		addAction: self fetchAllRepositoriesAction;		"Repository pop up menu"		addSelectionAction: self synchronizeRepositoryAction;		addSelectionAction: self showHistoryAction;		addSelectionAction: self switchBranchAction;		addSelectionAction: self createNewBranchAction;		addSelectionAction: self addRemoteAction;		addSelectionAction: self fetchAction;		addSelectionAction: self pullAction;		addSelectionAction: self pullFromAction;		addSelectionAction: self pushAction;		addSelectionAction: self pushToAction;		addSelectionAction: self cloneRepositoryAgainAction;		addSelectionAction: self refreshRepositoryAction;		addSelectionAction: self editRepositoryAction;		addSelectionAction: self forgetRepositoryAction;		"Plugin actions"		dynamicActionsOnSelection: [ :presentation | 			presentation selection pluginActions ];		"Double click action"		onChangeOfPort: #strongSelection act: [ :presentation | 			self synchronize: presentation selection repository ]! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeRepositoriesIn: composite	| table |	table := composite fastTable.	table		title: 'Repositories';		display: [ self visibleRepositoryModels  ];		column: 'Name' evaluated: #descriptionText width: 200;		column: 'Current branch' evaluated: #branchName width: 120;		column: 'Loaded version' evaluated: #loadedCodeDescription width: 200;		column: 'Status' evaluated: #status width: 150.	table updateOn: IceRepositoryRegistryModified from: [ Iceberg announcer weak ].	self repositoryRegistry do: [ :repo | 		table updateOn: IceRepositoryAnnouncement from: repo announcer ].	table updateOn: MCPackageModified from: MCPackageManager announcer.		Iceberg announcer weak 		subscribe: IceRepositoryCreated 		send: #execute:		to: (IceRepositoryUpdateHelper for: table).	table				"Task bar menu"		addAction: self newRepositoryAction;		addAction: self cloneRepositoryAction;		addAction: self addLocalRepositoryAction;		addAction: self fetchAllRepositoriesAction;		"Repository pop up menu"		addSelectionAction: self synchronizeRepositoryAction;		addSelectionAction: self showHistoryAction;		addSelectionAction: self switchBranchAction;		addSelectionAction: self createNewBranchAction;		addSelectionAction: self addRemoteAction;		addSelectionAction: self fetchAction;		addSelectionAction: self pullAction;		addSelectionAction: self pullFromAction;		addSelectionAction: self pushAction;		addSelectionAction: self pushToAction;		addSelectionAction: self cloneRepositoryAgainAction;		addSelectionAction: self refreshRepositoryAction;		addSelectionAction: self editRepositoryAction;		addSelectionAction: self forgetRepositoryAction;		"Plugin actions"		dynamicActionsOnSelection: [ :presentation | 			presentation selection pluginActions ];		"Double click action"		onChangeOfPort: #strongSelection act: [ :presentation | 			self synchronize: presentation selection repository ]! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeRepositoryInfoIn: composite	self addRepositoryInfoTo: composite.	self composePackagesListIn: composite.	self addRepositoryRemotesTo: composite.	self addRepositoryBranchesTo: composite.	! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!createNewBranchAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection createNewBranchThen: [] ];		selectionCondition: #isOperative;		showTitle: 'Create new branch...';		shortcut: $B.! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!editRepositoryAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection editRepositoryThen: [				presentation pane browser pane update ] ];		showTitle: 'Edit repository...';		shortcut: $e;		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!fetchAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection fetch.			presentation update ];		selectionCondition: #isOperative;		icon: #glamorousLeftSide asIcon;		showTitle: 'Fetch incoming comits';		yourself! !!IceRepositoriesBrowser methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!fetchAllRepositories	UIManager default informUserDuring: [ :bar |		| repositoriesCount |		repositoriesCount := IceRepository registry size.		bar max: repositoriesCount + 1.				IceRepository registry doWithIndex: [ :repository :index|			bar label: 				('Looking for incoming commigs in all repositories ({1} of {2})'					format: {index. repositoriesCount}).			bar current: index.						repository fetch.		]]	 ! !!IceRepositoriesBrowser methodsFor: 'menu actions - repositories list' stamp: ' 7/21/2017 17:44:57'!fetchAllRepositoriesAction	^ GLMGenericAction new 		action: [ self fetchAllRepositories ];		icon: #glamorousLeftSide asIcon;		shortcut: $F;		showTitle: 'Fetch all'		! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!forgetRepositoryAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection forgetThen: [ 				presentation pane browser pane update ] ];		showTitle: 'Forget repository...'; 		shortcut: $x; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!inspectRepositoryAction	^ GLMGenericAction new		selectionAction: #inspectRepository;		showTitle: 'Inspect';		shortcut: $i;		yourself! !!IceRepositoriesBrowser methodsFor: 'private testing' stamp: ' 7/21/2017 17:44:57'!isRepositoryVisible: aRepository	^ aRepository isSystemRepository not 		or: [ Iceberg showSystemRepositories ]! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/21/2017 17:44:57'!loadPackageAction	^ GLMGenericAction new		action: [ :presentation :repo | 			presentation selection loadLatest.			presentation update ]; 		icon: #add asIcon;		shortcut: $l; 		title: 'Load package'; 		condition: [ :presentation | presentation selection notNil and: [ presentation selection isLoaded not ]];		yourself! !!IceRepositoriesBrowser methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!newRepository	IceNewRepositoryModel new openWithSpec! !!IceRepositoriesBrowser methodsFor: 'menu actions - repositories list' stamp: ' 7/21/2017 17:44:57'!newRepositoryAction	^ GLMGenericAction new		action: [ :presentation | self newRepository ];		icon: #smallNew asIcon;		shortcut: $n;		title: 'New repository'; showTitle! !!IceRepositoriesBrowser methodsFor: 'scripting opening' stamp: ' 7/21/2017 17:44:57'!open	IceRepository defaultBackend 		verifyBackendAvailabilityIfNot: [ :requiredVersion :currentVersion | 			^ UIManager default 				alert: ('This version of Iceberg requires libgit2 {1} to run (you have {2}).Please update your PharoVM before continue.' format: { requiredVersion. currentVersion }) ].	self openOn: Object new! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!pullAction	^ GLMGenericAction new		selectionAction: #pull;		selectionCondition: #isOperative;		icon: GLMUIThemeExtraIcons glamorousLeftSide;		showTitle: 'Pull incoming commits'; 		shortcut: $p; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!pullFromAction	^ GLMGenericAction new		selectionAction: #pullFrom;		selectionCondition: #isOperative;		showTitle: 'Pull from...'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!pushAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection pushThen: [ presentation pane browser update ]];		selectionCondition: #canPush;		icon: #glamorousRightSide asIcon;		showTitle: 'Push outgoing commits'; 		shortcut: $P; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!pushToAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection pushToThen: [ presentation pane browser update ]];		selectionCondition: #isOperative;		"icon: GLMUIThemeExtraIcons glamorousRightSide;"		showTitle: 'Push to...';		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!refreshRepositoryAction	^ GLMGenericAction new		selectionAction: #refresh;		showTitle: 'Refresh repository';		shortcut: $r! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/21/2017 17:44:57'!reloadAllPackagesAction	^ GLMGenericAction new		action: [ :presentation :model | 			model reloadAllLoadedPackages. 			presentation update ];		condition: [ :presentation :repo | (repo entity savedPackages select: #isLoaded) notEmpty ];		icon: #refresh asIcon;		shortcut: $e;		title: 'Reload all'; showTitle! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/21/2017 17:44:57'!reloadPackageAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection reload.			presentation update ]; 		icon: #refresh asIcon;		shortcut: $r; 		title: 'Reload package'; 		condition: [ :presentation | presentation selection notNil and: [ presentation selection isLoaded ]];		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/21/2017 17:44:57'!remoteAddAction	^ GLMGenericAction new		action: [ :presentation :model | 			model addRemoteThen: [ presentation pane browser update ] ];		icon: #add asIcon;		showTitle: 'Add remote'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/21/2017 17:44:57'!remoteFetchAction	^ GLMGenericAction new		action: [ :presentation :model | 			model fetchRemote: presentation selection. 			presentation pane browser update ];		icon: #glamorousLeftSide asIcon;		showTitle: 'Fetch'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/21/2017 17:44:57'!remoteMakePullingAction	^ GLMGenericAction new		action: [ :presentation :model | 			model makePullRemote: presentation selection. 			presentation pane browser update ];		showTitle: 'Make default pull remote'; 		enabledCondition: [ :presentation :model | 			(model isPullRemote: presentation selection) not ];		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/21/2017 17:44:57'!remoteMakePushingAction	^ GLMGenericAction new		action: [ :presentation :model | 			model makePushRemote: presentation selection. 			presentation pane browser update ];		showTitle: 'Make default push remote'; 		enabledCondition: [ :presentation :model | 			(model isPushRemote: presentation selection) not ];		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/21/2017 17:44:57'!remotePullAction	^ GLMGenericAction new		action: [ :presentation :model | 			model pullRemote: presentation selection. 			presentation pane browser update ];		icon: #glamorousLeftSide asIcon;		showTitle: 'Pull'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/21/2017 17:44:57'!remotePushAction	^ GLMGenericAction new		action: [ :presentation :model | 			model pushRemote: presentation selection. 			presentation pane browser update ];		icon: #glamorousRightSide asIcon;		showTitle: 'Push'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/21/2017 17:44:57'!remoteRemoveAction	^ GLMGenericAction new		action: [ :presentation :model | 			model 				removeRemote: presentation selection				then: [ presentation pane browser update ] ];		icon: #remove asIcon;		showTitle: 'Remove'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/21/2017 17:44:57'!removePackageAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection 				removeFromDiskThen: [ presentation update ] ]; 		icon: #smallDelete asIcon;		title: 'Remove package from repository (do not unload)'; 		condition: [ :presentation | 			presentation selection notNil and: [ presentation selection isLoaded ] ];		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/21/2017 17:44:57'!removePackageFromDiskAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection 				removeFromDiskThen: [ presentation update ] ]; 		icon: #smallDelete asIcon;		title: 'Remove package from disk'; 		condition: [ :presentation | 			presentation selection notNil and: [ presentation selection isLoaded not ] ];		yourself! !!IceRepositoriesBrowser methodsFor: 'private accessing' stamp: ' 7/21/2017 17:44:57'!repositoryRegistry 	^ IceRepository registry! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!showHistoryAction	^ GLMGenericAction new		selectionAction: #browseHistory;		selectionCondition: #isOperative;		icon: #glamorousBrowse asIcon;		showTitle: 'Show history...';		shortcut: $h! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!switchBranchAction	^ GLMGenericAction new		action: [ :presentation |			presentation selection ifNotNil: [:repo | repo switchBranch ].			presentation pane browser pane update ];		enabledCondition: [ :presentation | 			presentation selection notNil ];			selectionCondition: #isOperative;		showTitle: 'Switch branch...';		shortcut: $b.! !!IceRepositoriesBrowser methodsFor: 'private utilities' stamp: ' 7/21/2017 17:44:57'!synchronize: repository	"This hack is a workaround because port #strongSelection of glamour generates multiple events for a single double-click."	(lastSynchronization isNil 		or: [ (DateAndTime current - lastSynchronization first) seconds > 1		or: [ lastSynchronization second  ~= repository ]])		ifTrue: [ 			lastSynchronization := { DateAndTime current. repository }.			IceGlamourSynchronizer synchronize: repository ]	! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/21/2017 17:44:57'!synchronizeRepositoryAction	^ GLMGenericAction new		selectionAction: #synchronize;		selectionCondition: #isOperative;		icon: #glamorousBrowse asIcon;		shortcut: $s;		title: 'Synchronize repository...'; showTitle! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/21/2017 17:44:57'!unloadAndRemovePackageAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection 				unloadAndRemoveFromDiskThen: [ presentation update ] ]; 		icon: #smallDelete asIcon;		title: 'Unload & remove package from disk'; 		condition: [ :presentation | 			presentation selection notNil and: [ presentation selection isLoaded ] ];		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/21/2017 17:44:57'!unloadPackageAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection unload.			presentation update ]; 		icon: #delete asIcon;		shortcut: $u; 		title: 'Unload package'; 		condition: [ :presentation | 			presentation selection notNil and: [ presentation selection isLoaded ]];		yourself! !!IceRepositoriesBrowser methodsFor: 'private accessing' stamp: ' 7/21/2017 17:44:57'!visibleRepositoryModels	^ self repositoryRegistry 		select: [ :each | self isRepositoryVisible: each  ]		thenCollect: [ :repo | IceRepositoryModel modelFor: repo ]! !!IceTool class methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!chooseFrom: options displaying: descriptionBlock 	"Description block is used both for sorting and for displaying"		| sortedOptions index  |	sortedOptions := options asSortedCollection: [:wc1 :wc2 | (descriptionBlock value: wc1) < (descriptionBlock value: wc2) ].	index := self uiManager chooseFrom: (sortedOptions collect: descriptionBlock).	^ index > 0 		ifTrue: [ sortedOptions at: index ]		ifFalse: [ nil ]! !!IceTool class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultExtent	^ RealEstateAgent standardWindowExtent! !!IceTool class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!icon	^ #komitterSmalltalkhubRemote asIcon! !!IceTool class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ nil! !!IceTool methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!compose 	self tabulator with: [ :browser |		self configureBrowser: browser.		self composeBrowserOn: browser  ]! !!IceTool methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeBrowserOn: browser 	self subclassResponsibility! !!IceTool methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!configureBrowser: browser	"hack to add initial properties (as initialExtent) to browsers"		browser initialExtent: self initialExtent! !!IceTool methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ self class defaultExtent! !!IceTool methodsFor: 'action creators' stamp: ' 7/21/2017 17:44:57'!mergeIntoAction	^ GLMGenericAction new		action: [ :presentation |			IceMergeTool new 				source: presentation selection;				onMerge: [					presentation selection: nil.					presentation pane browser update 				];				run		];		icon: GLMUIThemeExtraIcons glamorousLeftSide;		shortcut: $m;		title: 'Merge into another branch...'; 		showTitle! !!IceTool methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ self class title! !!IceTool methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!titleIcon	^ self class icon! !!IceInteractiveCredentialsProvider class methodsFor: 'class initialization' stamp: ' 7/21/2017 17:44:57'!initialize	"self initialize"	IceCredentialsProvider providerType: self.! !!IceInteractiveCredentialsProvider methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!askForPlaintextCredentials: response	| model cancelled |		cancelled := false.	(model := IceAskForPlaintextCredentialsModel new)		openDialogWithSpec		okAction: [			| credentials | 			credentials := model credentials.			model storeCredentials 				ifTrue: [ self class plaintextCredentials: credentials ].			response readFrom: credentials.		];		cancelAction: [ cancelled := true ];		centered;		modalRelativeTo: World.	cancelled ifTrue: [ LGitNoCredentialsProvided signal ]! !!IceInteractiveCredentialsProvider methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!askForSshCredentials: response	| model cancelled |		cancelled := false.	(model := IceAskForSshCredentialsModel new)		openDialogWithSpec		okAction: [			| credentials | 			credentials := model credentials.			model storeCredentials 				ifTrue: [ self class sshCredentials: credentials ].			response readFrom: credentials ];		cancelAction: [ cancelled := true ];		centered;		modalRelativeTo: World.	cancelled ifTrue: [ LGitNoCredentialsProvided signal ]! !!IceInteractiveCredentialsProvider methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	tries := 0! !!IceInteractiveCredentialsProvider methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!providePlaintextCredentialsTo: credentials	tries := tries + 1.	tries >= 3 ifTrue: [ 		Transcript show: 'aborting'; cr.		LGitNoCredentialsProvided signal: 'There where already three failed attempts, aborting' ].		tries = 1 & self plaintextCredentials isPresent		ifTrue: [ credentials readFrom: self plaintextCredentials ]		ifFalse: [ self askForPlaintextCredentials: credentials ].! !!IceInteractiveCredentialsProvider methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!provideSshAgentCredentialsTo: credentials	"Just check for tries to ensure we do not enter an infinite cycle in libgit2"	tries := tries + 1.	tries >= 3 ifTrue: [ 		Transcript show: 'aborting'; cr.		LGitNoCredentialsProvided signal: 'No ssh-agent credentials found.' ].! !!IceInteractiveCredentialsProvider methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!provideSshCredentialsTo: credentials	tries := tries + 1.	tries >= 3 ifTrue: [ 		Transcript show: 'aborting'; cr.		LGitNoCredentialsProvided signal: 'There where already three failed attempts, aborting' ].		tries = 1 & self sshCredentials isPresent		ifTrue: [ credentials readFrom: self sshCredentials ]		ifFalse: [ self askForSshCredentials: credentials ].! !!GLMCherryPickTreeDataSource methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!cellColumn: column row: rowIndex	| item cell |	item := self elementAt: rowIndex.	cell := FTIndentedCellMorph new.	cell indentBy: item depth * 16.	cell 		addMorphBack: (self buttonFor: item);		addMorphBack: (CheckboxButtonMorph new			selected: (self isSelected: item data);			target: [ self toggleSelectionOf: item ];			actionSelector: #value;			yourself);		addMorphBack: (self createCellMorphFor: item).	^ cell! !!GLMCherryPickTreeDataSource methodsFor: 'private factory' stamp: ' 7/21/2017 17:44:57'!createCellMorphFor: item	| morph rowElements |	rowElements := OrderedCollection new.	(self iconFor: item data) ifNotNil: [ :icon | rowElements add: icon asMorph ].	rowElements		add: (self formatedDisplayValueOf: item data) asMorph asReadOnlyMorph;		addAll: (self tagMorphsFrom: self glamourPresentation for: item data).	morph := self createInnerCellMorph.	rowElements do: [ :each | morph addMorphBack: each ].	^ morph				! !!GLMCherryPickTreeDataSource methodsFor: 'private factory' stamp: ' 7/21/2017 17:44:57'!createInnerCellMorph	^ Morph new 		layoutPolicy: TableLayout new;		color: Color transparent;		hResizing: #spaceFill;		vResizing: #spaceFill;		listDirection: #leftToRight;		cellPositioning: #leftCenter;		cellInset: 5;		listCentering: #leftCenter;		wrapCentering: #leftCenter;		yourself! !!GLMCherryPickTreeDataSource methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!deselectAllChildrenOf: item	(self withAllChildrenOf: item) 		do: [ :each | selection remove: each data ifAbsent: [] ].	self tableRefresh! !!GLMCherryPickTreeDataSource methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	super initialize.	selection := Set new! !!GLMCherryPickTreeDataSource methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!isSelected: anObject	^ selection includes: anObject! !!GLMCherryPickTreeDataSource methodsFor: 'updating' stamp: ' 7/21/2017 17:44:57'!selectAll	self rootsItems do: [ :each | 		self selectAllChildrenOf: each ]! !!GLMCherryPickTreeDataSource methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!selectAllChildrenOf: item	(self withAllChildrenOf: item) 		do: [ :each | selection add: each data ]! !!GLMCherryPickTreeDataSource methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!selectAllWithChildren: aCollection	selection := Set new.	aCollection do: [ :each | self selectAllChildrenOf: each ]! !!GLMCherryPickTreeDataSource methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!selected: aCollection	selection := aCollection asSet! !!GLMCherryPickTreeDataSource methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!selection	^ selection! !!GLMCherryPickTreeDataSource methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!tableRefresh	self table ifNil: [ ^ self ].	super tableRefresh! !!GLMCherryPickTreeDataSource methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!toggleSelectionOf: item	(self isSelected: item data) 		ifTrue: [ self deselectAllChildrenOf: item ]		ifFalse: [ self selectAllChildrenOf: item ].	self glamourPresentation cherryPick: selection.	self tableRefresh! !!GLMCherryPickTreeDataSource methodsFor: 'updating' stamp: ' 7/21/2017 17:44:57'!updateSelectionWithCollectBlock: aBlock	self table ifNil: [ ^ self ].	super updateSelectionWithCollectBlock: aBlock! !!GLMCherryPickTreeDataSource methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!withAllChildrenOf: item	^ item children		inject: { item }		into: [ :all :each | all, (self withAllChildrenOf: each) ]! !!IceRemoteAdded class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!remote: aRemote	^ self new remote: aRemote! !!IceRemoteAdded methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote	^ remote! !!IceRemoteAdded methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote: anObject	remote := anObject! !!SwappedColorDiffMorph methodsFor: 'accessing colors' stamp: ' 7/21/2017 17:44:57'!additionColor	^ super removalColor! !!SwappedColorDiffMorph methodsFor: 'accessing colors' stamp: ' 7/21/2017 17:44:57'!removalColor	^ super additionColor ! !!GLMSwappedColorDiffPresentation methodsFor: 'rendering' stamp: ' 7/21/2017 17:44:57'!renderGlamorouslyOn: aRenderer 	self registerAnnouncements.	^ aRenderer renderSwappedColorDiffPresentation: self! !!MCRemoval methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!canBeBrowsed	^ false! !!MCRemoval methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!icon	^ Smalltalk ui icons iconNamed: #changeRemove! !!MCAddition methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!icon	^ Smalltalk ui icons iconNamed: #changeAdd! !!MCPatchOperation methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!canBeBrowsed	^ true! !!IceAbstractBranchModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!children	"It should return the children of my element. It will probably return the branches of a remote for the remotes and nothing for the branches."	^ self subclassResponsibility! !!IceAbstractBranchModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isBranchModel	^ false! !!IceAbstractBranchModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!nameToDisplay	^ self subclassResponsibility ! !!IceAbstractBranchModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ self subclassResponsibility! !!IceAbstractBranchModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!status	^ self subclassResponsibility! !!IceBranchGroupModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!localFromRepository: aRepository	^ self		repository: aRepository		branches: #localBranches		groupName:			('Local' asText				allBold;				yourself)! !!IceBranchGroupModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!repository: aRepository branches: aCollection groupName: aString	^ self new		repository: aRepository;		branches: aCollection;		groupName: aString;		yourself! !!IceBranchGroupModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!repository: aRepository remote: aRemote	^ self repository: aRepository branches: [ :repository | aRemote branchesFrom: repository ] groupName: aRemote asString! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branches	^ branches cull: self repository! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branches: aBlockOrSymbol	branches := aBlockOrSymbol! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!children	^ self branches collect: [ :branch | IceBranchModel parent: self branch: branch ]! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!groupName	^ groupName! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!groupName: aString	groupName := aString! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!nameToDisplay	^ self groupName! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anIceRepository	repository := anIceRepository! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!status	^ self branches size asString , ' branches'! !!IceBranchModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!parent: anIceBranchGroupModel branch: anIceBranch	^ self new		parentGroup: anIceBranchGroupModel;		branch: anIceBranch;		yourself! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branch	^ branch! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branch: anIceBranch	branch := anIceBranch! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!children	^ #()! !!IceBranchModel methodsFor: 'action' stamp: ' 7/21/2017 17:44:57'!compareCurrentToMe	self repository compareCurrentBranchWithBranch: self branch! !!IceBranchModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isBranchModel	^ true! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!nameToDisplay	^ self repository descriptionTextForBranch: self branch! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!parentGroup	^ parentGroup! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!parentGroup: anIceBranchGroupModel	parentGroup := anIceBranchGroupModel! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ self parentGroup repository! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!status	| incoming outgoing allStatus |		incoming := self branch incomingCommits size.	outgoing := self branch outgoingCommits size.		allStatus := OrderedCollection new.	(incoming = 0 and: [ outgoing = 0 ]) ifTrue: [ allStatus add: 'Up to date' ].	incoming > 0 ifTrue: [ allStatus add: ('{1} incoming' format: {incoming}) ].	outgoing > 0 ifTrue: [ allStatus add: ('{1} not published' format: {outgoing}) ].	^ allStatus asCommaString! !!IceBranchModel methodsFor: 'action' stamp: ' 7/21/2017 17:44:57'!switchToMe	self repository switchBranchTo: self branch! !!IceAbstractModel class methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!clearModels	"Clear the model cache, this is needed for correct testing"	modelCache := nil.! !!IceAbstractModel class methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!compactIfNeeded	| newModelCache |	self models size > 250 ifFalse: [ ^ self ].	newModelCache := self models select: [ :each | each notNil ].	modelCache := newModelCache	! !!IceAbstractModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!modelFor: entity	| model |	"We are using WeakValueDictionary to keep this sinchronized (in case you have more than 	 one window open, you want always same model). Now, it has to be cleaned when windows are 	 no longer around, but associations will be nil... so we cannot use a simple ifAbsentPut:. 	 Yep, ugly... but effective."		model := self models at: entity name ifAbsent: [ nil ].	^ model ifNil: [ 		self compactIfNeeded.		self models 			at: entity name			put: (self basicNew 				entity: entity; 				initialize; 				yourself) ]! !!IceAbstractModel class methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!models	"since a repository can have same name as a package (and we keep models by name), 	 I need to keep this as an instance of class and not a variable (who would be 	 shared by all hierarchy and because of that prone to errors)"	^ modelCache ifNil: [ modelCache := WeakValueDictionary new ]! !!IceAbstractModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!new	self error: 'Use #modelFor:'! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!announcer	^ self entity announcer! !!IceAbstractModel methodsFor: 'highlighting' stamp: ' 7/21/2017 17:44:57'!colorError	^ Color red! !!IceAbstractModel methodsFor: 'highlighting' stamp: ' 7/21/2017 17:44:57'!colorIncoming	^ Color brown! !!IceAbstractModel methodsFor: 'highlighting' stamp: ' 7/21/2017 17:44:57'!colorModified	^ Color r: 0 g: 0.5 b: 0! !!IceAbstractModel methodsFor: 'highlighting' stamp: ' 7/21/2017 17:44:57'!colorNotLoaded	^ Color darkGray! !!IceAbstractModel methodsFor: 'highlighting' stamp: ' 7/21/2017 17:44:57'!colorOutgoing	^ Color blue! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!entity	^ entity! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!entity: anObject	entity := anObject! !!IceAbstractModel methodsFor: 'highlighting' stamp: ' 7/21/2017 17:44:57'!highlight: aString	[ 		| text modified incoming outgoing |			text := Text fromString: aString.		self repository isMissing ifTrue: [ ^ text allBold; makeAllColor: self colorError ].		self isLoaded ifFalse: [ ^ text makeAllColor: self colorNotLoaded ].		modified := entity isModified.		incoming := self incomingCommits notEmpty.		outgoing := self outgoingCommits notEmpty.		modified ifTrue: [ text prepend: '* ' ].		modified | incoming | outgoing ifTrue: [ text allBold ].		modified ifTrue: [ ^ text makeAllColor: self colorModified ].		incoming ifTrue: [ ^ text makeAllColor: self colorIncoming ].		outgoing ifTrue: [ ^ text makeAllColor: self colorOutgoing ].		^ text	]	on: Error do: [ ^ aString ]! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!incomingCommits	^ incomingCommits value! !!IceAbstractModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	"NOTE: this was before [ self entity incomingCommits ], but this is not happy 	 with weak announcements (they will remain forever)... so we change them for 	 WeakMessageSend instances to avoid problems"	incomingCommits := (IceCachedValue		for: (WeakMessageSend receiver: self entity selector: #incomingCommits))			invalidateOn: IceRepositoryAnnouncement 			from: self repository announcer weak.		outgoingCommits := (IceCachedValue		for: (WeakMessageSend receiver: self entity selector: #outgoingCommits))			invalidateOn: IceRepositoryAnnouncement 			from: self repository announcer weak! !!IceAbstractModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isLoaded	self subclassResponsibility ! !!IceAbstractModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isMissing	^ self repository isMissing! !!IceAbstractModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isOperative	^ self repository isMissing not! !!IceAbstractModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!makeError: aString	^ aString asText allBold makeAllColor: self colorError	! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!outgoingCommits	^ outgoingCommits value	! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	self subclassResponsibility! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!status	"entity could be a repository or a package"	[		| status incoming outgoing | 		self verifyDirectoryStructureIfMissing: [ :message | ^ message ].				self isLoaded ifFalse: [ ^ 'Not loaded' ].		status := OrderedCollection new.		entity isModified ifTrue: [ status add: 'Uncommited changes' ].				incoming := self incomingCommits size.		incoming > 0 ifTrue: [ status add: ('{1} incoming' format: { incoming })].				outgoing := self outgoingCommits size.		outgoing > 0 ifTrue: [ status add: ('{1} not published' format: { outgoing })].		^ status ifEmpty: 'Up to date' ifNotEmpty: [ ', ' join: status ]	] 	on: Error do: [ :error | ^ self makeError: error description ]! !!IceAbstractModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!verifyDirectoryStructureIfMissing: aBlock	self repository isMissing 		ifTrue: [ ^ aBlock value: (self makeError: 'Local repository missing') ].	self repository isCodeMissing		ifTrue: [ ^ aBlock value: (self makeError: 'Code directory missing') ].! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!browse	^ self package browse! !!IcePackageModel methodsFor: 'highlighting' stamp: ' 7/21/2017 17:44:57'!highlight: aString	[ 		| text modified |			text := Text fromString: aString.		self repository isMissing ifTrue: [ ^ text allBold; makeAllColor: self colorError ].		self isLoaded ifFalse: [ ^ text makeAllColor: self colorNotLoaded ].		modified := entity isModified.		modified ifTrue: [ text prepend: '* ' ].		modified ifTrue: [ text allBold ].		modified ifTrue: [ ^ text makeAllColor: self colorModified ].		^ text	]	on: Error do: [ ^ aString ]! !!IcePackageModel methodsFor: 'acessing' stamp: ' 7/21/2017 17:44:57'!isLoaded	^ self package isLoaded! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!loadLatest	self package loadLatest! !!IcePackageModel methodsFor: 'acessing' stamp: ' 7/21/2017 17:44:57'!nameText	^ self highlight: self packageName! !!IcePackageModel methodsFor: 'acessing' stamp: ' 7/21/2017 17:44:57'!package	^ entity! !!IcePackageModel methodsFor: 'acessing' stamp: ' 7/21/2017 17:44:57'!packageName	^ self package name! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!reload	self package reload! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!removeFromDisk	self entity removeFromDisk! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!removeFromDiskThen: aBlock	(UIManager default confirm: ('You are going to remove package {1} from disk. Are you sure?' format: { self entity name }))		ifFalse: [ ^ self ].	self entity removeFromDisk: true.	aBlock value! !!IcePackageModel methodsFor: 'acessing' stamp: ' 7/21/2017 17:44:57'!repository	^ self entity repository! !!IcePackageModel methodsFor: 'acessing' stamp: ' 7/21/2017 17:44:57'!status	"entity could be a repository or a package"	[		| status | 		self repository isMissing ifTrue: [ ^ 'Local repository missing' asText allBold makeAllColor: self colorError ].		self isLoaded ifFalse: [ ^ 'Not loaded' ].		status := OrderedCollection new.		entity isModified ifTrue: [ status add: 'Uncommited changes' ].				^ status 			ifNotEmpty: [ status asCommaString ]			ifEmpty: [ 'Up to date' ] ] 	on: Error do: [ :error | ^ error description asText makeAllColor: self colorError ]! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!unload	self package unload! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!unloadAndRemoveFromDiskThen: aBlock	self unload.	self removeFromDiskThen: [].	aBlock value! !!IceRepositoryModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!registry	^ IceRepository registry collect: [ :repository | self modelFor: repository ]! !!IceRepositoryModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!tagDefaultPull	^ 'Pull'! !!IceRepositoryModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!tagDefaultPush	^ 'Push'! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/21/2017 17:44:57'!addRemoteThen: aBlock	IceRemoteModel new 		setModal: true;		repository: self repository;		onAccept: [ :remote |			self repository addRemote: remote. 			aBlock cull: remote ];		openWithSpec! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branchName	^ self repository branch name! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branches	^ self repository allBranches! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!browseHistory	IceHistoryBrowser openOn: self repository! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!canPush	[ 		^ self isOperative 			and: [ self outgoingCommits notEmpty 			and: [ self incomingCommits isEmpty ] ]	]	on: Error do: [ ^ false ]! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!compareCurrentBranchWithBranch: aBranch	IceBranchBrowser openOn: aBranch! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!createNewBranchThen: aBlock	| selection |	selection := UIManager default		request: 'Please provide the name of the new branch to be created'		initialAnswer: ''		title: 'Create new branch'.	selection ifNotNil: [ 		selection 			ifEmpty: [ 				UIManager default 					abort: 'Branch name can not be empty.' 					title: 'Create new branch'. ]			ifNotEmpty: [ 				self repository createBranch: selection.				aBlock cull: self repository branch ] ]! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!descriptionText	^ self highlight: self repository name! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!descriptionTextForBranch: aBranch	^ aBranch isRemote		ifTrue: [ aBranch basename ]		ifFalse: [ | text |			text := aBranch name asText.			(self isCurrentBranch: aBranch)				ifTrue: [ text allBold ].			text ]! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!descriptionTextForRemote: aRemote	^ aRemote remoteName! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!detailedInfo	^ 	self repository origin detailedInfo, { 		'Location' -> self repository location pathString. 		'Pulling from' -> (self repository pullRemote 			ifNotNil: [ :r | r remoteName ]			ifNil: [ self repository origin remoteName ]). 		'Pushing to' -> (self repository pushRemote 			ifNotNil: [ :r | r remoteName ]			ifNil: [ self repository origin remoteName ]).		'On branch' -> self repository branchName.	} ! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!editRepositoryThen: aBlock	(IceEditRepositoryModel repository: self repository) 		onAccept: aBlock;		openWithSpec! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!fetch	^ self repository fetch! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/21/2017 17:44:57'!fetchRemote: aRemote 	self repository fetchFrom: aRemote! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!forgetThen: aBlock	(UIManager default confirm:			('Are you sure to remove repository: {1}?(Packages will not be deleted, nor the repository from the file system)'				format: { self repository origin url })		label: 'Removing Iceberg Repository')	ifTrue: [ 		self repository forget.		aBlock cull: self ]! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!hasLocalBraches	^ self repository hasLocalBraches! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!inspectRepository	self repository inspect! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isCurrentBranch: aBranch	^ self repository branch = aBranch! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isLoaded	^ self repository loadedPackages isNotEmpty ! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isPullRemote: aRemote	^ self repository isPullRemote: aRemote! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isPushRemote: aRemote	^ self repository isPushRemote: aRemote! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isValid	^ self repository isValid! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!loadedCodeDescription	self verifyDirectoryStructureIfMissing: [ :message | ^ message ].	^ self repository loadedCode description! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!localBranches	^ self repository localBranches! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/21/2017 17:44:57'!makePullRemote: aRemote	self repository pullRemote: aRemote! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/21/2017 17:44:57'!makePushRemote: aRemote	self repository pushRemote: aRemote! !!IceRepositoryModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!pickBranch 	| branches |	 	branches := self repository branchesForCheckout.	^ UIManager default		chooseFrom: (branches collect: #name)		values: branches		message: 'Select the new branch you want to switch to:' 		title: 'Checkout branch'! !!IceRepositoryModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!pickRemote: aTitle	| remotes |	 	remotes := self repository remotes.	^ UIManager default		chooseFrom: (remotes collect: #remoteName)		values: remotes		message: 'Select the remote you want to use:' 		title: aTitle! !!IceRepositoryModel methodsFor: 'accessing plugins' stamp: ' 7/21/2017 17:44:57'!pluginActions	^ self repository pluginManager repositoryActions! !!IceRepositoryModel methodsFor: 'accessing plugins' stamp: ' 7/21/2017 17:44:57'!pluginPackageActionsFor: icePackage	^ self repository pluginManager packageActionsFor: icePackage! !!IceRepositoryModel methodsFor: 'accessing plugins' stamp: ' 7/21/2017 17:44:57'!pluginRemoteActionsFor: aRemote	^ self repository pluginManager remoteActionsFor: aRemote! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!pull	self validateCanPull ifFalse: [ ^ self ].	self repository pull! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!pullFrom	| remote |	self validateCanPull ifFalse: [ ^ self ].	remote := self pickRemote: 'Pull from'.	remote ifNil: [ ^ self ].	self repository pullFrom: remote.! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/21/2017 17:44:57'!pullRemote: aRemote	self repository pullFrom: aRemote! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/21/2017 17:44:57'!pushRemote: aRemote	self repository pushTo: aRemote! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!pushThen: aBlock	self 		pushTo: self repository pushRemote 		then: aBlock! !!IceRepositoryModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!pushTo: aRemote then: aBlock	"We need an existing remote as premise to do the push (new repositories can have this 	 situation)"	aRemote ifNil: [ 		^ UIManager default			abort: 'There is no remote to publish, please add one (in "remotes" tab).'			title: 'Publishing aborted' ].	[ 		UIManager default informUserDuring: [ :bar | 			bar label: ('Publishing local commits to {1}' format: { aRemote url }).			self repository pushTo: aRemote. 			aBlock value ] ] 	on: YouShouldPullBeforePush	do: [ 		UIManager default			abort: 'Publish operation is not possible because your repository is out of date. Please update your local repository and retry.'			title: 'Publishing aborted' ]! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!pushToThen: aBlock	| remote |	remote := self pickRemote: 'Push to'.	remote ifNil: [ ^ self ].	self pushTo: remote then: aBlock! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!refresh	self repository refresh! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!reloadAllLoadedPackages	self repository savedPackages 		select: #isLoaded 		thenDo: [ :each | each reload ].! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remotes	^ self repository remotes! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/21/2017 17:44:57'!removeRemote: aRemote then: aBlock	(self confirm: (('You are going to remove remote {1}. Are you sure?') format: {aRemote}))		ifFalse: [ ^ self ].	self repository removeRemote: aRemote.	aBlock cull: aRemote! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ self entity! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!restore	self repository backend cloneRepository.	self repository refresh.! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!savedPackages	^ [self repository savedPackages collect: [ :package | IcePackageModel modelFor: package ]]		on: Error do: [ :error | 			self inform: ('Error computing saved packages for repository: {1}. {2}'				format: { self repository name. error }).			#()		]! !!IceRepositoryModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!shouldCreateLocalBranchFromRemote 	^ UIManager default		confirm: 'You are trying to switch to a remote branch.' , String cr , 			'Do you want to create a local branch for it?' , String cr ,			'Note: if you do not create a local branch, you will be in a detached head and you won''t be abe to commit code!!'		label: 'Checkout remote branch'! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!statusForRemote: aRemote	| incoming outgoing allStatus |		incoming := (self repository incomingCommitsFrom: aRemote) size.	outgoing := (self repository outgoingCommitsTo: aRemote) size.		allStatus := OrderedCollection new.	(incoming = 0 and: [ outgoing = 0 ]) ifTrue: [ allStatus add: 'Up to date' ].	incoming > 0 ifTrue: [ allStatus add: ('{1} incoming' format: {incoming}) ].	outgoing > 0 ifTrue: [ allStatus add: ('{1} not published' format: {outgoing}) ].	^ ((self tagsForRemote: aRemote), allStatus) asCommaString! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!switchBranch	| branch |	branch := self pickBranch.	branch ifNil: [ ^ self ].	self switchBranchTo: branch! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!switchBranchTo: branch	branch isRemote		ifTrue: [ self repository localBranches 				detect: [:aBranch | aBranch name = branch basename ]				ifFound: [ UIManager default inform: 'Cannot switch to this branch. A local branch with the same name already exists!!'.								self flag: 'We should probably go into detached head state.' ]				ifNone: [ self shouldCreateLocalBranchFromRemote 					ifTrue: [ self repository backend withRepoDo: [ :repo | repo createBranchFromOrigin: branch basename ].								self repository checkoutBranch: branch basename ]					ifFalse: [ self shouldBeImplemented ] ] ]		ifFalse: [ self repository checkoutBranch: branch basename ]! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!synchronize	IceGlamourSynchronizer synchronize: self repository! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!tagsForRemote: aRemote	| tags |		tags := OrderedCollection new.	(self isPushRemote: aRemote) ifTrue: [ tags add: self class tagDefaultPush ]. 	(self isPullRemote: aRemote) ifTrue: [ tags add: self class tagDefaultPull ]. 		^ tags asArray! !!IceRepositoryModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!validateCanPull	self repository isModified		ifTrue: [ 			^ IceTool uiManager				confirm:					'Your repository has uncommited changes. Merging incoming commits will changeyour current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.'				label: 'You might loose your current changes!!'				trueChoice: 'Proceed anyway'				falseChoice: 'Cancel'				cancelChoice: nil				default: false ].	^ true! !!IceCachedValue class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!for: aBlock	^ self new updateAction: aBlock! !!IceCachedValue class methodsFor: 'settings' stamp: ' 7/21/2017 17:44:57'!timeout	^ 30 seconds! !!IceCachedValue methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	updating := false! !!IceCachedValue methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!invalidateOn: announcementType from: announcer	announcer subscribe: announcementType send: #reset to: self! !!IceCachedValue methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!isValid	^ lastUpdated isNotNil and: [ (DateAndTime current - lastUpdated) < self class timeout ]! !!IceCachedValue methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!reset	lastUpdated := nil! !!IceCachedValue methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!updateAction: anObject	updateAction := anObject! !!IceCachedValue methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!value	self isValid ifTrue: [ ^ value ].	updating ifTrue: [ ^ 'Loading...' asText allItalic ].	[ 		updating := true.		value := updateAction value.		lastUpdated := DateAndTime current.		^ value	]	ensure: [ updating := false ]! !!IceChangesTreeResetSelectionHelper class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!for: aPresentation	^ self new 		presentation: aPresentation;		yourself! !!IceChangesTreeResetSelectionHelper methodsFor: 'executing' stamp: ' 7/21/2017 17:44:57'!execute: ann	self presentation selection: nil! !!IceChangesTreeResetSelectionHelper methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!presentation	^ presentation! !!IceChangesTreeResetSelectionHelper methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!presentation: anObject	presentation := anObject! !!IceDiffChangeTreeBuilder methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!browseAction	^ GLMGenericAction new		action: [ :presentation | presentation selection browse ];		condition: [ :presentation :entity | 			presentation selection notNil 				and: [ presentation selection canBeBrowsed ]];		icon: #nautilus asIcon;		shortcut: $b;		title: 'Browse'; 		showTitle! !!IceDiffChangeTreeBuilder methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!browseReferencesAction	^ GLMGenericAction new		action: [ :presentation | presentation selection browseReferences ];		condition: [ :presentation | 			presentation selection notNil 				and: [ presentation selection canBrowseReferences ]];		shortcut: $n;		title: 'Browse references'; 		showTitle! !!IceDiffChangeTreeBuilder methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!buildOn: aPresenter	^ aPresenter fastTree		allExpanded;		children: #elements;		icon: #icon;		format: #description;		display: [ self elements ];		updateOn: IceChangeSetChanged from: #announcer;		addAction: self refreshTreeAction;		addSelectionAction: self browseAction;		addSelectionAction: self browseReferencesAction;		addSelectionAction: self revertChangeAction;		onChangeOfPort: #entity act: [ :presentation | 			self diff ifNotNil: [  				self diff announcer 					subscribe: IceChangeSetChanged 					send: #execute:					to: (IceChangesTreeResetSelectionHelper for: presentation) ] ];		yourself! !!IceDiffChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!diff	^ diff! !!IceDiffChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!diff: anObject	diff := anObject! !!IceDiffChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!elements 	^ self diff elements select: #hasChanges! !!IceDiffChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!entity	^ entity ifNil: [ self diff ]! !!IceDiffChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!entity: anObject	entity := anObject! !!IceDiffChangeTreeBuilder methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!refreshTreeAction	^ GLMGenericAction new		action: [ self entity refresh ];		icon: #glamorousRefresh asIcon;		shortcut: $r;		title: 'Refresh tree'; showTitle! !!IceDiffChangeTreeBuilder methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!revertChangeAction	^ GLMGenericAction new		action: [ :presentation | self entity revertChange: presentation selection ];		condition: [ self entity canRevertChanges ];		icon: #glamorousUndo asIcon;		title: 'Revert change'; 		showTitle! !!IceDiffCherryPickChangeTreeBuilder methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!buildOn: aPresenter	^ aPresenter cherryPickTree		allExpanded;		children: #elements;		icon: #icon;		format: #description;		display: [ self elements ];		allSelected;		onChangeOfCherryPick: [ :presentation | self selectedCherryPick: presentation cherryPick ];		updateOn: IceChangeSetChanged from: #announcer;		addAction: self refreshTreeAction;		addSelectionAction: self browseAction;		addSelectionAction: self browseReferencesAction;		addSelectionAction: self revertChangeAction;		onChangeOfPort: #entity act: [ :presentation | 			self diff ifNotNil: [				self diff announcer 					subscribe: IceChangeSetChanged					send: #execute:					to: (IceChangesTreeResetSelectionHelper for: presentation) ] ];		yourself! !!IceDiffCherryPickChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!onSelectCherryPick: aBlock	cherryPickBlock := aBlock! !!IceDiffCherryPickChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!selectedCherryPick: aSet	cherryPickBlock ifNil: [ ^ self ].	cherryPickBlock value: aSet! !!IceMergeTool methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!chooseTargetBranch	| branches |		self targetBranch ifNotNil: [ ^ self targetBranch ].		branches := self repository branchesForMerge: self source.	^ targetBranch := self uiManager		chooseFrom: (branches collect: #name)		values: branches		message: ('Select the branch into you want to merge commit {1}' format: { source shortId })		title: 'Merge your changes into another branch'.! !!IceMergeTool methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!confirmContinueWithDirtyRepository	^ self uiManager		confirm:'Your repository has uncommited changes. Merge will change your current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.'		label: 'You might loose your current changes!!'		trueChoice: 'Proceed anyway'		falseChoice: 'Cancel'		cancelChoice: nil		default: false! !!IceMergeTool methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!informAutomaticMergeImpossible	self uiManager		abort: 'Automatic merge is not possible, to merge manually please first checkout branch ', self targetBranch name, ' and then retry.' 		title: 'Automatic merge impossible'! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!onMerge	^ onMerge! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!onMerge: anObject	onMerge := anObject! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository ifNil: [ repository := self source repository ]! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	^ repository := anObject! !!IceMergeTool methodsFor: 'merging' stamp: ' 7/21/2017 17:44:57'!run	"Merge selected commit into another branch"	self repository isModified ifTrue: [ 		self confirmContinueWithDirtyRepository ifFalse: [ ^ self ]].	self chooseTargetBranch ifNil: [ ^ self ].	[ source mergeInto: self targetBranch ]		on: IceMergeAborted		do: [ 			self targetBranch name = repository branchName 				ifTrue: [ repository mergeConflictsWith: source ]				ifFalse: [ self informAutomaticMergeImpossible. ^ self ]].	self onMerge value ! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!source	^ source! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!source: anObject	source := anObject! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!targetBranch	^ targetBranch! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!targetBranch: anObject	targetBranch := anObject! !!IceRepositoryUpdateHelper class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!for: aPresentation	^ self new 		presentation: aPresentation;		yourself! !!IceRepositoryUpdateHelper methodsFor: 'executing' stamp: ' 7/21/2017 17:44:57'!execute: ann	self presentation		updateOn: IceRepositoryAnnouncement 		from: [ ann repository announcer weak ]! !!IceRepositoryUpdateHelper methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!presentation	^ presentation! !!IceRepositoryUpdateHelper methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!presentation: anObject	presentation := anObject! !!PharoShortcuts methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!openIcebergShortcut	^ $o meta, $i meta! !!Text methodsFor: '*Iceberg-UI' stamp: ' 7/21/2017 17:44:57'!allItalic	"Force this whole text to be italic."	string isEmpty ifTrue: [ ^ self ].	^ self addAttribute: TextEmphasis italic from: 1 to: string size.! !!GLMMorphicSwappedColorDiffRenderer methodsFor: 'rendering' stamp: ' 7/21/2017 17:44:57'!render: aPresentation	| textMorph |	textMorph := (SwappedColorDiffMorph		from: aPresentation displayValue first		to: aPresentation displayValue last		contextClass: aPresentation contextClassValue)			layoutFrame: (LayoutFrame identity);			vResizing: #spaceFill;			hResizing: #spaceFill;			yourself.	^textMorph! !!Trait method!uiManager	^ UIManager default! !!Trait method!uiManager	^ UIManager default! !!Trait method!uiManager	^ UIManager default! !!Trait method!mergeIntoAnotherBranch: aCommit andThen: aBlock	"Merge selected commit into another branch"	| branches selection repository |	repository := aCommit repository.		repository isModified ifTrue: [ 		(self uiManager			confirm:'Your repository has uncommited changes. Merge will change your current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.'			label: 'You might loose your current changes!!'			trueChoice: 'Proceed anyway'			falseChoice: 'Cancel'			cancelChoice: nil			default: false) 			ifFalse: [ ^ self ].	 ].		branches := repository branchesForMerge: aCommit.	selection := self uiManager		chooseFrom: (branches collect: #name)		values: branches		message: ('Select the branch into you want to merge commit {1}' format: { aCommit shortId })		title: 'Merge your changes into another branch'.	selection ifNotNil: [ 		[ aCommit mergeInto: selection ]			on: IceMergeAborted			do: [ 				selection name = repository branchName 					ifTrue: [ repository mergeConflictsWith: aCommit ]					ifFalse: [ 						self uiManager 						abort: 'Automatic (fast-forward) merge is not possible, to merge manually please first checkout branch ', selection name, ' and then retry.' 						title: 'Automatic merge failed' ]			].		aBlock value 	]! !!Trait method!mergeIntoAnotherBranch: aCommit andThen: aBlock	"Merge selected commit into another branch"	| branches selection repository |	repository := aCommit repository.		repository isModified ifTrue: [ 		(self uiManager			confirm:'Your repository has uncommited changes. Merge will change your current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.'			label: 'You might loose your current changes!!'			trueChoice: 'Proceed anyway'			falseChoice: 'Cancel'			cancelChoice: nil			default: false) 			ifFalse: [ ^ self ].	 ].		branches := repository branchesForMerge: aCommit.	selection := self uiManager		chooseFrom: (branches collect: #name)		values: branches		message: ('Select the branch into you want to merge commit {1}' format: { aCommit shortId })		title: 'Merge your changes into another branch'.	selection ifNotNil: [ 		[ aCommit mergeInto: selection ]			on: IceMergeAborted			do: [ 				selection name = repository branchName 					ifTrue: [ repository mergeConflictsWith: aCommit ]					ifFalse: [ 						self uiManager 						abort: 'Automatic (fast-forward) merge is not possible, to merge manually please first checkout branch ', selection name, ' and then retry.' 						title: 'Automatic merge failed' ]			].		aBlock value 	]! !!Trait method!mergeIntoAnotherBranch: aCommit andThen: aBlock	"Merge selected commit into another branch"	| branches selection repository |	repository := aCommit repository.		repository isModified ifTrue: [ 		(self uiManager			confirm:'Your repository has uncommited changes. Merge will change your current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.'			label: 'You might loose your current changes!!'			trueChoice: 'Proceed anyway'			falseChoice: 'Cancel'			cancelChoice: nil			default: false) 			ifFalse: [ ^ self ].	 ].		branches := repository branchesForMerge: aCommit.	selection := self uiManager		chooseFrom: (branches collect: #name)		values: branches		message: ('Select the branch into you want to merge commit {1}' format: { aCommit shortId })		title: 'Merge your changes into another branch'.	selection ifNotNil: [ 		[ aCommit mergeInto: selection ]			on: IceMergeAborted			do: [ 				selection name = repository branchName 					ifTrue: [ repository mergeConflictsWith: aCommit ]					ifFalse: [ 						self uiManager 						abort: 'Automatic (fast-forward) merge is not possible, to merge manually please first checkout branch ', selection name, ' and then retry.' 						title: 'Automatic merge failed' ]			].		aBlock value 	]! !!Trait method!pushRepository: repository andThen: aBlock	[ UIManager default informUserDuring: [ :bar | | remote |		remote := repository pushRemote.		bar label: ('Publishing local commits to {1}' format: {remote}).		repository pushTo: remote. 		aBlock value.	]] 	on: YouShouldPullBeforePush	do: [ 		self uiManager			abort: 'Publish operation is not possible because your repository is out of date. Please update your local repository and retry.'			title: 'Publishing aborted' 	]! !!Trait method!pushRepository: repository andThen: aBlock	[ UIManager default informUserDuring: [ :bar | | remote |		remote := repository pushRemote.		bar label: ('Publishing local commits to {1}' format: {remote}).		repository pushTo: remote. 		aBlock value.	]] 	on: YouShouldPullBeforePush	do: [ 		self uiManager			abort: 'Publish operation is not possible because your repository is out of date. Please update your local repository and retry.'			title: 'Publishing aborted' 	]! !!Trait method!pushRepository: repository andThen: aBlock	[ UIManager default informUserDuring: [ :bar | | remote |		remote := repository pushRemote.		bar label: ('Publishing local commits to {1}' format: {remote}).		repository pushTo: remote. 		aBlock value.	]] 	on: YouShouldPullBeforePush	do: [ 		self uiManager			abort: 'Publish operation is not possible because your repository is out of date. Please update your local repository and retry.'			title: 'Publishing aborted' 	]! !!Trait method!uiManager	^ self class uiManager! !!Trait method!uiManager	^ self class uiManager! !!Trait method!uiManager	^ self class uiManager! !"Iceberg-UI"!!IceGitHubPullRequestBrowser commentStamp: '<historical>' prior: 0!I'm a browser to show a pull request in detailt. Since a PR is not much more than a branch, I extend the branch browser :)!!IceGitHubPullRequestListBrowser commentStamp: '<historical>' prior: 0!I'm a browser to show all open pull requests in a repository.!!IceGitHubError commentStamp: 'EstebanLorenzano 2/1/2017 17:15' prior: 0!I'm an error that happens when something fails when performing a GitHub action.!!IceGitHubBadCredentialsError commentStamp: '<historical>' prior: 0!I'm an error that happens when credentials are bad.!!IceGitHubGenericError commentStamp: '<historical>' prior: 0!I'm an error that happens when something went wrong on GitHub API operations.!!IceGitHubJSONDataSource commentStamp: '<historical>' prior: 0!I'm a generic datasource to show in a table results of a JSON. I'm intended to be used to show information from GitHub API, but I'm generic enough to be used which any kind of JSON structure.!!IceGitHubPullRequestDataSource commentStamp: '<historical>' prior: 0!I'm a datasource for pull request status, to be used when showing pull requests details. See IceGitHubPullRequestDetailModel!!IceGitHubAcceptPullRequestModel commentStamp: '<historical>' prior: 0!I'm a dialog for collecting data to accept a pull request.!!IceGitHubCreatePullRequestModel commentStamp: '<historical>' prior: 0!I'm a dialog to ask for data relevant to create a pull request.!!IceGitHubPullRequestActionsModel commentStamp: '<historical>' prior: 0!I'm an actions toolbar, to be used with IceGitHubPullRequestBrowser.!!IceGitHubPullRequestDetailModel commentStamp: '<historical>' prior: 0!I'm a spec model to present a detailed view of a Pull Request.!!IceGitHubRejectPullRequestModel commentStamp: '<historical>' prior: 0!I'm a dialog to collect data about a pull request rejection.!!IceGitHubSelectListModel commentStamp: '<historical>' prior: 0!I'm a dialog to select a list of anything (used by branches now).!!IceGitHubAPI commentStamp: '<historical>' prior: 0!I represent an access point to the GitHub API. I provide different high level abstractions to interact with GitHub, following the speciphications you can find here: https://developer.github.com/v3/!!IceGitHubAPIPaginatedResult commentStamp: '<historical>' prior: 0!I'm a paginated answer from github (he sends results in pages and includes information in headers)!!IceGitHubCommand commentStamp: '<historical>' prior: 0!I'm a generic command to perform plugin actions for GitHub.My children define the real behavior, and they need to implement #execute.!!IceGitHubNewPullRequestCommand commentStamp: '<historical>' prior: 0!I'm a command to create a Pull Request!!IceGitHubRemoveBranchesCommand commentStamp: '<historical>' prior: 0!I'm a command to remove branches from remotes.!!IceGitHubViewPullRequestCommand commentStamp: '<historical>' prior: 0!I'm a command to show the pull request review browser.!!IceGitHubPullRequest commentStamp: '<historical>' prior: 0!I'm a pull request from github API. I represent (more or less), what is described here: https://developer.github.com/v3/pulls/#list-pull-requests!!IceGitHubPullRequestDefinition commentStamp: '<historical>' prior: 0!I am a pull request. I can be sent using ==#sendWithCredentials:== protocol.!!IceGitHubSelectItem commentStamp: '<historical>' prior: 0!I'm a helper to keep selected items in a list.!!IceGitHubPullRequestPlugin commentStamp: '<historical>' prior: 0!I define the plugin GitHub - Pull Request!!IceGitHubPullRequestBrowser methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!acceptPullRequest	IceGitHubAcceptPullRequestModel new 		onAccept: [ :model | 			self pullRequest 				acceptMessage: model message 				type: model type ];		openWithSpec	! !!IceGitHubPullRequestBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!addChangesTreeTo: a with: commitInfo	(IceDiffChangeTreeBuilder new		entity: commitInfo;		diff: (commitInfo ifNotNil: [ 			commitInfo diffTo: (commitInfo repository commitAt: self baseSHA)  ]);		buildOn: a)		title: 'Changes vs. destination' .	super addChangesTreeTo: a with: commitInfo! !!IceGitHubPullRequestBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!baseSHA	^ self pullRequest baseSHA! !!IceGitHubPullRequestBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!composeBrowserOn: browser	browser 		row: [:row | 			row 				column: #commits; 				column: #changes ]; 		row: #diff;		row: #actions size: 35.		browser transmit to: #commits; andShow: [ :a | self composeCommitsIn: a ].	self addChangesTreesTo: browser.	self addDiffTo: browser.	self addCommitInfoTo: browser.		browser transmit to: #actions; andShow: [ :a | 		a morph			morph: [ 				IceGitHubPullRequestActionsModel new 					onMerge: [ self mergePullRequestIntoImage ];					onAccept: [ self acceptPullRequest ];					onReject: [ self rejectPullRequest ];					buildWithSpec ] ]! !!IceGitHubPullRequestBrowser methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!mergePullRequestIntoImage	(UIManager default confirm: ('I will create a new local branch named {1}. Should I continue?' format: { self pullRequest branchName }))	ifFalse: [ ^ self ].	self pullRequest mergeIntoImage! !!IceGitHubPullRequestBrowser methodsFor: 'scripting opening' stamp: ' 7/21/2017 17:44:57'!open	self openOn: self pullRequest branch! !!IceGitHubPullRequestBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!pullRequest	^ pullRequest! !!IceGitHubPullRequestBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!pullRequest: anObject	pullRequest := anObject! !!IceGitHubPullRequestBrowser methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!rejectPullRequest	IceGitHubRejectPullRequestModel new 		onAccept: [ :model | 			self pullRequest 				rejectMessage: model message  ];		openWithSpec! !!IceGitHubPullRequestBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ 'Browsing pull request: #{1} {2}' format: { self pullRequest number. self pullRequest title  }! !!IceGitHubPullRequestListBrowser class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultExtent	^ 700@700! !!IceGitHubPullRequestListBrowser class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!icon	^ #komitterSmalltalkhubRemote asIcon! !!IceGitHubPullRequestListBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!buildOn: browser	browser 		row: #pullRequests;		row: #detail span: 2.			browser transmit to: #pullRequests; andShow: [ :a |		a fastTable 			title: 'Open pull requests';			addAction: self refreshAction;			selectionAct: [ :presentation | 				self viewPullRequest: presentation selection ] 				entitled: 'Review pull request...';			onChangeOfPort: #strongSelection act: [ :presentation | 				self viewPullRequest: presentation selection ];			column: '#' evaluated: #number width: 50;			column: 'State' evaluated: #state width: 50;			column: 'Author' evaluated: #author width: 120;			column: 'Title' evaluated: #title ].			browser transmit from: #pullRequests; to: #detail; andShow: [ :a |		a morph 			title: [ :pr | '#{1} {2}' format: {pr number. pr title} ];			morph: [ :presentation :pr | (IceGitHubPullRequestDetailModel for: pr) buildWithSpec ] ]! !!IceGitHubPullRequestListBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!compose	self tabulator with: [ :browser |		browser initialExtent: self initialExtent.		self buildOn: browser ]! !!IceGitHubPullRequestListBrowser methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!fetchPullRequests	^ (IceGitHubAPI new		getPullRequests: self remote owner project: self remote projectName) all		collect: [ :each | 			(IceGitHubPullRequest fromJSON: each)				repository: self repository;				yourself ]! !!IceGitHubPullRequestListBrowser methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ self class defaultExtent! !!IceGitHubPullRequestListBrowser methodsFor: 'scripting opening' stamp: ' 7/21/2017 17:44:57'!open	^ self openOn: self pullRequests! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!pullRequests	^ pullRequests! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!pullRequests: anObject	pullRequests := anObject! !!IceGitHubPullRequestListBrowser methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!refreshAction	^ GLMGenericAction new		action: [ :presentation |			UIManager default				informUser: 'Refreshing pull request list' 				during: [ self refreshPullRequests ].			presentation update ];		icon: #refresh asIcon;		title: 'Refresh'; 		showTitle! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!refreshPullRequests	self pullRequests: self fetchPullRequests! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote	^ remote! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote: anObject	remote := anObject! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ 'Pull requests on {1} ({2})' format: { self remote remoteName. self remote url }! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!titleIcon	^ self class icon! !!IceGitHubPullRequestListBrowser methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!viewPullRequest: aPullRequest	UIManager default 		informUser: ('Opening pull request {1} {2}' format: { aPullRequest number. aPullRequest title })		during: [  			IceGitHubPullRequestBrowser new 			pullRequest: aPullRequest;			open ]! !!IceGitHubBadCredentialsError class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isAppropriateFor: aResponse 	^ aResponse status = 401! !!IceGitHubBadCredentialsError methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!messageBody	^ 'Credentials provided are wrong'! !!IceGitHubError class methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!errorClassFor: aResponse	^ self allSubclasses 		detect: [ :each | each isAppropriateFor: aResponse  ]		ifNone: [ self ]! !!IceGitHubError class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!for: aResponse	^ (self errorClassFor: aResponse) new 		response: aResponse;		yourself	! !!IceGitHubError class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isAppropriateFor: aResponse	^ false! !!IceGitHubError class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!signalFor: aResponse	^ (self for: aResponse) signal! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!code	^ self response status! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!contents	^ self response contents! !!IceGitHubError methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!customError: aDictionary	^ aDictionary at: #message		! !!IceGitHubError methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!errorToString: aDictionary 	(aDictionary at: #code) = 'custom' ifTrue: [ ^ self customError: aDictionary ].	(aDictionary at: #code) = 'invalid' ifTrue: [ ^ self invalidError: aDictionary ].		^ self unknownError: aDictionary	! !!IceGitHubError methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!invalidError: aDictionary	^ 'Invalid field: ', (aDictionary at: #field)			! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!jsonContents	^ jsonContents ifNil: [ jsonContents := STON fromString: self contents ]		! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!messageBody	| errors |	errors := self jsonContents at: #errors ifAbsent: [ ^ '' ].	^ String streamContents: [ :stream | 		errors			do: [ :each | stream << (self errorToString: each) ] 			separatedBy: [ stream cr ] ].! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!messageText	^ self jsonContents at: #message! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!response	^ response! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!response: anObject	response := anObject! !!IceGitHubError methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!unknownError: aDictionary	^ String streamContents: [ :stream | 		(aDictionary associations sorted: [ :a :b | a key < b key  ])			do: [ :each | stream << each key << ': ' << each value ]			separatedBy: [ stream << ', ' ] ]! !!IceGitHubGenericError class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isAppropriateFor: aResponse	^ aResponse status = 422! !!IceGitHubJSONDataSource methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!actionColumn: column	elements := elements sorted: [ :a :b |		(a at: column id) < (b at: column id) ]		! !!IceGitHubJSONDataSource methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!cellColumn: column row: rowIndex 	^ FTCellMorph new  		addMorphBack: ((self elementAt: rowIndex) at: column id) asStringMorph;		yourself	! !!IceGitHubJSONDataSource methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!columnTitleFor: column	^ column id capitalized! !!IceGitHubJSONDataSource methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!headerColumn: column	column id ifNil: [ ^ nil ].	^ SimpleButtonMorph new		layoutPolicy: RowLayout new; 		listDirection: #leftToRight; 		wrapCentering: #center;		cellInset: 5@0;		layoutInset: 5@0;		label: (self columnTitleFor: column);		target: self;		actionSelector: #actionColumn:;		arguments: {column};		yourself! !!IceGitHubPullRequestDataSource methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!actionColumn: column	column id = #target_url ifTrue: [ ^ self ].	^ super actionColumn: column	! !!IceGitHubPullRequestDataSource methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!cellColumn: column row: rowIndex 	column id = #target_url ifTrue: [ ^ self targetUrlCellColumn: column rowIndex: rowIndex ].	column id = #state ifTrue: [ ^ self statusCellColumn: column rowIndex: rowIndex ].	column id = #context ifTrue: [ ^ self contextCellColumn: column rowIndex: rowIndex ].	^ super cellColumn: column row: rowIndex ! !!IceGitHubPullRequestDataSource methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!columnTitleFor: column	column id = #target_url ifTrue: [ ^ '' ].	^ super columnTitleFor: column! !!IceGitHubPullRequestDataSource methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!contextCellColumn: column rowIndex: rowIndex	| context |	context := (self elementAt: rowIndex) at: column id.	(context includesSubstring: 'travis-ci')		ifTrue: [ context := 'travis-ci' ].	^ FTCellMorph new  		addMorphBack: context asMorph;		yourself		! !!IceGitHubPullRequestDataSource methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!copyToClipboard: url	Clipboard clipboardText: url.	UIManager default inform: ('Url {1} copied to clipboard' format: { url })! !!IceGitHubPullRequestDataSource methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!iconForStatus: status	status = 'success' ifTrue: [ ^ #testGreen asIcon ].	status = 'failure' ifTrue: [ ^ #testRed asIcon ].	status = 'pending' ifTrue: [ ^ #testYellow asIcon ].		^ #testNotRun asIcon! !!IceGitHubPullRequestDataSource methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!statusCellColumn: column rowIndex: rowIndex	| status |	status := (self elementAt: rowIndex) at: column id.	^ FTCellMorph new  		cellInset: 5;		addMorphBack: (self iconForStatus: status) asMorph;		addMorphBack: status asStringMorph;		yourself	! !!IceGitHubPullRequestDataSource methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!targetUrlCellColumn: column rowIndex: rowIndex	| url |	url := (self elementAt: rowIndex) at: column id.	^ FTCellMorph new  		addMorphBack: (			IconicButton new				target: self;				actionSelector: #copyToClipboard:;				arguments: { url };				labelGraphic: (#smallCopy asIcon scaledToSize: 12@12);				color: Color transparent;				helpText: ('Copy url {1} to clipboard' format: { url });				borderWidth: 0;				yourself);		yourself	! !!IceGitHubAcceptPullRequestModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!availableTypes	^ #('merge' 'squash' 'rebase')! !!IceGitHubAcceptPullRequestModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec 	<spec>	^ SpecLayout composed		newColumn: [ :col |			col 				newRow: [:row | row add: #messageLabel width: 80; add: #messageText ];				newRow: [:row | row add: #typeLabel width: 80; add: #typeList ] height: 25;				add: #acceptButton height: self buttonHeight  ];		yourself! !!IceGitHubAcceptPullRequestModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultType	^ 'merge'! !!IceGitHubAcceptPullRequestModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!messageGhostText	^ 'Commit titleAdd an optional extented description'! !!IceGitHubAcceptPullRequestModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!title	^ 'Accept pull request'! !!IceGitHubAcceptPullRequestModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!accept	acceptBlock ifNotNil: [ 		acceptBlock cull: self ].		self window delete! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!acceptButton	^ acceptButton! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!acceptButton: anObject	acceptButton := anObject! !!IceGitHubAcceptPullRequestModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ 500@250! !!IceGitHubAcceptPullRequestModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializePresenter	super initializePresenter.	self typeList 		items: self class availableTypes;		displayBlock: [ :each | each  ];		setSelectedItem: self class defaultType! !!IceGitHubAcceptPullRequestModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	messageLabel := self newLabel.	messageText := self newText autoAccept: true.	typeLabel := self newLabel.	typeList := self newDropList.	acceptButton := self newButton.			messageLabel label: 'Comment'.	messageText 	whenBuiltDo: [ :this | this widget withGhostText: self class messageGhostText ].	typeLabel label: 'Merge type'.	acceptButton label: 'Accept pull request'.	acceptButton action: [ self accept ].		self focusOrder 		add: messageText;		add: typeList;		add: acceptButton! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!message	^ self messageText text asString! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!messageLabel	^ messageLabel! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!messageLabel: anObject	messageLabel := anObject! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!messageText	^ messageText! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!messageText: anObject	messageText := anObject! !!IceGitHubAcceptPullRequestModel methodsFor: 'events' stamp: ' 7/21/2017 17:44:57'!onAccept: aBlock	acceptBlock := aBlock! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!type	^ self typeList selectedItem! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!typeLabel	^ typeLabel! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!typeLabel: anObject	typeLabel := anObject! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!typeList	^ typeList! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!typeList: anObject	typeList := anObject! !!IceGitHubCreatePullRequestModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec 	<spec>	^ SpecLayout composed		newColumn: [ :col |			col 				newRow: [:row | row add: #titleLabel width: 80; add: #titlePanel ] height: 25;				newRow: [:row | 					row 						newColumn: #headLabel width: 80;						newColumn: [ :col2 | 							col2 newRow: [ :row2 | 								row2									add: #headForkList;									add: #headBranchList ] ] ] height: 25;				newRow: [:row | 					row 						newColumn: #baseLabel width: 80;						newColumn: [ :col2 |							col2 newRow: [ :row2 |								row2 									add: #baseForkList;									add: #baseBranchList ] ] ] height: 25;				newRow: [:row | row add: #bodyLabel width: 80; add: #bodyPanel ];				add: #addButton height: self buttonHeight  ];		yourself! !!IceGitHubCreatePullRequestModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!new	self error: 'Use #repository:credentials:'! !!IceGitHubCreatePullRequestModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!repository: aRepository credentials: aCredentials headRemote: aRemote	^ self basicNew 		initializeRepository: aRepository 			credentials: aCredentials			headRemote: aRemote;		yourself! !!IceGitHubCreatePullRequestModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!title	^ 'New pull request'! !!IceGitHubCreatePullRequestModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!accept	| title |		title := self titlePanel text trim.	title ifEmpty: [ 		UIManager default alert: 'You need to specify a title for the pull request.' title: 'Error'. 		^ self ].		acceptBlock ifNotNil: [ 		acceptBlock cull: self createPullRequest ].		self window delete! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!addButton	^ addButton! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!addButton: anObject	addButton := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!availableBranchNames	^ availableBranchNames ifNil: [ availableBranchNames := self obtainAvailableBranchNames ]! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!availableRemotes	"retrieves available remotes to perform the PR"	^ availableRemotes ifNil: [ availableRemotes := self obtainAvailableRemotes ]! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!baseBranchList	^ baseBranchList! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!baseBranchList: anObject	baseBranchList := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!baseBranchNames	^ self baseBranches collect: [ :each | each at: #name ]! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!baseBranches	^ baseBranches ifNil: [ 		baseBranches := self requestBaseBranches ]! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!baseDefaultBranchName	^ self gitBase at: #'default_branch' ! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!baseForkList	^ baseForkList! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!baseForkList: anObject	baseForkList := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!baseLabel	^ baseLabel! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!baseLabel: anObject	baseLabel := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!baseRemote	"This is the 'base' remote (the place where the repository is forked). This is used to 	 suggest fork PR destination (base)"	^ baseRemote ifNil: [ baseRemote := self obtainBaseRemote ]! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!bodyLabel	^ bodyLabel! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!bodyLabel: anObject	bodyLabel := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!bodyPanel	^ bodyPanel! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!bodyPanel: anObject	bodyPanel := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branch	^ self repository branch! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!createPullRequest	^ IceGitHubPullRequestDefinition new 		credentials: self credentials;		title: self titlePanel text trim;		headRemote: self headForkList selectedItem;		headBranchName: self headBranchList selectedItem;		baseRemote: self baseForkList selectedItem;		baseBranchName: self baseBranchList selectedItem;		body: self bodyPanel text asString trim;		yourself! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!credentials	^ credentials! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!credentials: aCredentials	credentials := aCredentials! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultBaseBranchName	self hasParent ifFalse: [ ^ self baseDefaultBranchName ].	^ self baseBranchNames 		detect: [ :each | each = self branch basename ] 		ifNone: [ self baseDefaultBranchName ]! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultHeadBranchName	^ self branch basename ! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!gitBase	| info |	^ (info := self gitRepositoryInfo) 		at: #parent		ifAbsent: [ info ]! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!gitRepositoryInfo	^ gitRepositoryInfo ifNil: [ 		gitRepositoryInfo := self requestGitRepositoryInfo ]! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!hasParent	^ self gitRepositoryInfo includesKey: #parent! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!headBranchList	^ headBranchList! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!headBranchList: anObject	headBranchList := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!headForkList	^ headForkList! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!headForkList: anObject	headForkList := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!headLabel	^ headLabel! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!headLabel: anObject	headLabel := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!headRemote 	^ headRemote  ifNil: [ self repository pushRemote ]! !!IceGitHubCreatePullRequestModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ 500@300! !!IceGitHubCreatePullRequestModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializePresenter	super initializePresenter.	self titlePanel text: self branch basename.	self headForkList		items: self availableRemotes;		displayBlock: [ :each | each owner, '/', each projectName ];		setSelectedItem: self headRemote.	self headBranchList 		items: self availableBranchNames;		displayBlock: [ :each | each ];		setSelectedItem: self defaultHeadBranchName.	self baseForkList		items: self availableRemotes;		displayBlock: [ :each | each owner, '/', each projectName ];		setSelectedItem: self baseRemote.	self baseBranchList 		items: self availableBranchNames;		displayBlock: [ :each | each ];		setSelectedItem: self defaultBaseBranchName! !!IceGitHubCreatePullRequestModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeRepository: aRepository credentials: aCredentials headRemote: aRemote	repository := aRepository.	credentials := aCredentials.	headRemote := aRemote.	self initialize! !!IceGitHubCreatePullRequestModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	titleLabel := self newLabel.	titlePanel := self newTextInput autoAccept: true.	headLabel := self newLabel.	headForkList := self newDropList.	headBranchList := self newDropList.	baseLabel := self newLabel.	baseForkList := self newDropList.	baseBranchList := self newDropList.	bodyLabel := self newLabel.	bodyPanel := self newText autoAccept: true.	addButton := self newButton.			titleLabel label: 'Title'.	headLabel label: 'From (Head)'.	baseLabel label: 'To (Base)'.	bodyLabel label: 'Comment'.	addButton label: 'Create pull request'.	addButton action: [ self accept ].		self focusOrder 		add: titlePanel;		add: headForkList;		add: headBranchList;		add: baseForkList;		add: baseBranchList;		add: bodyPanel;		add: addButton! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!obtainAvailableBranchNames	^ ((self repository allBranches 		collect: #basename as: Set)		addAll: self baseBranchNames;		asArray)		sort.	! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!obtainAvailableRemotes	| remotes |		remotes := self repository remotes.	(remotes includes: self baseRemote)		ifFalse: [ remotes := remotes copyWith: self baseRemote ].	^ remotes	! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!obtainBaseRemote	| base |	base := self gitBase.	^ IceRemote url: ((base at: #'git_url') copyReplaceAll: 'git://' with: 'https://')! !!IceGitHubCreatePullRequestModel methodsFor: 'events' stamp: ' 7/21/2017 17:44:57'!onAccept: aBlock	acceptBlock := aBlock! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceGitHubCreatePullRequestModel methodsFor: 'private request' stamp: ' 7/21/2017 17:44:57'!requestBaseBranches	^ IceGitHubAPI new 		credentials: self credentials;		getBranches: self baseRemote owner project: self baseRemote projectBasename ! !!IceGitHubCreatePullRequestModel methodsFor: 'private request' stamp: ' 7/21/2017 17:44:57'!requestGitRepositoryInfo	| remote |	remote := self headRemote.	^ IceGitHubAPI new 		credentials: self credentials;		getRepository: remote owner 			project: remote projectBasename! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!titleLabel	^ titleLabel! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!titleLabel: anObject	titleLabel := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!titlePanel	^ titlePanel! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!titlePanel: anObject	titlePanel := anObject! !!IceGitHubPullRequestActionsModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec	<spec>	^ SpecLayout composed		newRow: [ :row | 			row				add: #mergeButton;				add: #acceptButton;				add: #rejectButton ]! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!acceptButton	^ acceptButton! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!acceptButton: anObject	acceptButton := anObject! !!IceGitHubPullRequestActionsModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	mergeButton := self newButton.	acceptButton := self newButton.	rejectButton := self newButton.			mergeButton 		label: 'Merge into image';		action: [ mergeBlock value ].	acceptButton 		label: 'Accept pull request';		action: [ acceptBlock value ].	rejectButton 		label: 'Reject pull request';		action: [ rejectBlock value ]! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!mergeButton	^ mergeButton! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!mergeButton: anObject	mergeButton := anObject! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!onAccept: aBlock	acceptBlock := aBlock! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!onMerge: aBlock	mergeBlock := aBlock! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!onReject: aBlock	rejectBlock := aBlock! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!rejectButton	^ rejectButton! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!rejectButton: anObject	rejectButton := anObject! !!IceGitHubPullRequestDetailModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec 	<spec>	^ SpecLayout composed		newColumn: [ :c |			c 				newRow: [:row | row add: #urlLabel width: 80; add: #urlText ] height: 25;				newRow: [:row | row add: #authorLabel width: 80; add: #authorText ] height: 25;				newRow: [:row | row add: #fromLabel width: 80; add: #fromText ] height: 25;				newRow: [:row | row add: #toLabel width: 80; add: #toText ] height: 25;				newRow: [:row | row add: #mergeableLabel width: 80; add: #mergeablePanel ] height: 25;				newRow: [:row | row add: #statusLabel width: 80; add: #statusPanel ] height: 25;				newRow: [:row | row add: #checksTable ];				newRow: [:row | row add: #bodyText ] ];		yourself! !!IceGitHubPullRequestDetailModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!for: aPullRequest	^ self basicNew 		initializePullRequest: aPullRequest;		yourself! !!IceGitHubPullRequestDetailModel class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!new	self error: 'Use #for:'! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!authorLabel	^ authorLabel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!authorLabel: anObject	authorLabel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!authorText	^ authorText! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!authorText: anObject	authorText := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!bodyText	^ bodyText! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!bodyText: anObject	bodyText := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!checksTable	^ checksTable! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!checksTable: anObject	checksTable := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!fromLabel	^ fromLabel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!fromLabel: anObject	fromLabel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!fromText	^ fromText! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!fromText: anObject	fromText := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!iconForMergeable: mergeable	mergeable = true ifTrue: [ ^ #smallOk asIcon ].	^ #smallCancel asIcon! !!IceGitHubPullRequestDetailModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!iconForStatus: status	status = 'success' ifTrue: [ ^ #testGreen asIcon ].	status = 'failure' ifTrue: [ ^ #testRed asIcon ].	status = 'pending' ifTrue: [ ^ #testYellow asIcon ].		^ #testNotRun asIcon! !!IceGitHubPullRequestDetailModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	super initialize.	self retrieveStatuses.	self retrieveDetail.! !!IceGitHubPullRequestDetailModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializePullRequest: aPullRequest	pullRequest := aPullRequest.	self initialize	! !!IceGitHubPullRequestDetailModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	urlLabel := self newLabel label: 'Url'.	authorLabel := self newLabel label: 'Author'.	fromLabel := self newLabel label: 'From'.	toLabel := self newLabel label: 'Into'.	mergeableLabel := self newLabel label: 'Mergeable'.	statusLabel := self newLabel label: 'Status'.	urlText := self newTextInput 		enabled: false;		text: self pullRequest url.	authorText  := self newTextInput 		enabled: false;		text: self pullRequest author.	fromText  := self newTextInput 		enabled: false;		text: self pullRequest headLabel.	toText  := self newTextInput 		enabled: false;		text: self pullRequest baseLabel.	mergeablePanel := self newMergeablePanel.	statusPanel := self newStatusPanel.	checksTable := self newChecksTable.	bodyText := self newText 		enabled: false;		text: self pullRequest body.! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!mergeableLabel	^ mergeableLabel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!mergeableLabel: anObject	mergeableLabel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!mergeablePanel	^ mergeablePanel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!mergeablePanel: anObject	mergeablePanel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'private factory' stamp: ' 7/21/2017 17:44:57'!newChecksTable	^ FTTableMorph new 		addColumn: ((FTColumn id: #target_url) width: 18);		addColumn: ((FTColumn id: #state) width: 65);		addColumn: ((FTColumn id: #context) width: 100);		addColumn: (FTColumn id: #description);		cellInset: 5;		beResizable;		vResizing: #spaceFill;		hResizing: #spaceFill;		asSpecAdapter		! !!IceGitHubPullRequestDetailModel methodsFor: 'private factory' stamp: ' 7/21/2017 17:44:57'!newMergeablePanel	^ PanelMorph new 		color: Color transparent;		layoutPolicy: TableLayout new;		listDirection: #leftToRight;		cellInset: 5;		vResizing: #spaceFill;		hResizing: #spaceFill;		asSpecAdapter! !!IceGitHubPullRequestDetailModel methodsFor: 'private factory' stamp: ' 7/21/2017 17:44:57'!newStatusPanel	^ PanelMorph new 		color: Color transparent;		layoutPolicy: TableLayout new;		listDirection: #leftToRight;		cellInset: 5;		vResizing: #spaceFill;		hResizing: #spaceFill;		asSpecAdapter! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!pullRequest	^ pullRequest! !!IceGitHubPullRequestDetailModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!retrieveDetail		self mergeablePanel widget addMorphBack: 'Loading...' asMorph.	[ | detail mergeable |  		[  			detail := self pullRequest detail.			mergeable := detail at: #mergeable ]		on: Error do: [ :e | mergeable := nil ].		UIManager default defer: [ 			self mergeablePanel widget				removeAllMorphs;				addMorphBack: (self iconForMergeable: mergeable) asMorph;				addMorphBack: (self textForMergeable: mergeable) asMorph ]	] fork! !!IceGitHubPullRequestDetailModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!retrieveStatuses	self statusPanel widget addMorphBack: 'Loading...' asMorph.	[ 	| status generalStatus statuses |		[		status := self pullRequest status.		generalStatus := status at: 'state'.		statuses := status at: 'statuses' ]	on: Error do: [ :e | 		generalStatus := 'Unknown'.		statuses := #() ].		UIManager default defer: [ 		self statusPanel widget			removeAllMorphs;			addMorphBack: (self iconForStatus: generalStatus) asMorph;			addMorphBack: generalStatus asMorph.	 	self checksTable widget dataSource: (IceGitHubPullRequestDataSource elements: statuses) ]	] fork! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!statusLabel	^ statusLabel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!statusLabel: anObject	statusLabel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!statusPanel	^ statusPanel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!statusPanel: anObject	statusPanel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!textForMergeable: mergeable	mergeable = true ifTrue: [ ^ 'Yes' ].	mergeable = false ifTrue: [ ^ 'There are conflicts' ].	^ mergeable asString	! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!toLabel	^ toLabel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!toLabel: anObject	toLabel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!toText	^ toText! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!toText: anObject	toText := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!urlLabel	^ urlLabel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!urlLabel: anObject	urlLabel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!urlText	^ urlText! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!urlText: anObject	urlText := anObject! !!IceGitHubRejectPullRequestModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!availableTypes	^ #('merge' 'squash' 'rebase')! !!IceGitHubRejectPullRequestModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec 	<spec>	^ SpecLayout composed		newColumn: [ :col |			col 				newRow: [:row | row add: #messageLabel width: 80; add: #messageText ];				add: #acceptButton height: self buttonHeight  ];		yourself! !!IceGitHubRejectPullRequestModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!defaultType	^ 'merge'! !!IceGitHubRejectPullRequestModel class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!messageGhostText	^ 'Commit titleAdd an optional extented description'! !!IceGitHubRejectPullRequestModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!title	^ 'Accept pull request'! !!IceGitHubRejectPullRequestModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!accept	acceptBlock ifNotNil: [ 		acceptBlock cull: self ].		self window delete! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!acceptButton	^ acceptButton! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!acceptButton: anObject	acceptButton := anObject! !!IceGitHubRejectPullRequestModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ 500@250! !!IceGitHubRejectPullRequestModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	messageLabel := self newLabel.	messageText := self newText autoAccept: true.	acceptButton := self newButton.			messageLabel label: 'Comment'.	messageText 	whenBuiltDo: [ :this | this widget withGhostText: self class messageGhostText ].	acceptButton label: 'Reject pull request'.	acceptButton action: [ self accept ].		self focusOrder 		add: messageText;		add: acceptButton! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!message	^ self messageText text asString! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!messageLabel	^ messageLabel! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!messageLabel: anObject	messageLabel := anObject! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!messageText	^ messageText! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!messageText: anObject	messageText := anObject! !!IceGitHubRejectPullRequestModel methodsFor: 'events' stamp: ' 7/21/2017 17:44:57'!onAccept: aBlock	acceptBlock := aBlock! !!IceGitHubSelectListModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!buttonLabel	^ 'Select'! !!IceGitHubSelectListModel class methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!defaultExtent 	^ 550@500! !!IceGitHubSelectListModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!defaultSpec	<spec>	^ SpecLayout composed		newColumn:[ :col | 			col  				newRow: #listPanel;				newRow: #selectButton height: self buttonHeight ];		yourself! !!IceGitHubSelectListModel class methodsFor: 'specs' stamp: ' 7/21/2017 17:44:57'!title	^ 'Select...'! !!IceGitHubSelectListModel methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!confirmSelection	acceptBlock ifNotNil: [ 		acceptBlock value: selectedItems ].	self window delete! !!IceGitHubSelectListModel methodsFor: 'private factory' stamp: ' 7/21/2017 17:44:57'!createCheckboxFor: anObject	^ CheckboxMorph 		on: (IceGitHubSelectItem list: selectedItems item: anObject) 		selected: #value 		changeSelected: #value:! !!IceGitHubSelectListModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!displayBlock: aBlock 	self listPanel displayBlock: aBlock! !!IceGitHubSelectListModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!initialExtent	^ self class defaultExtent! !!IceGitHubSelectListModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	selectedItems := Set new.	super initialize.	self title: self class title! !!IceGitHubSelectListModel methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWidgets	listPanel := self instantiate: FastTableModel.	listPanel icons: [ :each | self createCheckboxFor: each ].	selectButton := self newButton.		selectButton 		label: self class buttonLabel;		action: [ self confirmSelection ].		self focusOrder 		add: listPanel;		add: selectButton! !!IceGitHubSelectListModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!items: aCollection	self listPanel items: aCollection! !!IceGitHubSelectListModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!listPanel	^ listPanel! !!IceGitHubSelectListModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!listPanel: anObject	listPanel := anObject! !!IceGitHubSelectListModel methodsFor: 'events' stamp: ' 7/21/2017 17:44:57'!onAccept: aBlock	acceptBlock := aBlock! !!IceGitHubSelectListModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!selectButton	^ selectButton! !!IceGitHubSelectListModel methodsFor: 'accessing ui' stamp: ' 7/21/2017 17:44:57'!selectButton: anObject	selectButton := anObject! !!IceGitHubSelectListModel methodsFor: 'api' stamp: ' 7/21/2017 17:44:57'!selectLabel: aString	self selectButton label: aString! !!IceGitHubAPI class methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!obtainCredentials	| newCredentials provider |		provider := IceCredentialsProvider default.	newCredentials := IcePlaintextCredentials new.	IceCredentialsProvider default providePlaintextCredentialsTo: newCredentials.	^ newCredentials! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/21/2017 17:44:57'!acceptPullRequest: owner project: projectName number: aNumber data: aDictionary	^ self 		put: 'repos/', owner, '/', projectName, '/pulls/', aNumber asString, '/merge'		with: [ :client |			client 				entity: (ZnEntity text: (STON toJsonString: aDictionary));				contentType: ZnMimeType applicationJson ]! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/21/2017 17:44:57'!addComment: owner project: projectName number: aNumber data: aDictionary	^ self 		post: 'repos/', owner, '/', projectName, '/issues/', aNumber asString, '/comments'		with: [ :client |			client 				entity: (ZnEntity text: (STON toJsonString: aDictionary));				contentType: ZnMimeType applicationJson ]! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/21/2017 17:44:57'!addPullRequest: owner project: projectName data: aDictionary	^ self 		post: 'repos/', owner, '/', projectName, '/pulls'		with: [ :client |			client 				entity: (ZnEntity text: (STON toJsonString: aDictionary));				contentType: ZnMimeType applicationJson ]! !!IceGitHubAPI methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!contentsWithValidationDo: aBlock	^ (self responseWithValidationDo: aBlock) contents! !!IceGitHubAPI methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!credentials	^ credentials ifNil: [ credentials := self class obtainCredentials ]! !!IceGitHubAPI methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!credentials: anObject	credentials := anObject! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/21/2017 17:44:57'!delete: aString 	^ self jsonContentsWithValidationDo: [		(self newRequestTo: aString)			delete;			response ]! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/21/2017 17:44:57'!deleteBranch: owner project: projectName name: branchName	^ self delete: 'repos/', owner, '/', projectName, '/git/refs/heads/', branchName! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/21/2017 17:44:57'!get: aString 	^ self jsonContentsWithValidationDo: [		(self newRequestTo: aString)			get;			response ]! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/21/2017 17:44:57'!getBranch: owner project: projectName name: branchName	^ self get: 'repos/', owner,'/', projectName, '/branches/', branchName! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/21/2017 17:44:57'!getBranches: owner project: projectName	^ self get: 'repos/', owner,'/', projectName, '/branches'! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/21/2017 17:44:57'!getPaginated: aString 	^ IceGitHubAPIPaginatedResult api: self request: aString! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/21/2017 17:44:57'!getPullRequests: owner project: projectName	^ self getPaginated: 'repos/', owner, '/', projectName, '/pulls'		! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/21/2017 17:44:57'!getRaw: aString 	^ self responseWithValidationDo: [		(self newRequestTo: aString)			get;			response ]! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/21/2017 17:44:57'!getRepository: owner project: projectName	^ self get: 'repos/', owner,'/', projectName! !!IceGitHubAPI methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!jsonContentsWithValidationDo: aBlock	^ STON fromString: (self contentsWithValidationDo: aBlock)! !!IceGitHubAPI methodsFor: 'private factory' stamp: ' 7/21/2017 17:44:57'!newRequestTo: aString	^ ZnClient new 		in: [ :this | 			self credentials ifNotNil: [ 				this 					username: self credentials username 					password: self credentials password ] ]; 		headerAt: 'Accept' put: 'application/vnd.github.v3+json';		url: 'https://api.github.com/', aString;		yourself! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/21/2017 17:44:57'!patch: aString with: aBlock  	^ self jsonContentsWithValidationDo: [		(self newRequestTo: aString)			in: aBlock;			patch;			response ]! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/21/2017 17:44:57'!post: aString with: aBlock  	^ self jsonContentsWithValidationDo: [		(self newRequestTo: aString)			in: aBlock;			post;			response ]! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/21/2017 17:44:57'!put: aString with: aBlock  	^ self jsonContentsWithValidationDo: [		(self newRequestTo: aString)			in: aBlock;			put;			response ]! !!IceGitHubAPI methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!responseWithValidationDo: aBlock	| response |		response := aBlock value.	response isSuccess 		ifFalse: [ IceGitHubError signalFor: response ].	^ response! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/21/2017 17:44:57'!updatePullRequest: owner project: projectName number: aNumber data: aDictionary 	^ self 		patch: 'repos/', owner, '/', projectName, '/pulls/', aNumber asString		with: [ :client |			client 				entity: (ZnEntity text: (STON toJsonString: aDictionary));				contentType: ZnMimeType applicationJson ]! !!IceGitHubAPIPaginatedResult class methodsFor: 'as yet unclassified' stamp: ' 7/21/2017 17:44:57'!api: anAPI request: aString	^ self new 		api: anAPI;		request: aString;		yourself		! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!all	| stream |	stream := Array new writeStream.	[ self hasNext ] 	whileTrue: [ stream << self next ].	^ stream contents! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!api	^ api! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!api: anObject	api := anObject! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!hasNext	^ result isNil or: [ self parseMorePages: (result headers at: 'Link' ifAbsent: [ nil ]) ]! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!next 	nextPage ifNil: [ nextPage := 1 ].	[ result := self api getRaw: (self request asUrl ? (#page -> nextPage asString)) asString ]	ensure: [ nextPage := nextPage + 1].	^ STON fromString: result contents! !!IceGitHubAPIPaginatedResult methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!parseMorePages: aString 	"github does not send 'Links' header if there are no pages, and it does not sends 'next' link	 if we are at the last page"	aString ifNil: [ ^ false ].	^ (aString substrings: ',') anySatisfy: [ :each | each includesSubstring: 'rel="next"' ] ! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!request	^ request! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!request: anObject	request := anObject! !!IceGitHubCommand class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!repository: aRepository 	^ self new repository: aRepository ! !!IceGitHubCommand methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!credentials 	^ credentials ifNil: [ credentials := self obtainCredentials ]! !!IceGitHubCommand methodsFor: 'execute' stamp: ' 7/21/2017 17:44:57'!execute 	self subclassResponsibility! !!IceGitHubCommand methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!github	^ IceGitHubAPI new 		credentials: self credentials;		yourself! !!IceGitHubCommand methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!obtainCredentials	^ IceGitHubAPI obtainCredentials! !!IceGitHubCommand methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!reportError: error	UIManager default 		alert: error messageBody		title: 'Error creating pull request: ', error messageText! !!IceGitHubCommand methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceGitHubCommand methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: aRepository	repository := aRepository! !!IceGitHubNewPullRequestCommand methodsFor: 'execute' stamp: ' 7/21/2017 17:44:57'!execute 	(self validateMakePullRequestOn: self repository) ifFalse: [ ^ #() ].		(IceGitHubCreatePullRequestModel 		repository: self repository 		credentials: self credentials		headRemote: self remote)		setModal: true; 		onAccept: [ :pullRequest | 			[ 				pullRequest send.				UIManager default inform: 'Pull request created.' ]			on: IceGitHubError do: [ :e | self reportError: e ] ];		openWithSpec ! !!IceGitHubNewPullRequestCommand methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote	^ remote! !!IceGitHubNewPullRequestCommand methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote: anObject	remote := anObject! !!IceGitHubNewPullRequestCommand methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!validateMakePullRequestOn: aRepository	| status |		status := OrderedCollection new: 2.	aRepository isModified 		ifTrue: [ status add: 'Uncommited changes' ].	(aRepository outgoingCommitsTo: (aRepository pushRemote)) 		ifNotEmpty: [ :commits | '{1} not published' format: { commits size } ].	status ifEmpty: [ ^ true ].		^ UIManager default 		confirm: (('{1} has ongoing modifications ({2}). Do you want to continue anyway?') format: { aRepository name. status asCommaString })! !!IceGitHubRemoveBranchesCommand class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!repository: aRepository remote: aRemote	^ self new 		repository: aRepository;		remote: aRemote;		yourself! !!IceGitHubRemoveBranchesCommand methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!cacheAllBranches	self remoteBranches do: [ :each | | branchName |		branchName := each at: 'name'.		branchesByName 			at: branchName 			ifAbsentPut: [ self remoteBranch: branchName ] ]! !!IceGitHubRemoveBranchesCommand methodsFor: 'execute' stamp: ' 7/21/2017 17:44:57'!execute 	UIManager default 		informUser: ('Retrieving branch information from {1}' format: { self remote url })		during: [ self cacheAllBranches ].	IceGitHubSelectListModel new 		setModal: true;		title: ('Select branches to remove on remote {1}' format: {self remote remoteName});		selectLabel: 'Remove branches';		items: self remoteBranches;		displayBlock: [ :each | 			'{1} ({2})' format: { 				each at: 'name'. 				self timeSinceLastCommit: each } ];		onAccept: [ :selection | self removeBranches: selection ];		openWithSpec! !!IceGitHubRemoveBranchesCommand methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize 	super initialize.	branchesByName := OrderedDictionary new! !!IceGitHubRemoveBranchesCommand methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote	^ remote! !!IceGitHubRemoveBranchesCommand methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote: aRemote	remote := aRemote! !!IceGitHubRemoveBranchesCommand methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!remoteBranch: aName	^ self requestRemoteBranch: aName! !!IceGitHubRemoveBranchesCommand methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!remoteBranches	^ branches ifNil: [ branches := self requestRemoteBranches ]! !!IceGitHubRemoveBranchesCommand methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!removeBranch: json	| branchName |		branchName := json at: 'name'.	IceGitHubAPI new 		credentials: self credentials;		deleteBranch: self remote owner 			project: self remote projectBasename			name: branchName.	UIManager default inform: ('Branch {1} removed.' format: { branchName })			! !!IceGitHubRemoveBranchesCommand methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!removeBranches: aCollection	[ 		aCollection do: [ :each | self removeBranch: each ] ]	on: IceGitHubError do: [ :e | self reportError: e ]! !!IceGitHubRemoveBranchesCommand methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!requestRemoteBranch: aName	^ IceGitHubAPI new		getBranch: self remote owner 		project: self remote projectBasename		name: aName! !!IceGitHubRemoveBranchesCommand methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!requestRemoteBranches	^ IceGitHubAPI new		getBranches: self remote owner 		project: self remote projectBasename! !!IceGitHubRemoveBranchesCommand methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!timeSinceLastCommit: json	| branchName branchJson lastCommitDate |	branchName := json at: 'name'.	branchJson := branchesByName at: branchName.	lastCommitDate := ((((branchJson at: 'commit') at: 'commit') at: 'author') at: 'date') asDateAndTime.	^ '{1} days' format: { (Date today - lastCommitDate) days }! !!IceGitHubViewPullRequestCommand methodsFor: 'execute' stamp: ' 7/21/2017 17:44:57'!execute	UIManager default 		informUser: ('Retrieving pull requests from {1}' format: { self remote })  		during: [ 			IceGitHubPullRequestListBrowser new				repository: self repository;				remote: self remote;				refreshPullRequests;				open ]! !!IceGitHubViewPullRequestCommand methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote	^ remote! !!IceGitHubViewPullRequestCommand methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote: anObject	remote := anObject! !!IceGitHubPullRequest class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!fromJSON: aDictionary	^ self basicNew		initializeWithJSON: aDictionary;		yourself! !!IceGitHubPullRequest methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!acceptMessage: messageString type: typeString	IceGitHubAPI new 		acceptPullRequest: self owner 			project: self projectName			number: self number			data: { 				#commit_title -> (messageString lines 					ifNotEmpty: [ :each | each first trimBoth ] 					ifEmpty: [ '' ]). 				#commit_message -> (messageString lines 					ifNotEmpty: [ :lines | (lines allButFirst joinUsing: String lf) trimBoth ] 					ifEmpty: [ '' ]). 				#sha-> self headSHA.				#merge_method -> typeString } asDictionary! !!IceGitHubPullRequest methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!addComment: messageString	IceGitHubAPI new 		addComment: self owner 			project: self projectName			number: self number			data: { #body -> messageString } asDictionary! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!author	^ (self jsonAt: 'user') at: 'login'! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!baseLabel	^ (self jsonAt: #base) at: #label! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!baseSHA	^ (self jsonAt: #base) at: #sha! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!body	^ self jsonAt: #body! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branch	fetched ifFalse: [ self fetch ].	^ branch ifNil: [		branch := IceRemoteBranch			remoteName: self remote remoteName 			branchName: ((self jsonAt: #head) at: #ref)			inRepository: self repository.		branch ]! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branchName	^ self branch basename! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!detail	^ detail ifNil: [		detail := IceGitHubAPI new get: ((self jsonAt: #url) allButFirst: 23) ]! !!IceGitHubPullRequest methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!fetch	[ ^ self repository fetchFrom: self remote ]	ensure: [ fetched := true ]! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!headLabel	^ (self jsonAt: #head) at: #label! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!headSHA	^ (self jsonAt: #head) at: #sha! !!IceGitHubPullRequest methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initialize	super initialize.	fetched := false! !!IceGitHubPullRequest methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeWithJSON: aDictionary	json := aDictionary.	self initialize! !!IceGitHubPullRequest methodsFor: 'private accessing' stamp: ' 7/21/2017 17:44:57'!json	^ json! !!IceGitHubPullRequest methodsFor: 'private accessing' stamp: ' 7/21/2017 17:44:57'!jsonAt: aKey	^ self json at: aKey! !!IceGitHubPullRequest methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!mergeIntoImage	self repository 		ensureBranch: self branchName;		checkoutBranch: self branchName;		merge: self branch lastCommit! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!number	^ self jsonAt: #number! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!owner 	^ (((self jsonAt: #base) at: #repo) at: #owner) at: #login! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!projectName	^ ((self jsonAt: #base) at: #repo) at: #name! !!IceGitHubPullRequest methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!rejectMessage: messageString	messageString trimBoth 		ifNotEmpty: [ self addComment: messageString ].	IceGitHubAPI new 		updatePullRequest: self owner 			project: self projectName			number: self number			data: { #state -> #closed } asDictionary! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remote	| remote |	remote := IceRemote 		name: self author		url: (((self jsonAt: #head) at: #repo) at: #ssh_url).	^ self repository remotes 		detect: [ :each | each = remote ]		ifFound: [ :each | each ]		ifNone: [ 			self repository addRemote: remote.			remote ].		! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ repository! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository: anObject	repository := anObject! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!state	^ self jsonAt: #state! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!status	^ status ifNil: [ 		status := IceGitHubAPI new 			get: 'repos/', self owner, '/', self projectName, '/commits/', self headSHA, '/status' ]! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ self jsonAt: #title! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!url	^ self jsonAt: #url! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!baseBranchName	^ baseBranchName! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!baseBranchName: anObject	baseBranchName := anObject! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!baseRemote	^ baseRemote! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!baseRemote: anObject	baseRemote := anObject! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!body	^ body! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!body: anObject	body := anObject! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!credentials	^ credentials! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!credentials: anObject	credentials := anObject! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!headBranchName	^ headBranchName! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!headBranchName: anObject	headBranchName := anObject! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!headRemote	^ headRemote! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!headRemote: anObject	headRemote := anObject! !!IceGitHubPullRequestDefinition methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!send	| pullRequestData |	pullRequestData := { 		'title' -> self title.		'head' -> (self headRemote owner, ':', self headBranchName).		'base' -> self baseBranchName.		'body' -> self body.	} asDictionary.		IceGitHubAPI new 		credentials: self credentials;		addPullRequest: self baseRemote owner 			project: self baseRemote projectBasename 			data: pullRequestData! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title	^ title! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!title: anObject	title := anObject! !!IceGitHubSelectItem class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!list: selectedItems item: anObject	^ self basicNew 		initializeList: selectedItems item: anObject;		yourself! !!IceGitHubSelectItem class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!new	self error: 'Use #list:item:'! !!IceGitHubSelectItem methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!addItem	(list includes: item) ifTrue: [ ^ self ].	list add: item ! !!IceGitHubSelectItem methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeList: aCollection item: anObject	list := aCollection.	item := anObject.	self initialize! !!IceGitHubSelectItem methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!removeItem	(list includes: item) ifFalse: [ ^ self ].	list remove: item ! !!IceGitHubSelectItem methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!value 	^ list includes: item! !!IceGitHubSelectItem methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!value: aBoolean	aBoolean 		ifTrue: [ self addItem ]		ifFalse: [ self removeItem ]	! !!IceGitHubPullRequestPlugin class methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isAvailableFor: aRepository	"validate if this is a github repository"	^ aRepository origin host = 'github.com'! !!IceGitHubPullRequestPlugin methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!newPullRequest: aRepository 	^ self newPullRequest: aRepository remote: aRepository pushRemote ! !!IceGitHubPullRequestPlugin methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!newPullRequest: aRepository remote: aRemote	(IceGitHubNewPullRequestCommand repository: aRepository) 		remote: aRemote;		execute! !!IceGitHubPullRequestPlugin methodsFor: 'private actions' stamp: ' 7/21/2017 17:44:57'!newPullRequestAction	^ GLMGenericAction new		action: [ :presenter | self newPullRequest: presenter selection repository ];		category: 'GitHub';		showTitle: 'Create pull request...'; 		yourself! !!IceGitHubPullRequestPlugin methodsFor: 'private actions' stamp: ' 7/21/2017 17:44:57'!newPullRequestRemoteAction	^ GLMGenericAction new		action: [ :presentation :model |			self newPullRequest: model repository remote: presentation selection ];		category: 'GitHub';		showTitle: 'Create pull request...'; 		yourself! !!IceGitHubPullRequestPlugin methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remoteActionsFor: aRemote	^ { 	self newPullRequestRemoteAction.	self viewPullRequestsRemoteAction.	self removeOldBranchesRemoteAction. 	}! !!IceGitHubPullRequestPlugin methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!removeBranches: aRepository	self removeBranches: aRepository remote: aRepository pushRemote! !!IceGitHubPullRequestPlugin methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!removeBranches: aRepository remote: aRemote	(IceGitHubRemoveBranchesCommand 		repository: aRepository 		remote: aRemote)		execute! !!IceGitHubPullRequestPlugin methodsFor: 'private actions' stamp: ' 7/21/2017 17:44:57'!removeOldBranchesAction	^ GLMGenericAction new		action: [ :presentation | self removeBranches: presentation selection repository ];		category: 'GitHub';		showTitle: 'Remove old branches...'; 		yourself! !!IceGitHubPullRequestPlugin methodsFor: 'private actions' stamp: ' 7/21/2017 17:44:57'!removeOldBranchesRemoteAction	^ GLMGenericAction new		action: [ :presentation :model | 			self removeBranches: model remote: presentation selection ];		category: 'GitHub';		showTitle: 'Remove old branches...'; 		yourself! !!IceGitHubPullRequestPlugin methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repositoryActions	^ { 	self newPullRequestAction. 	self viewPullRequestsAction.	self removeOldBranchesAction. 	}! !!IceGitHubPullRequestPlugin methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!viewPullRequest: aRepository 	^ self viewPullRequest: aRepository remote: aRepository pushRemote ! !!IceGitHubPullRequestPlugin methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!viewPullRequest: aRepository remote: aRemote	(IceGitHubViewPullRequestCommand repository: aRepository) 		remote: aRemote;		execute! !!IceGitHubPullRequestPlugin methodsFor: 'private actions' stamp: ' 7/21/2017 17:44:57'!viewPullRequestsAction	^ GLMGenericAction new		action: [ :presenter | self viewPullRequest: presenter selection repository ];		category: 'GitHub';		showTitle: 'Review pull requests...'; 		yourself! !!IceGitHubPullRequestPlugin methodsFor: 'private actions' stamp: ' 7/21/2017 17:44:57'!viewPullRequestsRemoteAction	^ GLMGenericAction new		action: [ :presentation :model | 			self viewPullRequest: model repository remote: presentation selection ];		category: 'GitHub';		showTitle: 'Review pull requests...'; 		yourself! !"Iceberg-Plugin-GitHub"!!IceLibgitVersionReader commentStamp: 'NicoPasserini 7/7/2016 11:58' prior: 0!Reads an MCVersion from a git repository (its blob, not a working copy!!) using libgit bindings.Currently we only support metadata-less repositories.!!IceLibgitCommitWalk commentStamp: 'NicoPasserini 9/21/2016 14:26' prior: 0!Utility class for searching through a commit history taking advantage of git revwalk utilities. Found and returned commits will be added to the commit cache of the corresponding IceRepository.!!IceLibgitFileUtils commentStamp: 'NicoPasserini 7/7/2016 12:15' prior: 0!Emulates other 'file utils' classes by reading from a git repository (its blob, not a working copy'). Allows for reading any tree (from any commit) in the repository.!!IceLibgitLocalRepository commentStamp: 'NicoPasserini 6/28/2016 10:56' prior: 0!Adapter which allows an IceRepository to use libgit as underlying storage.!!Trait method!lookupPackages	^ (self packageEntries		collect: [ :entry |			entry packageName -> (IceSavedPackage 				named: entry packageName				repository: self frontend).		])		asDictionary! !!Trait method!description	"Use local directory as description, as Monticello uses this to determine if two repositories are the same. This allows for having multiple local clones of the same remote repositories, which in turn could allow for using standard Pharo tools, for example to compare versions."	^ self basicCodeDirectory pathString, ' (', self class description, ')'! !!Trait method!iceCommitFrom: aCommitish	"The type of 'aCommitish' depends on how each backend internal representation. "	^ self frontend		commitAt: (self commitIdFrom: aCommitish )		ifAbsentPut: [ self class parseCommitInfo: aCommitish ]! !!Trait method!packageEntries	self codeDirectory exists ifFalse: [ ^ #() ].	^ self codeDirectory entries 		select: [ :entry | self isPackageEntry: entry ]	! !!Trait method!codeDirectory	"Code repository might have been deleted or image might have been moved."	self repositoryDirectory exists		ifTrue: [ ^ self basicCodeDirectory ]		ifFalse: [ IceLocalRepositoryMissing signalFor: self frontend ]! !!Trait method!isMissing	^ self repositoryDirectory isNil 		or: [ self repositoryDirectory exists not ]! !!Trait method!merge: aCommitId into: aBranchName	| currentBranchName |	currentBranchName := self branch name.	[ 		self checkoutBranch: aBranchName.		self merge: aCommitId ]	ensure: [ 		self checkoutBranch: currentBranchName ]! !!Trait method!basicCodeDirectory	^ self subdirectory isEmptyOrNil 		ifTrue: [ self repositoryDirectory ]		ifFalse: [ self repositoryDirectory / self subdirectory  ].! !!Trait method!isPackageEntry: entry	^ entry isDirectory and: [ self canReadFileNamed: entry name ]	! !!Trait method!initialize	IceRepository defaultBackendType ifNil: [ 		IceRepository defaultBackend: self ]! !!IceLibgitTreeBuilder commentStamp: 'NicoPasserini 7/12/2016 11:29' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	builder:		<Object>	changes:		<Object>	children:		<Object>	entryName:		<Object>	originalTree:		<LGitTree> Contains the original contents on which this builder bases. Warning: this will not reflect the actual contents of the builder. Use #buildTree instead.	parent:		<Object>    Implementation Points!!IceSemanticVersion commentStamp: '<historical>' prior: 0!I represent the semver (http://semver.org) of libgit2. Since I exist just to be able to compare versions, I'm limited (reason why I'm not promoted to a more general package).!!IceLibgitStCypressWriter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!fileUtils	^ IceLibgitFileUtils current! !!IceLibgitStCypressWriter methodsFor: 'initialize-release' stamp: ' 7/21/2017 17:44:57'!propertyFileExtension  ^ MCFileTreeRepository defaultPropertyFileExtension! !!IceLibgitStCypressWriter methodsFor: 'visiting' stamp: ' 7/21/2017 17:44:57'!writeInDirectoryName: directoryNameOrPath fileName: fileName extension: ext visit: visitBlock    | directory |    directory := self directoryForDirectoryNamed: directoryNameOrPath.    self fileUtils        writeStreamFor: fileName , ext        in: directory        do: [ :fs |             self setFileStream: fs.            visitBlock value ]! !!IceLibgitVersionReader class methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!compatibleAuthorNameOf: aString	"Timestamp of method has a very precise format that needs to be fulfiled: 				'FirstnameLastname MM/DD/YYYY HH/MM' 		Problem is that git username is different: Firstname Lastname.	To make this compatible, we remove spaces... but this can be a problem in the future... 	we'll see."	^ aString reject: [ :each | each = Character space ]! !!IceLibgitVersionReader class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!on: aCommitOrTree iceVersion: iceVersion	^ (self on: aCommitOrTree) 		iceVersion: iceVersion; 		yourself! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!commit	^ stream! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!fileUtils	^ IceLibgitFileUtils current! !!IceLibgitVersionReader methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!hasMonticelloMetadata	^ false! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!iceVersion	^ iceVersion! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!iceVersion: anObject	iceVersion := anObject.	self packageDirectory: iceVersion package directoryPathString	! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!loadVersionInfo	^ info := self iceVersion info! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!packageNameFromPackageDirectory	^ iceVersion packageName! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!versionName	^ ('{1}-{2}.{3}' format: {		self packageNameFromPackageDirectory. 		self commit compatibleUsername. 		self versionNumber	})! !!IceLibgitWriter methodsFor: 'writing' stamp: ' 7/21/2017 17:44:57'!addString: string at: fileNameOrPath encodedTo: ignored    "fileNameOrPath may have one or two elements"    "encodeTo: arg, because FileTree uses UTF8 by default"	| split path fileName |	split := fileNameOrPath lastIndexOf: $/.	path := fileNameOrPath first: split.	fileName := fileNameOrPath copyFrom: split + 1.		(self packageFileDirectory entryByPath: path)		addEntryNamed: fileName withContents: string.! !!IceLibgitWriter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!fileUtils	^ IceLibgitFileUtils current! !!IceLibgitWriter methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!snapshotWriterClass	^ IceLibgitStCypressWriter! !!IceLibgitWriter methodsFor: 'visiting' stamp: ' 7/21/2017 17:44:57'!subPackageFileDirectoryFor: directoryNameOrPath	^ self packageFileDirectory entryByPath: directoryNameOrPath ! !!IceLibgitWriter methodsFor: 'visiting' stamp: ' 7/21/2017 17:44:57'!writeVersion: aVersion	directory := aVersion package name, '.package'.	self packageFileDirectory deleteAll.	self writeFormat.	self writePackage: aVersion package.	self writeDefinitions: aVersion.	aVersion dependencies do: [ :ea | self writeVersionDependency: ea ]! !!IceLibgitCommitWalk methodsFor: 'walking' stamp: ' 7/21/2017 17:44:57'!commitsDo: aBlock 	self maxNumber 		ifNil: [ super commitsDo: aBlock ]		ifNotNil: [ | count |			count := 0.			super commitsDo: [ :commit |				aBlock value: commit.				count := count + 1.				count == self maxNumber ifTrue: [ ^ self ]			]		]! !!IceLibgitCommitWalk methodsFor: 'walking' stamp: ' 7/21/2017 17:44:57'!firstCommit	^ self commitsDo: [ :commit | ^ commit ] ! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!fromBranch: branch	[ self revwalk pushReference: (lgitRepository lookupBranch: branch name) ]		on: LGit_GIT_EINVALIDSPEC do: [			"branch real branch, so try to find a corresponding treeish using revparse, 			this will handle stuff like 'master~1'"			self fromLGitId: (lgitRepository revparse: branch name) id		]! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!fromCommit: commit	self fromCommitId: commit id! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!fromCommitId: commitId	self fromLGitId: (LGitId fromHexString: commitId)! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!fromHead	self revwalk pushHead! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!fromLGitId: lGitId	self revwalk pushCommit: lGitId! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!fromTag: tag	self revwalk.	^ self fromLGitId: (lgitRepository revparse: tag name) id! !!IceLibgitCommitWalk methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!rawResultsDo: aBlockClosure 	self revwalk 		select: [ :result | self shouldInclude: result ]		thenDo: aBlockClosure! !!IceLibgitCommitWalk methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!revwalk	^ revwalk ifNil: [		repository withRepoDo: [ :repo |			"Keep a reference to the repo so that it does not get garbage collected 			(that would free C memory and make leave the revwalk object dumb)"			lgitRepository := repo. 			^ revwalk := LGitRevwalk of: repo.		] 	]! !!IceLibgitCommitWalk methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!shouldInclude: aLGitCommit 	^ self modifyingPackage 		ifNil: [ true ]		ifNotNil: [ :package | 			aLGitCommit changesFileNamed: package directoryPathString ]! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/21/2017 17:44:57'!uptoCommit: commit	self revwalk hideCommit: (LGitId fromHexString: commit id)! !!IceLibgitFileUtils class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!current    ^ Current ifNil: [ Current := self new ]! !!IceLibgitFileUtils methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!deleteAll: aTreeBuilder     ^ aTreeBuilder deleteAll! !!IceLibgitFileUtils methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!directoryExists: aLGitTreeEntry 	^ aLGitTreeEntry type = LGitObjectTypeEnum git_obj_tree! !!IceLibgitFileUtils methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!directoryFromEntry: treeEntry 	^ treeEntry object! !!IceLibgitFileUtils methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!directoryFromPath: aString relativeTo: aCommitOrTree	^ aCommitOrTree 		entryByPath: aString 		ifAbsent: [ 			IceMissingRepositoryEntry new name: aString; owner: aCommitOrTree; signal ] ! !!IceLibgitFileUtils methodsFor: 'as yet unclassified' stamp: ' 7/21/2017 17:44:57'!pathNameDelimiter	^ $/! !!IceLibgitFileUtils methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!readStreamFor: fileName in: tree do: aBlock	(tree entryByPath: fileName) readStreamDo: aBlock! !!IceLibgitFileUtils methodsFor: 'utilities' stamp: ' 7/21/2017 17:44:57'!writeStreamFor: fileName in: directory do: aBlock 	directory addEntryNamed: fileName withContents: (String streamContents: aBlock).! !!IceLibgitLocalRepository class methodsFor: 'descriptions' stamp: ' 7/21/2017 17:44:57'!description	^ 'Libgit'! !!IceLibgitLocalRepository class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!newRepositoryAt: aFileReference origin: anIceRemoteRepository subdirectory: aString	^ self new		location: aFileReference;		origin: anIceRemoteRepository;		subdirectory: aString;		yourself! !!IceLibgitLocalRepository class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!newRepositoryAt: aFileReference subdirectory: aString	^ self new		location: aFileReference;		subdirectory: aString;		yourself! !!IceLibgitLocalRepository class methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!parseCommitInfo: aLGitCommit	^ IceCommitInfo new		commitId: aLGitCommit id hexString;		username: aLGitCommit committer name;		datetime: aLGitCommit time asDateAndTime;		parentIds: (aLGitCommit parents collect: [ :parent | parent id hexString ]);		comment: aLGitCommit message! !!IceLibgitLocalRepository class methodsFor: 'utils' stamp: ' 7/21/2017 17:44:57'!requiredLibGit2MinimumVersion	^ IceSemanticVersion 		major: 0 		minor: 25 		patch: 1! !!IceLibgitLocalRepository class methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!shortName	^ 'Libgit'! !!IceLibgitLocalRepository class methodsFor: 'utils' stamp: ' 7/21/2017 17:44:57'!verifyBackendAvailabilityIfNot: aBlock	| presentVersion requiredVersion |		presentVersion := IceSemanticVersion fromArray: LGitLibrary uniqueInstance version.	requiredVersion := self requiredLibGit2MinimumVersion.		requiredVersion <= presentVersion 		ifFalse: [ ^ aBlock cull: requiredVersion cull: presentVersion ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!addFilesToIndex: aListOfPaths	self withRepoDo: [ :repo | 		| index |		index := repo index.		index addAll: aListOfPaths.		index writeToDisk.	]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!addRemote: aRemote	self withRepoDo: [ :repo |		repo addRemote: aRemote remoteName url: aRemote url ]! !!IceLibgitLocalRepository methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!addTo: aMCRepositoryGroup 	"For now do not add me as an MCRepository"! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!allBranches	self withRepoDo: [ :repo | 			^ OrderedCollection new: 10 streamContents: [ :stream |			repo allBranchesDo: [ :br :isLocal | 				stream nextPut: (					IceBranch 						named: br name 						local: isLocal						inRepository: self frontend) ]]]	! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!branch	"The branch variable and this accessor are useful when you do not have a real git repository yet. Once created it might be safer to use #currentBranch instead."	^ self lookupHead! !!IceLibgitLocalRepository methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!canReadFileNamed: aString 	^ aString endsWith: '.package'! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!changedFilesBetween: aCommitish and: otherCommitish	"Answer a list of files that changed between two commits"	| fromTree toTree |		self withRepoDo: [ :repo | | diff |		fromTree := (LGitCommit of: repo fromId: (LGitId fromHexString: aCommitish id)) tree.		toTree := (LGitCommit of: repo fromId: (LGitId fromHexString: otherCommitish id)) tree.				diff := LGitDiff of: repo.		diff diffTree: fromTree toTree: toTree. 		^ diff files ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!checkoutBranch: newBranchName 	self withRepoDo: [ :repo |		repo checkout: newBranchName ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!cloneRepository	self cloneRepositoryFrom: self origin! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!cloneRepositoryFrom: aRemote	^ self cloneRepositoryFrom: aRemote branch: nil! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!cloneRepositoryFrom: aRemote branch: aBranchName	| url |		url := aRemote url.	LGitGlobal runSequence: [ 		| repo cloneOptions |		repo := LGitRepository on: self location.		cloneOptions := LGitCloneOptions withCredentialsProvider: IceCredentialsProvider default.				repo clone: url options: cloneOptions.		aBranchName ifNotNil: [ 			repo checkout: aBranchName ].		(LGitRemote of: repo named: 'origin')			lookup;			setUrl: url ]! !!IceLibgitLocalRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!commitIdFrom: aLGitCommit 	^ aLGitCommit id hexString! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!commitIndexWithMessage: message andParents: parentCommitishList	self withRepoDo: [ :repo | 		| signature commitId indexTreeId |		[ signature := repo defaultSignature ]		on: LGit_GIT_ENOTFOUND do: [ :e | 			IceGitUsernameOrEmailNotFound guessKind: e ifNot: [ e pass ] ].		indexTreeId := repo index writeTreeAndReturnOid.		 		commitId := (LGitCommitBuilder of: repo)			tree: (LGitTree of: repo fromId: indexTreeId);			message: message;			parents: (repo isUnborn				ifTrue: [ #() ]				ifFalse: [ self libGitCommitsFrom: repo for: parentCommitishList ]);			"'HEAD' branch could not exist yet. No problem, libgit will create it, 			but we have to remember it to notify the frontend."			updateReference: ([ repo head name ] 				on: LGit_GIT_EUNBORNBRANCH				do: [ 'refs/heads/', self branch nameForFirstCommit ]);			author: signature;			committer: signature;			writeCommit;			commitId.					 ^ self class parseCommitInfo: (LGitCommit of: repo fromId: commitId) ]! !!IceLibgitLocalRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!commitsInBranch: branchName do: aBlock	"Iterates commit in a branch, in reverse chronological order (latest first)"	self withRepoDo: [ :repo |		(LGitRevwalk of: repo)			pushReference: (repo lookupBranch: branchName);			beSortedReverse;			do: aBlock ]! !!IceLibgitLocalRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!commitsInCurrentBranchDo: aBlock	self withRepoDo: [ :repo |		(LGitRevwalk of: repo)			pushHead;			do: aBlock.	]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!contentOfFileNamed: aPathString commit: aCommitId	self withRepoDo: [ :repo |		| commit |		commit := LGitCommit of: repo fromHexString: aCommitId.		^ (commit entryByPath: aPathString) object contents	]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!createBranch: branchName	self withRepoDo: [ :repo |		| newBranch |		newBranch := repo createBranch: branchName target: repo head.		repo setHead: newBranch ]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!currentBranch	"#currentBranch will look for the branch in the actual repository,	#branch is the branch that was set to me manually. Normally they should return the same value,	but if the repository does not yet exist, #currentBranch will fail."	self withRepoDo: [ :repo |		^ repo head basename	]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!fetch	self fetchFrom: self origin! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!fetchFrom: aRemote	self withRepoDo: [ :repo | 		(LGitRemote of: repo named: aRemote remoteName) 			lookup; 			fetchWithCredentials: IceCredentialsProvider default ]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!frontend	^ frontend! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!frontend: anObject	frontend := anObject! !!IceLibgitLocalRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!guessUsernameOrEmailNotFound: anError ifNot: notBlock 	(anError messageText = 'Config value ''user.name'' was not found' 		or: [ anError messageText = 'Config value ''user.email'' was not found' ])		ifTrue: [ IceGitUsernameOrEmailNotFound signal ].	notBlock value! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!init	"Initialize new repository (git init)"	LGitGlobal runSequence: [ 		(LGitRepository on: self location) init ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!internalStoreVersion: aMCVersion 	IceMetadatalessFileTreeWriter 		fileOut: aMCVersion 		on: (IceBackendWriterAdapter for: self).! !!IceLibgitLocalRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isCodeMissing	^ self subdirectory isEmptyOrNil 		ifTrue: [ self isMissing ]		ifFalse: [ (self repositoryDirectory / self subdirectory) exists not  ]! !!IceLibgitLocalRepository methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!isUnborn	self withRepoDo: [ :repo | ^ repo isUnborn ]! !!IceLibgitLocalRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!libGitCommitsFrom: aLGitRepository for: aListOfCommitish	^ aListOfCommitish collect: 		[ :commitish | 		LGitCommit of: aLGitRepository fromId: (LGitId fromHexString: commitish id) ]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!localBranchNames	self withRepoDo: [ :repo | ^ repo branches collect: #basename ]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location	^ location! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!location: anObject	location := anObject! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!lookupBranchNamed: branchName inRemote: remoteName	self withRepoDo: [ :repo |		[ repo lookupRemoteBranch: remoteName, '/', branchName ]			on: LGit_GIT_ENOTFOUND do: [ ^ nil ].				^ IceRemoteBranch 			remoteName: remoteName			branchName: branchName			inRepository: self frontend	]! !!IceLibgitLocalRepository methodsFor: 'private' stamp: ' 7/21/2017 17:44:57'!lookupHead	self withRepoDo: [ :repo | 		| head |		repo isUnborn ifTrue: [ ^ IceUnbornBranch new ].		head := repo head.		^ head isBranch 			ifTrue: [ IceLocalBranch named: head basename inRepository: self frontend ] 			ifFalse: [ head object asIcebergObjectInRepository: self ] ]! !!IceLibgitLocalRepository methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!mcVersionFor: iceVersion	self withRepoDo: [ :repo | 		| commit |		commit := LGitCommit of: repo fromId: (LGitId fromHexString: iceVersion commit id).		[ ^ (IceLibgitVersionReader 				on: commit				iceVersion: iceVersion) 				version ] 			on: IceMissingRepositoryEntry 			do: [ IceVersionDoesNotExist new version: iceVersion; signal ]	]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!merge: commitId	self withRepoDo: [ :repo | 		| myCommit theirCommit mergeBase |		"Decide if we can fast-forward or we must do a real merge"				myCommit := repo head object.		theirCommit := LGitCommit of: repo fromHexString: commitId.		mergeBase := repo mergeBaseBetween: myCommit id and: theirCommit id.				(mergeBase = myCommit id)			ifTrue: [ 				"No need to merge, just fast-forward current HEAD"				repo checkout_treeish: theirCommit.				repo head resolve setTargetId: theirCommit id.			]			ifFalse: [				| mergedIndex treeId signature |								"Merge both commits"				mergedIndex := myCommit merge: theirCommit.				mergedIndex hasConflicts 					ifTrue: [ 						"Abort merge and signal for manual merge. 						Index is not saved and repository will be discarded, 						so no further action is needed to abort the merge" 						IceMergeAborted signal 					]					ifFalse: [						"Commit mergedIndex"						signature := repo defaultSignature.						treeId := mergedIndex writeTreeAndReturnOid.						repo checkout_treeish: (LGitTree of: repo fromId: treeId).									(LGitCommitBuilder of: repo)							tree: (LGitTree of: repo fromId: treeId);							message: 'Merge with ', commitId;							parents: { myCommit. theirCommit };							updateReference: repo head name;							author: signature;							committer: signature;							writeCommit.							]			]	]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!mergeBaseBetween: aCommitId and: anotherCommitId 	self withRepoDo: [ :repo |		^ (repo 				mergeBaseBetween: (LGitId fromHexString: aCommitId) 				and: (LGitId fromHexString: anotherCommitId)) 				hexString ]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!newCommitWalk	^ IceLibgitCommitWalk forRepository: self! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!origin	| remotes |	remotes := self remotes.	remotes ifEmpty: [ ^ nil  ].	^ remotes		detect: [ :each | each isOrigin ]		ifNone: [ remotes first ]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!outgoingCommits	self withRepoDo: [ :repo |		| currentBranch commits walk |				commits := OrderedCollection new.		currentBranch := repo lookupBranch: self branch name.			walk := (LGitRevwalk of: repo)			pushReference: currentBranch;			hideReference: currentBranch upstream			yourself.					[ walk hasNext ] whileTrue: [ 			commits add: walk next		].		^ commits	]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!packagesPresentOn: aCommitish	"Answer a list of package names present on this commit"	self withRepoDo: [ :repo | | tree dir sourceEntries |		tree := (LGitCommit of: repo fromId: (LGitId fromHexString: aCommitish id)) tree.		self flag: #todo. "this needs to change with multiple dirs"		dir := self subdirectory.		sourceEntries := dir isEmptyOrNil			ifTrue: [ tree entries ]			ifFalse: [ (tree entryByPath: dir) entries ]. 		^ ((sourceEntries 			collect: [ :each | each filename ])			select: [ :each | each endsWith: '.package' ])			collect: [ :each | each copyFrom: 1 to: (each findString: '.package') - 1 ] ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!pull	self pullFrom: self origin! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!pullFrom: aRemote	self withRepoDo: [ :repo | 		| gitRemote myCommit theirCommit mergeBase |		"Fetch"		gitRemote := (LGitRemote of: repo named: aRemote remoteName) lookup.		gitRemote fetchWithCredentials: IceCredentialsProvider default.				"Decide if we can fast-forward or we must do a real merge"		myCommit := repo head object.		theirCommit := repo head upstream object.		mergeBase := repo mergeBaseBetween: myCommit id and: theirCommit id.				(mergeBase = myCommit id)			ifTrue: [ 				"No need to merge, just fast-forward current HEAD"				repo checkout_treeish: repo head upstream object.				repo fastForward			]			ifFalse: [				| mergedIndex treeId signature |								"Merge both commits"				mergedIndex := myCommit merge: theirCommit.								"Commit index"				signature := repo defaultSignature.				treeId := mergedIndex writeTreeAndReturnOid.					(LGitCommitBuilder of: repo)					tree: (LGitTree of: repo fromId: treeId);					message: 'Merge with ', repo head upstream name;					parents: { myCommit. theirCommit };					updateReference: repo head name;					author: signature;					committer: signature;					writeCommit.					]	]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!push	self pushTo: self origin! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!pushTo: aRemote	self withRepoDo: [ :repo |		| gitRemote reference remoteBranchName |				gitRemote := (LGitRemote of: repo named: aRemote remoteName) lookup.		reference := repo head.			remoteBranchName := reference name. "TODO: https://github.com/npasserini/iceberg/issues/90"				gitRemote			pushWithRefSpec: (LGitRefSpec new				source: reference name;				destination: remoteBranchName;				yourself)			pushOptions: (LGitPushOptions defaults				callbacks: (LGitRemoteCallbacks withProvider: IceCredentialsProvider default);				yourself).		"Since the push created the branch in the remote, we can now add an upstream to this branch."		reference upstream ifNil: [ 			reference setUpstream: aRemote remoteName, '/', reference basename ] ]! !!IceLibgitLocalRepository methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!readableFileNames	self shouldBeImplemented.! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!remoteUrl	self withRepoDo: [ :repo | ^ repo origin url ]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!remotes	| gitRemotes |	self withRepoDo: [ :repo | gitRemotes := repo allRemotes ].	^ gitRemotes collect: [ :each | 		(IceRemote url: each url)			remoteName: each remoteName;			yourself ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!removeRemote: aRemote	self withRepoDo: [ :repo |		(LGitRemote of: repo named: aRemote remoteName) 			lookup;			delete ]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repositoryDirectory	^ self location! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!revparse: aString 	self withRepoDo: [ :repo | 		^ (repo revparse: aString) asIcebergObjectInRepository: self	]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!revparseCommit: aString 	self withRepoDo: [ :repo | 		^ self iceCommitFrom: (repo revparse: aString) object 	]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!stagedFiles	| statusMask modifiedPaths |	statusMask :=  (LGitStatusTypeEnum git_status_index_new value)				| (LGitStatusTypeEnum git_status_index_modified value)				| (LGitStatusTypeEnum git_status_index_deleted value)				| (LGitStatusTypeEnum git_status_index_typechange value)				| (LGitStatusTypeEnum git_status_index_renamed value).		self withRepoDo: 		[ :repo | 		modifiedPaths := repo index 			entriesSelect: [ :path :status | (status & statusMask) > 0 ] ].	^ modifiedPaths 		collect: [ :entry | entry first asFileReference ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/21/2017 17:44:57'!storeVersion: aMCVersion 	self withRepoDo: [ :repo | 		| treeBuilder signature parentCommit head |		head := repo head.		parentCommit := head object.		treeBuilder := IceLibgitTreeBuilder on: parentCommit tree.		IceLibgitWriter fileOut: aMCVersion on: (treeBuilder entryByPath: self subdirectory).				signature := repo defaultSignature.		(LGitCommitBuilder of: repo)			tree: treeBuilder buildTree;			message: aMCVersion info message;			parents: { parentCommit };			updateReference: head;			author: signature;			committer: signature;			writeCommit.			]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!subdirectory	^ subdirectory! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!subdirectory: anObject	subdirectory := anObject! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!upstream	self withRepoDo: [ :repo | ^ repo head upstream ifNotNil: #name ]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!username: aName email: anEmail global: globalBoolean	"set user.name and user.email properties. 	 this could be a nonsense with other backends, but git has them and needs them :)"	self withRepoDo: [ :repo | | config |		config := repo config.		globalBoolean ifTrue: [ config := config openGlobal ].		config 			setString: 'user.name' to: aName;			setString: 'user.email' to: anEmail ]! !!IceLibgitLocalRepository methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!validate	"TODO"! !!IceLibgitLocalRepository methodsFor: 'private auxiliar' stamp: ' 7/21/2017 17:44:57'!withRepoDo: aBlock	LGitGlobal runSequence: [ 		| repo |		repo := (LGitRepository on: self location) open.		aBlock value: repo ]! !!IceLibgitTreeBuilder class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!on: aLGitTree	"Creates a tree builder on the root of the repository"	^ self new initializeWithTree: aLGitTree! !!IceLibgitTreeBuilder methodsFor: 'modifying' stamp: ' 7/21/2017 17:44:57'!addEntryNamed: name withContents: aString	self builder 		addEntry: (LGitBlob of: self repository fromString: aString)		filename: name.			self changes add: name.	hasChanges := true! !!IceLibgitTreeBuilder methodsFor: 'building' stamp: ' 7/21/2017 17:44:57'!buildTree	self children keysAndValuesDo: [ :childEntryName :childBuilder |		childBuilder hasChanges ifTrue: [ 			self builder 				addEntry: childBuilder buildTree				filename: childEntryName		]	].	^ self builder newTree! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!builder	^ builder ifNil: [ 		builder := LGitTreeBuilder 			of: self repository			fromTree: self initialTree ]! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!changes	^ changes ifNil: [ changes := OrderedCollection new ]! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!children	^ children ifNil: [ children := Dictionary new ]! !!IceLibgitTreeBuilder methodsFor: 'modifying' stamp: ' 7/21/2017 17:44:57'!deleteAll	self builder clear.! !!IceLibgitTreeBuilder methodsFor: 'patches' stamp: ' 7/21/2017 17:44:57'!directory	^ self ! !!IceLibgitTreeBuilder methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!entryByName: aString	^ self children 		at: aString 		ifAbsentPut: [  			self class new 				initializeWithParent: self 				entryName: aString ]! !!IceLibgitTreeBuilder methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!entryByPath: aString	^ (aString = '.' )		ifTrue: [ self ]		ifFalse: [( ($/ split: aString) reject: #isEmpty)			inject: self 			into: [ :treeBuilder :name | treeBuilder entryByName: name ]]! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!entryName	^ entryName! !!IceLibgitTreeBuilder methodsFor: 'querying' stamp: ' 7/21/2017 17:44:57'!hasChanges	^ hasChanges		or: [ initialTree isNil "It means that this is a new tree"		or: [ self children anySatisfy: #hasChanges ]]! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!initialTree	^ initialTree! !!IceLibgitTreeBuilder methodsFor: 'initializing' stamp: ' 7/21/2017 17:44:57'!initialize	super initialize.	hasChanges := false.	! !!IceLibgitTreeBuilder methodsFor: 'initializing' stamp: ' 7/21/2017 17:44:57'!initializeWithParent: anIceTreeBuilder entryName: aString	| treeEntry |	parent := anIceTreeBuilder.	entryName := aString.	treeEntry := parent builder getEntryNamed: entryName.	treeEntry isReady "i.e. the entry alredy exists in parent tree"		ifTrue: [ initialTree := treeEntry tree ]		ifFalse: [ 			"The entry didn't exist so this is a new entry"			hasChanges := true ]! !!IceLibgitTreeBuilder methodsFor: 'initializing' stamp: ' 7/21/2017 17:44:57'!initializeWithTree: aLGitTree	"This is a builder on the root of a repository"	initialTree := aLGitTree ! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!parent	^ parent! !!IceLibgitTreeBuilder methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut: $(.	self printPathOn: aStream.	aStream nextPut: $)! !!IceLibgitTreeBuilder methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printPathOn: aStream	parent 		ifNil: [ 			aStream nextPutAll: initialTree repository workingDirectoryName ]		ifNotNil: [ 				parent printPathOn: aStream.			aStream nextPut: $/;				nextPutAll: entryName ] ! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!repository	^ parent 		ifNotNil: [ self parent repository ]		ifNil: [ self initialTree owner ]! !!IceSemanticVersion class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!fromArray: anArray	^ self 		major: anArray first 		minor: anArray second 		patch: anArray third! !!IceSemanticVersion class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!major: majorNumber minor: minorNumber patch: patchNumber	^ self basicNew 		initializeMajor: majorNumber 			minor: minorNumber 			patch: patchNumber;		yourself! !!IceSemanticVersion class methodsFor: 'instance creation' stamp: ' 7/21/2017 17:44:57'!new	self error: 'Use one of my siblings'! !!IceSemanticVersion methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!< aMagnitude 	"Answer whether the receiver is less than the argument."	| version |	version := aMagnitude iceSemanticVersion.	^ self major < version major		or: [ self minor < version minor 		or: [ self patch < version patch ] ]! !!IceSemanticVersion methodsFor: 'testing' stamp: ' 7/21/2017 17:44:57'!= aMagnitude 	"Compare the receiver with the argument and answer with true if the 	receiver is equal to the argument. Otherwise answer false."	| version |		version := aMagnitude iceSemanticVersion.	^ self major = version major 		and: [ self minor = version minor		and: [ self patch = version patch ] ] ! !!IceSemanticVersion methodsFor: 'hash' stamp: ' 7/21/2017 17:44:57'!hash	^ ((self species hash		bitXor: self major)		bitXor: self minor)		bitXor: self patch! !!IceSemanticVersion methodsFor: 'converting' stamp: ' 7/21/2017 17:44:57'!iceSemanticVersion	^ self! !!IceSemanticVersion methodsFor: 'initialization' stamp: ' 7/21/2017 17:44:57'!initializeMajor: majorNumber minor: minorNumber patch: patchNumber	major := majorNumber.	minor := minorNumber. 	patch := patchNumber! !!IceSemanticVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!major	^ major! !!IceSemanticVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!minor	^ minor! !!IceSemanticVersion methodsFor: 'accessing' stamp: ' 7/21/2017 17:44:57'!patch	^ patch! !!IceSemanticVersion methodsFor: 'printing' stamp: ' 7/21/2017 17:44:57'!printOn: stream 	stream 		<< self major asString 		<< '.' << self minor asString 		<< '.' << self patch asString! !!Magnitude methodsFor: '*Iceberg-Libgit' stamp: ' 7/21/2017 17:44:57'!iceSemanticVersion	^ IceSemanticVersion major: self asInteger minor: 0 patch: 0! !"Iceberg-Libgit"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.585.mcz') load.ScriptLoader new update60509.!----End fileIn----!----QUIT----2017-07-21T17:45:10.565386+02:00 Pharo.image priorSource: 383265!----QUIT----2017-07-21T17:45:21.503773+02:00 Pharo.image priorSource: 1264177!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 7/24/2017 12:47' prior: 33937868!commentForCurrentUpdate ^ '20268 update iceberg v0.5.5	https://pharo.fogbugz.com/f/cases/20268'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 7/24/2017 12:48'!script60510	^ 'AST-Core-TheIntegrator.496.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.23.mczCodeImport-TheIntegrator.92.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.195.mczCollections-Strings-TheIntegrator.451.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.105.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.31.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.431.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.190.mczGraphics-Files-TheIntegrator.80.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.87.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-Plugin-GitHub-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.34.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2522.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.177.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.195.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1183.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.315.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.56.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.85.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.892.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1437.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.792.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.388.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.76.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.73.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.39.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.992.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.197.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.113.mczUnifiedFFI-Legacy-EstebanLorenzano.3.mczUnifiedFFI-Tests-EstebanLorenzano.41.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.461.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.40.mczZodiac-Core-TheIntegrator.48.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 7/24/2017 12:48'!update60510	"self new update60510"	self withUpdateLog: '20268 update iceberg v0.5.5	https://pharo.fogbugz.com/f/cases/20268'.	self loadTogether: self script60510 merge: false.	#('Iceberg-UI' 'Iceberg-Plugin-GitHub' 'Iceberg-Plugin' 'Iceberg-Metacello-Integration' 'Iceberg-Libgit' 'Iceberg' 'BaselineOfIceberg' 'LibGit-Core' 'BaselineOfLibGit') do: [ :each | each asPackage removeFromSystem ].Metacello new  baseline: 'Iceberg';  repository: 'github://pharo-vcs/iceberg:v0.5.5';  load.(Smalltalk classNamed: #Iceberg) enableMetacelloIntegration: false.	self flushCaches.! !ScriptLoader removeSelector: #update60509!ScriptLoader removeSelector: #script60509!"ScriptLoader60"!Smalltalk globals removeClassNamed: #AnObsoleteGLMSwappedColorDiffPresentation!Smalltalk globals removeClassNamed: #AnObsoleteIceCommitInfoModel!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryUpdateHelper!Smalltalk globals removeClassNamed: #AnObsoleteGLMCherryPickTreePresentation!Smalltalk globals removeClassNamed: #AnObsoleteGLMCherryPickTreeDataSource!Smalltalk globals removeClassNamed: #AnObsoleteIceAskForPlaintextCredentialsModel!Smalltalk globals removeClassNamed: #AnObsoleteIceChangesTreeResetSelectionHelper!Smalltalk globals removeClassNamed: #AnObsoleteIceFileModel!Smalltalk globals removeClassNamed: #AnObsoleteIceHistoryBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIcePackageModel!Smalltalk globals removeClassNamed: #AnObsoleteIceImportLocalRepositoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGlamourChangesTree!Smalltalk globals removeClassNamed: #AnObsoleteIceGlamourPublishBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceBranchGroupModel!Smalltalk globals removeClassNamed: #AnObsoleteIceCloneRepositoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceAbstractBrowser!Smalltalk globals removeClassNamed: #AnObsoleteSwappedColorDiffMorph!Smalltalk globals removeClassNamed: #AnObsoleteIceAskForUsernameAndEmailModel!Smalltalk globals removeClassNamed: #AnObsoleteIceDiffCherryPickChangeTreeBuilder!Smalltalk globals removeClassNamed: #AnObsoleteIceCommitModel!Smalltalk globals removeClassNamed: #AnObsoleteIceRemoteModel!Smalltalk globals removeClassNamed: #AnObsoleteIceTool!Smalltalk globals removeClassNamed: #AnObsoleteIceInteractiveCredentialsProvider!Smalltalk globals removeClassNamed: #AnObsoleteGLMMorphicCherryPickTreeRenderer!Smalltalk globals removeClassNamed: #AnObsoleteIceCachedValue!IceMergeTool removeSelector: #pushRepository:andThen:!IceMergeTool removeSelector: #uiManager!IceMergeTool removeSelector: #mergeIntoAnotherBranch:andThen:!IceMergeTool class removeSelector: #uiManager!Smalltalk globals removeClassNamed: #AnObsoleteTIceTool!Smalltalk globals removeClassNamed: #AnObsoleteIceDirectoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceBranchBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceMergeTool!Smalltalk globals removeClassNamed: #AnObsoleteIceAbstractModel!Smalltalk globals removeClassNamed: #AnObsoleteIceEditRepositoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGlamourCommitBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceAbstractBranchModel!Smalltalk globals removeClassNamed: #AnObsoleteIceCherryPickCommitModel!Smalltalk globals removeClassNamed: #AnObsoleteGLMMorphicSwappedColorDiffRenderer!Smalltalk globals removeClassNamed: #AnObsoleteIceGlamourSynchronizer!Smalltalk globals removeClassNamed: #AnObsoleteIceRemoteAdded!Smalltalk globals removeClassNamed: #AnObsoleteIceAskForSshCredentialsModel!Smalltalk globals removeClassNamed: #AnObsoleteIceDiffChangeTreeBuilder!Smalltalk globals removeClassNamed: #AnObsoleteIceLocationModel!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoriesBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceNewRepositoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGlamourUpdateBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceBranchModel!Smalltalk globals removeClassNamed: #AnObsoleteIceCreateRepositoryModel!Smalltalk globals removeClassNamed: #AnObsoleteIceEmbeddedBrowser!ToolShortcutsCategory removeSelector: #openIceberg!IceRemote removeSelector: #branchesFrom:!PharoShortcuts removeSelector: #openIcebergShortcut!GLMCompositePresentation removeSelector: #cherryPickTree!GLMCompositePresentation removeSelector: #swappedColorDiff!GLMMorphicRenderer removeSelector: #renderCherryPickTreePresentation:!GLMMorphicRenderer removeSelector: #renderSwappedColorDiffPresentation:!GLMGenericAction removeSelector: #selectionAction:!GLMGenericAction removeSelector: #selectionCondition:!GLMGenericAction removeSelector: #showTitle:!MCPatchOperation removeSelector: #canBeBrowsed!MCAddition removeSelector: #icon!Text removeSelector: #allItalic!MCModification removeSelector: #icon!DateAndTime removeSelector: #asStringYMDHM!DateAndTime removeSelector: #asLocalStringYMDHM!MCRemoval removeSelector: #canBeBrowsed!MCRemoval removeSelector: #icon!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubPullRequestBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubPullRequestActionsModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubViewPullRequestCommand!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubAcceptPullRequestModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubNewPullRequestCommand!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubJSONDataSource!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubAPIPaginatedResult!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubError!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubSelectListModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubSelectItem!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubPullRequestListBrowser!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubPullRequestDetailModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubPullRequest!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubCreatePullRequestModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubRemoveBranchesCommand!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubPullRequestDataSource!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubCommand!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubGenericError!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubAPI!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubPullRequestPlugin!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubBadCredentialsError!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubRejectPullRequestModel!Smalltalk globals removeClassNamed: #AnObsoleteIceGitHubPullRequestDefinition!Smalltalk globals removeClassNamed: #AnObsoleteIcePharoFogbugzPlugin!Smalltalk globals removeClassNamed: #AnObsoleteIcePlugin!Smalltalk globals removeClassNamed: #AnObsoleteIcePluginManager!Smalltalk globals removeClassNamed: #AnObsoleteIceBaselineInstallerPlugin!Smalltalk globals removeClassNamed: #AnObsoleteIcePharoFogbugzModel!IceRepository removeSelector: #pluginManager!Smalltalk globals removeClassNamed: #AnObsoleteIceGithubRepositoryType!Smalltalk globals removeClassNamed: #AnObsoleteIceMetacelloRepositoryType!Smalltalk globals removeClassNamed: #AnObsoleteIceMetacelloPharoPlatform!Smalltalk globals removeClassNamed: #AnObsoleteIceGitLocalRepositoryType!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitStCypressWriter!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitFileUtils!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitLocalRepository!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitVersionReader!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitTreeBuilder!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitWriter!Smalltalk globals removeClassNamed: #AnObsoleteIceSemanticVersion!Smalltalk globals removeClassNamed: #AnObsoleteIceLibgitCommitWalk!Magnitude removeSelector: #iceSemanticVersion!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryCreated!Smalltalk globals removeClassNamed: #AnObsoleteIceCommitInfo!Smalltalk globals removeClassNamed: #AnObsoleteIceVersionDoesNotExist!Smalltalk globals removeClassNamed: #AnObsoleteIceFileRemote!Smalltalk globals removeClassNamed: #AnObsoleteIceStructuralChangeSet!Smalltalk globals removeClassNamed: #AnObsoleteIceError!Smalltalk globals removeClassNamed: #AnObsoleteIceLocalBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceGitUsernameOrEmailNotFound!Smalltalk globals removeClassNamed: #AnObsoleteIceMetacelloRepositoryAdapter!Smalltalk globals removeClassNamed: #AnObsoleteIceClassChangeSet!Smalltalk globals removeClassNamed: #AnObsoleteIceMergeAborted!Smalltalk globals removeClassNamed: #AnObsoleteIceRemovedClassReference!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryCreator!Smalltalk globals removeClassNamed: #AnObsoleteManifestIceberg!Smalltalk globals removeClassNamed: #AnObsoleteIceUnknownBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceAbstractDiff!Smalltalk globals removeClassNamed: #AnObsoleteIceRemote!Smalltalk globals removeClassNamed: #AnObsoleteIceWrongUrl!Smalltalk globals removeClassNamed: #AnObsoleteIceTemporaryVersion!Smalltalk globals removeClassNamed: #AnObsoleteIcePushed!Smalltalk globals removeClassNamed: #AnObsoleteIceLoadedCode!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryAnnouncement!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryForgotten!Smalltalk globals removeClassNamed: #AnObsoleteTIceRepositoryBackend!Smalltalk globals removeClassNamed: #AnObsoleteIceHttpsRemote!Smalltalk globals removeClassNamed: #AnObsoleteIceCommited!Smalltalk globals removeClassNamed: #AnObsoleteIceAbstractVersion!Smalltalk globals removeClassNamed: #AnObsoleteIceRemoteBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceMissingRepositoryEntry!Smalltalk globals removeClassNamed: #AnObsoleteIcePlaintextCredentials!Smalltalk globals removeClassNamed: #AnObsoleteIcePackageChangeSet!Smalltalk globals removeClassNamed: #AnObsoleteIceDuplicatedRepository!Smalltalk globals removeClassNamed: #AnObsoleteIceBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceSshCredentials!Smalltalk globals removeClassNamed: #AnObsoleteIceMetadatalessFileTreeWriter!Smalltalk globals removeClassNamed: #AnObsoleteIceCredentialsProvider!Smalltalk globals removeClassNamed: #AnObsoleteIcePackageOrganizationChange!Smalltalk globals removeClassNamed: #AnObsoleteYouShouldPullBeforePush!Smalltalk globals removeClassNamed: #AnObsoleteIceClassReference!Smalltalk globals removeClassNamed: #AnObsoleteIceRepository!Smalltalk globals removeClassNamed: #AnObsoleteIceMCVersionInfo!Smalltalk globals removeClassNamed: #AnObsoleteIceUnbornBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceAbstractCommitWalk!Smalltalk globals removeClassNamed: #AnObsoleteIceNoRemoteBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceScpRemote!Smalltalk globals removeClassNamed: #AnObsoleteIceSavedPackageVersion!Smalltalk globals removeClassNamed: #AnObsoleteIceNoCurrentBranch!Smalltalk globals removeClassNamed: #AnObsoleteIceCommitish!Smalltalk globals removeClassNamed: #AnObsoleteIcePackageLoaded!Smalltalk globals removeClassNamed: #AnObsoleteIceHttpRemote!Smalltalk globals removeClassNamed: #AnObsoleteIceDiff!Smalltalk globals removeClassNamed: #AnObsoleteIceUndefinedRemote!Smalltalk globals removeClassNamed: #AnObsoleteIcePackageUnloaded!Smalltalk globals removeClassNamed: #AnObsoleteIceberg!Smalltalk globals removeClassNamed: #AnObsoleteIceLocalRepositoryMissing!Smalltalk globals removeClassNamed: #AnObsoleteIcePackageReference!Smalltalk globals removeClassNamed: #AnObsoleteIceMethodChange!Smalltalk globals removeClassNamed: #AnObsoleteNothingToCommitException!Smalltalk globals removeClassNamed: #AnObsoleteIceSimpleClassReference!Smalltalk globals removeClassNamed: #AnObsoleteIceSavedPackage!Smalltalk globals removeClassNamed: #AnObsoleteIceMetadatalessStCypressWriter!Smalltalk globals removeClassNamed: #AnObsoleteIceWorkingCopy!Smalltalk globals removeClassNamed: #AnObsoleteIceChangeSet!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryModified!Smalltalk globals removeClassNamed: #AnObsoleteIceBackendWriterAdapter!Smalltalk globals removeClassNamed: #AnObsoleteIceChangeSetChanged!Smalltalk globals removeClassNamed: #AnObsoleteIceTag!Smalltalk globals removeClassNamed: #AnObsoleteIceRepositoryRegistryModified!Smalltalk globals removeClassNamed: #AnObsoleteIceNetworkRemote!Smalltalk globals removeClassNamed: #AnObsoleteCannotIdentifyVersionForCommit!Smalltalk globals removeClassNamed: #AnObsoleteIceForeignVersion!LGitTreeEntry removeSelector: #readStreamDo:!LGitTreeEntry removeSelector: #tree!LGitTreeEntry removeSelector: #name!MCDefinition removeSelector: #addAnalysisToPackageChangeSet:change:!MCDefinition removeSelector: #iceClass!MCDefinition removeSelector: #addToPackageChangeSet:!MCDefinition removeSelector: #icePackage!LGitReturnCodeEnum removeSelector: #asBoolean!MCOrganizationDefinition removeSelector: #iceClass!MCOrganizationDefinition removeSelector: #addAnalysisToPackageChangeSet:change:!MCOrganizationDefinition removeSelector: #icePackage!MCVersion removeSelector: #directoryName!MCGitHubRepository removeSelector: #getOrCreateIcebergRepository!MCGitHubRepository removeSelector: #commitIdFor:ifFound:!MCGitHubRepository removeSelector: #commitId!MCGitHubRepository removeSelector: #httpsUrl!MCGitHubRepository removeSelector: #scpUrl!MCPatchOperation removeSelector: #icePackage!MCPatchOperation removeSelector: #iceClass!MCPatchOperation removeSelector: #addToPackageChangeSet:!MCPatchOperation removeSelector: #asIceChangeSet!LGitTag removeSelector: #asIcebergObjectInRepository:!LGitCredentialsPlaintext removeSelector: #readFrom:!LGitDiff removeSelector: #includesFileNamed:!LGitDiff removeSelector: #files!LGitDiff removeSelector: #filesDo:!LGitCredentialsSSH removeSelector: #readFrom:!LGitCommit removeSelector: #changesFileNamed:!LGitCommit removeSelector: #asIcebergObjectInRepository:!MCClassDefinition removeSelector: #classCategory!MCPostscriptDefinition removeSelector: #addToPackageChangeSet:!MCRepository removeSelector: #commitIdFor:ifFound:!RPackage removeSelector: #iceRepository!MCWorkingCopy removeSelector: #loadedVersion!MCClassTraitDefinition removeSelector: #classCategory!MCMethodDefinition removeSelector: #method!MCMethodDefinition removeSelector: #classCategory!MCMethodDefinition removeSelector: #icePackage!FileSystemDirectoryEntry removeSelector: #packageName!MCGitHubRepository class removeSelector: #commitIdFor:!Smalltalk globals removeClassNamed: #AnObsoleteBaselineOfIceberg!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffHunk!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EBAREREPO!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiff!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutNotifyTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffLineCallback!LGitExternalStructure removeSelector: #shouldContinuePrintingOn:!LGitExternalStructure removeSelector: #objectPrintOn:!LGitExternalStructure removeSelector: #printOn:!LGitExternalObject removeSelector: #objectPrintOn:!LGitExternalObject removeSelector: #printOn:!Smalltalk globals removeClassNamed: #AnObsoleteTLGitPrintingTrait!Smalltalk globals removeClassNamed: #AnObsoleteLGitBuf!Smalltalk globals removeClassNamed: #AnObsoleteLGitOpeningRepositoryError!Smalltalk globals removeClassNamed: #AnObsoleteLGitWritepackFreeCallout!Smalltalk globals removeClassNamed: #AnObsoleteLGitCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitRemoteCompletionTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ENOTFOUND!Smalltalk globals removeClassNamed: #AnObsoleteLGitWriteBackValueUInt!Smalltalk globals removeClassNamed: #AnObsoleteLGitFetchPruneTypeEnum!LGitExternalObject removeSelector: #safeFFICalloutIn:!LGitExternalObject removeSelector: #signalNotReady!LGitExternalObject removeSelector: #validate:shouldBe:!LGitExternalObject removeSelector: #ifNotReady:!LGitExternalObject removeSelector: #withReturnHandlerDo:!LGitExternalObject removeSelector: #ffiLibrary!LGitExternalObject removeSelector: #ffiLibraryName!LGitExternalObject removeSelector: #callUnchecked:options:!LGitExternalObject removeSelector: #call:options:!LGitExternalObject removeSelector: #signalIfNotReady!LGitExternalObject removeSelector: #call:!LGitExternalObject removeSelector: #ffiNull!LGitExternalObject class removeSelector: #ffiLibrary!LGitExternalObject class removeSelector: #ffiLibraryName!LGitExternalObject class removeSelector: #validate:shouldBe:!LGitExternalObject class removeSelector: #call:options:!LGitExternalObject class removeSelector: #call:!LGitExternalObject class removeSelector: #withReturnHandlerDo:!LGitGlobal removeSelector: #safeFFICalloutIn:!LGitGlobal removeSelector: #signalNotReady!LGitGlobal removeSelector: #validate:shouldBe:!LGitGlobal removeSelector: #ifNotReady:!LGitGlobal removeSelector: #withReturnHandlerDo:!LGitGlobal removeSelector: #ffiLibrary!LGitGlobal removeSelector: #ffiLibraryName!LGitGlobal removeSelector: #callUnchecked:options:!LGitGlobal removeSelector: #call:options:!LGitGlobal removeSelector: #signalIfNotReady!LGitGlobal removeSelector: #call:!LGitGlobal removeSelector: #ffiNull!LGitGlobal removeSelector: #isReady!LGitGlobal class removeSelector: #ffiLibrary!LGitGlobal class removeSelector: #ffiLibraryName!LGitGlobal class removeSelector: #call:options:!LGitGlobal class removeSelector: #validate:shouldBe:!LGitGlobal class removeSelector: #call:!LGitGlobal class removeSelector: #withReturnHandlerDo:!LGitCredentials removeSelector: #safeFFICalloutIn:!LGitCredentials removeSelector: #signalNotReady!LGitCredentials removeSelector: #validate:shouldBe:!LGitCredentials removeSelector: #ifNotReady:!LGitCredentials removeSelector: #withReturnHandlerDo:!LGitCredentials removeSelector: #ffiLibrary!LGitCredentials removeSelector: #ffiLibraryName!LGitCredentials removeSelector: #callUnchecked:options:!LGitCredentials removeSelector: #call:options:!LGitCredentials removeSelector: #signalIfNotReady!LGitCredentials removeSelector: #call:!LGitCredentials removeSelector: #ffiNull!LGitCredentials removeSelector: #isReady!LGitCredentials class removeSelector: #ffiLibrary!LGitCredentials class removeSelector: #ffiLibraryName!LGitCredentials class removeSelector: #call:options:!LGitCredentials class removeSelector: #validate:shouldBe:!LGitCredentials class removeSelector: #call:!LGitCredentials class removeSelector: #withReturnHandlerDo:!LGitExternalStructure removeSelector: #safeFFICalloutIn:!LGitExternalStructure removeSelector: #signalNotReady!LGitExternalStructure removeSelector: #validate:shouldBe:!LGitExternalStructure removeSelector: #ifNotReady:!LGitExternalStructure removeSelector: #withReturnHandlerDo:!LGitExternalStructure removeSelector: #ffiLibrary!LGitExternalStructure removeSelector: #ffiLibraryName!LGitExternalStructure removeSelector: #callUnchecked:options:!LGitExternalStructure removeSelector: #call:options:!LGitExternalStructure removeSelector: #signalIfNotReady!LGitExternalStructure removeSelector: #call:!LGitExternalStructure removeSelector: #ffiNull!LGitExternalStructure removeSelector: #isReady!LGitExternalStructure class removeSelector: #validate:shouldBe:!LGitExternalStructure class removeSelector: #withReturnHandlerDo:!LGitExternalStructure class removeSelector: #ffiLibrary!LGitExternalStructure class removeSelector: #ffiLibraryName!LGitExternalStructure class removeSelector: #call:options:!LGitExternalStructure class removeSelector: #call:!Smalltalk globals removeClassNamed: #AnObsoleteTLGitCalloutTrait!Smalltalk globals removeClassNamed: #AnObsoleteLGitUpdateTipsCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitStringArray!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ENONFASTFORWARD!Smalltalk globals removeClassNamed: #AnObsoleteLGitRemote!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffLineTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitRemoteCreateCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffPerfData!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_PASSTHROUGH!Smalltalk globals removeClassNamed: #AnObsoleteLGitIndex!Smalltalk globals removeClassNamed: #AnObsoleteLGitCloneLocalTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitFileSignatureCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredentialsPlaintext!Smalltalk globals removeClassNamed: #AnObsoleteLGitNoCredentialsProvided!Smalltalk globals removeClassNamed: #AnObsoleteLGitPackBuilder!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalArray!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutPerfDataCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitStatusTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitStructWithDefaults!Smalltalk globals removeClassNamed: #AnObsoleteLGitCallError!Smalltalk globals removeClassNamed: #AnObsoleteLGitOpenFlagEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalStructureFieldParser!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGitRepositoryNotFound!Smalltalk globals removeClassNamed: #AnObsoleteLGitRevwalk!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffStatsFormatTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitSimilarityCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitError!Smalltalk globals removeClassNamed: #AnObsoleteLGitDatabase!Smalltalk globals removeClassNamed: #AnObsoleteLGitCommit!Smalltalk globals removeClassNamed: #AnObsoleteLGitIndexMatchedPathCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredentialsSSHAgent!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EEOF!Smalltalk globals removeClassNamed: #AnObsoleteLGitAnnotatedCommit!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalStringArray!Smalltalk globals removeClassNamed: #AnObsoleteLGitCompletionCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitSubmoduleIgnoreTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitActionSequence!Smalltalk globals removeClassNamed: #AnObsoleteLGitTransferProgress!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ITEROVER!Smalltalk globals removeClassNamed: #AnObsoleteLGitPathSpecFlagTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffFindOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EPEEL!Smalltalk globals removeClassNamed: #AnObsoleteLGitTreeBuilder!Smalltalk globals removeClassNamed: #AnObsoleteLGitErrorTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitTransferProgressCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitOdbWritepack!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EINVALID!Smalltalk globals removeClassNamed: #AnObsoleteLGitTag!Smalltalk globals removeClassNamed: #AnObsoleteLGitDeltaTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitPackbuilderProgressCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffBinaryFile!Smalltalk globals removeClassNamed: #AnObsoleteLGitNoReturnCodeHandlerDefined!Smalltalk globals removeClassNamed: #AnObsoleteLGitBranchIterator!Smalltalk globals removeClassNamed: #AnObsoleteLGitBlameFlagTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffBinaryCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitFunctionReturn!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredentialsFreeCallout!Smalltalk globals removeClassNamed: #AnObsoleteLGitIllegalArgument!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushOptionsVersionEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitFetchOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EBUFS!Smalltalk globals removeClassNamed: #AnObsoleteLGitWriteBackValue!Smalltalk globals removeClassNamed: #AnObsoleteLGitObjectTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredentials!Smalltalk globals removeClassNamed: #AnObsoleteLGitTransportCertificateCheckCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushUpdate!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ECERTIFICATE!Smalltalk globals removeClassNamed: #AnObsoleteLGitPatch!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffFindTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushStatusForeachCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffFile!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EUNMERGED!Smalltalk globals removeClassNamed: #AnObsoleteLGitConfig!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffHunkCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitBlameHunk!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EUNBORNBRANCH!Smalltalk globals removeClassNamed: #AnObsoleteLGitWritepackCommitCallout!Smalltalk globals removeClassNamed: #AnObsoleteLGitBufferSignatureCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitRemoteAutotagOptionTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitProxyOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EMODIFIED!Smalltalk globals removeClassNamed: #AnObsoleteLGitWriteBackValueSizeT!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalEnumerationUInt32!Smalltalk globals removeClassNamed: #AnObsoleteLGitTreewalkCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitSignature!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EEXISTS!Smalltalk globals removeClassNamed: #AnObsoleteLGitReference!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffFormatTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushUpdateReferenceCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffLine!Smalltalk globals removeClassNamed: #AnObsoleteLGitTransport!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffStats!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutStrategyEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffNotifyCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutPerfData!Smalltalk globals removeClassNamed: #AnObsoleteLGitObjectNotFound!Smalltalk globals removeClassNamed: #AnObsoleteLGitOdb!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutNotifyCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitRevwalkSortTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitRemoteCallbacks!Smalltalk globals removeClassNamed: #AnObsoleteLGitAbstractError!Smalltalk globals removeClassNamed: #AnObsoleteLGitFilemodeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitLibrary!Smalltalk globals removeClassNamed: #AnObsoleteLGitBlameOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EAMBIGUOUS!Smalltalk globals removeClassNamed: #AnObsoleteLGitRepositoryObject!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffOptionTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalStructure!Smalltalk globals removeClassNamed: #AnObsoleteLGitRepositoryCreateCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffSimilarityMetric!Smalltalk globals removeClassNamed: #AnObsoleteLGitObjectNotInitialized!Smalltalk globals removeClassNamed: #AnObsoleteLGitBlob!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredentialsTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitFreeSignatureCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredentialsSSH!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EAUTH!Smalltalk globals removeClassNamed: #AnObsoleteLGitRepository!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalCommitArray!Smalltalk globals removeClassNamed: #AnObsoleteLGitCheckoutProgressCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitStructVersionsEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitTime!Smalltalk globals removeClassNamed: #AnObsoleteLGitCallReturnHandler!Smalltalk globals removeClassNamed: #AnObsoleteLGitOptionsVersionsEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitSafeFFICalloutMethodBuilder!Smalltalk globals removeClassNamed: #AnObsoleteLGitCloneOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGitWritingTreeFailed!Smalltalk globals removeClassNamed: #AnObsoleteLGitStatusList!Smalltalk globals removeClassNamed: #AnObsoleteLGitDirectionEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitStatusCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitId!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EUSER!Smalltalk globals removeClassNamed: #AnObsoleteLGitObject!Smalltalk globals removeClassNamed: #AnObsoleteLGitPackbuilderForeachCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffBinary!Smalltalk globals removeClassNamed: #AnObsoleteLGitCallout!Smalltalk globals removeClassNamed: #AnObsoleteLGitBlame!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalUInt8Array!Smalltalk globals removeClassNamed: #AnObsoleteLGitCredAcquireCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitTreewalkModeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ERROR!Smalltalk globals removeClassNamed: #AnObsoleteLGitSafeFFICalloutAPI!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_OK!Smalltalk globals removeClassNamed: #AnObsoleteLGitProxyTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EINVALIDSPEC!Smalltalk globals removeClassNamed: #AnObsoleteLGitTreeEntry!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalEnumerationInt32!Smalltalk globals removeClassNamed: #AnObsoleteLGitTransportCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitPackbuilderForeachPayload!Smalltalk globals removeClassNamed: #AnObsoleteLGitExternalObject!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EUNCOMMITTED!Smalltalk globals removeClassNamed: #AnObsoleteLGitTree!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffBinaryTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushNegotiationCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffDelta!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ECONFLICT!Smalltalk globals removeClassNamed: #AnObsoleteLGitCommitBuilder!Smalltalk globals removeClassNamed: #AnObsoleteLGitBranchTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffFileCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitRefSpec!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EAPPLIED!Smalltalk globals removeClassNamed: #AnObsoleteLGitWritepackAppendCallout!Smalltalk globals removeClassNamed: #AnObsoleteManifestLibGitCore!Smalltalk globals removeClassNamed: #AnObsoleteLGitReferenceTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitMergeOptions!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_EORPHANEDHEAD!Smalltalk globals removeClassNamed: #AnObsoleteLGitWriteBackValueInt!Smalltalk globals removeClassNamed: #AnObsoleteLGitReturnCodeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitTransportMessageCallback!Smalltalk globals removeClassNamed: #AnObsoleteLGitRemoteHead!Smalltalk globals removeClassNamed: #AnObsoleteLGit_GIT_ELOCKED!Smalltalk globals removeClassNamed: #AnObsoleteLGitPathSpecMatchList!Smalltalk globals removeClassNamed: #AnObsoleteLGitDiffFlagTypeEnum!Smalltalk globals removeClassNamed: #AnObsoleteLGitGlobal!Smalltalk globals removeClassNamed: #AnObsoleteLGitPushTransferProgressCallback!Object removeSelector: #handleLGitReturnCode!String removeSelector: #asLGitExternalString!Smalltalk globals removeClassNamed: #AnObsoleteBaselineOfLibGit!!BaselineOfIceberg methodsFor: 'baseline' stamp: ' 7/24/2017 12:50:00'!baseline: spec	<baseline>	spec for: #common do: [ 				spec postLoadDoIt: #resetKMRepository.				spec		configuration: 'OSSubprocess' with: [ spec			versionString: #stable;			repository: 'github://marianopeck/OSSubprocess/repository' ];		configuration: 'ProcessWrapper' with: [ spec			versionString: #stable;			repository: 'http://smalltalkhub.com/mc/Pharo/MetaRepoForPharo50/main' ];		baseline: 'FileTree' with: [ spec			repository: 'github://pharo-vcs/filetree:pharo6.0_dev/repository';			loads: 'Git' ];		baseline: 'LibGit' with: [ spec			repository: 'github://pharo-vcs/libgit2-pharo-bindings:v0.25.1';  			loads: 'default' ];		project: 'LibGit-Tests'          copyFrom: 'LibGit'          with: [ spec loads: #('tests') ];		for: #MacOS do: [ spec			package: 'Iceberg-GitCommand'			with: [ spec requires: #('OSSubprocess') ] ];		for: #Unix do: [ spec			package: 'Iceberg-GitCommand'			with: [ spec requires: #('OSSubprocess' ) ] ];		for: #Windows do: [ spec			package: 'Iceberg-GitCommand'			with: [ spec requires: #('ProcessWrapper') ] ];		package: 'Iceberg';		package: 'Iceberg-Plugin' with: [ spec requires: #('Iceberg') ];		package: 'Iceberg-Plugin-GitHub' with: [ spec requires: #('Iceberg-Plugin' 'Iceberg-UI') ];		package: 'Iceberg-Metacello-Integration' with: [ spec requires: #('Iceberg')];		package: 'Iceberg-UI' with: [ spec requires: #('Iceberg') ];		package: 'Iceberg-Tests' with: [ spec requires: #('Iceberg' 'Iceberg-GitCommand') ];		package: 'Iceberg-UI-Tests' with: [ spec requires: #('Iceberg-UI' 'Iceberg-Tests')];		package: 'Iceberg-GitFileTree' with: [ spec requires: #('Iceberg' 'FileTree') ];		package: 'Iceberg-GitFileTree-Tests' with: [ spec requires: #('Iceberg-GitFileTree' 'Iceberg-Tests') ];		package: 'Iceberg-Libgit' with: [ spec requires: #('Iceberg' 'LibGit') ];		group: 'minimal' with: #('Iceberg' 'Iceberg-Libgit');		group: 'default' with: #(minimal 'Iceberg-Metacello-Integration' 'Iceberg-UI' 'Iceberg-Plugin' 'Iceberg-Plugin-GitHub');		group: 'allTests' with: #('Iceberg-Tests' 'LibGit-Tests' 'Iceberg-GitFileTree-Tests' 'Iceberg-UI-Tests' );		group: 'development' with: #(default 'Iceberg-GitFileTree' allTests)	]! !!BaselineOfIceberg methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:00'!customProjectAttributes	Smalltalk os isMacOS ifTrue: [ ^ #(#MacOS) ].	Smalltalk os isUnix ifTrue: [ ^ #(#Unix) ].	Smalltalk os isWindows ifTrue: [ ^ #(#Windows) ]! !!BaselineOfIceberg methodsFor: 'script' stamp: ' 7/24/2017 12:50:00'!resetKMRepository	KMRepository reset! !"BaselineOfIceberg"!!BaselineOfLibGit methodsFor: 'baseline' stamp: ' 7/24/2017 12:50:03'!baseline: spec  <baseline>  spec    for: #(common)    do: [       spec        package: 'LibGit-Tests' with: [ spec requires: 'LibGit-Core' ];        package: 'LibGit-GT' with: [ spec requires: 'LibGit-Core' ];        package: 'LibGit-Patches' with: [ spec requires: 'LibGit-Core' ];        package: 'LibGit-Core'.      spec        group: 'default'        with: #('LibGit-Core').		spec			group: 'development'			with: #('default' 'LibGit-Tests' 'LibGit-Patches' 'LibGit-GT').		spec			group: 'tests'			with: #('LibGit-Tests').		spec postLoadDoIt: #postLoadActions ]! !!BaselineOfLibGit methodsFor: 'doits' stamp: ' 7/24/2017 12:50:03'!changeRepositoryType	| repos newRepo |	(Smalltalk hasClassNamed: #MCGitRepository) ifFalse: [ ^ self ].		repos := MCRepositoryGroup default repositories		select: [ :r | (r description includesSubstring: 'LibGit:master') or: [ 			r description includesSubstring: 'LibGit/master' ] ].	repos ifEmpty: [  ^ self ].		'github-cache/theseion' asFileReference deleteAll.	newRepo := (Smalltalk at: #MCGitRepository) new		repoUrl: 'git@github.com:theseion/LibGit';		ensureDirectory;		yourself.			MCRepositoryGroup allInstances		select: [ :group | group repositories includesAnyOf: repos ]		thenDo: [ :group | 			repos do: [ :repo | group removeRepository: repo ].			group addRepository: newRepo ]! !!BaselineOfLibGit methodsFor: 'doits' stamp: ' 7/24/2017 12:50:03'!postLoadActions	self changeRepositoryType! !"BaselineOfLibGit"!!LGitExternalArray commentStamp: 'MaxLeske 7/14/2015 09:09' prior: 0!I provide general implementations for my subclasses that represent dedicated arrays of a certain type.!!LGitExternalCommitArray commentStamp: 'MaxLeske 7/13/2015 17:10' prior: 0!I represent an external array of commits.!!LGitExternalStringArray commentStamp: 'MaxLeske 7/13/2015 17:12' prior: 0!I represent an external array of strings. Since strings are of variable size, they can not be easily represented by the general implementation.I take care of converting regular strings to external ones (which allocates and reserves the memory) and reading strings from memory.I override #free to ensure that the memory for the external strings is correctly freed.!!LGitExternalUInt8Array commentStamp: 'MaxLeske 7/15/2015 10:31' prior: 0!My elements are 8 bit unsigned integers.!!LGitExternalEnumerationUInt32 commentStamp: 'MaxLeske 3/17/2014 13:57' prior: 0!See the comment in NBExternalEnumeration. I am a copy of NBExternalEnumeration with the exception that I inherit from Object, not from SharedPool.!!LGitCheckoutStrategyEnum commentStamp: 'MaxLeske 8/13/2015 11:06' prior: 0!/** * Checkout behavior flags * * In libgit2, checkout is used to update the working directory and index * to match a target tree.  Unlike git checkout, it does not move the HEAD * commit for you - use `git_repository_set_head` or the like to do that. * * Checkout looks at (up to) four things: the "target" tree you want to * check out, the "baseline" tree of what was checked out previously, the * working directory for actual files, and the index for staged changes. * * You give checkout one of three strategies for update: * * - `GIT_CHECKOUT_NONE` is a dry-run strategy that checks for conflicts, *   etc., but doesn't make any actual changes. * * - `GIT_CHECKOUT_FORCE` is at the opposite extreme, taking any action to *   make the working directory match the target (including potentially *   discarding modified files). * * - `GIT_CHECKOUT_SAFE` is between these two options, it will only make *   modifications that will not lose changes. * *                         |  target == baseline   |  target !!= baseline  | *    ---------------------|-----------------------|----------------------| *     workdir == baseline |       no action       |  create, update, or  | *                         |                       |     delete file      | *    ---------------------|-----------------------|----------------------| *     workdir exists and  |       no action       |   conflict (notify   | *       is !!= baseline    | notify dirty MODIFIED | and cancel checkout) | *    ---------------------|-----------------------|----------------------| *      workdir missing,   | notify dirty DELETED  |     create file      | *      baseline present   |                       |                      | *    ---------------------|-----------------------|----------------------| * * To emulate `git checkout`, use `GIT_CHECKOUT_SAFE` with a checkout * notification callback (see below) that displays information about dirty * files.  The default behavior will cancel checkout on conflicts. * * To emulate `git checkout-index`, use `GIT_CHECKOUT_SAFE` with a * notification callback that cancels the operation if a dirty-but-existing * file is found in the working directory.  This core git command isn't * quite "force" but is sensitive about some types of changes. * * To emulate `git checkout -f`, use `GIT_CHECKOUT_FORCE`. * * * There are some additional flags to modified the behavior of checkout: * * - GIT_CHECKOUT_ALLOW_CONFLICTS makes SAFE mode apply safe file updates *   even if there are conflicts (instead of cancelling the checkout). * * - GIT_CHECKOUT_REMOVE_UNTRACKED means remove untracked files (i.e. not *   in target, baseline, or index, and not ignored) from the working dir. * * - GIT_CHECKOUT_REMOVE_IGNORED means remove ignored files (that are also *   untracked) from the working directory as well. * * - GIT_CHECKOUT_UPDATE_ONLY means to only update the content of files that *   already exist.  Files will not be created nor deleted.  This just skips *   applying adds, deletes, and typechanges. * * - GIT_CHECKOUT_DONT_UPDATE_INDEX prevents checkout from writing the *   updated files' information to the index. * * - Normally, checkout will reload the index and git attributes from disk *   before any operations.  GIT_CHECKOUT_NO_REFRESH prevents this reload. * * - Unmerged index entries are conflicts.  GIT_CHECKOUT_SKIP_UNMERGED skips *   files with unmerged index entries instead.  GIT_CHECKOUT_USE_OURS and *   GIT_CHECKOUT_USE_THEIRS to proceed with the checkout using either the *   stage 2 ("ours") or stage 3 ("theirs") version of files in the index. * * - GIT_CHECKOUT_DONT_OVERWRITE_IGNORED prevents ignored files from being *   overwritten.  Normally, files that are ignored in the working directory *   are not considered "precious" and may be overwritten if the checkout *   target contains that file. * * - GIT_CHECKOUT_DONT_REMOVE_EXISTING prevents checkout from removing *   files or folders that fold to the same name on case insensitive *   filesystems.  This can cause files to retain their existing names *   and write through existing symbolic links. */!!LGitDeltaTypeEnum commentStamp: 'MaxLeske 8/13/2015 10:32' prior: 0!/** * What type of change is described by a git_diff_delta? * * `GIT_DELTA_RENAMED` and `GIT_DELTA_COPIED` will only show up if you run * `git_diff_find_similar()` on the diff object. * * `GIT_DELTA_TYPECHANGE` only shows up given `GIT_DIFF_INCLUDE_TYPECHANGE` * in the option flags (otherwise type changes will be split into ADDED / * DELETED pairs). */!!LGitDiffBinaryTypeEnum commentStamp: 'MaxLeske 8/13/2015 14:28' prior: 0!/** * When producing a binary diff, the binary data returned will be * either the deflated full ("literal") contents of the file, or * the deflated binary delta between the two sides (whichever is * smaller). */!!LGitOptionsVersionsEnum commentStamp: 'MaxLeske 7/17/2015 13:37' prior: 0!I map names to versions for all the option structs.!!LGitProxyTypeEnum commentStamp: '<historical>' prior: 0!/** * The type of proxy to use. */!!LGitRevwalkSortTypeEnum commentStamp: 'MaxLeske 3/1/2015 16:39' prior: 0!/** * Sort the repository contents in no particular ordering; * this sorting is arbitrary, implementation-specific * and subject to change at any time. * This is the default sorting for new walkers. */#define GIT_SORT_NONE			(0)/** * Sort the repository contents in topological order * (parents before children); this sorting mode * can be combined with time sorting. */#define GIT_SORT_TOPOLOGICAL (1 << 0)/** * Sort the repository contents by commit time; * this sorting mode can be combined with * topological sorting. */#define GIT_SORT_TIME			(1 << 1)/** * Iterate through the repository contents in reverse * order; this sorting mode can be combined with * any of the above. */#define GIT_SORT_REVERSE		(1 << 2)!!LGitStatusTypeEnum commentStamp: 'MaxLeske 8/13/2015 10:34' prior: 0!/** * Status flags for a single file. * * A combination of these values will be returned to indicate the status of * a file.  Status compares the working directory, the index, and the * current HEAD of the repository.  The `GIT_STATUS_INDEX` set of flags * represents the status of file in the index relative to the HEAD, and the * `GIT_STATUS_WT` set of flags represent the status of the file in the * working directory relative to the index. */!!LGitRefSpec commentStamp: 'MaxLeske 4/18/2014 11:59' prior: 0!Use:	LGitRefSpec fromString: '+refs/heads/*:refs/remotes/origin/*'.Note: The asterisk wildcard (*) matches all refs of a given path (not explicitly documented in the below).From the git-fetch man page:<refspec>           The format of a <refspec> parameter is an optional plus +, followed by the source           ref <src>, followed by a colon :, followed by the destination ref <dst>.           The remote ref that matches <src> is fetched, and if <dst> is not empty string,           the local ref that matches it is fast-forwarded using <src>. If the optional plus           + is used, the local ref is updated even if it does not result in a fast-forward           update.               Note               If the remote branch from which you want to pull is modified in non-linear               ways such as being rewound and rebased frequently, then a pull will attempt a               merge with an older version of itself, likely conflict, and fail. It is under               these conditions that you would want to use the + sign to indicate               non-fast-forward updates will be needed. There is currently no easy way to               determine or declare that a branch will be made available in a repository               with this behavior; the pulling user simply must know this is the expected               usage pattern for a branch.               Note               You never do your own development on branches that appear on the right hand               side of a <refspec> colon on Pull: lines; they are to be updated by git               fetch. If you intend to do development derived from a remote branch B, have a               Pull: line to track it (i.e.  Pull: B:remote-B), and have a separate branch               my-B to do your development on top of it. The latter is created by git branch               my-B remote-B (or its equivalent git checkout -b my-B remote-B). Run git               fetch to keep track of the progress of the remote side, and when you see               something new on the remote branch, merge it into your development branch               with git pull . remote-B, while you are on my-B branch.               Note               There is a difference between listing multiple <refspec> directly on git pull               command line and having multiple Pull: <refspec> lines for a <repository> and               running git pull command without any explicit <refspec> parameters. <refspec>               listed explicitly on the command line are always merged into the current               branch after fetching. In other words, if you list more than one remote refs,               you would be making an Octopus. While git pull run without any explicit               <refspec> parameter takes default <refspec>s from Pull: lines, it merges only               the first <refspec> found into the current branch, after fetching all the               remote refs. This is because making an Octopus from remote refs is rarely               done, while keeping track of multiple remote heads in one-go by fetching more               than one is often useful.Some short-cut notations are also supported.           o    tag <tag> means the same as refs/tags/<tag>:refs/tags/<tag>; it requests               fetching everything up to the given tag.           o   A parameter <ref> without a colon fetches that ref into FETCH_HEAD, and               updates the remote-tracking branches (if any).!!LGitExternalStructure commentStamp: 'MaxLeske 3/1/2015 20:36' prior: 0!Important: structs in libgit2 are usually freed by libgit2 itself.	We therefore disable freeing of structs during GC to prevent invalid	memory accesses. However, users of any struct need to make sure that	they free the struct (using a manual #free send) iff it is necessary.	Otherwise the structs will leak and we can't reclaim the space once the	object representing the struct has been collected!!LGitCredentialsSSH commentStamp: '<historical>' prior: 0!I'm a set of credentials who asks public/private keys from from files (in case you need something different than what is answered by ssh-agent, provided by LGitCredentialsSSHAgent)!!LGitCredentialsSSHAgent commentStamp: '<historical>' prior: 0!I'm a set of credentials who feeds from the ssh-agent client.!!LGitDiffBinary commentStamp: 'MaxLeske 8/13/2015 14:22' prior: 0!/** Structure describing the binary contents of a diff. */!!LGitDiffBinaryFile commentStamp: 'MaxLeske 8/13/2015 14:22' prior: 0!/** The contents of one of the files in a binary diff. */!!LGitDiffDelta commentStamp: 'MaxLeske 7/4/2015 17:03' prior: 0!I represent the difference between two entities (e.g. two files). If one of the entities is new or deleted the "nfiles" field will hold be set to 1, otherwise it will be set to 2.!!LGitId commentStamp: '<historical>' prior: 0!I'm an unique identity of any object (commit, tree, blob, tag).https://libgit2.github.com/libgit2/#HEAD/type/git_oidNOTE: This might be replaces by an FFITypeArray in the future.!!LGitRemoteHead commentStamp: 'EstebanLorenzano 1/5/2017 16:00' prior: 0!I'm a description of a reference advertised by a remote server, given out on `ls` calls.https://libgit2.github.com/libgit2/#HEAD/type/git_remote_head!!LGitSignature commentStamp: '<historical>' prior: 0!A LGitSignature represents the information of a specific person for a commit.Instance Variables	email:		ByteString	name:		ByteString	when:		DateAndTime!!LGitProxyOptions commentStamp: '<historical>' prior: 0!/** * Options for connecting through a proxy * * Note that not all types may be supported, depending on the platform * and compilation options. */!!LGitPushOptions commentStamp: 'MaxLeske 8/13/2015 23:46' prior: 0!/** * Controls the behavior of a git_push object. */!!LGitRemoteCallbacks commentStamp: 'MaxLeske 8/13/2015 13:20' prior: 0!/** * The callback settings structure * * Set the callbacks to be called by the remote when informing the user * about the progress of the network operations. */!!LGitSafeFFICalloutAPI commentStamp: 'JanVanDeSandt 5/1/2016 21:18' prior: 0!I'm a variant of FFICalloutAPI that uses a different builder to generate methods with an extra check to see if the object is 'ready' or not.!!LGitRepository commentStamp: '<historical>' prior: 0!A LGitRepository represents a git repository.Instance Variables	handle:		NBExternalObjecthandle	- reference to the external object!!LGitConfig commentStamp: 'NicoPasserini 2/8/2017 00:51' prior: 0!/** Memory representation of a set of config files */typedef struct git_config git_config;https://libgit2.github.com/libgit2/#HEAD/type/git_config!!LGitCommit commentStamp: 'NicoPasserini 11/3/2016 15:40' prior: 0!A LGitCommit represents a specific commit and the associate information.Instance Variables	handle:		NBExternalObjecthandle	- the handle to the external data object!!LGitTag commentStamp: 'NicoPasserini 11/3/2016 15:40' prior: 0!A LGitTag represents a git tag and the associate information.Instance Variables	handle:		NBExternalObjecthandle	- the handle to the external data object!!LGitReference commentStamp: '<historical>' prior: 0!A LGitReference represents the reference to a git object. References can be symbolic as for instance HEAD or a branch etc.Instance Variables	handle:			NBExternalObject	repoHandle:	NBExternalObjecthandle	- the reference to the external object representing the referencerepoHandle	- the reference to the repository in which the reference is contained!!LGitNoCredentialsProvided commentStamp: 'EstebanLorenzano 2/8/2017 16:19' prior: 0!I'm an error thrown in callbacks when no credentials has been found.Callbacks supplying credentials HAVE to throw this error and not one created by themselves (because libgit2 aborts processing with this exception and not with others). !!ManifestLibGitCore commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!LGitCredAcquireCallback commentStamp: 'MaxLeske 3/1/2015 16:57' prior: 0!/** * Signature of a function which acquires a credential object. * * - cred: The newly created credential object. * - url: The resource for which we are demanding a credential. * - username_from_url: The username that was embedded in a "user@host" *                          remote url, or NULL if not included. * - allowed_types: A bitmask stating which cred types are OK to return. * - payload: The payload provided when specifying this callback. * - returns 0 for success, < 0 to indicate an error, > 0 to indicate *       no credential was acquired */!!LGitIndexMatchedPathCallback commentStamp: '<historical>' prior: 0!I define a git_index_matched_path_cb.https://libgit2.github.com/libgit2/#HEAD/group/callback/git_index_matched_path_cb!!LGitSafeFFICalloutMethodBuilder commentStamp: 'JanVanDeSandt 5/1/2016 21:17' prior: 0!I'm a variant of FFICalloutMethodBuilder  that adds a call to  #signalIfNotReady  before the actual ffi call.!!TLGitCalloutTrait classTrait methodsFor: 'ffi-calls' stamp: ' 7/24/2017 12:50:03'!call: fnSpec	^ (self ffiCalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibrary! !!TLGitCalloutTrait classTrait methodsFor: 'ffi-calls' stamp: ' 7/24/2017 12:50:03'!call: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibrary! !!TLGitCalloutTrait classTrait methodsFor: 'resources' stamp: ' 7/24/2017 12:50:03'!ffiLibrary	^LGitLibrary ! !!TLGitCalloutTrait classTrait methodsFor: 'resources' stamp: ' 7/24/2017 12:50:03'!ffiLibraryName	^self ffiLibrary! !!TLGitCalloutTrait classTrait methodsFor: 'argument validation' stamp: ' 7/24/2017 12:50:03'!validate: anObject shouldBe: aClass	"I allow for nil values."	(anObject isNil or: [ anObject isKindOf: aClass ])		ifFalse: [ LGitIllegalArgument signalWith: anObject shouldBe: aClass ]! !!TLGitCalloutTrait classTrait methodsFor: 'exit code handling' stamp: ' 7/24/2017 12:50:03'!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!TLGitCalloutTrait methodsFor: 'ffi-calls' stamp: ' 7/24/2017 12:50:03'!call: fnSpec	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibraryName! !!TLGitCalloutTrait methodsFor: 'ffi-calls' stamp: ' 7/24/2017 12:50:03'!call: fnSpec options: options	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!TLGitCalloutTrait methodsFor: 'ffi-calls' stamp: ' 7/24/2017 12:50:03'!callUnchecked: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!TLGitCalloutTrait methodsFor: 'resources' stamp: ' 7/24/2017 12:50:03'!ffiLibrary	^self class ffiLibrary! !!TLGitCalloutTrait methodsFor: 'resources' stamp: ' 7/24/2017 12:50:03'!ffiLibraryName	^self class ffiLibrary! !!TLGitCalloutTrait methodsFor: 'resources' stamp: ' 7/24/2017 12:50:03'!ffiNull	^FFIExternalObject null! !!TLGitCalloutTrait methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!ifNotReady: aBlock	"use extra block so compiler can optimize"	self isReady ifFalse: [ aBlock value ]! !!TLGitCalloutTrait methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isReady	^ true! !!TLGitCalloutTrait methodsFor: 'ffi-calls' stamp: ' 7/24/2017 12:50:03'!safeFFICalloutIn: aContext	^ LGitSafeFFICalloutAPI inContext: aContext! !!TLGitCalloutTrait methodsFor: 'signalling' stamp: ' 7/24/2017 12:50:03'!signalIfNotReady	self ifNotReady: [ self signalNotReady ]! !!TLGitCalloutTrait methodsFor: 'signalling' stamp: ' 7/24/2017 12:50:03'!signalNotReady	LGitObjectNotInitialized signalWith: self! !!TLGitCalloutTrait methodsFor: 'argument validation' stamp: ' 7/24/2017 12:50:03'!validate: anObject shouldBe: aClass	self class validate: anObject shouldBe: aClass! !!TLGitCalloutTrait methodsFor: 'exit code handling' stamp: ' 7/24/2017 12:50:03'!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!TLGitPrintingTrait methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!objectPrintOn: aStream! !!TLGitPrintingTrait methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!printOn: aStream	| title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: [ 'an ' ] ifFalse: [ 'a ' ]);		nextPutAll: title.			(self shouldContinuePrintingOn: aStream) ifFalse: [ ^ self ].		aStream nextPutAll: ' ('.	self objectPrintOn: aStream.	aStream nextPut: $)! !!TLGitPrintingTrait methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!shouldContinuePrintingOn: aStream	^ true! !!LGitExternalArray class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!externalNew: numberOfElements	^ self 		externalNewType: self type 		size: numberOfElements! !!LGitExternalArray class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!onAddress: handle size: numberOfElements	^ self fromHandle: handle type: self type size: numberOfElements! !!LGitExternalArray class methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!type 	^ self subclassResponsibility! !!LGitExternalArray methodsFor: 'converting' stamp: ' 7/24/2017 12:50:03'!asArray	| array |	array := Array new: self size.	1 to: self size do: [ :index |		array			at: index			put: (self at: index) ].			^ array! !!LGitExternalCommitArray class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!fromCollection: aCollection	| instance |	instance := self externalNew: aCollection size.	aCollection withIndexDo: [ :commit :index |		instance at: index put: commit ].		^ instance! !!LGitExternalCommitArray class methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!type 	^ LGitCommit! !!LGitExternalCommitArray methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!at: anIndex	^ LGitCommit fromHandle: (super at: anIndex)! !!LGitExternalCommitArray methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!at: anIndex put: aLGitCommit	^ super at: anIndex put: aLGitCommit getHandle! !!LGitExternalStringArray class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!fromCollection: aCollection	| instance |	instance := self externalNew: aCollection size.	aCollection withIndexDo: [ :element :index |		instance at: index put: element ].		^ instance! !!LGitExternalStringArray class methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!type	^ 'char*'! !!LGitExternalStringArray methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!at: anInteger	^ (self primAt: anInteger) readString! !!LGitExternalStringArray methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!at: index put: aString	^ super at: index put: aString asLGitExternalString getHandle! !!LGitExternalStringArray methodsFor: 'initialize-release' stamp: ' 7/24/2017 12:50:03'!free	1 to: self size do: [ :index | 		(self primAt: index) free ].		super free! !!LGitExternalStringArray methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!primAt: anInteger	^ super at: anInteger! !!LGitExternalUInt8Array class methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!type	^ FFIUInt32! !!LGitExternalUInt8Array methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!type 	^ FFIUInt8! !!LGitBlameFlagTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^ #(		"Normal blame the default"		GIT_BLAME_NORMAL 0		"Track lines that have moved within a file (like `git blame -M`).		 * NOT IMPLEMENTED."		GIT_BLAME_TRACK_COPIES_SAME_FILE 1		"Track lines that have moved across files in the same commit (like `git blame -C`).		 * NOT IMPLEMENTED."		GIT_BLAME_TRACK_COPIES_SAME_COMMIT_MOVES 2		"Track lines that have been copied from another file that exists in the		 * same commit (like `git blame -CC`). Implies SAME_FILE.		 * NOT IMPLEMENTED."		GIT_BLAME_TRACK_COPIES_SAME_COMMIT_COPIES 4		"Track lines that have been copied from another file that exists in *any*		 * commit (like `git blame -CCC`). Implies SAME_COMMIT_COPIES.		 * NOT IMPLEMENTED."		GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES 8		"Restrict the search of commits to those reachable following only the		 * first parents."		GIT_BLAME_FIRST_PARENT 16	)! !!LGitBlameFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_blame_first_parent	^ self basicNew		value: 16;		yourself! !!LGitBlameFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_blame_normal	^ self basicNew		value: 0;		yourself! !!LGitBlameFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_blame_track_copies_any_commit_copies	^ self basicNew		value: 8;		yourself! !!LGitBlameFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_blame_track_copies_same_commit_copies	^ self basicNew		value: 4;		yourself! !!LGitBlameFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_blame_track_copies_same_commit_moves	^ self basicNew		value: 2;		yourself! !!LGitBlameFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_blame_track_copies_same_file	^ self basicNew		value: 1;		yourself! !!LGitBranchTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_BRANCH_LOCAL 1	GIT_BRANCH_REMOTE 2	GIT_BRANCH_ALL 3)! !!LGitBranchTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_branch_all	^ self basicNew		value: 3;		yourself! !!LGitBranchTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_branch_local	^ self basicNew		value: 1;		yourself! !!LGitBranchTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_branch_remote	^ self basicNew		value: 2;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_CHECKOUT_NOTIFY_NONE 0	GIT_CHECKOUT_NOTIFY_CONFLICT 1	GIT_CHECKOUT_NOTIFY_DIRTY 2	GIT_CHECKOUT_NOTIFY_UPDATED 4	GIT_CHECKOUT_NOTIFY_UNTRACKED 8	GIT_CHECKOUT_NOTIFY_IGNORED 16	GIT_CHECKOUT_NOTIFY_ALL 65535)! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_notify_all	^ self basicNew		value: 65535;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_notify_conflict	^ self basicNew		value: 1;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_notify_dirty	^ self basicNew		value: 2;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_notify_ignored	^ self basicNew		value: 16;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_notify_none	^ self basicNew		value: 0;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_notify_untracked	^ self basicNew		value: 8;		yourself! !!LGitCheckoutNotifyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_notify_updated	^ self basicNew		value: 4;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'enum description' stamp: ' 7/24/2017 12:50:03'!enumDecl	^ #(		GIT_CHECKOUT_NONE  0 "< default is a dry run, no actual updates "		" Allow safe updates that cannot overwrite uncommitted data "		GIT_CHECKOUT_SAFE  "1 bitShift: 0" 1		" Allow all updates to force working directory to look like index "		GIT_CHECKOUT_FORCE  "1 bitShift: 1" 2		" Allow checkout to recreate missing files "		GIT_CHECKOUT_RECREATE_MISSING  "1 bitShift: 2" 4		" Allow checkout to make safe updates even if conflicts are found "		GIT_CHECKOUT_ALLOW_CONFLICTS  "1 bitShift: 4" 16		" Remove untracked files not in index (that are not ignored) "		GIT_CHECKOUT_REMOVE_UNTRACKED  "1 bitShift: 5" 32		" Remove ignored files not in index "		GIT_CHECKOUT_REMOVE_IGNORED  "1 bitShift: 6" 64		" Only update existing files, don't create new ones "		GIT_CHECKOUT_UPDATE_ONLY  "1 bitShift: 7" 128		"		 * Normally checkout updates index entries as it goes; this stops that.		 * Implies `GIT_CHECKOUT_DONT_WRITE_INDEX`.		 "		GIT_CHECKOUT_DONT_UPDATE_INDEX  "1 bitShift: 8" 256		" Don't refresh index/config/etc before doing checkout "		GIT_CHECKOUT_NO_REFRESH  "1 bitShift: 9" 512		" Allow checkout to skip unmerged files "		GIT_CHECKOUT_SKIP_UNMERGED  "1 bitShift: 10" 1024		" For unmerged files, checkout stage 2 from index "		GIT_CHECKOUT_USE_OURS  "1 bitShift: 11" 2048		" For unmerged files, checkout stage 3 from index "		GIT_CHECKOUT_USE_THEIRS  "1 bitShift: 12" 4096		" Treat pathspec as simple list of exact match file paths "		GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH  "1 bitShift: 13" 8192		" Ignore directories in use, they will be left empty "		GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES  "1 bitShift: 18" 262144		" Don't overwrite ignored files that exist in the checkout target "		GIT_CHECKOUT_DONT_OVERWRITE_IGNORED  "1 bitShift: 19" 524288		" Write normal merge files for conflicts "		GIT_CHECKOUT_CONFLICT_STYLE_MERGE  "1 bitShift: 20" 1048576		" Include common ancestor data in diff3 format files for conflicts "		GIT_CHECKOUT_CONFLICT_STYLE_DIFF3  "1 bitShift: 21" 2097152		" Don't overwrite existing files or folders "		GIT_CHECKOUT_DONT_REMOVE_EXISTING  "1 bitShift: 22" 4194304		" Normally checkout writes the index upon completion; this prevents that. "		GIT_CHECKOUT_DONT_WRITE_INDEX  "1 bitShift: 23" 8388608		"		 * THE FOLLOWING OPTIONS ARE NOT YET IMPLEMENTED		 "		" Recursively checkout submodules with same options (NOT IMPLEMENTED) "		GIT_CHECKOUT_UPDATE_SUBMODULES  "1 bitShift: 16" 65536		" Recursively checkout submodules if HEAD moved in super repo (NOT IMPLEMENTED) "		GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED  "1 bitShift: 17" 131072)! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_allow_conflicts	^ self basicNew		value: 16;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_conflict_style_diff3	^ self basicNew		value: 2097152;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_conflict_style_merge	^ self basicNew		value: 1048576;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_disable_pathspec_match	^ self basicNew		value: 8192;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_dont_overwrite_ignored	^ self basicNew		value: 524288;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_dont_remove_existing	^ self basicNew		value: 4194304;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_dont_update_index	^ self basicNew		value: 256;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_dont_write_index	^ self basicNew		value: 8388608;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_force	^ self basicNew		value: 2;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_no_refresh	^ self basicNew		value: 512;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_none	^ self basicNew		value: 0;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_recreate_missing	^ self basicNew		value: 4;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_remove_ignored	^ self basicNew		value: 64;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_remove_untracked	^ self basicNew		value: 32;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_safe	^ self basicNew		value: 1;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_safe_create	^ self basicNew		value: 2;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_skip_locked_directories	^ self basicNew		value: 262144;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_skip_unmerged	^ self basicNew		value: 1024;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_update_only	^ self basicNew		value: 128;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_update_submodules	^ self basicNew		value: 65536;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_update_submodules_if_changed	^ self basicNew		value: 131072;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_use_ours	^ self basicNew		value: 2048;		yourself! !!LGitCheckoutStrategyEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_use_theirs	^ self basicNew		value: 4096;		yourself! !!LGitCloneLocalTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^ #(			GIT_CLONE_LOCAL_AUTO 0			GIT_CLONE_LOCAL 1			GIT_CLONE_NO_LOCAL 2			GIT_CLONE_LOCAL_NO_LINKS 3		)! !!LGitCloneLocalTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_clone_local	^ self basicNew		value: 1;		yourself! !!LGitCloneLocalTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_clone_local_auto	^ self basicNew		value: 0;		yourself! !!LGitCloneLocalTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_clone_local_no_links	^ self basicNew		value: 3;		yourself! !!LGitCloneLocalTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_clone_no_local	^ self basicNew		value: 2;		yourself! !!LGitCredentialsTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_CREDTYPE_USERPASS_PLAINTEXT 1	GIT_CREDTYPE_SSH_KEY 2	GIT_CREDTYPE_SSH_CUSTOM 4	GIT_CREDTYPE_DEFAULT 8)! !!LGitCredentialsTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_credtype_default	^ self basicNew		value: 8;		yourself! !!LGitCredentialsTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_credtype_ssh_custom	^ self basicNew		value: 4;		yourself! !!LGitCredentialsTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_credtype_ssh_key	^ self basicNew		value: 2;		yourself! !!LGitCredentialsTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_credtype_userpass_plaintext	^ self basicNew		value: 1;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_DELTA_UNMODIFIED 0 "no changes"	GIT_DELTA_ADDED 1 "entry does not exist in old version"	GIT_DELTA_DELETED 2 "entry does not exist in new version"	GIT_DELTA_MODIFIED 3 "entry content changed between old and new"	GIT_DELTA_RENAMED 4 "entry was renamed between old and new"	GIT_DELTA_COPIED 5 "entry was copied from another old entry"	GIT_DELTA_IGNORED 6 "entry is ignored item in workdir"	GIT_DELTA_UNTRACKED 7 "entry is untracked item in workdir"	GIT_DELTA_TYPECHANGE 8 "type of entry changed between old and new"	GIT_DELTA_UNREADABLE 9 "entry is unreadable"	GIT_DELTA_CONFLICTED 10 "< entry in the index is conflicted")! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_delta_added	^ self basicNew		value: 1;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_delta_conflicted	^ self basicNew		value: 10;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_delta_copied	^ self basicNew		value: 5;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_delta_deleted	^ self basicNew		value: 2;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_delta_ignored	^ self basicNew		value: 6;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_delta_modified	^ self basicNew		value: 3;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_delta_renamed	^ self basicNew		value: 4;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_delta_typechange	^ self basicNew		value: 8;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_delta_unmodified	^ self basicNew		value: 0;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_delta_unreadable	^ self basicNew		value: 9;		yourself! !!LGitDeltaTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_delta_untracked	^ self basicNew		value: 7;		yourself! !!LGitDiffBinaryTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(		" There is no binary delta. "		GIT_DIFF_BINARY_NONE 0		" The binary data is the literal contents of the file. "		GIT_DIFF_BINARY_LITERAL 1		" The binary data is the delta from one side to the other. "		GIT_DIFF_BINARY_DELTA 2	)! !!LGitDiffBinaryTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_binary_delta	^ self basicNew		value: 2;		yourself! !!LGitDiffBinaryTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_binary_literal	^ self basicNew		value: 1;		yourself! !!LGitDiffBinaryTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_binary_none	^ self basicNew		value: 0;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	<todo: 'enum defines 0 twice (one commented out). Use second enum?'>	^#(	" Obey `diff.renames`. Overridden by any other GIT_DIFF_FIND_... flag. "	GIT_DIFF_FIND_BY_CONFIG 0	" Look for renames? (`--find-renames`) "	GIT_DIFF_FIND_RENAMES 1	" Consider old side of MODIFIED for renames? (`--break-rewrites=N`) "	GIT_DIFF_FIND_RENAMES_FROM_REWRITES 2	" Look for copies? (a la `--find-copies`). "	GIT_DIFF_FIND_COPIES 4	" Consider UNMODIFIED as copy sources? (`--find-copies-harder`).	 *	 * For this to work correctly use GIT_DIFF_INCLUDE_UNMODIFIED when	 * the initial `git_diff` is being generated.	 "	GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED 8	" Mark significant rewrites for split (`--break-rewrites=/M`) "	GIT_DIFF_FIND_REWRITES 16	" Actually split large rewrites into delete/add pairs "	GIT_DIFF_BREAK_REWRITES 32	" Mark rewrites for split and break into delete/add pairs "	GIT_DIFF_FIND_AND_BREAK_REWRITES 48	" Find renames/copies for UNTRACKED items in working directory.	 *	 * For this to work correctly use GIT_DIFF_INCLUDE_UNTRACKED when the	 * initial `git_diff` is being generated (and obviously the diff must	 * be against the working directory for this to make sense).	 "	GIT_DIFF_FIND_FOR_UNTRACKED 64	" Turn on all finding features. "	GIT_DIFF_FIND_ALL 255	" Measure similarity ignoring leading whitespace (default) "	"GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE 0"	" Measure similarity ignoring all whitespace "	GIT_DIFF_FIND_IGNORE_WHITESPACE 4096	" Measure similarity including all data "	GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE 8192	" Measure similarity only by comparing SHAs (fast and cheap) "	GIT_DIFF_FIND_EXACT_MATCH_ONLY 16384	" Do not break rewrites unless they contribute to a rename.	 *	 * Normally GIT_DIFF_FIND_AND_BREAK_REWRITES will measure the self-	 * similarity of modified files and split the ones that have changed a	 * lot into a DELETE / ADD pair.  Then the sides of that pair will be	 * considered candidates for rename and copy detection.	 *	 * If you add this flag in and the split pair is *not* used for an	 * actual rename or copy then the modified record will be restored to	 * a regular MODIFIED record instead of being split.	 "	GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY 32768	" Remove any UNMODIFIED deltas after find_similar is done.	 *	 * Using GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED to emulate the	 * --find-copies-harder behavior requires building a diff with the	 * GIT_DIFF_INCLUDE_UNMODIFIED flag.  If you do not want UNMODIFIED	 * records in the final result pass this flag to have them removed.	 "	GIT_DIFF_FIND_REMOVE_UNMODIFIED 65536	)! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_break_rewrites	^ self basicNew		value: 32;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_break_rewrites_for_renames_only	^ self basicNew		value: 32768;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_all	^ self basicNew		value: 255;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_and_break_rewrites	^ self basicNew		value: 48;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_by_config	^ self basicNew		value: 0;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_copies	^ self basicNew		value: 4;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_copies_from_unmodified	^ self basicNew		value: 8;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_dont_ignore_whitespace	^ self basicNew		value: 8192;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_exact_match_only	^ self basicNew		value: 16384;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_for_untracked	^ self basicNew		value: 64;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_ignore_whitespace	^ self basicNew		value: 4096;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_remove_unmodified	^ self basicNew		value: 65536;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_renames	^ self basicNew		value: 1;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_renames_from_rewrites	^ self basicNew		value: 2;		yourself! !!LGitDiffFindTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_rewrites	^ self basicNew		value: 16;		yourself! !!LGitDiffFlagTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_DIFF_FLAG_BINARY 0 "file(s) treated as binary data"	GIT_DIFF_FLAG_NOT_BINARY 1 "file(s) treated as text data"	GIT_DIFF_FLAG_VALID_ID  2 "`id` value is known correct"	)! !!LGitDiffFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_flag_binary	^ self basicNew		value: 0;		yourself! !!LGitDiffFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_flag_not_binary	^ self basicNew		value: 1;		yourself! !!LGitDiffFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_flag_valid_id	^ self basicNew		value: 2;		yourself! !!LGitDiffFormatTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_DIFF_FORMAT_PATCH        1 "full git diff"	GIT_DIFF_FORMAT_PATCH_HEADER 2 "just the file headers of patch"	GIT_DIFF_FORMAT_RAW          3 "like git diff --raw"	GIT_DIFF_FORMAT_NAME_ONLY    4 "like git diff --name-only"	GIT_DIFF_FORMAT_NAME_STATUS  5 "like git diff --name-status"	)! !!LGitDiffFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_format_name_only	^ self basicNew		value: 4;		yourself! !!LGitDiffFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_format_name_status	^ self basicNew		value: 5;		yourself! !!LGitDiffFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_format_patch	^ self basicNew		value: 1;		yourself! !!LGitDiffFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_format_patch_header	^ self basicNew		value: 2;		yourself! !!LGitDiffFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_format_raw	^ self basicNew		value: 3;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^{	 "These values will be sent to `git_diff_line_cb` along with the line"	#GIT_DIFF_LINE_CONTEXT.   '$ '.	#GIT_DIFF_LINE_ADDITION.  '$+'.	#GIT_DIFF_LINE_DELETION.  '$-'.	#GIT_DIFF_LINE_CONTEXT_EOFNL. '$='."Both files have no LF at end"	#GIT_DIFF_LINE_ADD_EOFNL. '$>'.    "Old has no LF at end new does"	#GIT_DIFF_LINE_DEL_EOFNL. '$<'.    "Old has LF at end new does not"	"The following values will only be sent to a `git_diff_line_cb` when	 * the content of a diff is being formatted through `git_diff_print`.	"	#GIT_DIFF_LINE_FILE_HDR.  '$F'.	#GIT_DIFF_LINE_HUNK_HDR.  '$H'.	#GIT_DIFF_LINE_BINARY.    '$B' "For 'Binary files x and y differ'"	}! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_line_add_eofnl	^ self basicNew		value: $>;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_line_addition	^ self basicNew		value: $+;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_line_binary	^ self basicNew		value: $B;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_line_context	^ self basicNew		value: $ ;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_line_context_eofnl	^ self basicNew		value: $=;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_line_del_eofnl	^ self basicNew		value: $<;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_line_deletion	^ self basicNew		value: $-;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_line_file_hdr	^ self basicNew		value: $F;		yourself! !!LGitDiffLineTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_line_hunk_hdr	^ self basicNew		value: $H;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	"Normal diff, the default"	GIT_DIFF_NORMAL 0	"	 * Options controlling which files will be in the diff	"	"Reverse the sides of the diff"	GIT_DIFF_REVERSE 1	"Include ignored files in the diff"	GIT_DIFF_INCLUDE_IGNORED 2	"Even with GIT_DIFF_INCLUDE_IGNORED, an entire ignored directory	 *  will be marked with only a single entry in the diff; this flag	 *  adds all files under the directory as IGNORED entries, too.	"	GIT_DIFF_RECURSE_IGNORED_DIRS 4	"Include untracked files in the diff"	GIT_DIFF_INCLUDE_UNTRACKED 8	"Even with GIT_DIFF_INCLUDE_UNTRACKED, an entire untracked	 *  directory will be marked with only a single entry in the diff	 *  (a la what core Git does in `git status`); this flag adds *all*	 *  files under untracked directories as UNTRACKED entries, too.	"	GIT_DIFF_RECURSE_UNTRACKED_DIRS 16	"Include unmodified files in the diff"	GIT_DIFF_INCLUDE_UNMODIFIED 32	"Normally, a type change between files will be converted into a	 *  DELETED record for the old and an ADDED record for the new; this	 *  options enabled the generation of TYPECHANGE delta records.	"	GIT_DIFF_INCLUDE_TYPECHANGE 64	"Even with GIT_DIFF_INCLUDE_TYPECHANGE, blob->tree changes still	 *  generally show as a DELETED blob.  This flag tries to correctly	 *  label blob->tree transitions as TYPECHANGE records with new_file's	 *  mode set to tree.  Note: the tree SHA will not be available.	"	GIT_DIFF_INCLUDE_TYPECHANGE_TREES 128	"Ignore file mode changes"	GIT_DIFF_IGNORE_FILEMODE 256	"Treat all submodules as unmodified"	GIT_DIFF_IGNORE_SUBMODULES 512	"Use case insensitive filename comparisons"	GIT_DIFF_IGNORE_CASE 1024	"If the pathspec is set in the diff options, this flags means to	 *  apply it as an exact match instead of as an fnmatch pattern.	"	GIT_DIFF_DISABLE_PATHSPEC_MATCH 4096	"Disable updating of the `binary` flag in delta records.  This is	 *  useful when iterating over a diff if you don't need hunk and data	 *  callbacks and want to avoid having to load file completely.	"	GIT_DIFF_SKIP_BINARY_CHECK 8192	"When diff finds an untracked directory, to match the behavior of	 *  core Git, it scans the contents for IGNORED and UNTRACKED files.	 *  If *all* contents are IGNORED, then the directory is IGNORED; if	 *  any contents are not IGNORED, then the directory is UNTRACKED.	 *  This is extra work that may not matter in many cases.  This flag	 *  turns off that scan and immediately labels an untracked directory	 *  as UNTRACKED (changing the behavior to not match core Git).	"	GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS 16384	"When diff finds a file in the working directory with stat	 * information different from the index, but the OID ends up being the	 * same, write the correct stat information into the index.  Note:	 * without this flag, diff will always leave the index untouched.	"	GIT_DIFF_UPDATE_INDEX 32768	"Include unreadable files in the diff"	GIT_DIFF_INCLUDE_UNREADABLE 65536		"Include unreadable files in the diff"	GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED 131072	"	 * Options controlling how output will be generated	"	"Treat all files as text, disabling binary attributes & detection"	GIT_DIFF_FORCE_TEXT 1048576	"Treat all files as binary, disabling text diffs"	GIT_DIFF_FORCE_BINARY 2097152	"Ignore all whitespace"	GIT_DIFF_IGNORE_WHITESPACE 4194304	"Ignore changes in amount of whitespace"	GIT_DIFF_IGNORE_WHITESPACE_CHANGE 8388608	"Ignore whitespace at end of line"	GIT_DIFF_IGNORE_WHITESPACE_EOL 16777216	"When generating patch text, include the content of untracked	 *  files.  This automatically turns on GIT_DIFF_INCLUDE_UNTRACKED but	 *  it does not turn on GIT_DIFF_RECURSE_UNTRACKED_DIRS.  Add that	 *  flag if you want the content of every single UNTRACKED file.	"	GIT_DIFF_SHOW_UNTRACKED_CONTENT 33554432	"When generating output, include the names of unmodified files if	 *  they are included in the git_diff.  Normally these are skipped in	 *  the formats that list files (e.g. name-only, name-status, raw).	 *  Even with this, these will not be included in patch format.	"	GIT_DIFF_SHOW_UNMODIFIED 67108864	"Use the 'patience diff' algorithm"	GIT_DIFF_PATIENCE 268435456	"Take extra time to find minimal diff"	GIT_DIFF_MINIMAL 536870912	"Include the necessary deflate / delta information so that `git-apply`	 *  can apply given diff information to binary files.	"	GIT_DIFF_SHOW_BINARY 1073741824	)! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_disable_pathspec_match	^ self basicNew		value: 4096;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_enable_fast_untracked_dirs	^ self basicNew		value: 16384;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_force_binary	^ self basicNew		value: 2097152;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_force_text	^ self basicNew		value: 1048576;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_ignore_case	^ self basicNew		value: 1024;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_ignore_filemode	^ self basicNew		value: 256;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_ignore_submodules	^ self basicNew		value: 512;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_ignore_whitespace	^ self basicNew		value: 4194304;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_ignore_whitespace_change	^ self basicNew		value: 8388608;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_ignore_whitespace_eol	^ self basicNew		value: 16777216;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_include_ignored	^ self basicNew		value: 2;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_include_typechange	^ self basicNew		value: 64;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_include_typechange_trees	^ self basicNew		value: 128;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_include_unmodified	^ self basicNew		value: 32;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_include_unreadable	^ self basicNew		value: 65536;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_include_unreadable_as_untracked	^ self basicNew		value: 131072;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_include_untracked	^ self basicNew		value: 8;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_minimal	^ self basicNew		value: 536870912;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_normal	^ self basicNew		value: 0;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_patience	^ self basicNew		value: 268435456;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_recurse_ignored_dirs	^ self basicNew		value: 4;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_recurse_untracked_dirs	^ self basicNew		value: 16;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_reverse	^ self basicNew		value: 1;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_show_binary	^ self basicNew		value: 1073741824;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_show_unmodified	^ self basicNew		value: 67108864;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_show_untracked_content	^ self basicNew		value: 33554432;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_skip_binary_check	^ self basicNew		value: 8192;		yourself! !!LGitDiffOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_update_index	^ self basicNew		value: 32768;		yourself! !!LGitDiffStatsFormatTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	"No stats"	GIT_DIFF_STATS_NONE 0	"Full statistics equivalent of `--stat`"	GIT_DIFF_STATS_FULL 1	"Short statistics equivalent of `--shortstat`"	GIT_DIFF_STATS_SHORT 2	"Number statistics equivalent of `--numstat`"	GIT_DIFF_STATS_NUMBER 4	"Extended header information such as creations renames and mode changes equivalent of `--summary`"	GIT_DIFF_STATS_INCLUDE_SUMMARY 8	)! !!LGitDiffStatsFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_stats_full	^ self basicNew		value: 1;		yourself! !!LGitDiffStatsFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_stats_include_summary	^ self basicNew		value: 8;		yourself! !!LGitDiffStatsFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_stats_none	^ self basicNew		value: 0;		yourself! !!LGitDiffStatsFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_stats_number	^ self basicNew		value: 4;		yourself! !!LGitDiffStatsFormatTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_stats_short	^ self basicNew		value: 2;		yourself! !!LGitDirectionEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_DIRECTION_FETCH 0	GIT_DIRECTION_PUSH 1)! !!LGitDirectionEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_direction_fetch	^ self basicNew		value: 0;		yourself! !!LGitDirectionEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_direction_push	^ self basicNew		value: 1;		yourself! !!LGitErrorTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^ #(		GITERR_NONE 0		GITERR_NOMEMORY		1		GITERR_OS				2		GITERR_INVALID		3			GITERR_REFERENCE		4		GITERR_ZLIB			5		GITERR_REPOSITORY	6		GITERR_CONFIG	7		GITERR_REGEX	8		GITERR_ODB	9		GITERR_INDEX			10		GITERR_OBJECT			11		GITERR_NET				12		GITERR_TAG			13		GITERR_TREE			14		GITERR_INDEXER		15		GITERR_SSL				16		GITERR_SUBMODULE	17		GITERR_THREAD		18		GITERR_STASH			19		GITERR_CHECKOUT		20		GITERR_FETCHHEAD	21		GITERR_MERGE			22		GITERR_SSH	23		GITERR_FILTER 24		GITERR_REVERT	25		GITERR_CALLBACK	26		GITERR_CHERRYPICK	27		GITERR_DESCRIBE	28		GITERR_REBASE	29		GITERR_FILESYSTEM	30)! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_callback	^ self basicNew		value: 26;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_checkout	^ self basicNew		value: 20;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_cherrypick	^ self basicNew		value: 27;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_config	^ self basicNew		value: 7;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_describe	^ self basicNew		value: 28;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_fetchhead	^ self basicNew		value: 21;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_filesystem	^ self basicNew		value: 30;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_filter	^ self basicNew		value: 24;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_index	^ self basicNew		value: 10;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_indexer	^ self basicNew		value: 15;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_invalid	^ self basicNew		value: 3;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_merge	^ self basicNew		value: 22;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_net	^ self basicNew		value: 12;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_nomemory	^ self basicNew		value: 1;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_none	^ self basicNew		value: 0;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_object	^ self basicNew		value: 11;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_odb	^ self basicNew		value: 9;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_os	^ self basicNew		value: 2;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_rebase	^ self basicNew		value: 29;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_reference	^ self basicNew		value: 4;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_regex	^ self basicNew		value: 8;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_repository	^ self basicNew		value: 6;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_revert	^ self basicNew		value: 25;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_ssh	^ self basicNew		value: 23;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_ssl	^ self basicNew		value: 16;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_stash	^ self basicNew		value: 19;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_submodule	^ self basicNew		value: 17;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_tag	^ self basicNew		value: 13;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_thread	^ self basicNew		value: 18;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_tree	^ self basicNew		value: 14;		yourself! !!LGitErrorTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!giterr_zlib	^ self basicNew		value: 5;		yourself! !!LGitExternalEnumerationInt32 class methodsFor: 'accessing-defaults' stamp: ' 7/24/2017 12:50:03'!defaultRepresentationType	^ FFIInt32 new! !!LGitObjectTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_OBJ_ANY -2	GIT_OBJ_BAD -1	GIT_OBJ__EXT1 0	GIT_OBJ_COMMIT 1	GIT_OBJ_TREE 2	GIT_OBJ_BLOB 3	GIT_OBJ_TAG 4	GIT_OBJ__EXT2 5	GIT_OBJ_OFS_DELTA 6	GIT_OBJ_REF_DELTA 7)! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_obj__ext1	^ self basicNew		value: 0;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_obj__ext2	^ self basicNew		value: 5;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_obj_any	^ self basicNew		value: -2;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_obj_bad	^ self basicNew		value: -1;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_obj_blob	^ self basicNew		value: 3;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_obj_commit	^ self basicNew		value: 1;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_obj_ofs_delta	^ self basicNew		value: 6;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_obj_ref_delta	^ self basicNew		value: 7;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_obj_tag	^ self basicNew		value: 4;		yourself! !!LGitObjectTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_obj_tree	^ self basicNew		value: 2;		yourself! !!LGitReturnCodeEnum class methodsFor: 'enum description' stamp: ' 7/24/2017 12:50:03'!enumDecl	^ #(			GIT_OK           0		"< No error "			GIT_ERROR       -1		"< Generic error "			GIT_ENOTFOUND   -3		"< Requested object could not be found "			GIT_EEXISTS     -4		"< Object exists preventing operation "			GIT_EAMBIGUOUS  -5		"< More than one object matches "			GIT_EBUFS       -6		"< Output buffer too short to hold data "			"GIT_EUSER is a special error that is never generated by libgit2			 * code.  You can return it from a callback (e.g to stop an iteration)			 * to know that it was generated by the callback and not by libgit2.			 "			GIT_EUSER       -7			GIT_EBAREREPO         -8	"< Operation not allowed on bare repository "			GIT_EUNBORNBRANCH     -9	"< HEAD refers to branch with no commits "			GIT_EUNMERGED        -10	"< Merge in progress prevented operation "			GIT_ENONFASTFORWARD  -11	"< Reference was not fast-forwardable "			GIT_EINVALIDSPEC     -12	"< Name/ref spec was not in a valid format "			GIT_ECONFLICT        -13	"< Checkout conflicts prevented operation "			GIT_ELOCKED          -14	"< Lock file prevented operation "			GIT_EMODIFIED        -15	"< Reference value does not match expected "			GIT_EAUTH            -16      "< Authentication error "			GIT_ECERTIFICATE     -17      "< Server certificate is invalid "			GIT_EAPPLIED         -18	"< Patch/merge has already been applied "			GIT_EPEEL            -19      "< The requested peel operation is not possible "			GIT_EEOF             -20      "< Unexpected EOF "			GIT_EINVALID         -21      "< Invalid operation or input "			GIT_EUNCOMMITTED     -22	"< Uncommitted changes in index prevented operation "			GIT_PASSTHROUGH      -30	"< Internal only "			GIT_ITEROVER         -31	"< Signals end of iteration with iterator "		)! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_eambiguous	^ self basicNew		value: -5;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_eapplied	^ self basicNew		value: -18;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_eauth	^ self basicNew		value: -16;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_ebarerepo	^ self basicNew		value: -8;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_ebufs	^ self basicNew		value: -6;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_ecertificate	^ self basicNew		value: -17;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_econflict	^ self basicNew		value: -13;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_eeof	^ self basicNew		value: -20;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_eexists	^ self basicNew		value: -4;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_einvalid	^ self basicNew		value: -21;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_einvalidspec	^ self basicNew		value: -12;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_elocked	^ self basicNew		value: -14;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_emodified	^ self basicNew		value: -15;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_enonfastforward	^ self basicNew		value: -11;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_enotfound	^ self basicNew		value: -3;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_epeel	^ self basicNew		value: -19;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_error	^ self basicNew		value: -1;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_eunbornbranch	^ self basicNew		value: -9;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_euncommitted	^ self basicNew		value: -22;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_eunmerged	^ self basicNew		value: -10;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_euser	^ self basicNew		value: -7;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_iterover	^ self basicNew		value: -31;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_ok	^ self basicNew		value: 0;		yourself! !!LGitReturnCodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_passthrough	^ self basicNew		value: -30;		yourself! !!LGitReturnCodeEnum class methodsFor: 'handlers' stamp: ' 7/24/2017 12:50:03'!handlers	^ handlers ifNil: [ handlers := self setUpHandlers ]! !!LGitReturnCodeEnum class methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!setUpHandlers	^ (self declaration associations collect: [ :nameToValue |		nameToValue key -> (LGitCallReturnHandler for: (self perform: nameToValue key)) ]) asDictionary! !!LGitReturnCodeEnum methodsFor: 'handling' stamp: ' 7/24/2017 12:50:03'!handleLGitReturnCode	| handler |	self isOk		ifTrue: [ ^ self ].	handler := self handlers		at: self symbol		ifAbsent: [ LGitNoReturnCodeHandlerDefined signalWith: self ].	^ handler isError		ifTrue: [ handler signalWith: LGitError last ]		ifFalse: [ self ]! !!LGitReturnCodeEnum methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!handlers	^ self class handlers! !!LGitReturnCodeEnum methodsFor: 'as yet unclassified' stamp: ' 7/24/2017 12:50:03'!isOk	^ value = 0! !!LGitExternalEnumerationUInt32 class methodsFor: 'converting' stamp: ' 7/24/2017 12:50:03'!asExternalTypeOn: generator	^ FFIExternalEnumerationType 		objectClass: self 		representationType: self representationType! !!LGitExternalEnumerationUInt32 class methodsFor: 'class initialization' stamp: ' 7/24/2017 12:50:03'!buildDeclaration	| dictionary |	self removeOldAccessors.	dictionary := self literalDeclaration.	self compileAccessorsFrom: dictionary.		^ declaration := dictionary! !!LGitExternalEnumerationUInt32 class methodsFor: 'class initialization' stamp: ' 7/24/2017 12:50:03'!compileAccessorsFrom: aDictionary	aDictionary keysAndValuesDo: [ :symbol :value |		self class			compile: (String streamContents: [ :stream |				stream					nextPutAll: symbol asString; cr; tab;					nextPutAll: '^ self basicNew'; cr; tab; tab;					nextPutAll: 'value: ';					nextPutAll: value asString;					nextPutAll: ';'; cr; tab; tab;					nextPutAll: 'yourself' ])			classified: 'accessing-values' ]! !!LGitExternalEnumerationUInt32 class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!declaration	^ declaration ifNil: [ declaration := self literalDeclaration ]! !!LGitExternalEnumerationUInt32 class methodsFor: 'accessing-defaults' stamp: ' 7/24/2017 12:50:03'!defaultRepresentationType	^ FFIUInt32 new! !!LGitExternalEnumerationUInt32 class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#()! !!LGitExternalEnumerationUInt32 class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!fromInteger: anInteger	^self basicNew		value: anInteger;		yourself! !!LGitExternalEnumerationUInt32 class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!includes: aSymbol	^ self declaration includesKey: aSymbol! !!LGitExternalEnumerationUInt32 class methodsFor: 'class initialization' stamp: ' 7/24/2017 12:50:03'!initialize	declaration := nil.	representationType := nil.! !!LGitExternalEnumerationUInt32 class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!literalDeclaration	| dictionary |	dictionary := self enumDecl in: [ :decl |		decl isDictionary			ifTrue: [ decl ]			ifFalse: [ Dictionary newFromPairs: decl ] ].			self makeSelectorsLegalIn: dictionary.	^ dictionary! !!LGitExternalEnumerationUInt32 class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!makeSelectorsLegalIn: aDictionary	aDictionary associationsDo: [ :nameToValue |		| selector |		selector := nameToValue key asLowercase asSymbol.		nameToValue key: selector ]! !!LGitExternalEnumerationUInt32 class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!new	^ self shouldNotImplement ! !!LGitExternalEnumerationUInt32 class methodsFor: 'class initialization' stamp: ' 7/24/2017 12:50:03'!removeOldAccessors	declaration ifNil: [ ^ self ].		declaration keys do: [ :selector |		self class removeSelector: selector ]! !!LGitExternalEnumerationUInt32 class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!representationType	^ representationType ifNil: [ representationType := self defaultRepresentationType ]! !!LGitExternalEnumerationUInt32 methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!= anEnumInst	^ self class == anEnumInst class and: [		self value = anEnumInst value ]! !!LGitExternalEnumerationUInt32 methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!hash	^ self className hash bitXor: self value hash! !!LGitExternalEnumerationUInt32 methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isPartOfBitFlag: anInteger	"A bit flag may be composed of several values, where every bit	represents the state of one flag. Therefore, a 2 bit value can	represent 2 different flags, for instance. The #bitAnd: operation	will mask all other flags.		For some reason the libgit2 folks thought it would make sense to	use flags of value 0 in bit flags. That forces one to check for zero	(on the entire word)	explicitly. WTF."	^ self value isZero		ifTrue: [ anInteger isZero ]		ifFalse: [ (self value bitAnd: anInteger) = self value ]! !!LGitExternalEnumerationUInt32 methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!printOn: stream	super printOn: stream.	value isInteger 		" temp: due to a uffi bug (?) sometimes value == self"		ifFalse: [ ^ self ].	stream nextPut: $(;		nextPutAll: self symbol printString;		nextPutAll: ' [';		nextPutAll: self value asString;		nextPut: $];		nextPut: $)! !!LGitExternalEnumerationUInt32 methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!symbol	<todo: 'now we can handle enums which define the same value multiple times, but in case of this handler, we don''t know which name we need to associate with the return value. This is basically random...'>	^ self class declaration		keyAtValue: self value		ifAbsent: [ nil ]! !!LGitExternalEnumerationUInt32 methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!value	^ value! !!LGitExternalEnumerationUInt32 methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!value: anInteger	value := anInteger ! !!LGitFetchPruneTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^ #(		"		 * Use the setting from the configuration		 "		GIT_FETCH_PRUNE_UNSPECIFIED 0		"		 * Force pruning on		 "		GIT_FETCH_PRUNE 1		"		 * Force pruning off		 "		GIT_FETCH_NO_PRUNE 2	)! !!LGitFetchPruneTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_fetch_no_prune	^ self basicNew		value: 2;		yourself! !!LGitFetchPruneTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_fetch_prune	^ self basicNew		value: 1;		yourself! !!LGitFetchPruneTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_fetch_prune_unspecified	^ self basicNew		value: 0;		yourself! !!LGitFilemodeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_FILEMODE_NEW 0	GIT_FILEMODE_TREE 16384	GIT_FILEMODE_BLOB 33188	GIT_FILEMODE_BLOB_EXECUTABLE 33261	GIT_FILEMODE_LINK 40960	GIT_FILEMODE_COMMIT 57344)! !!LGitFilemodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_filemode_blob	^ self basicNew		value: 33188;		yourself! !!LGitFilemodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_filemode_blob_executable	^ self basicNew		value: 33261;		yourself! !!LGitFilemodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_filemode_commit	^ self basicNew		value: 57344;		yourself! !!LGitFilemodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_filemode_link	^ self basicNew		value: 40960;		yourself! !!LGitFilemodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_filemode_new	^ self basicNew		value: 0;		yourself! !!LGitFilemodeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_filemode_tree	^ self basicNew		value: 16384;		yourself! !!LGitOpenFlagEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_REPOSITORY_OPEN_NO_SEARCH 1	GIT_REPOSITORY_OPEN_CROSS_FS 2	GIT_REPOSITORY_OPEN_BARE 4)! !!LGitOpenFlagEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_repository_open_bare	^ self basicNew		value: 4;		yourself! !!LGitOpenFlagEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_repository_open_cross_fs	^ self basicNew		value: 2;		yourself! !!LGitOpenFlagEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_repository_open_no_search	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_BLAME_OPTIONS_VERSION_1 1	GIT_CHECKOUT_OPTIONS_VERSION_1 1	GIT_CLONE_OPTIONS_VERSION_1 1	GIT_DIFF_OPTIONS_VERSION_1 1	GIT_DIFF_FIND_OPTIONS_VERSION_1 1	GIT_FETCH_OPTIONS_VERSION_1 1	GIT_PUSH_OPTIONS_VERSION_1 1	)! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_blame_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_checkout_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_clone_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_find_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_diff_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_fetch_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_merge_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitOptionsVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_push_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_PATHSPEC_DEFAULT 0	"forces match to ignore case; otherwise match will use native case sensitivity of platform filesystem"	GIT_PATHSPEC_IGNORE_CASE 1	"forces case sensitive match; otherwise match will use native case sensitivity of platform filesystem"	GIT_PATHSPEC_USE_CASE 2	"disables glob patterns and just uses simple string comparison for matching"	GIT_PATHSPEC_NO_GLOB 4	"means the match functions return error code GIT_ENOTFOUND if no matches are found; otherwise no matches is still success (return 0) but git_pathspec_match_list_entrycount will indicate 0 matches."	GIT_PATHSPEC_NO_MATCH_ERROR 8	"means that the git_pathspec_match_list should track which patterns matched which files so that at the end of the match we can identify patterns that did not match any files."	GIT_PATHSPEC_FIND_FAILURES 16	"means that the git_pathspec_match_list does not need to keep the actual matching filenames. Use this to just test if there were any matches at all or in combination with GIT_PATHSPEC_FIND_FAILURES to validate a pathspec."	GIT_PATHSPEC_FAILURES_ONLY 32)! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_pathspec_default	^ self basicNew		value: 0;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_pathspec_failures_only	^ self basicNew		value: 32;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_pathspec_find_failures	^ self basicNew		value: 16;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_pathspec_ignore_case	^ self basicNew		value: 1;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_pathspec_no_glob	^ self basicNew		value: 4;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_pathspec_no_match_error	^ self basicNew		value: 8;		yourself! !!LGitPathSpecFlagTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_pathspec_use_case	^ self basicNew		value: 2;		yourself! !!LGitProxyTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^ #(	"/**	 * Do not attempt to connect through a proxy	 *	 * If built against libcurl, it itself may attempt to connect	 * to a proxy if the environment variables specify it.	 */"	GIT_PROXY_NONE 0	"/**	 * Try to auto-detect the proxy from the git configuration.	 */"	GIT_PROXY_AUTO 1	"/**	 * Connect via the URL given in the options	 */"	GIT_PROXY_SPECIFIED 2	)! !!LGitProxyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_proxy_auto	^ self basicNew		value: 1;		yourself! !!LGitProxyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_proxy_none	^ self basicNew		value: 0;		yourself! !!LGitProxyTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_proxy_specified	^ self basicNew		value: 2;		yourself! !!LGitPushOptionsVersionEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^ #(			LGIT_PUSH_OPTIONS_VERSION_1 1		)! !!LGitPushOptionsVersionEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!lgit_push_options_version_1	^ self basicNew		value: 1;		yourself! !!LGitReferenceTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_REF_INVALID 0	GIT_REF_OID 1	GIT_REF_SYMBOLIC 2	GIT_REF_LISTALL 3)! !!LGitReferenceTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_ref_invalid	^ self basicNew		value: 0;		yourself! !!LGitReferenceTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_ref_listall	^ self basicNew		value: 3;		yourself! !!LGitReferenceTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_ref_oid	^ self basicNew		value: 1;		yourself! !!LGitReferenceTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_ref_symbolic	^ self basicNew		value: 2;		yourself! !!LGitRemoteAutotagOptionTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^ #(		"		 * Use the setting from the configuration.		 "		GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED 0		"		 * Ask the server for tags pointing to objects we're already		 * downloading.		 "		GIT_REMOTE_DOWNLOAD_TAGS_AUTO 1		"		 * Don't ask for any tags beyond the refspecs.		 "		GIT_REMOTE_DOWNLOAD_TAGS_NONE 2		"		 * Ask for the all the tags.		 "		GIT_REMOTE_DOWNLOAD_TAGS_ALL 3	)! !!LGitRemoteAutotagOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_remote_download_tags_all	^ self basicNew		value: 3;		yourself! !!LGitRemoteAutotagOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_remote_download_tags_auto	^ self basicNew		value: 1;		yourself! !!LGitRemoteAutotagOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_remote_download_tags_none	^ self basicNew		value: 2;		yourself! !!LGitRemoteAutotagOptionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_remote_download_tags_unspecified	^ self basicNew		value: 0;		yourself! !!LGitRemoteCompletionTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_REMOTE_COMPLETION_DOWNLOAD 0	GIT_REMOTE_COMPLETION_INDEXING 1	GIT_REMOTE_COMPLETION_ERROR 2)! !!LGitRemoteCompletionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_remote_completion_download	^ self basicNew		value: 0;		yourself! !!LGitRemoteCompletionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_remote_completion_error	^ self basicNew		value: 2;		yourself! !!LGitRemoteCompletionTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_remote_completion_indexing	^ self basicNew		value: 1;		yourself! !!LGitRevwalkSortTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_SORT_NONE 0	GIT_SORT_TOPOLOGICAL 1	GIT_SORT_TIME 2	GIT_SORT_REVERSE 4	)! !!LGitRevwalkSortTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_sort_none	^ self basicNew		value: 0;		yourself! !!LGitRevwalkSortTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_sort_reverse	^ self basicNew		value: 4;		yourself! !!LGitRevwalkSortTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_sort_time	^ self basicNew		value: 2;		yourself! !!LGitRevwalkSortTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_sort_topological	^ self basicNew		value: 1;		yourself! !!LGitStatusTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(		GIT_STATUS_CURRENT  0		GIT_STATUS_INDEX_NEW         "1 bitShift: 0" 1		GIT_STATUS_INDEX_MODIFIED    "1 bitShift: 1" 2		GIT_STATUS_INDEX_DELETED     "1 bitShift: 2" 4		GIT_STATUS_INDEX_RENAMED     "1 bitShift: 3" 8		GIT_STATUS_INDEX_TYPECHANGE  "1 bitShift: 4" 16		GIT_STATUS_WT_NEW            "1 bitShift: 7" 128		GIT_STATUS_WT_MODIFIED       "1 bitShift: 8" 256		GIT_STATUS_WT_DELETED        "1 bitShift: 9" 512		GIT_STATUS_WT_TYPECHANGE     "1 bitShift: 10" 1024		GIT_STATUS_WT_RENAMED        "1 bitShift: 11" 2048		GIT_STATUS_WT_UNREADABLE     "1 bitShift: 12" 4096		GIT_STATUS_IGNORED           "1 bitShift: 14" 16384		GIT_STATUS_CONFLICTED        "1 bitShift: 15" 32768)! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_conflicted	^ self basicNew		value: 32768;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_current	^ self basicNew		value: 0;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_ignored	^ self basicNew		value: 16384;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_index_deleted	^ self basicNew		value: 4;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_index_modified	^ self basicNew		value: 2;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_index_new	^ self basicNew		value: 1;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_index_renamed	^ self basicNew		value: 8;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_index_typechange	^ self basicNew		value: 16;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_wt_deleted	^ self basicNew		value: 512;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_wt_modified	^ self basicNew		value: 256;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_wt_new	^ self basicNew		value: 128;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_wt_renamed	^ self basicNew		value: 2048;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_wt_typechange	^ self basicNew		value: 1024;		yourself! !!LGitStatusTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_status_wt_unreadable	^ self basicNew		value: 4096;		yourself! !!LGitStructVersionsEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(		GIT_REMOTE_CALLBACKS_VERSION_1 1	)! !!LGitStructVersionsEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_remote_callbacks_version_1	^ self basicNew		value: 1;		yourself! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_SUBMODULE_IGNORE_RESET     -1 "reset to on-disk value"	GIT_SUBMODULE_IGNORE_NONE      1  "any change or untracked == dirty"	GIT_SUBMODULE_IGNORE_UNTRACKED 2  "dirty if tracked files change"	GIT_SUBMODULE_IGNORE_DIRTY     3  "only dirty if HEAD moved"	GIT_SUBMODULE_IGNORE_ALL       4  "never dirty"	GIT_SUBMODULE_IGNORE_DEFAULT   0)! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_submodule_ignore_all	^ self basicNew		value: 4;		yourself! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_submodule_ignore_default	^ self basicNew		value: 0;		yourself! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_submodule_ignore_dirty	^ self basicNew		value: 3;		yourself! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_submodule_ignore_none	^ self basicNew		value: 1;		yourself! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_submodule_ignore_reset	^ self basicNew		value: -1;		yourself! !!LGitSubmoduleIgnoreTypeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_submodule_ignore_untracked	^ self basicNew		value: 2;		yourself! !!LGitTreewalkModeEnum class methodsFor: 'enum declaration' stamp: ' 7/24/2017 12:50:03'!enumDecl	^#(	GIT_TREEWALK_PRE 0	GIT_TREEWALK_POST 1)! !!LGitTreewalkModeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_treewalk_post	^ self basicNew		value: 1;		yourself! !!LGitTreewalkModeEnum class methodsFor: 'accessing-values' stamp: ' 7/24/2017 12:50:03'!git_treewalk_pre	^ self basicNew		value: 0;		yourself! !!LGitFunctionReturn class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!methodSelector: aSymbol value: anObject	^ self new		methodSelector: aSymbol;		value: anObject;		yourself! !!LGitFunctionReturn methodsFor: 'handling' stamp: ' 7/24/2017 12:50:03'!handleLGitReturnCode	^ self value handleLGitReturnCode! !!LGitFunctionReturn methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!methodSelector	^ methodSelector! !!LGitFunctionReturn methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!methodSelector: aSymbol	methodSelector := aSymbol! !!LGitFunctionReturn methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!value	^ value! !!LGitFunctionReturn methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!value: anObject	value := anObject! !!LGitGlobal class methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!checkInitialized	"Make sure that LigGit2 is properly initialized."	self ffiLibrary isInitialized 		ifFalse: [ self ffiLibrary uniqueInstance initializeLibGit2 ]! !!LGitGlobal class methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!runSequence: aBlock	LGitActionSequence value ifNotNil: aBlock.		LGitActionSequence		value: thisContext sender		during: [			self checkInitialized.			aBlock value ]! !!LGitRefSpec class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!fromString: aString	^ self new		initializeFromString: aString;		yourself! !!LGitRefSpec methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!beForced	forced := true! !!LGitRefSpec methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!destination	^ destination ifNil: [ '' ]! !!LGitRefSpec methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!destination: aString	destination := aString! !!LGitRefSpec methodsFor: 'intialization' stamp: ' 7/24/2017 12:50:03'!initializeFromString: aString	<todo: 'use exceptions instead of assertions'>	| stream |	self assert: ('((\+[\w/]+)|([\w/]*))\:[\w/]+' asRegex matches: aString).		stream := aString readStream.	[		(stream peek = $+) ifTrue: [ 			self beForced.			stream next ].		self source: (stream upTo: $:).		self destination: stream upToEnd ] ensure: [ stream close ]! !!LGitRefSpec methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isForced	^ forced ifNil: [ false ]! !!LGitRefSpec methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!printOn: aStream	self isForced ifTrue: [ aStream nextPut: $+ ].	aStream		nextPutAll: self source;		nextPut: $:;		nextPutAll: self destination! !!LGitRefSpec methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!source	^ source ifNil: [ '' ]! !!LGitRefSpec methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!source: aString	source := aString! !!Object methodsFor: '*LibGit-Core-FFI-Handling' stamp: ' 7/24/2017 12:50:03'!handleLGitReturnCode	^ self! !!LGitBlameHunk class methodsFor: 'alignment' stamp: ' 7/24/2017 12:50:03'!byteAlignment	^ 1! !!LGitBlameHunk class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	<hack: 'orig_start_line_number is a uint16_t according to spec. The offset of orig_signature however is 56, not 54 (while the first fields are *not* aligned). To fix that, I changed the type of orig_start_line_number to uint32_t'>	^ #(		#FFIUInt16 lines_in_hunk "is the number of lines in this hunk"		LGitId final_commit_id "is the OID of the commit where this line was last changed."		#FFIUInt16 final_start_line_number "is the 1-based line number where this hunk begins, in the final version of the file"		LGitSignature * final_signature				LGitId orig_commit_id "is the OID of the commit where this hunk was found. This will usually be the same as final_commit_id, except when GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES has been specified."		String orig_path "is the path to the file where this hunk originated, as of the commit specified by orig_commit_id."		#FFIUInt32 orig_start_line_number "is the 1-based line number where this hunk begins in the file named by orig_path in the commit specified by orig_commit_id."		LGitSignature * orig_signature				Boolean boundary "is 1 iff the hunk has been tracked to a boundary commit (the root, or the commit specified in git_blame_options.oldest_commit)"	)! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!boundary	^ self prim_boundary! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!finalCommitId	"prim version doesn't work"	"^ self prim_final_commit_id"		^ LGitId fromHandle: (handle copyFrom: 3 to: 22)! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!finalSignature		^ self prim_final_signature! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!finalStartLineNumber	^ self prim_final_start_line_number! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!numberOfLines	^ self prim_lines_in_hunk! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!originalCommitId	"prim version doesn't work"	"^ self prim_orig_commit_id"		^LGitId fromHandle: (handle copyFrom: 29 to: 48)! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!originalPath	^ self prim_orig_path readString! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!originalSignature		^ self prim_orig_signature! !!LGitBlameHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!originalStartLineNumber	^ self prim_orig_start_line_number! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_boundary	"This method was automatically generated"	^handle booleanAt: OFFSET_PRIM_BOUNDARY! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_boundary: anObject	"This method was automatically generated"	handle booleanAt: OFFSET_PRIM_BOUNDARY put: anObject! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_final_commit_id	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_FINAL_COMMIT_ID length: LGitId byteSize)! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_final_commit_id: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_FINAL_COMMIT_ID put: anObject getHandle length: LGitId byteSize! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_final_signature	"This method was automatically generated"	^LGitSignature fromHandle: (handle pointerAt: OFFSET_PRIM_FINAL_SIGNATURE)! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_final_signature: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_FINAL_SIGNATURE put: anObject getHandle.! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_final_start_line_number	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_FINAL_START_LINE_NUMBER! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_final_start_line_number: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_FINAL_START_LINE_NUMBER put: anObject! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_lines_in_hunk	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_LINES_IN_HUNK! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_lines_in_hunk: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_LINES_IN_HUNK put: anObject! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_orig_commit_id	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_ORIG_COMMIT_ID length: LGitId byteSize)! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_orig_commit_id: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_ORIG_COMMIT_ID put: anObject getHandle length: LGitId byteSize! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_orig_path	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_ORIG_PATH) type: ExternalType char asPointerType! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_orig_path: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_ORIG_PATH put: anObject getHandle.! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_orig_signature	"This method was automatically generated"	^LGitSignature fromHandle: (handle pointerAt: OFFSET_PRIM_ORIG_SIGNATURE)! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_orig_signature: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_ORIG_SIGNATURE put: anObject getHandle.! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_orig_start_line_number	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_ORIG_START_LINE_NUMBER! !!LGitBlameHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_orig_start_line_number: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_ORIG_START_LINE_NUMBER put: anObject! !!LGitBuf class methodsFor: 'field definition' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^ #(		char * ptr;		size_t asize;		size_t size;	)		"self rebuildFieldAccessors"! !!LGitBuf class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!signature_free: handle 	^ self		call: #(void git_buf_free(void *handle))		options: #(  )! !!LGitBuf methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!free	"Free the memory referred to by the git_buf.	Note that this does not free the git_buf itself, just the memory pointed to by buffer->ptr. This 	will not free the memory if it looks like it was not allocated internally, but it will clear the 	buffer back to the empty state."	self class signature_free: handle! !!LGitBuf methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_asize	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_ASIZE! !!LGitBuf methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_asize: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_ASIZE put: anObject! !!LGitBuf methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_ptr	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PTR) type: ExternalType char asPointerType! !!LGitBuf methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_ptr: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PTR put: anObject getHandle.! !!LGitBuf methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_size	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_SIZE! !!LGitBuf methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_size: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_SIZE put: anObject! !!LGitCheckoutPerfData class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^ #(		size_t mkdir_calls;		size_t stat_calls;		size_t chmod_calls;	)! !!LGitCheckoutPerfData methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_chmod_calls	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_CHMOD_CALLS! !!LGitCheckoutPerfData methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_chmod_calls: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_CHMOD_CALLS put: anObject! !!LGitCheckoutPerfData methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_mkdir_calls	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_MKDIR_CALLS! !!LGitCheckoutPerfData methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_mkdir_calls: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_MKDIR_CALLS put: anObject! !!LGitCheckoutPerfData methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_stat_calls	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_STAT_CALLS! !!LGitCheckoutPerfData methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_stat_calls: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_STAT_CALLS put: anObject! !!LGitCredentials class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(	LGitCredentialsTypeEnum credtype;	LGitCredentialsFreeCallout free;	)! !!LGitCredentials methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createWith: aStructure	self subclassResponsibility! !!LGitCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!passphrase	^ passphrase! !!LGitCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!passphrase: aString	passphrase := aString! !!LGitCredentials methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_credtype	"This method was automatically generated"	^LGitCredentialsTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_CREDTYPE)! !!LGitCredentials methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_credtype: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CREDTYPE put: anObject value! !!LGitCredentials methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_free	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_FREE) type: ExternalType void asPointerType! !!LGitCredentials methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_free: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_FREE put: anObject getHandle.! !!LGitCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!username	^ username! !!LGitCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!username: aString	username := aString! !!LGitCredentialsPlaintext class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!createFrom: provider onto: lgitCredentials	| credentials |	[		credentials := self new.		provider providePlaintextCredentialsTo: credentials.		credentials createWith: lgitCredentials.		^ 0	]	on: LGitNoCredentialsProvided do: [ :e | 		LGitError setError: 'Invalid username and/or password provided.'.						^ -1 ]! !!LGitCredentialsPlaintext class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!username: username passphrase: passphrase	^ self new		username: username;		passphrase: passphrase;		yourself! !!LGitCredentialsPlaintext methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createWith: aStructure	<todo: 'use exceptions instead of assertions'>	self assert: self username isEmptyOrNil not.	self assert: self passphrase isEmptyOrNil not.	self withReturnHandlerDo: [ 		self 			cred_userpass_plaintext_new: aStructure			username: self username			password: self passphrase ]! !!LGitCredentialsPlaintext methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!cred_userpass_plaintext_new: out username: usernameString password: password 	^self call: #(		LGitReturnCodeEnum git_cred_userpass_plaintext_new(			LGitCredentials * out, 			String username, 			String password)	) options: #(  )! !!LGitCredentialsPlaintext methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_credtype	"This method was automatically generated"	^LGitCredentialsTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_CREDTYPE)! !!LGitCredentialsPlaintext methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_credtype: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CREDTYPE put: anObject value! !!LGitCredentialsPlaintext methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_free	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_FREE) type: ExternalType void asPointerType! !!LGitCredentialsPlaintext methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_free: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_FREE put: anObject getHandle.! !!LGitCredentialsSSH class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!createFrom: provider onto: lgitCredentials	| credentials |	 	[		credentials := self new.		provider provideSshCredentialsTo: credentials.		credentials createWith: lgitCredentials.		^ 0	]	on: LGitNoCredentialsProvided do: [ 		LGitError setError: 'Invalid ssh keys in provided files.'.				-1 ]! !!LGitCredentialsSSH class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!createFrom: provider username: username onto: lgitCredentials	 ^ self createFrom: provider onto: lgitCredentials! !!LGitCredentialsSSH class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!username: username passphrase: passphrase publicKeyReference: publicKeyFileReference privateKeyReference: privateKeyFileReference	^ self new		username: username;		passphrase: passphrase;		publicKeyReference: publicKeyFileReference;		privateKeyReference: privateKeyFileReference;		yourself! !!LGitCredentialsSSH methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createWith: aStructure	<todo: 'use exceptions instead of assertions'>	self assert: self username isEmptyOrNil not.	self assert: self publicKeyReference exists.	self assert: self privateKeyReference exists.	self withReturnHandlerDo: [ 		self 			cred_ssh_key_new: aStructure			username: self username			publickey: self publicKeyReference fullName			privatekey: self privateKeyReference fullName			passphrase: self passphrase ]! !!LGitCredentialsSSH methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!cred_ssh_key_new: out username: usernameString publickey: publickey privatekey: privatekey passphrase: passphraseString	^self call: 		#(int git_cred_ssh_key_new(			LGitCredentials * out, 			String usernameString, 			String publickey, 			String privatekey, 			String passphraseString)) options: #(  )! !!LGitCredentialsSSH methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!cred_username_new: out username: usernameString	^ self 		call: #(int git_cred_username_new (LGitCredentials * out, String usernameString)) 		options: #()			! !!LGitCredentialsSSH methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_credtype	"This method was automatically generated"	^LGitCredentialsTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_CREDTYPE)! !!LGitCredentialsSSH methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_credtype: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CREDTYPE put: anObject value! !!LGitCredentialsSSH methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_free	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_FREE) type: ExternalType void asPointerType! !!LGitCredentialsSSH methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_free: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_FREE put: anObject getHandle.! !!LGitCredentialsSSH methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!privateKeyReference	^ privateKeyReference! !!LGitCredentialsSSH methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!privateKeyReference: aFileReference	privateKeyReference := aFileReference! !!LGitCredentialsSSH methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!publicKeyReference	^ publicKeyReference! !!LGitCredentialsSSH methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!publicKeyReference: aFileReference	publicKeyReference := aFileReference! !!LGitCredentialsSSH methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!setGitUsernameIn: aStructure	self withReturnHandlerDo: [ 		self cred_username_new: aStructure username: 'git'	]! !!LGitCredentialsSSHAgent class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!createFrom: provider username: username onto: lgitCredentials	| credentials |		[  		credentials := self new.		provider provideSshAgentCredentialsTo: credentials.			credentials createWith: username onto: lgitCredentials.		^ 0 ]	on: LGitNoCredentialsProvided do: [ 		LGitError setError: 'No ssh-agent suitable credentials found.'.		^ -1 ]! !!LGitCredentialsSSHAgent methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createWith: aName onto: aStructure	<todo: 'use exceptions instead of assertions'>	self assert: aName isEmptyOrNil not.	self withReturnHandlerDo: [ 		self cred_ssh_key_new: aStructure username: aName ]! !!LGitCredentialsSSHAgent methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!cred_ssh_key_new: out username: aName	^ self call: #(int git_cred_ssh_key_from_agent(LGitCredentials *out, String aName))! !!LGitCredentialsSSHAgent methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_credtype	"This method was automatically generated"	^LGitCredentialsTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_CREDTYPE)! !!LGitCredentialsSSHAgent methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_credtype: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CREDTYPE put: anObject value! !!LGitCredentialsSSHAgent methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_free	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_FREE) type: ExternalType void asPointerType! !!LGitCredentialsSSHAgent methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_free: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_FREE put: anObject getHandle.! !!LGitDiffBinary class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(			uint contains_data;		LGitDiffBinaryFile old_file; "< The contents of the old file."		LGitDiffBinaryFile new_file; "< The contents of the new file."	)! !!LGitDiffBinary methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_contains_data	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_CONTAINS_DATA! !!LGitDiffBinary methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_contains_data: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CONTAINS_DATA put: anObject! !!LGitDiffBinary methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_new_file	"This method was automatically generated"	^ LGitDiffBinaryFile fromHandle: (handle referenceStructAt: OFFSET_PRIM_NEW_FILE length: LGitDiffBinaryFile byteSize)! !!LGitDiffBinary methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_new_file: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_NEW_FILE put: anObject getHandle length: LGitDiffBinaryFile byteSize! !!LGitDiffBinary methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_old_file	"This method was automatically generated"	^ LGitDiffBinaryFile fromHandle: (handle referenceStructAt: OFFSET_PRIM_OLD_FILE length: LGitDiffBinaryFile byteSize)! !!LGitDiffBinary methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_old_file: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_OLD_FILE put: anObject getHandle length: LGitDiffBinaryFile byteSize! !!LGitDiffBinaryFile class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(		" The type of binary data for this file. "		LGitDiffBinaryTypeEnum type;		" The binary data, deflated. is char* originally, but I do not want to get the \0"		void *data;		" The length of the binary data. "		size_t datalen;		" The length of the binary data after inflation. "		size_t inflatedlen;	)! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_DATA) type: ExternalType void asPointerType! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_DATA put: anObject getHandle.! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_datalen	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_DATALEN! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_datalen: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_DATALEN put: anObject! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_inflatedlen	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_INFLATEDLEN! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_inflatedlen: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_INFLATEDLEN put: anObject! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_type	"This method was automatically generated"	^LGitDiffBinaryTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_TYPE)! !!LGitDiffBinaryFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_type: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_TYPE put: anObject value! !!LGitDiffDelta class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(		LGitDeltaTypeEnum status	uint32 flags	"for RENAMED and COPIED, value 0-100"	uint16 similarity	"number of files in this delta"	uint16 nfiles	LGitDiffFile old_file	LGitDiffFile new_file	)! !!LGitDiffDelta methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!newFile	^ self prim_new_file! !!LGitDiffDelta methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!numberOfFiles	^ self prim_nfiles! !!LGitDiffDelta methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!oldFile	^ self prim_old_file! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FLAGS! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FLAGS put: anObject! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_new_file	"This method was automatically generated"	^ LGitDiffFile fromHandle: (handle referenceStructAt: OFFSET_PRIM_NEW_FILE length: LGitDiffFile byteSize)! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_new_file: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_NEW_FILE put: anObject getHandle length: LGitDiffFile byteSize! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_nfiles	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_NFILES! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_nfiles: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_NFILES put: anObject! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_old_file	"This method was automatically generated"	^ LGitDiffFile fromHandle: (handle referenceStructAt: OFFSET_PRIM_OLD_FILE length: LGitDiffFile byteSize)! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_old_file: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_OLD_FILE put: anObject getHandle length: LGitDiffFile byteSize! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_similarity	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_SIMILARITY! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_similarity: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_SIMILARITY put: anObject! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_status	"This method was automatically generated"	^LGitDeltaTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_STATUS)! !!LGitDiffDelta methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_status: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_STATUS put: anObject value! !!LGitDiffDelta methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!status	^ self prim_status! !!LGitDiffFile class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(	LGitId id	String path	int64 size	uint32 flags	uint16 mode	uint16 id_abbrev	)! !!LGitDiffFile methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!id	^ self prim_id! !!LGitDiffFile methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!path	^ self prim_path readString! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FLAGS! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FLAGS put: anObject! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_id	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_ID length: LGitId byteSize)! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_id: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_ID put: anObject getHandle length: LGitId byteSize! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_id_abbrev	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_ID_ABBREV! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_id_abbrev: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_ID_ABBREV put: anObject! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_mode	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_MODE! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_mode: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_MODE put: anObject! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_path	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PATH) type: ExternalType char asPointerType! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_path: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PATH put: anObject getHandle.! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_size	"This method was automatically generated"	^handle signedLongLongAt: OFFSET_PRIM_SIZE! !!LGitDiffFile methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_size: anObject	"This method was automatically generated"	handle signedLongLongAt: OFFSET_PRIM_SIZE put: anObject! !!LGitDiffFile methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!size	^ self prim_size! !!LGitDiffHunk class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(	int old_start "Starting line number in old_file"	int old_lines "Number of lines in old_file"	int new_start "Starting line number in new_file"	int new_lines "Number of lines in new_file"	size_t header_len "Number of bytes in header text"	Char128 header "Header text, NUL-byte terminated" 		)! !!LGitDiffHunk class methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!initialize	Char128 := FFITypeArray ofType: #char size: 128! !!LGitDiffHunk methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_patch_get_hunk: out lines_in_hunk: lines_in_hunk patch: patch hunk_idx: hunk_idx	^ self		call: #(LGitReturnCodeEnum git_patch_get_hunk(LGitDiffHunk * self, LGitWriteBackValueSizeT lines_in_hunk, LGitPatch patch, size_t hunk_idx))		options: #(  )! !!LGitDiffHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!newNumberOfLines	^ self prim_new_lines! !!LGitDiffHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!newStart	^ self prim_new_start! !!LGitDiffHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!oldNumberOfLines	^ self prim_old_lines! !!LGitDiffHunk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!oldStart	^ self prim_old_start! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_header	"This method was automatically generated"	^(FFITypeArray ofType: #FFICharacterType size: 128) fromHandle: (handle copyFrom: OFFSET_PRIM_HEADER to: OFFSET_PRIM_HEADER + 127)! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_header: anObject	"This method was automatically generated"	handle replaceFrom: OFFSET_PRIM_HEADER to: OFFSET_PRIM_HEADER + 127 with: anObject getHandle startingAt: 1! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_header_len	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_HEADER_LEN! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_header_len: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_HEADER_LEN put: anObject! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_new_lines	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_NEW_LINES! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_new_lines: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_NEW_LINES put: anObject! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_new_start	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_NEW_START! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_new_start: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_NEW_START put: anObject! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_old_lines	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_OLD_LINES! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_old_lines: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_OLD_LINES put: anObject! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_old_start	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_OLD_START! !!LGitDiffHunk methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_old_start: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_OLD_START put: anObject! !!LGitDiffLine class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(	LGitDiffLineTypeEnum	  origin       "A git_diff_line_t value"	int    old_lineno   "Line number in old file or -1 for added line"	int    new_lineno   "Line number in new file or -1 for deleted line"	int    num_lines    "Number of newline characters in content"	size_t content_len  "Number of bytes of data"	int64 content_offset "Offset in the original file to the content"	String content "Pointer to diff text, not NUL-byte terminated"	) ! !!LGitDiffLine methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!content	^ (self prim_content getHandle copyFrom: 1 to: self prim_content_len) asString! !!LGitDiffLine methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!newLineNumber	^ self prim_new_lineno! !!LGitDiffLine methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!oldLineNumber	^ self prim_old_lineno! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_content	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_CONTENT) type: ExternalType char asPointerType! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_content: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_CONTENT put: anObject getHandle.! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_content_len	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_CONTENT_LEN! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_content_len: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_CONTENT_LEN put: anObject! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_content_offset	"This method was automatically generated"	^handle signedLongLongAt: OFFSET_PRIM_CONTENT_OFFSET! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_content_offset: anObject	"This method was automatically generated"	handle signedLongLongAt: OFFSET_PRIM_CONTENT_OFFSET put: anObject! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_new_lineno	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_NEW_LINENO! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_new_lineno: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_NEW_LINENO put: anObject! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_num_lines	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_NUM_LINES! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_num_lines: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_NUM_LINES put: anObject! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_old_lineno	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_OLD_LINENO! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_old_lineno: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_OLD_LINENO put: anObject! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_origin	"This method was automatically generated"	^LGitDiffLineTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_ORIGIN)! !!LGitDiffLine methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_origin: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_ORIGIN put: anObject value! !!LGitDiffLine methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!size	^ self prim_content_len! !!LGitDiffPerfData class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(	uint version	size_t stat_calls "Number of stat() calls performed"	size_t oid_calculations "Number of ID calculations"	)! !!LGitDiffPerfData methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_oid_calculations	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_OID_CALCULATIONS! !!LGitDiffPerfData methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_oid_calculations: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_OID_CALCULATIONS put: anObject! !!LGitDiffPerfData methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_stat_calls	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_STAT_CALLS! !!LGitDiffPerfData methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_stat_calls: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_STAT_CALLS put: anObject! !!LGitDiffPerfData methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_VERSION! !!LGitDiffPerfData methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject! !!LGitDiffSimilarityMetric class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc"int (*file_signature)(		void **out, const git_diff_file *file,		const char *fullpath, void *payload);	int (*buffer_signature)(		void **out, const git_diff_file *file,		const char *buf, size_t buflen, void *payload);	void (*free_signature)(void *sig, void *payload);	int (*similarity)(int *score, void *siga, void *sigb, void *payload);	void *payload;"	^#(	LGitFileSignatureCallback file_signature;	LGitBufferSignatureCallback buffer_signature;	LGitFreeSignatureCallback free_signature;	LGitSimilarityCallback similarity;	void *payload;	)! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_buffer_signature	"This method was automatically generated"	^LGitBufferSignatureCallback forAddress: ((handle pointerAt: OFFSET_PRIM_BUFFER_SIGNATURE) asInteger)! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_buffer_signature: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_BUFFER_SIGNATURE		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_file_signature	"This method was automatically generated"	^LGitFileSignatureCallback forAddress: ((handle pointerAt: OFFSET_PRIM_FILE_SIGNATURE) asInteger)! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_file_signature: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_FILE_SIGNATURE		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_free_signature	"This method was automatically generated"	^LGitFreeSignatureCallback forAddress: ((handle pointerAt: OFFSET_PRIM_FREE_SIGNATURE) asInteger)! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_free_signature: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_FREE_SIGNATURE		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PAYLOAD) type: ExternalType void asPointerType! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PAYLOAD put: anObject getHandle.! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_similarity	"This method was automatically generated"	^LGitSimilarityCallback forAddress: ((handle pointerAt: OFFSET_PRIM_SIMILARITY) asInteger)! !!LGitDiffSimilarityMetric methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_similarity: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_SIMILARITY		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitError class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(	String message;	LGitErrorTypeEnum klass;	)! !!LGitError class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!giterr_clear	^ self call: #(void giterr_clear()) options: #(  )! !!LGitError class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!giterr_last	^ self call: #(void *giterr_last()) options: #(  )! !!LGitError class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!giterr_set_str: string	"GIT_EUSER = -7"	^ self call: #(void giterr_set_str(-7, String string))! !!LGitError class methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!last	| externalData |	externalData := self giterr_last.	^ self fromHandle: externalData getHandle! !!LGitError class methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!lastMessage	^ self last message! !!LGitError class methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!setError: aString	self giterr_set_str: aString! !!LGitError methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!message	^ self isNull		ifFalse: [ self prim_message readString ]		ifTrue: [ 'no error message set by libgit2' ]! !!LGitError methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_klass	"This method was automatically generated"	^LGitErrorTypeEnum fromInteger: (handle signedLongAt: OFFSET_PRIM_KLASS)! !!LGitError methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_klass: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_KLASS put: anObject value! !!LGitError methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_message	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_MESSAGE) type: ExternalType char asPointerType! !!LGitError methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_message: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_MESSAGE put: anObject getHandle.! !!LGitError methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!type	^ self isNull		ifFalse: [ self prim_klass ]		ifTrue: [ nil ]! !!LGitExternalStructure class methodsFor: 'managing accessors' stamp: ' 7/24/2017 12:50:03'!createAccessorsFor: fieldName 	"Define read/write accessors for the given field"	| code |	code := fieldName,'	"This method was automatically generated"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>		^ self fieldAt: ' , fieldName printString.	Author useAuthor: 'NativeBoost' during: [ 		| selector |		selector := self compileSilently: code classified: (self protocolForField: fieldName).		self package addMethod: (self compiledMethodAt: selector) ].		code := fieldName,': anObject	"This method was automatically generated"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>		^ self fieldAt: ' , fieldName printString , ' put: anObject'.	Author useAuthor: 'NativeBoost' during: [ 		| selector |		selector := self compileSilently: code classified: (self protocolForField: fieldName).		self package addMethod: (self compiledMethodAt: selector) ]! !!LGitExternalStructure class methodsFor: 'managing accessors' stamp: ' 7/24/2017 12:50:03'!fieldNamesAndProtocols	^ Dictionary new! !!LGitExternalStructure class methodsFor: 'managing accessors' stamp: ' 7/24/2017 12:50:03'!fieldSpec	^ LGitExternalStructureFieldParser new  		parseFields: self fieldsDesc structure: self.! !!LGitExternalStructure class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!finalizeResourceData: aHandle	"Call the class specific free frunction if aHandle is still a valid external address."	aHandle isNull ifTrue: [ ^self ].	self perform: self freeFunctionSelector with: aHandle.	aHandle beNull! !!LGitExternalStructure class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!free: aHandle	aHandle free! !!LGitExternalStructure class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #free:! !!LGitExternalStructure class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!fromExternalAddress: anAddress	anAddress isNull		ifTrue: [ ^ nil ].	^ self fromHandle: anAddress getHandle! !!LGitExternalStructure class methodsFor: 'managing accessors' stamp: ' 7/24/2017 12:50:03'!generatedFieldProtocolName	^ 'libgit-fields'! !!LGitExternalStructure class methodsFor: 'managing accessors' stamp: ' 7/24/2017 12:50:03'!protocolForField: aString	^ self fieldNamesAndProtocols		at: aString		ifAbsent: [ 'libgit-fields' ]! !!LGitExternalStructure class methodsFor: 'managing accessors' stamp: ' 7/24/2017 12:50:03'!removeAccessor: aSelector	self package removeMethod: (self		compiledMethodAt: aSelector		ifAbsent: [ ^ self ]).			^ super removeAccessor: aSelector! !!LGitExternalStructure methodsFor: 'initialize-release' stamp: ' 7/24/2017 12:50:03'!autoRelease	"Some LGit structures need specialised free functions. Use the same autoRelease functionality	as FFIExternalReference to achieve this.	Note, subclasses should implement #resourceData	and #finalizeResourceData: on class side"	FFIExternalResourceManager addResource: self! !!LGitExternalStructure methodsFor: 'initialize-release' stamp: ' 7/24/2017 12:50:03'!free	handle isExternalAddress 		ifTrue: [ 			self class finalizeResourceData: handle.			self assert: handle isNull ]! !!LGitExternalStructure methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isExternal	"answer true if data referenced by receiver located in external heap, or just in object memory "	^ handle isExternalAddress! !!LGitExternalStructure methodsFor: 'initialize-release' stamp: ' 7/24/2017 12:50:03'!resourceData	^ self getHandle! !!LGitId class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(	uint8 data1;	uint8 data2;	uint8 data3;	uint8 data4;	uint8 data5;	uint8 data6;	uint8 data7;	uint8 data8;	uint8 data9;	uint8 data10;	uint8 data11;	uint8 data12;	uint8 data13;	uint8 data14;	uint8 data15;	uint8 data16;	uint8 data17;	uint8 data18;	uint8 data19;	uint8 data20;	)! !!LGitId class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!fromByteArray: aByteArray	^ self new		prim_data1: (aByteArray at: 1);		prim_data2: (aByteArray at: 2);		prim_data3: (aByteArray at: 3);		prim_data4: (aByteArray at: 4);		prim_data5: (aByteArray at: 5);		prim_data6: (aByteArray at: 6);		prim_data7: (aByteArray at: 7);		prim_data8: (aByteArray at: 8);		prim_data9: (aByteArray at: 9);		prim_data10: (aByteArray at: 10);		prim_data11: (aByteArray at: 11);		prim_data12: (aByteArray at: 12);		prim_data13: (aByteArray at: 13);		prim_data14: (aByteArray at: 14);		prim_data15: (aByteArray at: 15);		prim_data16: (aByteArray at: 16);		prim_data17: (aByteArray at: 17);		prim_data18: (aByteArray at: 18);		prim_data19: (aByteArray at: 19);		prim_data20: (aByteArray at: 20);		yourself! !!LGitId class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!fromHexString: aString	^ self fromByteArray: (ByteArray readHexFrom: aString)! !!LGitId methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!= anObject	^ self == anObject		or: [ self class = anObject class			and: [ self compare: anObject ] ]! !!LGitId methodsFor: 'converting' stamp: ' 7/24/2017 12:50:03'!asByteArray	^ (ByteArray new: 20)		at: 1 put: (self prim_data1);		at: 2 put: (self prim_data2);		at: 3 put: (self prim_data3);		at: 4 put: (self prim_data4);		at: 5 put: (self prim_data5);		at: 6 put: (self prim_data6);		at: 7 put: (self prim_data7);		at: 8 put: (self prim_data8);		at: 9 put: (self prim_data9);		at: 10 put: (self prim_data10);		at: 11 put: (self prim_data11);		at: 12 put: (self prim_data12);		at: 13 put: (self prim_data13);		at: 14 put: (self prim_data14);		at: 15 put: (self prim_data15);		at: 16 put: (self prim_data16);		at: 17 put: (self prim_data17);		at: 18 put: (self prim_data18);		at: 19 put: (self prim_data19);		at: 20 put: (self prim_data20);		yourself	! !!LGitId methodsFor: 'converting' stamp: ' 7/24/2017 12:50:03'!asInteger	^ self asByteArray asInteger! !!LGitId methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!asRelativePathString	| string |	string := String new: 41.	string pin.	self		oid_pathfmt: string		id: self.	string unpin.	^ string! !!LGitId methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!compare: anId	^ (self 		oid_cmp: self		b: anId) isZero! !!LGitId methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!hexString	| string |	self isExternal 		ifFalse: [ ^handle hex ].	string := String new: 40.	string pin.	self		oid_fmt: string		id: self.		string unpin.	^ string! !!LGitId methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!internalize	"Copy the data of this object over to Smalltalk memory if it is currently external.	Now we can keep on using this object after the containing object (Blob, Tree or Commit)	has been freed."	(handle isExternalAddress and: [ handle isNull not ])		ifTrue: [ 			| bytes |			bytes := handle copyFrom: 1 to: self class byteSize.			handle := bytes ]! !!LGitId methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!objectPrintOn: aStream	aStream nextPutAll: self hexString surroundedBySingleQuotes! !!LGitId methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!oid_cmp: a b: b 	^self call: #(int git_oid_cmp(LGitId * self, LGitId * b)) options: #(  )! !!LGitId methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!oid_fmt: out id:  objectId	^self call: #(void git_oid_fmt(void *out, LGitId * self)) options: #(  )! !!LGitId methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!oid_pathfmt: out id: id 	^ self call: #(void git_oid_pathfmt(void *out, LGitId * self)) options: #(  )! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data1	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA1! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data10	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA10! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data10: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA10 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data11	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA11! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data11: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA11 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data12	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA12! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data12: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA12 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data13	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA13! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data13: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA13 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data14	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA14! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data14: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA14 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data15	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA15! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data15: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA15 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data16	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA16! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data16: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA16 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data17	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA17! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data17: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA17 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data18	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA18! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data18: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA18 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data19	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA19! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data19: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA19 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data1: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA1 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data2	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA2! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data20	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA20! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data20: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA20 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data2: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA2 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data3	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA3! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data3: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA3 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data4	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA4! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data4: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA4 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data5	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA5! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data5: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA5 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data6	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA6! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data6: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA6 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data7	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA7! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data7: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA7 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data8	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA8! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data8: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA8 put: anObject! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data9	"This method was automatically generated"	^handle unsignedByteAt: OFFSET_PRIM_DATA9! !!LGitId methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_data9: anObject	"This method was automatically generated"	handle unsignedByteAt: OFFSET_PRIM_DATA9 put: anObject! !!LGitOdbWritepack class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(	"git_odb_backend *" void *backend; "Using void* because I didn't mapped the structure git_odb_backend"	LGitWritepackAppendCallout append;	LGitWritepackCommitCallout commit;	LGitWritepackFreeCallout free;	)! !!LGitOdbWritepack methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!appendWithBuffer: anAddress length: anInteger progress: aTransferProgress	| data callout|	data := self prim_append.	callout := LGitWritepackAppendCallout fromHandle: data getHandle.	^ callout		writepack: self		buffer: anAddress		length: anInteger		progress: aTransferProgress! !!LGitOdbWritepack methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!commitWithProgress: aTransferProgress	self withReturnHandlerDo: [		self prim_commit			writepack: self			progress: aTransferProgress ]! !!LGitOdbWritepack methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!free	self prim_free writepack: self! !!LGitOdbWritepack methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!odb_write_pack: out db: db progress_cb: progress_cb progress_payload: progress_payload 	^ self		call: #(#LGitReturnCodeEnum git_odb_write_pack(LGitOdbWritepack * self, LGitOdb db, LGitTransferProgressCallback progress_cb, void * progress_payload))		options: #( optMayGC optCoerceNilToNull )! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_append	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_APPEND) type: ExternalType void asPointerType! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_append: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_APPEND put: anObject getHandle.! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_backend	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_BACKEND) type: ExternalType void asPointerType! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_backend: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_BACKEND put: anObject getHandle.! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_commit	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_COMMIT) type: ExternalType void asPointerType! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_commit: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_COMMIT put: anObject getHandle.! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_free	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_FREE) type: ExternalType void asPointerType! !!LGitOdbWritepack methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_free: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_FREE put: anObject getHandle.! !!LGitPackbuilderForeachPayload class methodsFor: 'field definition' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(		LGitTransferProgress *stats;		LGitTransferProgressCallback *progress_cb;		void *progress_payload;		LGitOdbWritepack *writepack;	)! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_progress_cb	"This method was automatically generated"	^LGitTransferProgressCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PROGRESS_CB) asInteger)! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_progress_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PROGRESS_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_progress_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PROGRESS_PAYLOAD) type: ExternalType void asPointerType! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_progress_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PROGRESS_PAYLOAD put: anObject getHandle.! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_stats	"This method was automatically generated"	^LGitTransferProgress fromHandle: (handle pointerAt: OFFSET_PRIM_STATS)! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_stats: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_STATS put: anObject getHandle.! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_writepack	"This method was automatically generated"	^LGitOdbWritepack fromHandle: (handle pointerAt: OFFSET_PRIM_WRITEPACK)! !!LGitPackbuilderForeachPayload methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_writepack: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_WRITEPACK put: anObject getHandle.! !!LGitPackbuilderForeachPayload methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!stats	^ self prim_stats! !!LGitPackbuilderForeachPayload methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!stats: aTransferProgress	self prim_stats: aTransferProgress! !!LGitPackbuilderForeachPayload methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!writepack	^ self prim_writepack! !!LGitPackbuilderForeachPayload methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!writepack: aWritepack	self prim_writepack: aWritepack! !!LGitPushUpdate class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(		"		 * The source name of the reference		 "		String src_refname;		"		 * The name of the reference to update on the server		 "		String dst_refname;		"		 * The current target of the reference		 "		LGitId src		"		 * The new target for the reference		 "		LGitId dst	)! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_dst	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_DST length: LGitId byteSize)! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_dst: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_DST put: anObject getHandle length: LGitId byteSize! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_dst_refname	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_DST_REFNAME) type: ExternalType char asPointerType! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_dst_refname: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_DST_REFNAME put: anObject getHandle.! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_src	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_SRC length: LGitId byteSize)! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_src: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_SRC put: anObject getHandle length: LGitId byteSize! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_src_refname	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_SRC_REFNAME) type: ExternalType char asPointerType! !!LGitPushUpdate methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_src_refname: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_SRC_REFNAME put: anObject getHandle.! !!LGitRemoteHead class methodsFor: 'field definition' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	"self rebuildFieldAccessors"	^#(	int local; " available locally "	LGitId oid;	LGitId loid;	String name;	"	 * If the server send a symref mapping for this ref, this will	 * point to the target.	"	String symref_target;	)! !!LGitRemoteHead methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!name 	^ (self prim_name) readString! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_local	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_LOCAL! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_local: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_LOCAL put: anObject! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_loid	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_LOID length: LGitId byteSize)! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_loid: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_LOID put: anObject getHandle length: LGitId byteSize! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_name	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_NAME) type: ExternalType char asPointerType! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_name: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_NAME put: anObject getHandle.! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_oid	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_OID length: LGitId byteSize)! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_oid: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_OID put: anObject getHandle length: LGitId byteSize! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_symref_target	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_SYMREF_TARGET) type: ExternalType char asPointerType! !!LGitRemoteHead methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_symref_target: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_SYMREF_TARGET put: anObject getHandle.! !!LGitSignature class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(		char * name;		char * email;		LGitTime when;	)! !!LGitSignature class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!name: nameString email: emailString	^ self name: nameString email: emailString when: DateAndTime now! !!LGitSignature class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!name: nameString email: emailString when: dateAndTime	"Allocate an instance on the external heap and initialize it.	Use autoRelease so the data will be freed when the instance is gc'ed."	^ self externalNew			name: nameString;			email: emailString;			dateAndTime: dateAndTime;			autoRelease;			yourself! !!LGitSignature class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!signature_free: handle 	^ self		call: #(void git_signature_free(void *handle))		options: #(  )! !!LGitSignature methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!= anObject	^ self == anObject		or: [ self class == anObject class			and: [ self name = anObject name				and: [ self email = anObject email					and: [ self dateAndTime = anObject dateAndTime ] ] ] ]! !!LGitSignature methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!dateAndTime	^ self prim_when asDateAndTime! !!LGitSignature methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!dateAndTime: aDateAndTime	self prim_when: (LGitTime fromDateAndTime: aDateAndTime)! !!LGitSignature methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!email	^ self prim_email readString! !!LGitSignature methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!email: aString	self prim_email: aString asLGitExternalString! !!LGitSignature methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!hash	^ ((self name hash bitXor: self email hash) bitXor: self email hash) bitXor: self dateAndTime hash! !!LGitSignature methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!name	^ self prim_name readString! !!LGitSignature methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!name: aString	self prim_name: aString asLGitExternalString! !!LGitSignature methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!objectPrintOn: aStream	aStream		nextPutAll: self name;		nextPutAll: ' <';		nextPutAll: self email;		nextPutAll: '> '.	self dateAndTime printOn: aStream! !!LGitSignature methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_email	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_EMAIL) type: ExternalType char asPointerType! !!LGitSignature methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_email: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_EMAIL put: anObject getHandle.! !!LGitSignature methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_name	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_NAME) type: ExternalType char asPointerType! !!LGitSignature methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_name: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_NAME put: anObject getHandle.! !!LGitSignature methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_when	"This method was automatically generated"	^ LGitTime fromHandle: (handle referenceStructAt: OFFSET_PRIM_WHEN length: LGitTime byteSize)! !!LGitSignature methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_when: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_WHEN put: anObject getHandle length: LGitTime byteSize! !!LGitStringArray class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(		LGitExternalStringArray * strings;		size_t count;	)! !!LGitStringArray class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!strarray_free: handle	"libgit2 will also free all the strings in this struct"	^ self		call: #(void git_strarray_free(void *handle))		options: #()! !!LGitStringArray class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!withAll: stringCollection	"Allocate an instance on the external heap and initialize it with	<stringCollection>. Use autoRelease so the data will be freed when	the instance is gc'ed."	^ self externalNew		count: stringCollection size;		strings: stringCollection;		autoRelease;		yourself! !!LGitStringArray methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!count	^ self prim_count! !!LGitStringArray methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!count: anInteger	self prim_count: anInteger! !!LGitStringArray methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_count	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_COUNT! !!LGitStringArray methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_count: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_COUNT put: anObject! !!LGitStringArray methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_strings	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_STRINGS) type: ExternalType void asPointerType! !!LGitStringArray methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_strings: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_STRINGS put: anObject getHandle.! !!LGitStringArray methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!strings	| externalArray |	self count = 0		ifTrue: [ ^ #() ].	externalArray := LGitExternalStringArray 		onAddress: self prim_strings getHandle 		size: self count.	^externalArray asArray! !!LGitStringArray methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!strings: aCollection	| array |	array := LGitExternalStringArray fromCollection: aCollection.	self prim_strings: array! !!LGitBlameOptions class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^ #(		LGitOptionsVersionsEnum version		uint32 flags "is a combination of the git_blame_flag_t values above."		uint16 min_match_characters "is the lower bound on the number of alphanumeric characters that must be detected as moving/copying within a file for it to associate those lines with the parent commit. The default value is 20. This value only takes effect if any of the GIT_BLAME_TRACK_COPIES_* flags are specified."		LGitId newest_commit "is the id of the newest commit to consider. The default is HEAD."		LGitId oldest_commit "is the id of the oldest commit to consider. The default is the first commit encountered with a NULL parent."		size_t min_line "is the first line in the file to blame. The default is 1 (line numbers start with 1)."		size_t max_line "is the last line in the file to blame. The default is the last line of the file."	)! !!LGitBlameOptions methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blame_init_options: opts version: version	^ self		callUnchecked: #(int git_blame_init_options(LGitBlameOptions * self, LGitOptionsVersionsEnum version))		options: #( )! !!LGitBlameOptions methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!initializeWithDefaults	self withReturnHandlerDo: [		self			blame_init_options: self			version: LGitOptionsVersionsEnum git_blame_options_version_1 ]! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FLAGS! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FLAGS put: anObject! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_max_line	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_MAX_LINE! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_max_line: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_MAX_LINE put: anObject! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_min_line	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_MIN_LINE! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_min_line: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_MIN_LINE put: anObject! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_min_match_characters	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_MIN_MATCH_CHARACTERS! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_min_match_characters: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_MIN_MATCH_CHARACTERS put: anObject! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_newest_commit	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_NEWEST_COMMIT length: LGitId byteSize)! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_newest_commit: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_NEWEST_COMMIT put: anObject getHandle length: LGitId byteSize! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_oldest_commit	"This method was automatically generated"	^ LGitId fromHandle: (handle referenceStructAt: OFFSET_PRIM_OLDEST_COMMIT length: LGitId byteSize)! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_oldest_commit: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_OLDEST_COMMIT put: anObject getHandle length: LGitId byteSize! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitBlameOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitCheckoutOptions class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(		LGitOptionsVersionsEnum version;		uint checkout_strategy; "< default will be a dry run "		int disable_filters;    "< don't apply filters like CRLF conversion "		uint dir_mode;  "< default is 0755 "		uint file_mode; "< default is 0644 or 0755 as dictated by blob "		int file_open_flags;    "< default is O_CREAT | O_TRUNC | O_WRONLY "		uint notify_flags; "< see `git_checkout_notify_t` above "		LGitCheckoutNotifyCallback notify_cb;		void *notify_payload;		" Optional callback to notify the consumer of checkout progress. "		LGitCheckoutProgressCallback progress_cb;		void *progress_payload;		" When not zeroed out, array of fnmatch patterns specifying which		 *  paths should be taken into account, otherwise all files.  Use		 *  GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH to treat as simple list.		 "		LGitStringArray paths;		" The expected content of the working directory; defaults to HEAD.		 *  If the working directory does not match this baseline information,		 *  that will produce a checkout conflict.		 "		LGitTree *baseline;		" Like `baseline` above, though expressed as an index.  This		 *  option overrides `baseline`.		 "		LGitIndex *baseline_index; "< expected content of workdir, expressed as an index. "		String target_directory; "< alternative checkout path to workdir "		String ancestor_label; "< the name of the common ancestor side of conflicts "		String our_label; "< the name of the *our* side of conflicts "		String their_label; "< the name of the *their* side of conflicts "		" Optional callback to notify the consumer of performance data. "		LGitCheckoutPerfDataCallback perfdata_cb;		void *perfdata_payload;	)! !!LGitCheckoutOptions methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!checkoutStrategy: aCheckoutStrategyEnum	self prim_checkout_strategy: aCheckoutStrategyEnum value! !!LGitCheckoutOptions methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!checkout_init_options: opts version: version 	^ self		callUnchecked: #(int git_checkout_init_options(LGitCheckoutOptions * self, LGitOptionsVersionsEnum version))		options: #(  )! !!LGitCheckoutOptions methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!initializeWithDefaults	self withReturnHandlerDo: [		self			checkout_init_options: self			version: LGitOptionsVersionsEnum git_checkout_options_version_1 ]! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_ancestor_label	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_ANCESTOR_LABEL) type: ExternalType char asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_ancestor_label: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_ANCESTOR_LABEL put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_baseline	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_BASELINE) type: ExternalType void asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_baseline: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_BASELINE put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_baseline_index	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_BASELINE_INDEX) type: ExternalType void asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_baseline_index: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_BASELINE_INDEX put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_checkout_strategy	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_CHECKOUT_STRATEGY! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_checkout_strategy: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CHECKOUT_STRATEGY put: anObject! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_dir_mode	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_DIR_MODE! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_dir_mode: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_DIR_MODE put: anObject! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_disable_filters	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_DISABLE_FILTERS! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_disable_filters: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_DISABLE_FILTERS put: anObject! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_file_mode	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FILE_MODE! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_file_mode: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FILE_MODE put: anObject! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_file_open_flags	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_FILE_OPEN_FLAGS! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_file_open_flags: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_FILE_OPEN_FLAGS put: anObject! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_notify_cb	"This method was automatically generated"	^LGitCheckoutNotifyCallback forAddress: ((handle pointerAt: OFFSET_PRIM_NOTIFY_CB) asInteger)! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_notify_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_NOTIFY_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_notify_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_NOTIFY_FLAGS! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_notify_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_NOTIFY_FLAGS put: anObject! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_notify_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_NOTIFY_PAYLOAD) type: ExternalType void asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_notify_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_NOTIFY_PAYLOAD put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_our_label	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_OUR_LABEL) type: ExternalType char asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_our_label: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_OUR_LABEL put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_paths	"This method was automatically generated"	^ LGitStringArray fromHandle: (handle referenceStructAt: OFFSET_PRIM_PATHS length: LGitStringArray byteSize)! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_paths: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_PATHS put: anObject getHandle length: LGitStringArray byteSize! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_perfdata_cb	"This method was automatically generated"	^LGitCheckoutPerfDataCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PERFDATA_CB) asInteger)! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_perfdata_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PERFDATA_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_perfdata_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PERFDATA_PAYLOAD) type: ExternalType void asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_perfdata_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PERFDATA_PAYLOAD put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_progress_cb	"This method was automatically generated"	^LGitCheckoutProgressCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PROGRESS_CB) asInteger)! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_progress_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PROGRESS_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_progress_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PROGRESS_PAYLOAD) type: ExternalType void asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_progress_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PROGRESS_PAYLOAD put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_target_directory	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_TARGET_DIRECTORY) type: ExternalType char asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_target_directory: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_TARGET_DIRECTORY put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_their_label	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_THEIR_LABEL) type: ExternalType char asPointerType! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_their_label: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_THEIR_LABEL put: anObject getHandle.! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitCheckoutOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitCloneOptions class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(		LGitOptionsVersionsEnum version;				"		 * These options are passed to the checkout step. To disable		 * checkout, set the `checkout_strategy` to		 * `GIT_CHECKOUT_NONE`.		 "		LGitCheckoutOptions checkout_opts;		"		 * Options which control the fetch, including callbacks.		 *		 * The callbacks are used for reporting fetch progress, and for acquiring		 * credentials in the event they are needed.		 "		LGitFetchOptions fetch_opts;		"		 * Set to zero (false) to create a standard repo, or non-zero		 * for a bare repo		 "		Boolean bare;		"		 * Whether to use a fetch or copy the object database.		 "		LGitCloneLocalTypeEnum local;		"		 * The name of the branch to checkout. NULL means use the		 * remote's default branch.		 "		String checkout_branch;		"		 * A callback used to create the new repository into which to		 * clone. If NULL, the 'bare' field will be used to determine		 * whether to create a bare repository.		 "		LGitRepositoryCreateCallback repository_cb;		"		 * An opaque payload to pass to the git_repository creation callback.		 * This parameter is ignored unless repository_cb is non-NULL.		 "		void *repository_cb_payload;		"		 * A callback used to create the git_remote, prior to its being		 * used to perform the clone operation. See the documentation for		 * git_remote_create_cb for details. This parameter may be NULL,		 * indicating that git_clone should provide default behavior.		 "		LGitRemoteCreateCallback remote_cb;		"		 * An opaque payload to pass to the git_remote creation callback.		 * This parameter is ignored unless remote_cb is non-NULL.		 "		void *remote_cb_payload;	)! !!LGitCloneOptions class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!withCredentialsCallback: aBlock	| credentialsCallback callbacks fetchOptions  |	credentialsCallback := LGitCredAcquireCallback on: aBlock.	callbacks := LGitRemoteCallbacks defaults		credentials: credentialsCallback;		yourself.	fetchOptions := LGitFetchOptions defaults		callbacks: callbacks;		yourself.	^ self defaults		fetchOptions: fetchOptions;		yourself.	! !!LGitCloneOptions class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!withCredentialsProvider: provider	| fetchOptions |	fetchOptions := LGitFetchOptions defaults		callbacks: (LGitRemoteCallbacks withProvider: provider);		yourself.	^ self defaults		fetchOptions: fetchOptions		yourself.	! !!LGitCloneOptions methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!clone_init_options: opts version: version 	^ self		callUnchecked: #(LGitReturnCodeEnum git_clone_init_options(LGitCloneOptions *self, LGitOptionsVersionsEnum version))		options: #(  )! !!LGitCloneOptions methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fetchOptions	^ self prim_fetch_opts! !!LGitCloneOptions methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fetchOptions: _fetchOptions	fetchOptions := _fetchOptions.	self prim_fetch_opts: fetchOptions! !!LGitCloneOptions methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!initializeWithDefaults	self withReturnHandlerDo: [		self			clone_init_options: self			version: LGitOptionsVersionsEnum  git_clone_options_version_1 ]! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_bare	"This method was automatically generated"	^handle booleanAt: OFFSET_PRIM_BARE! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_bare: anObject	"This method was automatically generated"	handle booleanAt: OFFSET_PRIM_BARE put: anObject! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_checkout_branch	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_CHECKOUT_BRANCH) type: ExternalType char asPointerType! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_checkout_branch: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_CHECKOUT_BRANCH put: anObject getHandle.! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_checkout_opts	"This method was automatically generated"	^ LGitCheckoutOptions fromHandle: (handle referenceStructAt: OFFSET_PRIM_CHECKOUT_OPTS length: LGitCheckoutOptions byteSize)! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_checkout_opts: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_CHECKOUT_OPTS put: anObject getHandle length: LGitCheckoutOptions byteSize! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_fetch_opts	"This method was automatically generated"	^ LGitFetchOptions fromHandle: (handle referenceStructAt: OFFSET_PRIM_FETCH_OPTS length: LGitFetchOptions byteSize)! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_fetch_opts: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_FETCH_OPTS put: anObject getHandle length: LGitFetchOptions byteSize! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_local	"This method was automatically generated"	^LGitCloneLocalTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_LOCAL)! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_local: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_LOCAL put: anObject value! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_remote_cb	"This method was automatically generated"	^LGitRemoteCreateCallback forAddress: ((handle pointerAt: OFFSET_PRIM_REMOTE_CB) asInteger)! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_remote_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_REMOTE_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_remote_cb_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_REMOTE_CB_PAYLOAD) type: ExternalType void asPointerType! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_remote_cb_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_REMOTE_CB_PAYLOAD put: anObject getHandle.! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_repository_cb	"This method was automatically generated"	^LGitRepositoryCreateCallback forAddress: ((handle pointerAt: OFFSET_PRIM_REPOSITORY_CB) asInteger)! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_repository_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_REPOSITORY_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_repository_cb_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_REPOSITORY_CB_PAYLOAD) type: ExternalType void asPointerType! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_repository_cb_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_REPOSITORY_CB_PAYLOAD put: anObject getHandle.! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitCloneOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitCloneOptions methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!remoteCallback	^ self prim_remote_cb! !!LGitCloneOptions methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!remoteCallback: aRemoteCallback	self prim_remote_cb: aRemoteCallback! !!LGitDiffFindOptions class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(		LGitOptionsVersionsEnum version;		"Combination of git_diff_find_t values (default GIT_DIFF_FIND_BY_CONFIG).		 NOTE: if you don't explicitly set this, `diff.renames` could be set		 to false, resulting in `git_diff_find_similar` doing nothing."		uint32 flags;		" Similarity to consider a file renamed (default 50) "		uint16 rename_threshold;		" Similarity of modified to be eligible rename source (default 50) "		uint16 rename_from_rewrite_threshold;		" Similarity to consider a file a copy (default 50) "		uint16 copy_threshold;		" Similarity to split modify into delete/add pair (default 60) "		uint16 break_rewrite_threshold;		"Maximum similarity sources to examine for a file (somewhat like		 git-diff's `-l` option or `diff.renameLimit` config) (default 200)"		size_t rename_limit;		" Pluggable similarity metric; pass NULL to use internal metric "		LGitDiffSimilarityMetric metric;	)! !!LGitDiffFindOptions methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_find_init_options: opts version: version	^ self		callUnchecked: #(LGitReturnCodeEnum git_diff_find_init_options(LGitDiffFindOptions * self, LGitOptionsVersionsEnum version))		options: #(  )! !!LGitDiffFindOptions methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!initializeWithDefaults	self withReturnHandlerDo: [		self			diff_find_init_options: self			version: LGitOptionsVersionsEnum git_diff_find_options_version_1 ]! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_break_rewrite_threshold	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_BREAK_REWRITE_THRESHOLD! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_break_rewrite_threshold: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_BREAK_REWRITE_THRESHOLD put: anObject! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_copy_threshold	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_COPY_THRESHOLD! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_copy_threshold: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_COPY_THRESHOLD put: anObject! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FLAGS! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FLAGS put: anObject! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_metric	"This method was automatically generated"	^ LGitDiffSimilarityMetric fromHandle: (handle referenceStructAt: OFFSET_PRIM_METRIC length: LGitDiffSimilarityMetric byteSize)! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_metric: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_METRIC put: anObject getHandle length: LGitDiffSimilarityMetric byteSize! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_rename_from_rewrite_threshold	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_RENAME_FROM_REWRITE_THRESHOLD! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_rename_from_rewrite_threshold: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_RENAME_FROM_REWRITE_THRESHOLD put: anObject! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_rename_limit	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_RENAME_LIMIT! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_rename_limit: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_RENAME_LIMIT put: anObject! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_rename_threshold	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_RENAME_THRESHOLD! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_rename_threshold: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_RENAME_THRESHOLD put: anObject! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitDiffFindOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitDiffOptions class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(		LGitOptionsVersionsEnum version      "version for the struct"		uint32 flags            "defaults to GIT_DIFF_NORMAL"		"options controlling which files are in the diff"		LGitSubmoduleIgnoreTypeEnum ignore_submodules "submodule ignore rule"		LGitStringArray       pathspec     "defaults to include all paths"		LGitDiffNotifyCallback notify_cb		void *notify_payload		"options controlling how to diff text is generated"		uint32    context_lines    "defaults to 3"		uint32    interhunk_lines  "defaults to 0"		uint16    id_abbrev       "default 'core.abbrev' or 7 if unset"		int64   max_size         "defaults to 512MB"		String old_prefix       "defaults to 'a'"		String new_prefix       "defaults to 'b'"	)! !!LGitDiffOptions methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_init_options: opts version: version	^ self		callUnchecked: #(LGitReturnCodeEnum git_diff_init_options(LGitDiffOptions * self, LGitOptionsVersionsEnum version))		options: #(  )! !!LGitDiffOptions methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!initializeWithDefaults	self withReturnHandlerDo: [		self			diff_init_options: self			version: LGitOptionsVersionsEnum git_diff_options_version_1 ]! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_context_lines	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_CONTEXT_LINES! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_context_lines: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_CONTEXT_LINES put: anObject! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FLAGS! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FLAGS put: anObject! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_id_abbrev	"This method was automatically generated"	^handle unsignedShortAt: OFFSET_PRIM_ID_ABBREV! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_id_abbrev: anObject	"This method was automatically generated"	handle unsignedShortAt: OFFSET_PRIM_ID_ABBREV put: anObject! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_ignore_submodules	"This method was automatically generated"	^LGitSubmoduleIgnoreTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_IGNORE_SUBMODULES)! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_ignore_submodules: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_IGNORE_SUBMODULES put: anObject value! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_interhunk_lines	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_INTERHUNK_LINES! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_interhunk_lines: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_INTERHUNK_LINES put: anObject! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_max_size	"This method was automatically generated"	^handle signedLongLongAt: OFFSET_PRIM_MAX_SIZE! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_max_size: anObject	"This method was automatically generated"	handle signedLongLongAt: OFFSET_PRIM_MAX_SIZE put: anObject! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_new_prefix	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_NEW_PREFIX) type: ExternalType char asPointerType! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_new_prefix: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_NEW_PREFIX put: anObject getHandle.! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_notify_cb	"This method was automatically generated"	^LGitDiffNotifyCallback forAddress: ((handle pointerAt: OFFSET_PRIM_NOTIFY_CB) asInteger)! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_notify_cb: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_NOTIFY_CB		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_notify_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_NOTIFY_PAYLOAD) type: ExternalType void asPointerType! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_notify_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_NOTIFY_PAYLOAD put: anObject getHandle.! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_old_prefix	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_OLD_PREFIX) type: ExternalType char asPointerType! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_old_prefix: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_OLD_PREFIX put: anObject getHandle.! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_pathspec	"This method was automatically generated"	^ LGitStringArray fromHandle: (handle referenceStructAt: OFFSET_PRIM_PATHSPEC length: LGitStringArray byteSize)! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_pathspec: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_PATHSPEC put: anObject getHandle length: LGitStringArray byteSize! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitDiffOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitFetchOptions class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^ #(		LGitOptionsVersionsEnum version;		"		 * Callbacks to use for this fetch operation		 "		LGitRemoteCallbacks callbacks;		"		 * Whether to perform a prune after the fetch		 "		LGitFetchPruneTypeEnum prune;		"		 * Whether to write the results to FETCH_HEAD. Defaults to		 * on. Leave this default in order to behave like git.		 "		Boolean update_fetchhead;		"		 * Determines how to behave regarding tags on the remote, such		 * as auto-downloading tags for objects we're downloading or		 * downloading all of them.		 *		 * The default is to auto-follow tags.		 "		LGitRemoteAutotagOptionTypeEnum download_tags;		"	    * Proxy options to use, by default no proxy is used.	   "		LGitProxyOptions proxy_opts;		"	  	 * Extra headers for this fetch operation	 	"		LGitStringArray custom_headers;	)! !!LGitFetchOptions methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!callbacks	^ self prim_callbacks! !!LGitFetchOptions methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!callbacks: _callbacks	callbacks := _callbacks.	self prim_callbacks: callbacks! !!LGitFetchOptions methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!fetch_init_options: opts version: version	^ self		callUnchecked: #(LGitReturnCodeEnum git_fetch_init_options(LGitFetchOptions * self, LGitOptionsVersionsEnum version))		options: #(  )! !!LGitFetchOptions methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!initializeWithDefaults	self withReturnHandlerDo: [		self			fetch_init_options: self			version: LGitOptionsVersionsEnum git_fetch_options_version_1 ]! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_callbacks	"This method was automatically generated"	^ LGitRemoteCallbacks fromHandle: (handle referenceStructAt: OFFSET_PRIM_CALLBACKS length: LGitRemoteCallbacks byteSize)! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_callbacks: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_CALLBACKS put: anObject getHandle length: LGitRemoteCallbacks byteSize! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_custom_headers	"This method was automatically generated"	^ LGitStringArray fromHandle: (handle referenceStructAt: OFFSET_PRIM_CUSTOM_HEADERS length: LGitStringArray byteSize)! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_custom_headers: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_CUSTOM_HEADERS put: anObject getHandle length: LGitStringArray byteSize! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_download_tags	"This method was automatically generated"	^LGitRemoteAutotagOptionTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_DOWNLOAD_TAGS)! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_download_tags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_DOWNLOAD_TAGS put: anObject value! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_proxy_opts	"This method was automatically generated"	^ LGitProxyOptions fromHandle: (handle referenceStructAt: OFFSET_PRIM_PROXY_OPTS length: LGitProxyOptions byteSize)! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_proxy_opts: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_PROXY_OPTS put: anObject getHandle length: LGitProxyOptions byteSize! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_prune	"This method was automatically generated"	^LGitFetchPruneTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_PRUNE)! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_prune: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_PRUNE put: anObject value! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_update_fetchhead	"This method was automatically generated"	^handle booleanAt: OFFSET_PRIM_UPDATE_FETCHHEAD! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_update_fetchhead: anObject	"This method was automatically generated"	handle booleanAt: OFFSET_PRIM_UPDATE_FETCHHEAD put: anObject! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitFetchOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitMergeOptions class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	"https://libgit2.github.com/libgit2/#HEAD/type/git_merge_options"	^#(		LGitOptionsVersionsEnum version;		uint32 flags; "Should be: git_merge_flag_t"		uint rename_threshold;		uint target_limit;		void* metric; "Should be: git_diff_similarity_metric *"		uint recursion_limit;		String default_driver;		uint32 file_favor; "Should be: git_merge_favor_flag_t"		uint32 file_flags; "Should be: git_merge_file_flag_t"	)! !!LGitMergeOptions methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!initializeWithDefaults	self withReturnHandlerDo: [		self			merge_init_options: self			version: LGitOptionsVersionsEnum git_merge_options_version_1 ]! !!LGitMergeOptions methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!merge_init_options: opts version: version 	^ self		callUnchecked: #(int git_merge_init_options(			LGitMergeOptions * self, 			LGitOptionsVersionsEnum version))		options: #()! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_default_driver	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_DEFAULT_DRIVER) type: ExternalType char asPointerType! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_default_driver: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_DEFAULT_DRIVER put: anObject getHandle.! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_file_favor	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FILE_FAVOR! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_file_favor: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FILE_FAVOR put: anObject! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_file_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FILE_FLAGS! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_file_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FILE_FLAGS put: anObject! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_flags	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_FLAGS! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_flags: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_FLAGS put: anObject! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_metric	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_METRIC) type: ExternalType void asPointerType! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_metric: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_METRIC put: anObject getHandle.! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_recursion_limit	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_RECURSION_LIMIT! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_recursion_limit: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_RECURSION_LIMIT put: anObject! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_rename_threshold	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_RENAME_THRESHOLD! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_rename_threshold: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_RENAME_THRESHOLD put: anObject! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_target_limit	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_TARGET_LIMIT! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_target_limit: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_TARGET_LIMIT put: anObject! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitMergeOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitProxyOptions class methodsFor: 'field definition' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^ #(	LGitOptionsVersionsEnum version;	"/**	 * The type of proxy to use, by URL, auto-detect.	 */"	LGitProxyTypeEnum type;	"/**	 * The URL of the proxy.	 */"	String url;	"/**	 * This will be called if the remote host requires	 * authentication in order to connect to it.	 *	 * Returning GIT_PASSTHROUGH will make libgit2 behave as	 * though this field isn't set.	 */"	LGitCredAcquireCallback credentials;	"/**	 * If cert verification fails, this will be called to let the	 * user make the final decision of whether to allow the	 * connection to proceed. Returns 1 to allow the connection, 0	 * to disallow it or a negative value to indicate an error.	 */"   LGitTransportCertificateCheckCallback certificate_check;	"/**	 * Payload to be provided to the credentials and certificate	 * check callbacks.	 */"	void *payload;	)! !!LGitProxyOptions methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!initializeWithDefaults	self withReturnHandlerDo: [		self			proxy_init_options: self getHandle getHandle			version: LGitOptionsVersionsEnum git_fetch_options_version_1 ]! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_certificate_check	"This method was automatically generated"	^LGitTransportCertificateCheckCallback forAddress: ((handle pointerAt: OFFSET_PRIM_CERTIFICATE_CHECK) asInteger)! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_certificate_check: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_CERTIFICATE_CHECK		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_credentials	"This method was automatically generated"	^LGitCredAcquireCallback forAddress: ((handle pointerAt: OFFSET_PRIM_CREDENTIALS) asInteger)! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_credentials: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_CREDENTIALS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PAYLOAD) type: ExternalType void asPointerType! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PAYLOAD put: anObject getHandle.! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_type	"This method was automatically generated"	^LGitProxyTypeEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_TYPE)! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_type: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_TYPE put: anObject value! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_url	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_URL) type: ExternalType char asPointerType! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_url: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_URL put: anObject getHandle.! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitProxyOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitProxyOptions methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!proxy_init_options: opts version: version	^ self		callUnchecked: #(LGitReturnCodeEnum git_proxy_init_options(void *handle, LGitOptionsVersionsEnum version))		options: #(  )! !!LGitPushOptions class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^ #(	LGitOptionsVersionsEnum version;	"	 * If the transport being used to push to the remote requires the creation	 * of a pack file, this controls the number of worker threads used by	 * the packbuilder when creating that pack file to be sent to the remote.	 *	 * If set to 0, the packbuilder will auto-detect the number of threads	 * to create. The default value is 1.	 "	uint pb_parallelism;	"	 * Callbacks to use for this push operation	 "	LGitRemoteCallbacks callbacks;			"	* Proxy options to use, by default no proxy is used.	"	LGitProxyOptions proxy_opts;	"	 * Extra headers for this push operation	"	LGitStringArray custom_headers;)! !!LGitPushOptions methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!callbacks	^ self prim_callbacks! !!LGitPushOptions methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!callbacks: _callbacks	callbacks := _callbacks.	^ self prim_callbacks: callbacks! !!LGitPushOptions methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!initializeWithDefaults	self withReturnHandlerDo: [		self			push_init_options: self			version: LGitOptionsVersionsEnum git_push_options_version_1 ]! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_callbacks	"This method was automatically generated"	^ LGitRemoteCallbacks fromHandle: (handle referenceStructAt: OFFSET_PRIM_CALLBACKS length: LGitRemoteCallbacks byteSize)! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_callbacks: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_CALLBACKS put: anObject getHandle length: LGitRemoteCallbacks byteSize! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_custom_headers	"This method was automatically generated"	^ LGitStringArray fromHandle: (handle referenceStructAt: OFFSET_PRIM_CUSTOM_HEADERS length: LGitStringArray byteSize)! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_custom_headers: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_CUSTOM_HEADERS put: anObject getHandle length: LGitStringArray byteSize! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_pb_parallelism	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_PB_PARALLELISM! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_pb_parallelism: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_PB_PARALLELISM put: anObject! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_proxy_opts	"This method was automatically generated"	^ LGitProxyOptions fromHandle: (handle referenceStructAt: OFFSET_PRIM_PROXY_OPTS length: LGitProxyOptions byteSize)! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_proxy_opts: anObject	"This method was automatically generated"	handle structAt: OFFSET_PRIM_PROXY_OPTS put: anObject getHandle length: LGitProxyOptions byteSize! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version	"This method was automatically generated"	^LGitOptionsVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitPushOptions methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitPushOptions methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!push_init_options: options version: version	self		callUnchecked: #(LGitReturnCodeEnum git_push_init_options(LGitPushOptions * self, LGitOptionsVersionsEnum version))		options: #()! !!LGitRemoteCallbacks class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!defaults	^ super defaults 		certificateCheck: self newCertificateCheckCallback;		yourself! !!LGitRemoteCallbacks class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(		LGitStructVersionsEnum version;		"		 * Textual progress from the remote. Text send over the		 * progress side-band will be passed to this function (this is		 * the 'counting objects' output.		 "		LGitTransportMessageCallback sideband_progress;		"		 * Completion is called when different parts of the download		 * process are done (currently unused).		 "		LGitCompletionCallback completion;		"		 * This will be called if the remote host requires		 * authentication in order to connect to it.		 *		 * Returning GIT_PASSTHROUGH will make libgit2 behave as		 * though this field isn't set.		 "		LGitCredAcquireCallback credentials;		"		 * If cert verification fails, this will be called to let the		 * user make the final decision of whether to allow the		 * connection to proceed. Returns 1 to allow the connection, 0		 * to disallow it or a negative value to indicate an error.		 "	   LGitTransportCertificateCheckCallback certificate_check;		"		 * During the download of new data, this will be regularly		 * called with the current count of progress done by the		 * indexer.		 "		LGitTransferProgressCallback transfer_progress;		"		 * Each time a reference is updated locally, this function		 * will be called with information about it.		 "		LGitUpdateTipsCallback update_tips;		"		 * Function to call with progress information during pack		 * building. Be aware that this is called inline with pack		 * building operations, so performance may be affected.		 "		LGitPackbuilderProgressCallback pack_progress;		"		 * Function to call with progress information during the		 * upload portion of a push. Be aware that this is called		 * inline with pack building operations, so performance may be		 * affected.		 "		LGitPushTransferProgressCallback push_transfer_progress;		"		 * Called for each updated reference on push. If `status` is		 * not `NULL`, the update was rejected by the remote server		 * and `status` contains the reason given.		 "		LGitPushUpdateReferenceCallback push_update_reference;		"		 * Called once between the negotiation step and the upload. It		 * provides information about what updates will be performed.		 "		LGitPushNegotiationCallback push_negotiation;		"		 * Create the transport to use for this operation. Leave NULL		 * to auto-detect.		 "		LGitTransport transport;		"		 * This will be passed to each of the callbacks in this struct		 * as the last parameter.		 "		void *payload;	)! !!LGitRemoteCallbacks class methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!newCertificateCheckCallback	self flag: #fixMe. "I need to skip the verification of certificate because on macOS, 	libgit2 has problems to be compiled with Secure framework, and if compiled with 	openssl instead, openssl for macOS does not checks agains the certificates installed 	at S.O., so it will fail almost always. This is, of course, a workaround... eventually 	libgit2 will work :P"	^ LGitTransportCertificateCheckCallback on: [ :cert :value :host :payload  |		1 ]! !!LGitRemoteCallbacks class methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!newCredentialsCallbackFor: provider	^ LGitCredAcquireCallback		on: [ :output :url :username_from_url :allowed_types :data | 			"Allowed types are defined in git_credtype_t 		https://github.com/libgit2/libgit2/blob/HEAD/include/git2/transport.h#L81-111"			self				putCredentialsType: allowed_types				username: username_from_url				provider: provider				onto: output ]! !!LGitRemoteCallbacks class methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!putCredentialsType: types username: username provider: provider onto: output  	(types anyMask: 1 << 0) ifTrue: [ 		^ LGitCredentialsPlaintext createFrom: provider onto: output ].	(types anyMask: 1 << 1) ifTrue: [ 		^ provider sshCredentialsClass 			createFrom: provider 			username: username			onto: output ].	Transcript logCr: ('I can''t create credentials for type: {1}' format: {types}).	^ -1! !!LGitRemoteCallbacks class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!withProvider: provider	^ LGitRemoteCallbacks defaults		credentials: (self newCredentialsCallbackFor: provider);		certificateCheck: self newCertificateCheckCallback;		yourself! !!LGitRemoteCallbacks methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!certificateCheck: aCallback	certificateCheckCallback := aCallback.	self prim_certificate_check: aCallback! !!LGitRemoteCallbacks methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!credentials	^ self prim_credentials! !!LGitRemoteCallbacks methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!credentials: aCredentialsCallback	credentialsCallback := aCredentialsCallback.	self prim_credentials: credentialsCallback! !!LGitRemoteCallbacks methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!initializeWithDefaults	self withReturnHandlerDo: [		self			remote_init_callbacks: self			version: LGitStructVersionsEnum git_remote_callbacks_version_1 ]! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_certificate_check	"This method was automatically generated"	^LGitTransportCertificateCheckCallback forAddress: ((handle pointerAt: OFFSET_PRIM_CERTIFICATE_CHECK) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_certificate_check: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_CERTIFICATE_CHECK		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_completion	"This method was automatically generated"	^LGitCompletionCallback forAddress: ((handle pointerAt: OFFSET_PRIM_COMPLETION) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_completion: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_COMPLETION		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_credentials	"This method was automatically generated"	^LGitCredAcquireCallback forAddress: ((handle pointerAt: OFFSET_PRIM_CREDENTIALS) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_credentials: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_CREDENTIALS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_pack_progress	"This method was automatically generated"	^LGitPackbuilderProgressCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PACK_PROGRESS) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_pack_progress: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PACK_PROGRESS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_payload	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_PAYLOAD) type: ExternalType void asPointerType! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_payload: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_PAYLOAD put: anObject getHandle.! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_push_negotiation	"This method was automatically generated"	^LGitPushNegotiationCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PUSH_NEGOTIATION) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_push_negotiation: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PUSH_NEGOTIATION		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_push_transfer_progress	"This method was automatically generated"	^LGitPushTransferProgressCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PUSH_TRANSFER_PROGRESS) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_push_transfer_progress: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PUSH_TRANSFER_PROGRESS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_push_update_reference	"This method was automatically generated"	^LGitPushUpdateReferenceCallback forAddress: ((handle pointerAt: OFFSET_PRIM_PUSH_UPDATE_REFERENCE) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_push_update_reference: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_PUSH_UPDATE_REFERENCE		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_sideband_progress	"This method was automatically generated"	^LGitTransportMessageCallback forAddress: ((handle pointerAt: OFFSET_PRIM_SIDEBAND_PROGRESS) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_sideband_progress: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_SIDEBAND_PROGRESS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_transfer_progress	"This method was automatically generated"	^LGitTransferProgressCallback forAddress: ((handle pointerAt: OFFSET_PRIM_TRANSFER_PROGRESS) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_transfer_progress: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_TRANSFER_PROGRESS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_transport	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PRIM_TRANSPORT) type: ExternalType void asPointerType! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_transport: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PRIM_TRANSPORT put: anObject getHandle.! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_update_tips	"This method was automatically generated"	^LGitUpdateTipsCallback forAddress: ((handle pointerAt: OFFSET_PRIM_UPDATE_TIPS) asInteger)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_update_tips: anObject	"This method was automatically generated"	handle 		pointerAt: OFFSET_PRIM_UPDATE_TIPS		put: (anObject 			ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]			ifNil: [ ExternalAddress null ])! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version	"This method was automatically generated"	^LGitStructVersionsEnum fromInteger: (handle unsignedLongAt: OFFSET_PRIM_VERSION)! !!LGitRemoteCallbacks methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_version: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_VERSION put: anObject value! !!LGitRemoteCallbacks methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_init_callbacks: opts version: version 	^ self		call: #(LGitReturnCodeEnum git_remote_init_callbacks(LGitRemoteCallbacks * self, LGitStructVersionsEnum version))		options: #(  )! !!LGitStructWithDefaults class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!defaults	^ self externalNew		initializeWithDefaults;		yourself! !!LGitStructWithDefaults methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!initialize	super initialize.		"Options are only ever used during a single setup function call.	The contents of the struct are then copied to a libgit2 internal	struct."	self autoRelease! !!LGitStructWithDefaults methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!initializeWithDefaults	self subclassResponsibility! !!LGitTime class methodsFor: 'fields description' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(	int64 time;	int offset;	)! !!LGitTime class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!fromDateAndTime: aDateAndTime	^ self new 		time: aDateAndTime asUnixTime;		offset: aDateAndTime offset asMinutes asInteger;		yourself! !!LGitTime methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!= anObject	^ self == anObject		or: [ self class == anObject class			and: [ self time = anObject time				and: [  self offset = anObject offset ] ] ]! !!LGitTime methodsFor: 'converting' stamp: ' 7/24/2017 12:50:03'!asDateAndTime	^ (DateAndTime fromUnixTime: self time) 		offset: self offset;		yourself! !!LGitTime methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!hash	^ (super hash bitXor: self time) bitXor: self offset! !!LGitTime methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!objectPrintOn: aStream	self asDateAndTime printOn: aStream! !!LGitTime methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!offset	^ self prim_offset! !!LGitTime methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!offset: anInteger	self prim_offset: anInteger! !!LGitTime methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_offset	"This method was automatically generated"	^handle signedLongAt: OFFSET_PRIM_OFFSET! !!LGitTime methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_offset: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_PRIM_OFFSET put: anObject! !!LGitTime methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_time	"This method was automatically generated"	^handle signedLongLongAt: OFFSET_PRIM_TIME! !!LGitTime methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_time: anObject	"This method was automatically generated"	handle signedLongLongAt: OFFSET_PRIM_TIME put: anObject! !!LGitTime methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!time	^ self prim_time! !!LGitTime methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!time: anInteger	^ self prim_time: anInteger! !!LGitTransferProgress class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fieldsDesc	^#(	uint total_objects;	uint indexed_objects;	uint received_objects;	uint local_objects;	uint total_deltas;	uint indexed_deltas;	size_t received_bytes;	)! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_indexed_deltas	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_INDEXED_DELTAS! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_indexed_deltas: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_INDEXED_DELTAS put: anObject! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_indexed_objects	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_INDEXED_OBJECTS! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_indexed_objects: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_INDEXED_OBJECTS put: anObject! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_local_objects	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_LOCAL_OBJECTS! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_local_objects: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_LOCAL_OBJECTS put: anObject! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_received_bytes	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_RECEIVED_BYTES! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_received_bytes: anObject	"This method was automatically generated"	^handle platformUnsignedLongAt: OFFSET_PRIM_RECEIVED_BYTES put: anObject! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_received_objects	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_RECEIVED_OBJECTS! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_received_objects: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_RECEIVED_OBJECTS put: anObject! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_total_deltas	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_TOTAL_DELTAS! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_total_deltas: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_TOTAL_DELTAS put: anObject! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_total_objects	"This method was automatically generated"	^handle unsignedLongAt: OFFSET_PRIM_TOTAL_OBJECTS! !!LGitTransferProgress methodsFor: 'libgit-fields' stamp: ' 7/24/2017 12:50:03'!prim_total_objects: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_PRIM_TOTAL_OBJECTS put: anObject! !!LGitSafeFFICalloutAPI methodsFor: 'action' stamp: ' 7/24/2017 12:50:03'!newBuilder	^ LGitSafeFFICalloutMethodBuilder calloutAPI: self! !!String methodsFor: '*libgit-core' stamp: ' 7/24/2017 12:50:03'!asLGitExternalString	| data |	data := ExternalData		fromHandle: (ExternalAddress allocate: self size + 1)		type: ExternalType char asPointerType.	LibC memCopy: self to: data size: self size.	data getHandle byteAt: self size + 1 put: 0.	^ data! !!LGitCredentialsFreeCallout methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!credentials: credentials	^ self		call: #(void #(LGitCredentials * credentials))		options: #(optMayGC)! !!LGitWritepackAppendCallout methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!writepack: writepack buffer: buffer length: length progress: progress		^ self		call:			#(int #(LGitOdbWritepack * writepack , void * buffer , int length , LGitTransferProgress * progress))		options: #(optMayGC)! !!LGitWritepackCommitCallout methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!writepack: writepack progress: progress	^ self		call: #(int #(LGitOdbWritepack *writepack , LGitTransferProgress *progress))		options: #(optMayGC)! !!LGitWritepackFreeCallout methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!writepack: writepack	^ self call: #(void #(LGitOdbWritepack *writepack)) options: #()! !!LGitExternalObject class methodsFor: 'finalization' stamp: ' 7/24/2017 12:50:03'!finalizeResourceData: aHandle	"Call the class specific free frunction if aHandle is still a valid external address."	aHandle isNull ifTrue: [ ^self ].	self perform: self freeFunctionSelector with: aHandle.	aHandle beNull! !!LGitExternalObject class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #object_free:! !!LGitExternalObject class methodsFor: 'as yet unclassified' stamp: ' 7/24/2017 12:50:03'!fromHandle: aHandle	^self basicNew setHandle: aHandle! !!LGitExternalObject class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!object_free: handle 	"We pass a handle in here instead of the object. We can't pass the object since that	has already been gc'ed."	^self call: #(void git_object_free(void *handle)) options: #(  )! !!LGitExternalObject methodsFor: 'initialize-release' stamp: ' 7/24/2017 12:50:03'!free	handle isExternalAddress 		ifTrue: [ 			self class finalizeResourceData: handle.			self assert: handle isNull ]! !!LGitExternalObject methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isReady	^ self isNull not! !!LGitExternalObject methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!shouldContinuePrintingOn: aStream	self ifNotReady: [ aStream nextPutAll: ' (<not initialized>)' ].		^ self isReady! !!LGitOdb class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #odb_free:! !!LGitOdb class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!odb_free: handle		^ self call: #(void git_odb_free #(void *handle)) options: #()! !!LGitPackBuilder class methodsFor: 'native-boost' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #packbuilder_free:! !!LGitPackBuilder class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!packbuilder_free: handle		^ self		call: #(void git_packbuilder_free #(void *handle))		options: #()! !!LGitPackBuilder methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!packbuilder_foreach: pb cb: cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_packbuilder_foreach #(self , LGitPackbuilderForeachCallback cb ,  void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitPackBuilder methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!packbuilder_insert_commit: pb id: id		^ self		call:			#(LGitReturnCodeEnum git_packbuilder_insert_commit #(self , LGitId * id))		options: #(optMayGC)! !!LGitPackBuilder methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!packbuilder_insert_tree: pb id: id		^ self		call: #(LGitReturnCodeEnum git_packbuilder_insert_tree #(self , LGitId * id))		options: #(optMayGC)! !!LGitPackBuilder methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!packbuilder_new: out repo: repo		^ self		callUnchecked:			#(LGitReturnCodeEnum git_packbuilder_new #(LGitPackBuilder * self , LGitRepository repo))		options: #()! !!LGitRepository class methodsFor: 'native-boost' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #repository_free:! !!LGitRepository class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!new	self error: 'This class should be instantiated with a give path.'! !!LGitRepository class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!on: aFileReference	LGitGlobal checkInitialized.	^ self basicNew		initialize;		initializeOn: aFileReference! !!LGitRepository class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_free: handle		^ self call: #(void git_repository_free #(void *handle)) options: #()! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!addRemote: aName url: anUrl	(LGitRemote of: self named: aName url: anUrl) createWithoutSpec! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!allBranches	^ OrderedCollection new: 10 streamContents: [ :stream |		self allBranchesDo: [ :reference | 			stream nextPut: reference ] ]! !!LGitRepository methodsFor: 'enumerating' stamp: ' 7/24/2017 12:50:03'!allBranchesDo: aBlock	LGitBranchIterator allBranchesOf: self do: aBlock! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!allRemotes	| out |		out := LGitStringArray externalNew autoRelease.	self remote_list: out.	^ out strings collect: [ :each | (LGitRemote of: self named: each) lookup ]! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!beOpen	isOpen := true! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!branchNames	^ self branches collect: #name! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!branch_lookup: out branch_name: branch_name branch_type: branch_type		^ self		call:			#(LGitReturnCodeEnum git_branch_lookup #(LGitReference * out , self , String branch_name , LGitBranchTypeEnum branch_type))		options: #()! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!branches	^ OrderedCollection new: 10 streamContents: [ :stream |		self branchesDo: [ :reference | stream nextPut: reference ] ]! !!LGitRepository methodsFor: 'enumerating' stamp: ' 7/24/2017 12:50:03'!branchesDo: aBlock	LGitBranchIterator localBranchesOf: self do: aBlock.! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!checkout: aString	<todo: 'use proper exceptions'>	self assert: aString notNil.	self assert: aString trimBoth notEmpty.	[ 		| branch |		branch := self lookupLocalBranch: aString ifAbsent: [ self createBranchFromOrigin: aString ].		self checkout_treeish: branch object.		self setHead: branch.	] 	on: LGit_GIT_EINVALIDSPEC, LGit_GIT_ENOTFOUND do: [		"aString is not a valid branch name, so try to find a corresponding treeish using revparse, 		this will handle stuff like 'master~1'"		| commitish | 		commitish := self revparse: aString.		self checkout_treeish: commitish.		self setHeadDetached: commitish.	].! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!checkoutHead	self withReturnHandlerDo: [ 		self checkout_head_opts: (			LGitCheckoutOptions defaults				checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_safe;				yourself) ]! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!checkout_head_opts: opts	^ self		call:			#(LGitReturnCodeEnum git_checkout_head #(self , LGitCheckoutOptions * opts))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!checkout_treeish: treeish	"treeish can be a commit, tag or tree (or NULL to use HEAD)"	self withReturnHandlerDo: [ 		self			checkout_treeish: treeish			opts:				(LGitCheckoutOptions defaults					checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_safe;					yourself) ].! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!checkout_treeish: treeish opts: opts	^ self		call:			#(LGitReturnCodeEnum git_checkout_tree #(self , LGitObject treeish , LGitCheckoutOptions * opts))		options: #()! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!clone: aString	| cloneOptions |	cloneOptions := LGitCloneOptions defaults.	self		clone: aString		options: cloneOptions	! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!clone: aString options: cloneOptions	self		clone: aString		options: cloneOptions		to: self repositoryReference! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!clone: aString options: cloneOptions to: aFileReference	<todo: 'use exceptions instead of assertion'>	self assert: aString isEmptyOrNil not.	self assert: aFileReference notNil.	self assert: cloneOptions notNil.		aFileReference ensureCreateDirectory.		self withReturnHandlerDo: [ 		self 			clone: self			url: aString			local_path: aFileReference pathString			options: cloneOptions ]! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!clone: out url: url local_path: local_path options: options		^ self		callUnchecked:			#(LGitReturnCodeEnum git_clone (LGitRepository *out, String url, String local_path, LGitCloneOptions *options))		options: #(optCoerceNilToNull)! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!clone: aString withCredentials: aCredentialsProvider 	| cloneOptions |	cloneOptions := LGitCloneOptions withCredentialsProvider: aCredentialsProvider.	self		clone: aString		options: cloneOptions	! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!cloneHttps: aString	<todo: 'use exceptions instead of assertion'>	self assert: (aString beginsWith: 'https://').		self clone: aString! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!cloneLocal: aString	self clone: aString! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!cloneRemote: aRemote signature: aSignature	self		cloneRemote: aRemote		signature: aSignature		branch: 'master'! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!cloneRemote: aRemote signature: aSignature branch: aString	self		cloneRemote: aRemote		signature: aSignature		branch: aString		checkoutOptions: LGitCheckoutOptions defaults! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!cloneRemote: aRemote  signature: aSignature branch: aString checkoutOptions: options	<todo: 'use exceptions instead of assertions'>	self assert: aRemote hasFetchSpec.		self withReturnHandlerDo: [		self 			clone_into: self			remote: aRemote			co_opts: options			branch: aString			signature: aSignature ]! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!cloneSsh: aString	| credentials cloneOptions |	credentials := LGitRemote credentialsSsh.	cloneOptions := LGitCloneOptions withCredentialsCallback: 		[ :cred :url :username_from_url :allowed_types :data | 			allowed_types = 32 				ifTrue: [ credentials setGitUsernameIn: cred ]				ifFalse: [ credentials createWith: cred ].			0 		].		self		clone: aString		options: cloneOptions	! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!config	| config |	config := (LGitConfig of: self) autoRelease.	self withReturnHandlerDo: [ self repository_config: config ].	^ config! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!create	self exists ifTrue: [ ^ self ].		self repositoryReference ensureCreateDirectory! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createBranch: aString force: aBoolean	<todo: 'this method belongs somewhere else and should allow to specify the target'>	| reference |	reference := LGitReference of: self.	reference createSymbolic: 'refs/heads/' , aString target: 'refs/dummy' force: aBoolean.	^ reference! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createBranch: aString target: aGitReference	<todo: 'this method belongs somewhere else'>	^ self createBranch: aString target: aGitReference force: false! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createBranch: aString target: aGitReference force: aBoolean	<todo: 'this method belongs somewhere else'>	| reference |	reference := LGitReference of: self.	reference 		createDirect: 'refs/heads/' , aString 		target: aGitReference object id 		force: aBoolean.	^ reference! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createBranch: aString targetId: aGitId force: aBoolean	<todo: 'this method belongs somewhere else'>	| reference |	reference := LGitReference of: self.	reference createDirect: 'refs/heads/' , aString target: aGitId force: aBoolean.	^ reference! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createBranchFromOrigin: branchName	| remoteBranchName remoteBranch localBranch |	remoteBranchName := 'origin/', branchName.	remoteBranch := self lookupRemoteBranch: remoteBranchName.	localBranch := self createBranch: branchName target: remoteBranch.	localBranch setUpstream: remoteBranchName.	^ localBranch! !!LGitRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!createPackForReference: aReference	| odb walk packbuilder writepack stats packbuilderPayload progresscb packbuilderCallback |	odb := self database.	walk := (LGitRevwalk of: self)		beSortedByCommitTime;		pushReference: aReference;		yourself.	packbuilder := LGitPackBuilder new.	packbuilder packbuilder_new: packbuilder repo: self.	"hideCallback := LG2RevwalkHideCb on: [ :oid :payload |  ].	LG2RevwalkH uniqueInstance		revwalk_add_hide_cb: walk		hide_cb: hideCallback		payload: nil."	[ walk hasNext ] whileTrue: [ 		| commit tree |		commit := walk next.		tree := commit tree.		packbuilder			packbuilder_insert_commit: packbuilder id: commit id;			packbuilder_insert_tree: packbuilder id: tree id.		commit free.		tree free ].	progresscb := LGitTransferProgressCallback on: [ :progress :data | 0 ].	writepack := LGitOdbWritepack externalNew.	writepack		odb_write_pack: writepack		db: odb		progress_cb: progresscb		progress_payload: ExternalAddress null.	writepack := LGitOdbWritepack fromHandle: writepack getHandle pointer.	stats := LGitTransferProgress externalNew.	packbuilderPayload := LGitPackbuilderForeachPayload externalNew.	packbuilderCallback := LGitPackbuilderForeachCallback		on: [ :buffer :length :payload | payload writepack appendWithBuffer: buffer length: length progress: payload stats ].	packbuilderPayload		writepack: writepack;		stats: stats.	packbuilder packbuilder_foreach: packbuilder cb: packbuilderCallback payload: packbuilderPayload.	writepack commitWithProgress: stats! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createTag: aString targetId: aGitId force: aBoolean	"Create a tag. Based on #createBranch:targetId:force:"	| reference |	reference := LGitReference of: self.	reference		createDirect: 'refs/tags/', aString		target: aGitId		force: aBoolean.	^ reference! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!database	| database |	database := LGitOdb new.	self withReturnHandlerDo: [		self			repository_odb: database			repo: self ].			^ database! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!defaultSignature	| signaturePointer |	signaturePointer := ExternalAddress new.	self withReturnHandlerDo: [ self signature_default: signaturePointer repo: self ].	^ LGitSignature fromHandle: signaturePointer! !!LGitRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!deleteAllLooseObjectsForReference: aReference	(self repositoryReference / '.git' / 'objects') children		select: [ :entry | entry basename ~= 'pack' ]		thenDo: [ :entry | entry deleteAll ].		"raise an exception if not resolvable"	self head	"	| walker oid baseReference |	walker := LGitRevwalkType new.	LG2RevwalkH uniqueInstance		revwalk_new: walker		repo: self.	LG2RevwalkH uniqueInstance		revwalk_sorting: walker		sort_mode: 2.	LG2RevwalkH uniqueInstance		revwalk_push_ref: walker		refname: aReference name.	baseReference := aReference repository repositoryReference / '.git' / 'objects'.	oid := LGitId new.	[ (LG2RevwalkH uniqueInstance		revwalk_next: oid		walk: walker) isZero ] whileTrue: [			| fileReference |			fileReference := baseReference resolve: oid asRelativePathString.			fileReference delete.			fileReference parent hasChildren ifFalse: [ fileReference parent delete ] ]"! !!LGitRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!exists	^ self repositoryReference exists! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!fastForward	<todo: 'check for conflicts'>	"currently forces fastForward in every case"	self head resolve setTarget: (self lookup: 'FETCH_HEAD')! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!fetchFrom: remoteName 	(LGitRemote of: self named: remoteName) 		lookup; 		fetch! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!head	| head |	head := LGitReference of: self.	self withReturnHandlerDo: [ self repository_head: head of: self ].	^ head! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!index	| index |	index := LGitIndex of: self.	self withReturnHandlerDo: [ self repository_index: index repo: self ].	^ index! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!init	self initBare: false! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!initBare: aBoolean	self withReturnHandlerDo: [		self			repository_init: self			path: self repositoryReference pathString			is_bare: aBoolean ].	self autoRelease ! !!LGitRepository methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!initializeOn: aFileReference	repositoryPath := aFileReference! !!LGitRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isBare	^ self repository_is_bare: self! !!LGitRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isDirty: aFileReference	^ self index isDirty: aFileReference! !!LGitRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isEmpty	self exists ifFalse: [ ^ true ].		^ self repository_is_empty: self! !!LGitRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isInitialized	^ self isReady! !!LGitRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isOpen	^ isOpen ifNil: [ false ]! !!LGitRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isProperRepository	| return |	return := self		repository_open_ext: self		path: self repositoryReference pathString		flags: LGitOpenFlagEnum git_repository_open_no_search		ceiling_dirs: nil.			^ return isOk! !!LGitRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isUnborn	^ self repository_is_unborn: self! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/24/2017 12:50:03'!lookup: name	| reference |	reference := LGitReference of: self.	self withReturnHandlerDo: [		self			reference_lookup: reference			repo: self			shorthand: name ].			^ reference! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/24/2017 12:50:03'!lookupBranch: name	^ (name includes: $/)		ifTrue: [ self lookupRemoteBranch: (name withoutPrefix: 'refs/remotes/') ]		ifFalse: [ self lookupLocalBranch: name ] ! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/24/2017 12:50:03'!lookupBranch: branchName inRemote: remoteName	^ self lookupRemoteBranch: remoteName, '/', branchName! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/24/2017 12:50:03'!lookupBranch: name type: branchType	| reference |	reference := LGitReference of: self.	self withReturnHandlerDo: [ 		self			branch_lookup: reference			branch_name: name			branch_type: branchType	].	^ reference! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/24/2017 12:50:03'!lookupLocalBranch: name	^ self lookupBranch: name type: LGitBranchTypeEnum git_branch_local ! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/24/2017 12:50:03'!lookupLocalBranch: name ifAbsent: aBlock	^ [ self lookupLocalBranch: name ]		on: LGit_GIT_ENOTFOUND 		do: aBlock ! !!LGitRepository methodsFor: 'lookup' stamp: ' 7/24/2017 12:50:03'!lookupRemoteBranch: name	^ self lookupBranch: name type: LGitBranchTypeEnum git_branch_remote! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!merge: aLGitAnnotatedCommit 	| heads |	heads := (FFIExternalArray externalNewType: LGitAnnotatedCommit size: 1) autoRelease;		at: 1 put: aLGitAnnotatedCommit handle;		yourself.	self withReturnHandlerDo: [		self merge_heads: heads 			length: 1 			merge_options: LGitMergeOptions defaults			checkout_options: LGitCheckoutOptions defaults 	]! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!mergeBaseBetween: aLGitId and: aLGitId2 	| base |	base := LGitId new.	self withReturnHandlerDo: [ self merge_base: base between: aLGitId and: aLGitId2 ].	^ base! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!merge_base: out between: one and: two	^ self call: #(	LGitReturnCodeEnum git_merge_base #(			LGitId * out, 			self, 			LGitId * one, 			LGitId * two))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!merge_heads: heads length: length merge_options: mergeOptions checkout_options: checkoutOptions		^ self		callUnchecked:			#(LGitReturnCodeEnum git_merge #(				self , 				FFIExternalArray heads ,				int length , 				LGitMergeOptions * mergeOptions ,				LGitCheckoutOptions * checkoutOptions))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!new_signature: out name:name email:email time:time		^ self		call:			#(LGitReturnCodeEnum git_signature_new #(void **out , String name, String email, LGitTime time, 0))		options: #()! !!LGitRepository methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!objectPrintOn: aStream	aStream nextPutAll: self repositoryReference fullName.	self isBare 		ifTrue: [ aStream nextPutAll: ' [bare]' ]! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!open	self withReturnHandlerDo: [ 		self			repository_open: self			bare_path: self repositoryReference pathString ].	self beOpen! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!origin	^ (LGitRemote of: self named: 'origin') lookup; yourself! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!packHead	<todo: 'This method is distructive. It will delete *all* objects, including those not in the pack (not reachable from head'>	"USE VERY CAREFULLY"		LGitGlobal runSequence: [ self createPackForReference: self head ].	self deleteAllLooseObjectsForReference: self head! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_lookup: out repo: repo shorthand: shorthand		^ self		call:			#(LGitReturnCodeEnum git_reference_lookup #(LGitReference * out , self , String shorthand))		options: #()! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!references	self notYetImplemented! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_list: out	^ self 		call: #( int git_remote_list ( LGitStringArray *out, self ) ) 		options: #()! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!repositoryReference	^ repositoryPath! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_config: config	^ self		call:			#(LGitReturnCodeEnum git_repository_config(LGitConfig *config, self))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_head: reference of: repository		^ self		call:			#(LGitReturnCodeEnum git_repository_head #(LGitReference * reference , self))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_index: out repo: repo		^ self		call: #(LGitReturnCodeEnum git_repository_index #(LGitIndex * out , self))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_init: out path: path is_bare: is_bare		^ self		callUnchecked:			#(int git_repository_init #(LGitRepository * out , String path , Boolean is_bare))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_is_bare: repo		^ self call: #(Boolean git_repository_is_bare #(self)) options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_is_empty: repo		^ self call: #(Boolean git_repository_is_empty #(self)) options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_is_unborn: repo	^ self call: #( Boolean git_repository_head_unborn (self) ) options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_odb: out repo: repo		^ self		call: #(LGitReturnCodeEnum git_repository_odb #(LGitOdb * out , self))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_open: out bare_path: bare_path		^ self		callUnchecked:			#(LGitReturnCodeEnum git_repository_open #(LGitRepository * out , String bare_path))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_open_ext: out path: path flags: flags ceiling_dirs: ceiling_dirs		^ self		callUnchecked:			#(LGitReturnCodeEnum git_repository_open_ext #(LGitRepository * out , String path , LGitOpenFlagEnum flags , String ceiling_dirs))		options: #(optCoerceNilToNull optStringOrNull)! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_set_head: refname log_message: log_message		^ self		call:			#(int git_repository_set_head #(self , String refname , String log_message))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_set_head_detached: commitish		^ self		call:			#(int git_repository_set_head_detached #(self, LGitId * commitish))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!repository_workdir: repo		^ self call: #(String git_repository_workdir #(self)) options: #()! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!revparse: aString	"See git-rev-parse documentation.	Examples:		repository revparse: 'HEAD' 	# last commit		repository revparse: 'HEAD~5'	# 5 commits back from last commit		repository revparse: 'develop'	# last commit from develop branch	"	| object |	self assert: aString notNil.	self assert: aString trimBoth notEmpty.	object := LGitObject of: self.	self withReturnHandlerDo: [ 		self			revparse_single: object			repo: self			spec: aString ].	^ object concreteObject	! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!revparse_single: out repo: repo spec: spec		^ self		call:			#(LGitReturnCodeEnum git_revparse_single #(LGitObject * out , self , String spec))		options: #()! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!setHead: aLGitReference	self withReturnHandlerDo: [ 		self			repository_set_head: aLGitReference name			log_message: 'set head to refs/heads/' , aLGitReference name ]! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!setHeadDetached: commitish	self withReturnHandlerDo: [ 		self repository_set_head_detached: commitish id	]! !!LGitRepository methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!signatureWithName: name email: email dateTime: dateTime	| signaturePointer time |	signaturePointer := ExternalAddress new.	time := LGitTime fromDateAndTime: dateTime.	self		withReturnHandlerDo: [ self				new_signature: signaturePointer				name: name				email: email				time: time ].	^ LGitSignature fromHandle: signaturePointer! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!signature_default: out repo: repo		^ self		call:			#(LGitReturnCodeEnum git_signature_default #(void **out , self))		options: #()! !!LGitRepository methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tag_list: tag_names repo: repo		^ self		call:			#(LGitReturnCodeEnum git_tag_list #(LGitStringArray * tag_names , LGitRepository repo))		options: #()! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!tags	| array strings |	array := LGitStringArray externalNew.	self withReturnHandlerDo: [		self			tag_list: array			repo: self ].	strings := array strings.	array free.	^ strings	! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!workingDirectory	^ workingDirectory ifNil: [			workingDirectory := self withReturnHandlerDo: [				(self repository_workdir: self) asFileReference ] ]! !!LGitRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!workingDirectoryName	^ self isBare			ifTrue: [ nil ]			ifFalse: [ self workingDirectory basename ]! !!LGitAnnotatedCommit class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!annotated_commit_free: handle	^ self		call: #(void git_annotated_commit_free #(void *handle))		options: #()! !!LGitAnnotatedCommit class methodsFor: 'ligbit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #annotated_commit_free:! !!LGitAnnotatedCommit class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!fromRef: anLGitReference	^ (self of: anLGitReference repository) initializeFromRef: anLGitReference ! !!LGitAnnotatedCommit methodsFor: 'initialize' stamp: ' 7/24/2017 12:50:03'!annotated_commit_from_ref: ref	^ self callUnchecked: #(		int git_annotated_commit_from_ref #(			LGitAnnotatedCommit * self , 			LGitRepository repository ,			LGitReference ref)) 		options: #()! !!LGitAnnotatedCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!annotated_commit_id	 ^ self call: #(LGitId * git_annotated_commit_id #(self)) options: #()! !!LGitAnnotatedCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!id	^ self annotated_commit_id! !!LGitAnnotatedCommit methodsFor: 'initialize' stamp: ' 7/24/2017 12:50:03'!initializeFromRef: anLGitReference	self withReturnHandlerDo: [ 		self annotated_commit_from_ref: anLGitReference	].	self autoRelease! !!LGitBlame class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blame_free: handle	^ self call: #(void git_blame_free #(void *handle)) options: #()! !!LGitBlame class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #blame_free:! !!LGitBlame class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: aRepository on: aFileReference	^ (self of: aRepository)		getForReference: aFileReference;		yourself! !!LGitBlame methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blame_buffer: out reference: reference buffer: buffer buffer_len: buffer_len		^ self		callUnchecked:			#(FFIInt32 git_blame_buffer #(LGitBlame *self , LGitBlame reference , String buffer , size_t buffer_len))		options: #()! !!LGitBlame methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blame_file: out repo: repo path: path options: options		^ self		callUnchecked:			#(int git_blame_file #(LGitBlame * self , LGitRepository repo , String path , LGitBlameOptions * options))		options: #()! !!LGitBlame methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blame_get_hunk_byindex: blame index: index	"todo: using LGitBlameHunk* as return value causes random crashes"		^ self		call: #(void * git_blame_get_hunk_byindex #(self , uint32 index))		options: #()! !!LGitBlame methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blame_get_hunk_byline: blame lineno: lineno	"todo: using LGitBlameHunk* as return value causes random crashes"		^ self		call: #(void * git_blame_get_hunk_byline #(self , size_t lineno))		options: #()! !!LGitBlame methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blame_get_hunk_count: blame		^ self		call: #(uint32 git_blame_get_hunk_count #(self))		options: #()! !!LGitBlame methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!getForReference: aFileReference	^ self withReturnHandlerDo: [		self			blame_file: self			repo: self repository			path: ((aFileReference relativeTo: self repository repositoryReference) printWithDelimiter: $/)			options: LGitBlameOptions defaults ]! !!LGitBlame methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!hunkAt: anInteger	"use 1 based offset"	^ LGitBlameHunk fromExternalAddress: (		self			blame_get_hunk_byindex: self			index: anInteger - 1)! !!LGitBlame methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!hunkAtLineNumber: anInteger	"first line has index 1"	^ LGitBlameHunk fromExternalAddress: (		self			blame_get_hunk_byline: self			lineno: anInteger)! !!LGitBlame methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!numberOfHunks	^ self blame_get_hunk_count: self! !!LGitBranchIterator class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!allBranchesOf: repository do: aBlock	self 		of: repository 		branchType: LGitBranchTypeEnum git_branch_all		do: aBlock! !!LGitBranchIterator class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!branch_iterator_free: handle		^ self		call: #(void git_branch_iterator_free #(void *handle))		options: #()! !!LGitBranchIterator class methodsFor: 'native-boost' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #branch_iterator_free:! !!LGitBranchIterator class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!localBranchesOf: repository do: aBlock	self 		of: repository 		branchType: LGitBranchTypeEnum git_branch_local		do: aBlock! !!LGitBranchIterator class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: aRepository branchType: aLGitBranchTypeEnum do: aBlock	^ (self of: aRepository)		iterate: aLGitBranchTypeEnum;		branchesDo: aBlock! !!LGitBranchIterator class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!remoteBranchesOf: repository do: aBlock	self 		of: repository 		branchType: LGitBranchTypeEnum git_branch_remote		do: aBlock! !!LGitBranchIterator methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!branch_iterator_new: out repo: repo list_flags: list_flags		^ self		callUnchecked:			#(LGitReturnCodeEnum git_branch_iterator_new #(LGitBranchIterator * self , LGitRepository repo , LGitBranchTypeEnum list_flags))		options: #()! !!LGitBranchIterator methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!branch_next: out out_type: out_type	^ self		call:			#(LGitReturnCodeEnum git_branch_next #(				LGitReference * out ,				LGitWriteBackValueUInt * out_type,				LGitBranchIterator self))		options: #()! !!LGitBranchIterator methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!branchesDo: aBlock	| returnCode branchType reference finishedCode isLocal |		returnCode := LGitReturnCodeEnum git_ok.	finishedCode := LGitReturnCodeEnum git_iterover.	branchType := LGitWriteBackValueUInt new.		[ 		reference := LGitReference of: self repository.		returnCode := self branch_next: reference out_type: branchType.		isLocal := branchType value = LGitBranchTypeEnum git_branch_local value.		returnCode = finishedCode 	] 	whileFalse: [ aBlock cull: reference cull: isLocal ]! !!LGitBranchIterator methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!iterate: aLGitBranchTypeEnum	self repository signalIfNotReady.	self withReturnHandlerDo: [		self			branch_iterator_new: self			repo: self repository			list_flags: aLGitBranchTypeEnum ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!author	^ author ifNil: [		author := self repository defaultSignature ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!author: anLGitSignature	author := anLGitSignature! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!commitId	^ commitId ifNil: [ commitId := LGitId new ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!commitId: anLGitId	commitId := anLGitId! !!LGitCommitBuilder methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_create: theCommitId repo: repo update_ref: update_ref author: theAuthor committer: theCommitter message_encoding: message_encoding message: theMessage tree: theTree parent_count: parent_count parents: parentsPointer		<todo:		'try to use original function signature instead of passing ExternalAddress as last arg'>	^ self		callUnchecked:			#(LGitReturnCodeEnum git_commit_create #(LGitId * theCommitId , LGitRepository repo , String update_ref , LGitSignature * theAuthor , LGitSignature * theCommitter , String message_encoding , String theMessage , LGitTree theTree , int parent_count , void *parentsPointer))		options: #(optCoerceNilToNull)! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!committer	^ committer ifNil: [ 		committer := self repository defaultSignature ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!committer: anLGitSignature	committer := anLGitSignature! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!message	^ message ifNil: [ message := 'empty message' ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!message: aString	message := aString! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!messageEncoding	^ messageEncoding ifNil: [ 'UTF-8' ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!messageEncoding: aString	messageEncoding := aString! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!parents	^ parents ifNil: [ parents := #() ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!parents: aCollection	parents := aCollection! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!tree	<todo: 'use proper exceptions'>	^ tree ifNil: [ self error: 'need an existing tree here' ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!tree: anLGitTree	tree := anLGitTree! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!updateReference	^ updateReference! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!updateReference: aReference	updateReference := aReference! !!LGitCommitBuilder methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!writeCommit	| parentsPointer |	self withReturnHandlerDo: [ 		self assert: (self parents allSatisfy: #isReady).		parentsPointer := self parents			ifEmpty: [ ExternalAddress null ]			ifNotEmpty: [ (LGitExternalCommitArray fromCollection: self parents) getHandle ].	self withReturnHandlerDo: [ 		self			commit_create: self commitId			"libgit2 asserts the identity of this repository and the one it retrieves for the tree, so they need to be the same here"			repo: self tree owner 			update_ref: self updateReference			author: self author			committer: self committer			message_encoding: self messageEncoding			message: self message withUnixLineEndings			tree: self tree			parent_count: self parents size			parents: parentsPointer] ]! !!LGitCommitBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!writtenCommit	<todo: 'use proper exceptions'>	commitId ifNil: [ self error: 'haven''t written the commit yet!!' ].	^ LGitCommit of: self repository fromId: self commitId! !!LGitConfig class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!config_free: handle	^ self		call: #(void git_config_free #(void *handle))		options: #()! !!LGitConfig class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #config_free:! !!LGitConfig methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!config_get_string: name output: output	^ self call:			#(LGitReturnCodeEnum git_config_get_string_buf(				LGitBuf* output, 				self, 				String name))		options: #()! !!LGitConfig methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!config_open_global: out	^ self call: #(int git_config_open_global("LGitConfig **"void **out, self))! !!LGitConfig methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!config_set_bool: name to: value	^ self call:			#(LGitReturnCodeEnum git_config_set_bool(				self, 				String name, 				Boolean value))		options: #()! !!LGitConfig methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!config_set_string: name to: value	^ self call:			#(LGitReturnCodeEnum git_config_set_string(				self, 				String name, 				String value))		options: #()! !!LGitConfig methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!getString: name ifAbsent: aBlock	^ self getString: name ifPresent: #yourself ifAbsent: aBlock! !!LGitConfig methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!getString: name ifPresent: presentBlock ifAbsent: absentBlock	| buf |	buf := LGitBuf new.	^ [		self config_get_string: name output: buf.		buf prim_ptr readString 			ifNotEmpty: presentBlock			ifEmpty: absentBlock	]	ensure: [ buf free ]! !!LGitConfig methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!openGlobal	| outHandle |	outHandle := ExternalAddress null.	self config_open_global: outHandle.	^ (self class fromHandle: outHandle) autoRelease	! !!LGitConfig methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!setBoolean: aBoolean to: varName! !!LGitConfig methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!setString: name to: value	self config_set_string: name to: value! !!LGitDiff class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_free: handle		^ self call: #(void git_diff_free #(void *handle)) options: #()! !!LGitDiff class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #diff_free:! !!LGitDiff methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!deltaAt: anInteger	"use 1 based offset as in Smalltalk"	^ LGitDiffDelta fromHandle: (		self			diff_get_delta: self			idx: anInteger - 1) getHandle! !!LGitDiff methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!diffIndexToWorkDir	self diffIndexToWorkDirOptions: LGitDiffOptions defaults! !!LGitDiff methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!diffIndexToWorkDirOptions: anLGitDiffOptions	self withReturnHandlerDo: [		self			diff_index_to_workdir: self			repo: self repository			index: self repository index			opts: anLGitDiffOptions ]! !!LGitDiff methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!diffTree: oldTree toTree: newTree	self		diffTree: oldTree		toTree: newTree		options: LGitDiffOptions defaults! !!LGitDiff methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!diffTree: oldTree toTree: newTree options: anLGitDiffOptions	self withReturnHandlerDo: [		self			diff_tree_to_tree: self			repo: self repository			old_tree: oldTree			new_tree: newTree			opts: anLGitDiffOptions ]! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_blob_to_buffer: old_blob old_as_path: old_as_path buffer: buffer buffer_len: buffer_len buffer_as_path: buffer_as_path options: options file_cb: file_cb hunk_cb: hunk_cb line_cb: line_cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_diff_blob_to_buffer #(LGitBlob old_blob , String old_as_path , String buffer , size_t buffer_len , String buffer_as_path , LGitDiffOptions * options , LGitDiffFileCallback file_cb , LGitDiffHunkCallback hunk_cb , LGitDiffLineCallback line_cb , void * payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_blobs: old_blob old_as_path: old_as_path new_blob: new_blob new_as_path: new_as_path options: options file_cb: file_cb hunk_cb: hunk_cb line_cb: line_cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_diff_blobs (LGitBlob old_blob , String old_as_path , LGitBlob new_blob , String new_as_path , LGitDiffOptions *options , LGitDiffFileCallback file_cb , LGitDiffHunkCallback hunk_cb , LGitDiffLineCallback line_cb , void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_buffers: old_buffer old_len: old_len old_as_path: old_as_path new_buffer: new_buffer new_len: new_len new_as_path: new_as_path options: options file_cb: file_cb hunk_cb: hunk_cb line_cb: line_cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_diff_buffers #(FFIVoid * old_buffer , size_t old_len , String old_as_path , void *new_buffer , size_t new_len , String new_as_path , LGitDiffOptions * options , LGitDiffFileCallback file_cb , LGitDiffHunkCallback hunk_cb , LGitDiffLineCallback line_cb , void * payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_foreach: diff file_cb: file_cb binary_cb: binary_cb hunk_cb: hunk_cb line_cb: line_cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_diff_foreach #(self , LGitDiffFileCallback file_cb , LGitDiffBinaryCallback binary_cb , LGitDiffHunkCallback hunk_cb , LGitDiffLineCallback line_cb , void * payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_get_delta: diff idx: idx	<todo: 'use LGitDiffDelta* as return type'>		^ self		call: #(void *git_diff_get_delta #(self , size_t idx))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_get_perfdata: out diff: diff		^ self		call:			#(LGitReturnCodeEnum git_diff_get_perfdata #(LGitDiffPerfData * out , self))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_get_stats: out diff: diff		^ self		call: #(LGitReturnCodeEnum git_diff_get_stats #(LGitDiffStats * out , self))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_index_to_workdir: diff repo: repo index: index opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_diff_index_to_workdir #(LGitDiff * self , LGitRepository repo , LGitIndex index , LGitDiffOptions * opts))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_is_sorted_icase: diff		^ self call: #(Boolean git_diff_is_sorted_icase #(self)) options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_num_deltas: diff		^ self call: #(size_t git_diff_num_deltas #(self)) options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_num_deltas_of_type: diff type: type		^ self		call: #(size_t git_diff_num_deltas_of_type #(self , LGitDeltaTypeEnum type))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_print: diff format: format print_cb: print_cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_diff_print #(self , LGitDiffFormatTypeEnum format , LGitDiffLineCallback print_cb , void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_status_char: status		^ self		call: #(Character git_diff_status_char #(LGitDeltaTypeEnum status))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_tree_to_index: diff repo: repo old_tree: old_tree index: index opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_diff_tree_to_index #(LGitDiff * self , LGitRepository repo , LGitTree old_tree , LGitIndex index , LGitDiffOptions * opts))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_tree_to_tree: diff repo: repo old_tree: old_tree new_tree: new_tree opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_diff_tree_to_tree #(LGitDiff * diff , LGitRepository repo , LGitTree old_tree , LGitTree new_tree , LGitDiffOptions * opts))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_tree_to_workdir: diff repo: repo old_tree: old_tree opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_diff_tree_to_workdir #(LGitDiff * self , LGitRepository repo , LGitTree old_tree , LGitDiffOptions * opts))		options: #()! !!LGitDiff methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_tree_to_workdir_with_index: diff repo: repo old_tree: old_tree opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_diff_tree_to_workdir_with_index #(LGitDiff * self , LGitRepository repo , LGitTree old_tree , LGitDiffOptions * opts))		options: #()! !!LGitDiff methodsFor: 'enumerating' stamp: ' 7/24/2017 12:50:03'!filesDo: filesBlockOrNil binaryFilesDo: binaryBlockOrNil hunksDo: hunksBlockOrNil linesDo: linesBlockOrNil	^ self		diff_foreach: self		file_cb: (filesBlockOrNil 			ifNotNil: [ LGitDiffFileCallback on: filesBlockOrNil ]			ifNil: [ LGitCallback null ])		binary_cb: (binaryBlockOrNil 			ifNotNil: [ 	LGitDiffBinaryCallback on: binaryBlockOrNil ]			ifNil: [ LGitCallback null ])		hunk_cb: (hunksBlockOrNil 			ifNotNil: [ 	LGitDiffHunkCallback on: hunksBlockOrNil ]			ifNil: [ LGitCallback null ])		line_cb: (linesBlockOrNil 			ifNotNil: [ 	LGitDiffLineCallback on: linesBlockOrNil ]			ifNil: [ LGitCallback null ])		payload: ExternalAddress null! !!LGitDiff methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!numberOfDeltas	^ self diff_num_deltas: self! !!LGitDiff methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!patchAt: anInteger	^ LGitPatch		fromDiff: self		at: anInteger! !!LGitDiffStats class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_stats_free: handle		^ self call: #(void git_diff_stats_free #(void *handle)) options: #()! !!LGitDiffStats class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #diff_stats_free:! !!LGitDiffStats methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_stats_deletions: stats		^ self		call: #(size_t git_diff_stats_deletions #(self))		options: #()! !!LGitDiffStats methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_stats_files_changed: stats		^ self		call: #(size_t git_diff_stats_files_changed #(self))		options: #()! !!LGitDiffStats methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_stats_insertions: stats		^ self		call: #(size_t git_diff_stats_insertions #(self))		options: #()! !!LGitDiffStats methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_stats_to_buf: out stats: stats format: format width: width		^ self		call:			#(LGitReturnCodeEnum git_diff_stats_to_buf #(LGitBuffer out , self , LGitDiffStatsFormatTypeEnum format , size_t width))		options: #()! !!LGitIndex class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #index_free:! !!LGitIndex class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!index_free: handle		^ self call: #(void git_index_free #(void *handle)) options: #()! !!LGitIndex methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!addAll	| pathspec |	pathspec := LGitStringArray withAll: #().	self withReturnHandlerDo: [ 		self			index_add_all: self			pathspec: pathspec			flags: 0			callback: (LGitIndexMatchedPathCallback on: [ :a :b :c | 0 ])			payload: ExternalAddress null ]! !!LGitIndex methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!addAll: pathSpecs	| pathspec |	pathspec := LGitStringArray withAll: pathSpecs.	self withReturnHandlerDo: [ 		self			index_add_all: self			pathspec: pathspec			flags: 0			callback: (LGitIndexMatchedPathCallback on: [ :a :b :c | 0 ])			payload: ExternalAddress null ]! !!LGitIndex methodsFor: 'enumerating' stamp: ' 7/24/2017 12:50:03'!allFilesStatusDo: aBlock	"The callback is passed the path of the file, the status (a combination of the git_status_t values above) and the payload data pointer passed into this function.If the callback returns a non-zero value, this function will stop looping and return that value to caller."	self withReturnHandlerDo: [ 		self			status_foreach: self repository			callback: (LGitStatusCallback on: aBlock)			payload: nil ]! !!LGitIndex methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!checkout	self withReturnHandlerDo: [ 		self checkout_index_withOptions: 			(LGitCheckoutOptions defaults				checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_force;				yourself) ]! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!checkout_index_withOptions: opts	^ self		call: #(LGitReturnCodeEnum 			git_checkout_index(				LGitRepository repository, 				self, 				LGitCheckoutOptions *opts))		options: #()! !!LGitIndex methodsFor: 'enumerating' stamp: ' 7/24/2017 12:50:03'!entriesSelect: aBlock	| entries |	entries := OrderedCollection new.	self allFilesStatusDo: [ :path :status :payload |		(aBlock value: path value: status) ifTrue: [ entries add: {path. status. payload} ].		0 ].		^ entries! !!LGitIndex methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!entryCount	^ self index_entrycount: self! !!LGitIndex methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!forceRefresh	self withReturnHandlerDo: [ 		self			index_read: self			force: true ]! !!LGitIndex methodsFor: 'hack' stamp: ' 7/24/2017 12:50:03'!hackOwner: aRepository	"There is a bug in version 0.23 of libgit2, the returned index does not have an 	 owner (a pointer to a repository), as you would expect from the documentation. 	This breaks libgit encapsulation, and will probably fail if updating to a newer 	version, but anyway if we migrate this bug should be fixed."	self flag: #fixMe. "When possible :)"	"	NOTE: is Smalltalk wordSize + 1 because the structure is something like: 	struct git_index {		git_refcount rc; 		...	}		then:		struct git_refcount { 		git_atomic refcount;		void *owner;	}		and finally: 	git_atomic = int -> 32bits	git_atomic = int64_t -> 64bits		So we need to ensure the owner is set properly.	"	self handle 		pointerAt: Smalltalk wordSize + 1		put: repository handle! !!LGitIndex methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!hasConflicts	^ self index_has_conflicts asBoolean! !!LGitIndex methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!hasEntry: aString	^ self withReturnHandlerDo: [ 		self			index_find: nil			index: self			path: aString ]! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!index_add_all: index pathspec: pathspec flags: flags callback: callback payload: payload		^ self		call:			#(LGitReturnCodeEnum git_index_add_all #(				self, 				LGitStringArray *pathspec, 				uint flags, 				LGitIndexMatchedPathCallback callback, 				void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!index_entrycount: index		^ self call: #(size_t git_index_entrycount #(self)) options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!index_find: at_pos index: index path: path		^ self		call:			#(LGitReturnCodeEnum git_index_find #(LGitWriteBackValueSizeT *at_pos , self, String path))		options: #(optCoerceNilToNull)! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!index_has_conflicts 	^ self call: #(LGitReturnCodeEnum git_index_has_conflicts #(self)) options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!index_owner	^ self call: #(LGitRepository * git_index_owner (LGitIndex self)) options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!index_path	^ self		call: #(String git_index_path #(self))		options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!index_read: index force: force		^ self		call: #(LGitReturnCodeEnum git_index_read #(self , Boolean force))		options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!index_remove_all: index pathspec: pathspec callback: callback payload: payload		^ self		call:			#(LGitReturnCodeEnum git_index_remove_all #(self, LGitStringArray * pathspec, LGitIndexMatchedPathCallback callback, void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!index_update_all: index pathspec: pathspec callback: callback payload: payload		^ self		call:			#(LGitReturnCodeEnum git_index_update_all #(self, LGitStringArray *pathspec, LGitIndexMatchedPathCallback callback, void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!index_write	^ self		call: #(LGitReturnCodeEnum git_index_write #(self))		options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!index_write_tree: out index: index		^ self		call: #(LGitReturnCodeEnum git_index_write_tree #(LGitId * out , self))		options: #()! !!LGitIndex methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isBeingTracked: aString	| intValue |	(self repository repositoryReference resolve: aString) isDirectory ifTrue: [ ^ true ].		intValue := LGitWriteBackValueUInt new.	self withReturnHandlerDo: [ 		self			status_file: intValue			repo: self repository			path: aString ].	^ (LGitStatusTypeEnum  git_status_wt_new isPartOfBitFlag: intValue value) not! !!LGitIndex methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isDirty: aFileReference	| intValue |	intValue := LGitWriteBackValueInt new.	self withReturnHandlerDo: [		self			status_file: intValue			repo: self repository			path: ((aFileReference relativeTo: self repository repositoryReference) printWithDelimiter: $/) ].			^ intValue value isZero not! !!LGitIndex methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!owner	^ self index_owner! !!LGitIndex methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!path	^ self index_path! !!LGitIndex methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!removeAll	| pathspec |	pathspec := LGitStringArray withAll: #().	self withReturnHandlerDo: [ 		self			index_remove_all: self			pathspec: pathspec			callback: (LGitIndexMatchedPathCallback on: [ :a :b :c | 0 ])			payload: nil ]! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!status_file: status_flags repo: repo path: path		^ self		call:			#(LGitReturnCodeEnum git_status_file #(LGitWriteBackValueUInt status_flags, LGitRepository repo, String path))		options: #()! !!LGitIndex methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!status_foreach: repo callback: callback payload: payload		^ self		call:			#(LGitReturnCodeEnum git_status_foreach #(LGitRepository repo, LGitStatusCallback callback, void * payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitIndex methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!updateAll	| pathspec |	pathspec := LGitStringArray withAll: { '*' }.	self withReturnHandlerDo: [ 		self			index_update_all: self			pathspec: pathspec			callback: (LGitIndexMatchedPathCallback on: [ :a :b :c | 0 ])			payload: nil ]! !!LGitIndex methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!writeToDisk	self withReturnHandlerDo: [ self index_write ]! !!LGitIndex methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!writeTreeAndReturnOid	| oid |	oid := LGitId externalNew.	self withReturnHandlerDo: [ 		self			index_write_tree: oid			index: self ].			^ oid! !!LGitBlob class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blob_create_frombuffer: objectId repo: repo buffer: buffer len: len		^ self		call:			#(LGitReturnCodeEnum git_blob_create_frombuffer #(LGitId * objectId , LGitRepository repo , void  *buffer , size_t len))		options: #()! !!LGitBlob class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blob_create_fromdisk: objectId repo: repo path: path		^ self		call:			#(LGitReturnCodeEnum git_blob_create_fromdisk #(LGitId * objectId , LGitRepository repo , FFIExternalString path))		options: #()! !!LGitBlob class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blob_free: handle		^ self		call: 	#(void git_blob_free(void *handle))		options: #()! !!LGitBlob class methodsFor: 'accessing-defaults' stamp: ' 7/24/2017 12:50:03'!defaultFilemode	^ LGitFilemodeEnum git_filemode_blob! !!LGitBlob class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #blob_free:! !!LGitBlob class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isType: aType	^ aType = LGitObjectTypeEnum git_obj_blob! !!LGitBlob class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: aRepository fromExternalCollection: aCollection	| id |	self assert: (aCollection class = ByteArray or: [ aCollection class theMetaClass canUnderstand: #asExternalTypeOn: ]).	id := LGitId new.	self		blob_create_frombuffer: id		repo: aRepository		buffer: aCollection		len: aCollection size.	^ (self of: aRepository)		initializeWithId: id;		yourself! !!LGitBlob class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: aRepository fromFile: aFileReference	| id |	id := LGitId new.	self blob_create_fromdisk: id repo: aRepository path: aFileReference fullName.	^ (self of: aRepository)		initializeWithId: id;		yourself! !!LGitBlob class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: aRepository fromString: aString	^ self of: aRepository fromExternalCollection: aString! !!LGitBlob methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!= anObject	^ self == anObject or: [		self class == anObject class and: [			self isReady and: [				anObject isReady and: [					self id = anObject id ] ] ] ]! !!LGitBlob methodsFor: 'private-accessing' stamp: ' 7/24/2017 12:50:03'!binaryContents	| bytes |	"freeing not required. See #rawBuffer"	bytes := ByteArray new: self rawSize.	LibC memCopy: self rawBuffer to: bytes size: bytes size.	^bytes! !!LGitBlob methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blob_id: blob		^ self call: #(void * git_blob_id #(self)) options: #()! !!LGitBlob methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blob_is_binary: blob		^ self call: #(Boolean git_blob_is_binary #(self)) options: #()! !!LGitBlob methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blob_lookup: blob repo: repo id: objectId		^ self		callUnchecked:			#(LGitReturnCodeEnum git_blob_lookup #(LGitBlob * blob , LGitRepository repo , LGitId * objectId))		options: #()! !!LGitBlob methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blob_rawcontent: blob		^ self call: #(void * git_blob_rawcontent #(self)) options: #()! !!LGitBlob methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!blob_rawsize: blob		^ self call: #(int64 git_blob_rawsize #(self)) options: #()! !!LGitBlob methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!contents	^ self isBinary		ifTrue:  [ self binaryContents ]		ifFalse: [ self rawBuffer readStringUTF8 ]		! !!LGitBlob methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!get_id_data	^ self blob_id: self! !!LGitBlob methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!hash	^ self contents hash! !!LGitBlob methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isBinary	^ self blob_is_binary: self! !!LGitBlob methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isBlob	^ true! !!LGitBlob methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!lookup	self withReturnHandlerDo: [ self		blob_lookup: self 		repo: self repository		id: self id ].	self autoRelease! !!LGitBlob methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!names	| names |	names := OrderedCollection new.	self repository head object tree allEntriesDo: [ :rootPath :entry :payload |		entry repository: self repository.		entry object = self ifTrue: [ names add: entry filename ].		0 ].		^ names! !!LGitBlob methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!objectPrintOn: aStream	self id objectPrintOn: aStream! !!LGitBlob methodsFor: 'private-accessing' stamp: ' 7/24/2017 12:50:03'!rawBuffer	"freeing not required (see http://libgit2.github.com/libgit2/#HEAD/group/blob/git_blob_rawcontent)"	^ self blob_rawcontent: self! !!LGitBlob methodsFor: 'private-accessing' stamp: ' 7/24/2017 12:50:03'!rawSize	^ self blob_rawsize: self! !!LGitCommit class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_free: handle		^ self call: #(void git_commit_free #(void *handle)) options: #()! !!LGitCommit class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #commit_free:! !!LGitCommit class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isType: aType	^ aType = LGitObjectTypeEnum git_obj_commit! !!LGitCommit class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: aRepository fromHexString: aCommitId	^ self of: aRepository fromId: (LGitId fromHexString: aCommitId)! !!LGitCommit methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!= anObject	^ self == anObject or: [ 		self class == anObject class and: [			self isReady and: [				anObject isReady and: [					self id = anObject id ] ] ] ]! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!author	^ self commit_author: self! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!authorStruct	^ self commit_author: self! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_author: commit		^ self		call: #(LGitSignature * git_commit_author #(self))		options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_committer: commit		^ self		call: #(LGitSignature * git_commit_committer #(self))		options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_id: commit		^ self call: #(void * git_commit_id #(self)) options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_lookup: commit repo: repo id: objectId		^ self		callUnchecked:			#(LGitReturnCodeEnum git_commit_lookup #(LGitCommit * commit , LGitRepository repo , LGitId * objectId))		options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_message: commit		^ self call: #(String git_commit_message #(self)) options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_message_encoding: commit		^ self		call: #(String git_commit_message_encoding #(self))		options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_parent_id: commit n: n	<todo: 'using LGitId * as return type causes a crash'>		^ self		call: #(void *git_commit_parent_id #(self , uint n))		options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_parentcount: commit		^ self call: #(uint git_commit_parentcount #(self)) options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_raw_header: aCommit	^ self call: #(const char * git_commit_raw_header(self))! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_time: commit		^ self call: #(int64 git_commit_time #(self)) options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_time_offset: commit		^ self call: #(int git_commit_time_offset #(self)) options: #()! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!commit_tree: tree_out commit: commit		^ self		call: #(LGitReturnCodeEnum git_commit_tree #(LGitTree *tree_out , self))		options: #()! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!committer	^ self commit_committer: self! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!committerStruct	^ self commit_committer: self! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!entryByPath: aString 	^ self tree entryByPath: aString! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!entryByPath: aString ifAbsent: aBlock	^ self tree entryByPath: aString ifAbsent: aBlock! !!LGitCommit methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!get_id_data	^ self commit_id: self! !!LGitCommit methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!hasParents	^ self parents notEmpty! !!LGitCommit methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isCommit	^ true! !!LGitCommit methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isMerge	^ self parents size > 1! !!LGitCommit methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!lookup	self withReturnHandlerDo: [ 		self			commit_lookup: self			repo: self repository			id: self id ].	self autoRelease! !!LGitCommit methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!merge: anotherCommit	"Merge two commits, producing a git_index that reflects the result of the merge."	| index | 	index := LGitIndex of: self repository.	self withReturnHandlerDo: [ 		self merge_result: index commit: anotherCommit options: LGitMergeOptions defaults.	].	"There is a bug on libgit2 and we need to set the owner of the index (because it is not	setting it)"	index hackOwner: self repository.		^ index! !!LGitCommit methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!merge_result: out commit: anotherCommit options: options	^ self call: #(		LGitReturnCodeEnum git_merge_commits(			LGitIndex *out, 			LGitRepository repository, 			LGitCommit self, 			LGitCommit anotherCommit, 			LGitMergeOptions *options))		options: #()! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!message	<todo: 'use encoding to properly read the message'>	|  encoding |	encoding := self commit_message_encoding: self.	^ self commit_message: self! !!LGitCommit methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!objectPrintOn: aStream	self id hexString in: [ :hexId |		aStream			nextPutAll: (hexId first: 7);			nextPutAll: '...';			nextPutAll: (hexId last: 7);			nextPutAll: ', ';			nextPutAll: self message surroundedBySingleQuotes ]! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!owner	^ self 		call: #(void *git_commit_owner(self)) 		options: #()! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!parents	| parentCount |	parentCount := self commit_parentcount: self.	^ Array		new: parentCount		streamContents: [ :stream | 			0 to: parentCount - 1 do: [ :i | 				| parentOid parent |				parentOid := LGitId fromHandle: (self commit_parent_id: self n: i) getHandle.				parent := self class of: self repository fromId: parentOid.				stream nextPut: parent ] ]! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!rawHeader 	^ self commit_raw_header: self! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!time	| time offset |	time := self commit_time: self.	offset := self commit_time_offset: self.	^ LGitTime new		time: time;		offset: offset;		yourself! !!LGitCommit methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!tree	| tree |	tree := LGitTree of: self repository.	self commit_tree: tree commit: self.	^ tree! !!LGitObject class methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!classFor: aType	^ self subclasses detect: [ :class | class isType: aType ]! !!LGitObject class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #object_free:! !!LGitObject class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isType: aType	^ self subclassResponsibility! !!LGitObject class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!newFromReference: aReference	^self of: aReference repository from: aReference targetId! !!LGitObject class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!object_free: handle 	^self call: #(void git_object_free(void *handle)) options: #(  )! !!LGitObject class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: aRepository fromId: id	^ (self of: aRepository)		initializeWithId: id;		yourself! !!LGitObject methodsFor: 'converting' stamp: ' 7/24/2017 12:50:03'!concreteObject	^ (self class classFor: self type) of: self repository fromId: self id! !!LGitObject methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!get_id_data	^ self object_id: self! !!LGitObject methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!id	| data |	(id notNil or: [ self isNull ]) ifTrue: [ ^ id ].	data := self get_id_data.	id := LGitId fromHandle: data getHandle.	id internalize.	^ id	! !!LGitObject methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!initializeWithId: gitOid	id := gitOid.	self lookup! !!LGitObject methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isBlob	^ false! !!LGitObject methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isCommit	^ false! !!LGitObject methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isTag	^ false! !!LGitObject methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isTree	^ false! !!LGitObject methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!lookup	self withReturnHandlerDo: [ self		object_lookup: self 		repo: self repository		id: self id 		type: LGitObjectTypeEnum git_obj_any ]! !!LGitObject methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!objectPrintOn: aStream	self id ifNil: [ ^ self ].		aStream nextPutAll: self id hexString! !!LGitObject methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!object_dup: dest from: source		^ self		callUnchecked: #(LGitObjectTypeEnum git_object_dup(LGitObject *dest, LGitObject source))		options: #()! !!LGitObject methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!object_id: obj		^ self		call: #(void * git_object_id #(self))		options: #()! !!LGitObject methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!object_lookup: object repo: repo id: oid type: type		^ self		callUnchecked:			#(LGitReturnCodeEnum git_object_lookup #(LGitObject * object , LGitRepository repo , LGitId * oid , LGitObjectTypeEnum type))		options: #()! !!LGitObject methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!object_short_id: out		^ self		call: #(LGitObjectTypeEnum git_object_short_id(LGitBuf *out, self))		options: #()! !!LGitObject methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!object_type: obj		^ self		call: #(LGitObjectTypeEnum git_object_type #(self))		options: #()! !!LGitObject methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!shortId	| buf shortId |	buf := LGitBuf new.	self object_short_id: buf.	shortId := buf prim_ptr readString.	buf free.	^shortId ! !!LGitObject methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!type	^ self object_type: self! !!LGitTag class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #tag_free:! !!LGitTag class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isType: aType	^ aType = LGitObjectTypeEnum git_obj_tag! !!LGitTag class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tag_free: handle	^ self call: #(void git_tag_free #(void *handle)) options: #()! !!LGitTag methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!name	^ self tag_name! !!LGitTag methodsFor: 'accesing' stamp: ' 7/24/2017 12:50:03'!object	| peeled |	peeled := LGitObject of: self repository.	self tag_peel: peeled.	^ peeled concreteObject! !!LGitTag methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tag_name	^ self call: #(String git_tag_name #(self)) options: #()! !!LGitTag methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tag_peel: result	^ self		call: #(LGitReturnCodeEnum git_tag_peel #(LGitObject * result, self))		options: #()! !!LGitTree class methodsFor: 'accessing-defaults' stamp: ' 7/24/2017 12:50:03'!defaultFilemode	^ LGitFilemodeEnum git_filemode_tree! !!LGitTree class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #tree_free:! !!LGitTree class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isType: aType	^ aType = LGitObjectTypeEnum git_obj_tree! !!LGitTree class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_free: handle		^ self call: #(void git_tree_free #(void *handle)) options: #()! !!LGitTree methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!= anObject	^ self == anObject or: [ 		self class == anObject class and: [ 			self isReady and: [				anObject isReady and: [					self id = anObject id ] ] ] ]! !!LGitTree methodsFor: 'enumerating' stamp: ' 7/24/2017 12:50:03'!allEntriesDo: aBlock	"The entries will be traversed in the specified order, children subtrees will be automatically loaded as required, and the callback will be called once per entry with the current (relative) root for the entry and the entry data itself.If the callback returns a positive value, the passed entry will be skipped on the traversal (in pre mode). A negative value stops the walk."	self withReturnHandlerDo: [ 		self			tree_walk: self			mode: LGitTreewalkModeEnum git_treewalk_pre			callback: (LGitTreewalkCallback on: aBlock)			payload: ExternalAddress null ]! !!LGitTree methodsFor: 'traversing' stamp: ' 7/24/2017 12:50:03'!entries	| entryCount |	entryCount := self tree_entrycount: self.		^ Array new: entryCount streamContents: [ :stream |		0 to: entryCount - 1 do: [ :i || entry |			entry := self tree_entry_byindex: self idx: i.			entry repository: self repository.			stream nextPut: entry ] ]! !!LGitTree methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!entryByName: aString 	^ self entryByName: aString ifAbsent: [ 		self error: ('Entry {1} is not present in tree {2}' format: {aString. self})].! !!LGitTree methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!entryByName: aString ifAbsent: aBlock	| entry |	entry := self tree_entry_byname: self name: aString.	(entry isNil or: [ entry isNull ])		ifTrue: [ ^aBlock value ].	entry repository: self repository.	^entry! !!LGitTree methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!entryByPath: aString 	^ self entryByPath: aString ifAbsent: [ 		self error: ('Entry {1} is not present in tree {2}' format: {aString. self})].! !!LGitTree methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!entryByPath: aString ifAbsent: aBlock	| entry |	entry := LGitTreeEntry of: self repository.	self tree_entry_bypath: entry path: aString.	^ entry isNull		ifTrue: [ aBlock value ]		ifFalse: [ 			entry repository: self repository.			entry ]! !!LGitTree methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!get_id_data	^ self tree_id: self! !!LGitTree methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!hash	^ super hash bitXor: self id asInteger! !!LGitTree methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isEmpty	^ self entries isEmpty! !!LGitTree methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isLeaf	^ self entries noneSatisfy: [ :entry |		entry type = LGitObjectTypeEnum git_obj_tree  ]! !!LGitTree methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isTree	^ true! !!LGitTree methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!lookup	self withReturnHandlerDo: [		self			tree_lookup: self			repo: self repository			id: self id ].	self autoRelease! !!LGitTree methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!names	<todo: 'decide what to do with this:	- will not work for trees not referenced from head (e.g. in an older commit)	- very slow for large repositories because every entry is visited'>	| names |	names := OrderedCollection new.	self repository head object tree allEntriesDo: [ :name :entry :payload |		entry repository: self repository.		entry object = self ifTrue: [ names add: name ].		0 ].		^ names! !!LGitTree methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!objectPrintOn: aStream	aStream		nextPutAll: 'number of entries: ';		nextPutAll: self size asString! !!LGitTree methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!owner	^ self tree_owner: self! !!LGitTree methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!size	^ self tree_entrycount: self! !!LGitTree methodsFor: 'traversing' stamp: ' 7/24/2017 12:50:03'!subTreeEntries	^ self entries select: [ :entry |		entry type = LGitObjectTypeEnum git_obj_tree ]! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_entry_byindex: tree idx: idx		^ self		call: #(LGitTreeEntry git_tree_entry_byindex #(self , size_t idx))		options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_entry_byname: tree name: name		^ self		call: #(LGitTreeEntry git_tree_entry_byname #(self , String name))		options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_entry_bypath: out path: path		^ self		call:			#(LGitReturnCodeEnum git_tree_entry_bypath #(LGitTreeEntry * out, self, String path))		options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_entrycount: tree		^ self call: #(int git_tree_entrycount #(self)) options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_id: tree		^ self call: #(void * git_tree_id #(self)) options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_lookup: out repo: repo id: objectId		^ self		callUnchecked:			#(LGitReturnCodeEnum git_tree_lookup #(LGitTree * out , LGitRepository repo , LGitId * objectId))		options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_owner: tree		^ self call: #(LGitRepository git_tree_owner #(self)) options: #()! !!LGitTree methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_walk: tree mode: mode callback: callback payload: payload		^ self		call:			#(LGitReturnCodeEnum git_tree_walk #(LGitTree tree , LGitTreewalkModeEnum mode , LGitTreewalkCallback callback , void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitPatch class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!diff_patch_free: handle		^ self call: #(void git_patch_free #(void *handle)) options: #()! !!LGitPatch class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #diff_patch_free:! !!LGitPatch class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!fromDiff: aDiff at: anInteger	^ (self of: aDiff repository)		fromDiff: aDiff at: anInteger;		yourself! !!LGitPatch methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!fromDiff: aDiff at: anInteger	"use 1 based offset as in Smalltalk"	self withReturnHandlerDo: [		self			patch_from_diff: self			diff: aDiff			idx: anInteger - 1 ].	self autoRelease! !!LGitPatch methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!hunkAt: anInteger	| hunk lines |	hunk := LGitDiffHunk externalNew.	lines := LGitWriteBackValueSizeT new.	self withReturnHandlerDo: [		self			patch_get_hunk: hunk			lines_in_hunk: lines patch: self			hunk_idx: anInteger ].			^ hunk! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!patch_from_blob_and_buffer: out old_blob: old_blob old_as_path: old_as_path buffer: buffer buffer_len: buffer_len buffer_as_path: buffer_as_path opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_patch_from_blob_and_buffer #(LGitPatch * self , LGitBlob old_blob , String old_as_path , String buffer , FFIUInt32 buffer_len , String buffer_as_path , LGitDiffOptions * opts))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!patch_from_blobs: out old_blob: old_blob old_as_path: old_as_path new_blob: new_blob new_as_path: new_as_path opts: opts		^ self		callUnchecked:			#(LGitReturnCodeEnum git_patch_from_blobs #(LGitPatch * self , LGitBlob old_blob , String old_as_path , LGitBlob new_blob , String new_as_path , LGitDiffOptions * opts))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!patch_from_buffers: out old_buffer: old_buffer old_len: old_len old_as_path: old_as_path new_buffer: new_buffer new_len: new_len new_as_path: new_as_path opts: opts	self flag: #todo. "This one doesnt seems to exist anymore. Instead I think it is git_patch_from_blob_and_buffer"	^ self		callUnchecked:			#(LGitReturnCodeEnum git_patch_from_blobuffers #(LGitPatch * self , FFIVoid * old_buffer , FFIUInt32 old_len , String old_as_path , String new_buffer , FFIUInt32 new_len , String new_as_path , LGitDiffOptions * opts))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!patch_from_diff: out diff: diff idx: idx		^ self		callUnchecked:			#(LGitReturnCodeEnum git_patch_from_diff #(LGitPatch * self , LGitDiff diff , size_t idx))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!patch_get_delta: patch		^ self		call: #(LGitDiffDelta * git_patch_get_delta #(self))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!patch_get_hunk: out lines_in_hunk: lines_in_hunk patch: patch hunk_idx: hunk_idx		^ self		call:			#(LGitReturnCodeEnum git_patch_get_hunk #(				LGitDiffHunk **out , 				LGitWriteBackValueSizeT *lines_in_hunk, 				LGitPatch *patch, 				size_t hunk_idx))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!patch_get_line_in_hunk: out patch: patch hunk_idx: hunk_idx line_of_hunk: line_of_hunk		^ self		call:			#(LGitReturnCodeEnum git_patch_get_line_in_hunk #(LGitDiffLine * out , self , size_t hunk_idx , size_t line_of_hunk))		options: #()! !!LGitPatch methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!patch_print: patch print_cb: print_cb payload: payload		^ self		call:			#(LGitReturnCodeEnum git_patch_print #(self , LGitDiffLineCallback print_cb , void *payload))		options: #(optMayGC optCoerceNilToNull)! !!LGitPatch methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!printDiff	^ String new: 500 streamContents: [ :stream |		self printDiffOn: stream ]! !!LGitPatch methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!printDiffOn: aStream	| callback |	callback := LGitDiffLineCallback on: [ :delta :hunk :line :payload |		aStream nextPutAll: line content. 0 ].		self withReturnHandlerDo: [		self			patch_print: self			print_cb: callback			payload: nil ]! !!LGitPathSpecMatchList class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #pathspec_match_list_free:! !!LGitPathSpecMatchList class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!pathspec_match_list_free: handle		^ self		call: #(void git_pathspec_match_list_free #(void *handle))		options: #()! !!LGitPathSpecMatchList methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!pathspec_match_diff: out diff: diff flags: flags ps: ps		^ self		callUnchecked:			#(int git_pathspec_match_diff #(LGitPathSpecMatchList * self , LGitDiff diff , LGitPathSpecFlagTypeEnum flags , LGitPathSpec ps))		options: #()! !!LGitPathSpecMatchList methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!pathspec_match_list_diff_entry: m pos: pos		^ self		call:			#(LGitDiffDelta git_pathspec_match_list_diff_entry #(LGitPathSpecMatchList m , size_t pos))		options: #()! !!LGitReference class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #reference_free:! !!LGitReference class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_free: handle	^ self		call: #(void git_reference_free #(void *handle))		options: #()! !!LGitReference methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!= anObject	self class == anObject class ifFalse: [ ^ false ].		^ self == anObject or: [		(self 			reference_cmp: self 			ref2: anObject) = LGitReturnCodeEnum git_ok  ]	! !!LGitReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!annotatedCommit	^ LGitAnnotatedCommit fromRef: self! !!LGitReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!basename	^ self name copyAfterLast: $/! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!branch_is_head: branch		^ self call: #(int git_branch_is_head #(self)) options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!branch_set_upstream: upstream	^ self		callUnchecked:			#(LGitReturnCodeEnum git_branch_set_upstream #(self , String upstream))		options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!branch_upstream: out local: local	^ self		callUnchecked:			#(LGitReturnCodeEnum git_branch_upstream #(LGitReference * out , self))		options: #()! !!LGitReference methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createDirect: nameString target: aGitId force: aBoolean	self withReturnHandlerDo: [ 		self			reference_create: self			repo: self repository			name: nameString			id: aGitId			force: aBoolean			log_message: 'created reference ', nameString ]! !!LGitReference methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createSymbolic: nameString target: targetString force: aBoolean	self withReturnHandlerDo: [ 		self			reference_symbolic_create: self			repo: self repository			name: nameString			target: targetString			force: aBoolean			log_message: 'created reference ', nameString ]! !!LGitReference methodsFor: 'initialize-release' stamp: ' 7/24/2017 12:50:03'!initializeOn: aHandle in: aRepo	handle := aHandle.	self repository: aRepo.! !!LGitReference methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isBranch	^ (self reference_is_branch: self) = 1! !!LGitReference methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isDirect	^ (self reference_type: self) = LGitReferenceTypeEnum git_ref_oid! !!LGitReference methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isHead	^ (self branch_is_head: self) = 1! !!LGitReference methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isLocal	^ self reference_is_remote not! !!LGitReference methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isSymbolic	^ (self reference_type: self) = LGitReferenceTypeEnum git_ref_symbolic! !!LGitReference methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isTag	^ self reference_is_tag = 1! !!LGitReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!name	^ self reference_name: self! !!LGitReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!object	self isDirect 		ifFalse: [ ^ self resolve object ].	^(LGitObject of: self repository fromId: self targetId) concreteObject! !!LGitReference methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!objectPrintOn: aStream	aStream nextPutAll: self name surroundedBySingleQuotes! !!LGitReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!owner	^ self call: #(void * git_reference_owner #(self)) options: #()! !!LGitReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!pushUpstream	| pushRemote | 	^ self repository config 		getString: 'remote.pushDefault'		ifPresent: [ :pushRemoteName |			self repository 				lookupBranch: self upstream basename				inRemote: pushRemoteName ]		ifAbsent: [ self upstream ]! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_cmp: ref1 ref2: ref2		^ self		call: #(LGitReturnCodeEnum git_reference_cmp #(self , LGitReference ref2))		options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_create: out repo: repo name: name id: id force: force log_message: log_message		^ self		callUnchecked:			#(LGitReturnCodeEnum git_reference_create #(LGitReference * self , LGitRepository repo , String name , LGitId * id , Boolean force , String log_message))		options: #(optCoerceNilToNull)! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_is_branch: ref		^ self call: #(int git_reference_is_branch #(self)) options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_is_remote	^ self call: #(Boolean git_reference_is_remote #(self)) options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_is_tag		^ self call: #(int git_reference_is_tag #(self)) options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_lookup: out repo: repo name: name		^ self		callUnchecked:			#(LGitReturnCodeEnum git_reference_lookup #(LGitReference * self , LGitRepository repo , String name))		options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_name: ref		^ self call: #(String git_reference_name #(self)) options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_resolve: out ref: ref		^ self		callUnchecked: #(LGitReturnCodeEnum git_reference_resolve #(LGitReference * out , self))		options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_set_target: out ref: ref id: id log_message: log_message		^ self		call:			#(LGitReturnCodeEnum git_reference_set_target #(LGitReference * out , self , LGitId * id , String log_message))		options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_symbolic_create: out repo: repo name: name target: target force: force log_message: log_message		^ self		callUnchecked:			#(LGitReturnCodeEnum git_reference_symbolic_create #(LGitReference * self , LGitRepository repo , String name , String target , Boolean force , String log_message))		options: #(optCoerceNilToNull)! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_symbolic_set_target: out ref: ref target: target log_message: log_message		^ self		callUnchecked:			#(LGitReturnCodeEnum git_reference_symbolic_set_target #(LGitReference * self , LGitReference ref , String target , String log_message))		options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_target: ref	<todo: 'using LGitId* as return value causes random crashes'>		^ self call: #(void * git_reference_target #(self)) options: #()! !!LGitReference methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!reference_type: ref		^ self		call: #(LGitReferenceTypeEnum git_reference_type #(self))		options: #()! !!LGitReference methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!resolve	| resolved |	self isDirect 		ifTrue: [ ^ self ].	resolved := self class of: self repository.	self withReturnHandlerDo: [ self reference_resolve: resolved ref: self ].	^ resolved! !!LGitReference methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!setTarget: aReference	self setTargetId: aReference object id! !!LGitReference methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!setTargetId: aGitId	| newRef |	newRef := LGitReference of: self repository.	self		withReturnHandlerDo: [ 			self				reference_set_target: newRef				ref: self				id: aGitId				log_message: 'set ' , self name , ' to ' , aGitId hexString ]! !!LGitReference methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!setUpstream: upstreamName	self withReturnHandlerDo: [		self branch_set_upstream: upstreamName	]! !!LGitReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!shortName	^ self isLocal 		ifTrue: [ self basename ]		ifFalse: [ self name withoutPrefix: 'refs/remotes/']! !!LGitReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!targetId	| data oId |	data := self reference_target: self.	data getHandle isNull		ifTrue: [ ^ nil ].	oId := LGitId fromExternalAddress: data.	oId internalize.	^ oId! !!LGitReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!upstream	| upstream | 	upstream  := self class of: self repository.	[ self withReturnHandlerDo: [		self branch_upstream: upstream local: self	]] 	on: LGit_GIT_ENOTFOUND do: [ ^ nil ].	^ upstream! !!LGitRemote class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!credentials	^ Credentials ifNil: [ Credentials := SmallDictionary new ]! !!LGitRemote class methodsFor: 'convenience' stamp: ' 7/24/2017 12:50:03'!credentialsPlaintext	^ LGitCredentialsPlaintext		username: self username		passphrase: self password! !!LGitRemote class methodsFor: 'convenience' stamp: ' 7/24/2017 12:50:03'!credentialsSsh	^ LGitCredentialsSSH		username: self usernameSsh		passphrase: self keyPassPhrase		publicKeyReference: self keyFilePublicPath asFileReference		privateKeyReference: self keyFilePrivatePath asFileReference! !!LGitRemote class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #remote_free:! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!keyFilePrivatePath	^ self credentials		at: #keyFilePrivatePath		ifAbsentPut: [ UIManager default request: 'Path to your private key file (/home/foo/.ssh/key)?' ]! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!keyFilePrivatePath: aString	self credentials		at: #keyFilePrivatePath		put: aString! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!keyFilePublicPath	^ self credentials		at: #keyFilePublicPath		ifAbsentPut: [ UIManager default request: 'Path to your public key file (/home/foo/.ssh/key.pub)?' ]! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!keyFilePublicPath: aString	self credentials		at: #keyFilePublicPath		put: aString! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!keyPassPhrase	^ self credentials		at: #keyPassPhrase		ifAbsentPut: [ UIManager default request: 'Passphrase of your private key file?' ]! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!keyPassPhrase: aString	self credentials		at: #keyPassPhrase		put: aString! !!LGitRemote class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: aRepository named: aString	^ self of: aRepository named: aString url: nil! !!LGitRemote class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: aRepository named: nameString url: urlString	^ self		of: aRepository		named: nameString		url: urlString		fetchSpec: nil! !!LGitRemote class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: aRepository named: nameString url: urlString fetchSpec: aRefSpec	^ (self of: aRepository)		remoteName: nameString;		url: urlString;		fetchSpec: aRefSpec;		yourself! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!password	^ self credentials		at: #password		ifAbsentPut: [ UIManager default request: 'What''s the password for your account?' ]! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!password: aString	self credentials		at: #password		put: aString! !!LGitRemote class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_free: handle		^ self call: #(void git_remote_free #(void *handle)) options: #()! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!resetCredentials	Credentials := nil! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!username	^ self credentials		at: #username		ifAbsentPut: [ UIManager default request: 'What''s your account name?' ]! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!username: aString	self credentials		at: #username		put: aString! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!usernameSsh	^ self credentials		at: #usernameSsh		ifAbsentPut: [ 			UIManager default 				request: 'What''s your username for SSH (probably "git")?'				initialAnswer: 'git' ]! !!LGitRemote class methodsFor: 'accessing-credentials' stamp: ' 7/24/2017 12:50:03'!usernameSsh: aString	self credentials		at: #usernameSsh		put: aString! !!LGitRemote methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!addFetch	self withReturnHandlerDo: [ 		self			remote_add_fetch: self repository			remote: self remoteName			refspec: self fetchSpec ]! !!LGitRemote methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!addPush	self withReturnHandlerDo: [ 		self			remote_add_push: self repository			remote: self remoteName			refspec: self fetchSpec ]! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!connectFetch	self withReturnHandlerDo: [ 		self 			remote_connect: self 			direction: LGitDirectionEnum git_direction_fetch			callbacks: LGitRemoteCallbacks defaults ]! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!connectFetchWithCredentials: aCredentialsProvider	self withReturnHandlerDo: [ 		self 			remote_connect: self 			direction: LGitDirectionEnum git_direction_fetch			callbacks: (LGitRemoteCallbacks withProvider: aCredentialsProvider) ]! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!connectPushWithCredentials: aCredentialsProvider	self withReturnHandlerDo: [ 		self 			remote_connect: self 			direction: LGitDirectionEnum git_direction_push			callbacks: (LGitRemoteCallbacks withProvider: aCredentialsProvider) ]! !!LGitRemote methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!create	<todo: 'use exceptions instead of assertions'>	self assert: url notNil.	self assert: self repository isReady.		[ self hasFetchSpec		ifFalse: [ self createWithoutSpec ]		ifTrue: [ self createWithFetchSpec ] ]			on: LGit_GIT_EEXISTS			do: [ "all good then" ]! !!LGitRemote methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!createWithFetchSpec	self withReturnHandlerDo: [ 		self			remote_create_with_fetchspec: self			repo: self repository			name: self remoteName			url: self url			fetch: self fetchSpec ]! !!LGitRemote methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!createWithoutSpec	self withReturnHandlerDo: [ 		self			remote_create: self			repo: self repository			name: self remoteName			url: self url ]! !!LGitRemote methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!delete	self withReturnHandlerDo: [		self			remote_delete: self repository			name: self remoteName ]! !!LGitRemote methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!fetch	self isReady ifFalse: [ self create ].	self withReturnHandlerDo: [ 		self			remote_fetch: self			refspecs: self ffiNull handle			opts: (LGitFetchOptions defaults				callbacks: LGitRemoteCallbacks defaults;				yourself)			reflog_message: nil ]! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fetchSpec	^ fetchSpec! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fetchSpec: aRefSpec	fetchSpec := aRefSpec! !!LGitRemote methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!fetchWithCredentials: aCredentialsProvider	self isReady ifFalse: [ self create ].	self withReturnHandlerDo: [ 		self			remote_fetch: self			refspecs: self ffiNull handle			opts: (LGitFetchOptions defaults				callbacks:(LGitRemoteCallbacks withProvider: aCredentialsProvider);				yourself)			reflog_message: nil ]! !!LGitRemote methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!fetchWithMessage: aString	self create.			self withReturnHandlerDo: [ 		self			remote_fetch: self			refspecs: nil			opts: LGitFetchOptions defaults			reflog_message: aString ]! !!LGitRemote methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!fetchWithMessage: aString credentials: aCredentialsProvider 	self create.			self withReturnHandlerDo: [ 		self			remote_fetch: self			refspecs: nil			opts: (LGitFetchOptions defaults				callbacks: (LGitRemoteCallbacks withProvider: aCredentialsProvider);				yourself)			reflog_message: aString ]! !!LGitRemote methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!hasFetchSpec	^ self fetchSpec notNil ! !!LGitRemote methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!lookup	self withReturnHandlerDo: [ 		self			remote_lookup: self			repo: self repository			name: self remoteName.		self url: self remote_url ].	self flag: #todo. "shouldn't be autoreleased?"! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!ls	"I list all HEADS in connected remotes (you will need to #connectFetch or 	#connectPushWithCredentials: first)"	| out sizeBuf heads size |		sizeBuf := ByteArray new: FFISizeT externalTypeSize.	out := ExternalAddress new.		self withReturnHandlerDo: [ 		self remote_ls: out size: sizeBuf ].		size := sizeBuf signedLongAt: 1.	heads := Array new: size. 	1 to: size do: [ :index | 		heads at: index put: (LGitRemoteHead fromHandle: (out pointerAt: 1)).		out := out + FFIExternalType pointerSize ].		^ heads! !!LGitRemote methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!objectPrintOn: aStream	aStream nextPutAll: self remoteName! !!LGitRemote methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!pullWithFetchOptions: fetchOptions	<todo: 'check for conflicts'>	self repository isReady ifFalse: [  ^ self ].	self lookup.		self withReturnHandlerDo: [ 		self			remote_fetch: self			refspecs: nil			opts: fetchOptions			reflog_message: 'automatic pull from libgit2' ].		"assume that there are no conflicts and fast-forwad to FETCH_HEAD"	self repository fastForward! !!LGitRemote methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!pushWithRefSpec: aRefSpec pushOptions: pushOptions	| refspecs return |	refspecs := LGitStringArray withAll: { aRefSpec asString }.	return := self withReturnHandlerDo: [		self			remote_push: self			refspecs: refspecs			opts: pushOptions ].			^ return! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!refSpecs 	| specs |	specs := LGitStringArray externalNew autoRelease.	self withReturnHandlerDo: [ 		self remote_get_fetch_refspecs: specs ].	^ specs strings! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!remoteName	^ remoteName! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!remoteName: aString	remoteName := aString! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_add_fetch: repo remote: remote refspec: refspec		^ self		call:			#(LGitReturnCodeEnum git_remote_add_fetch #(LGitRepository repo , String remote String refspec))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_add_push: repo remote: remote refspec: refspec		^ self		call:			#(LGitReturnCodeEnum git_remote_add_push #(LGitRepository repo , String remote , String refspec))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_connect: remote direction: direction callbacks: remoteCallbacks		^ self		call:			#(LGitReturnCodeEnum git_remote_connect #(self , LGitDirectionEnum direction , LGitRemoteCallbacks * remoteCallbacks))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_create: out repo: repo name: name url: urlString		^ self		callUnchecked:			#(LGitReturnCodeEnum git_remote_create #(LGitRemote * self , LGitRepository repo , String name , String urlString))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_create_with_fetchspec: out repo: repo name: name url: urlString fetch: fetch		^ self		callUnchecked:			#(LGitReturnCodeEnum git_remote_create_with_fetchspec #(LGitRemote * self , LGitRepository repo , String name , String urlString , String fetch))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_delete: repo name: name		^ self		call:			#(LGitReturnCodeEnum git_remote_delete #(LGitRepository repo , String name))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_fetch: remote refspecs: refspecs opts: opts reflog_message: reflog_message		^ self		call:			#(LGitReturnCodeEnum git_remote_fetch #(self , void * refspecs , LGitFetchOptions * opts , String reflog_message))		options: #(optCoerceNilToNull)! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_get_fetch_refspecs: array	^ self call: #(int git_remote_get_fetch_refspecs(LGitStringArray *array, self))! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_lookup: out repo: repo name: name		^ self		callUnchecked:			#(LGitReturnCodeEnum git_remote_lookup #(LGitRemote * self , LGitRepository repo , String name))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_ls: out size: size	"	Since I will take a lost of addresses, I'm interested on 2nd level of 'out', that's why 	I transform `const git_remote_head ***out` into `void **out`	This is the original function: 		int git_remote_ls(const git_remote_head ***out, size_t *size, git_remote *remote)"	^ self call: #( LGitReturnCodeEnum git_remote_ls ( void **out, size_t *size, self ))! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_push: remote refspecs: refspecs opts: opts		^ self		call:			#(LGitReturnCodeEnum git_remote_push #(self , LGitStringArray * refspecs , LGitPushOptions * opts))		options: #(optCoerceNilToNull)! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_set_url: repo remote: remote url: urlString		^ self		call:			#(LGitReturnCodeEnum git_remote_set_url #(LGitRepository repo , String remote , String urlString))		options: #()! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_update_tips: remote callbacks: remoteCallbacks update_fetchhead: update_fetchhead download_tags: download_tags reflog_message: reflog_message		^ self		call:			#(LGitReturnCodeEnum git_remote_update_tips #(self , LGitRemoteCallbacks * remoteCallbacks , Boolean update_fetchhead , LGitRemoteAutotagOptionTypeEnum download_tags , String reflog_message))		options: #(optStringOrNull)! !!LGitRemote methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!remote_url	^ self		call: #(String git_remote_url #(self))		options: #()! !!LGitRemote methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!setUrl: aString	self withReturnHandlerDo: [ 		self			remote_set_url: self repository			remote: self remoteName			url: aString]! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!url	^ url! !!LGitRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!url: aString	url := aString! !!LGitRepositoryObject class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!new	self error: 'Use #of: to create an instance of ', self name! !!LGitRepositoryObject class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: aRepository	^ self basicNew		initialize;		repository: aRepository;		yourself! !!LGitRepositoryObject methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!repository	^ repository! !!LGitRepositoryObject methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!repository: aRepository	repository := aRepository! !!LGitRevwalk class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #revwalk_free:! !!LGitRevwalk class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: aRepository	^ (super of: aRepository)		createNew;		yourself! !!LGitRevwalk class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!revwalk_free: handle		^ self call: #(void git_revwalk_free #(void *handle)) options: #()! !!LGitRevwalk methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!basicNext	"Note: in the C code you would check the return code to see when the loop is over.	This method uses instances variables to enable more Smalltalk like looping:	[ walk hasNext ] whileTrue: [ walk next ]."	| previousCommit nextId |	previousCommit := currentCommit.	nextId := self basicNextObjectId.	currentCommit := self hasNext		ifTrue: [			LGitCommit				of: self repository				fromId: nextId ]		ifFalse: [ nil ].		^ previousCommit! !!LGitRevwalk methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!basicNextObjectId	| nextId returnCode |	nextId := LGitId new.	returnCode := self		revwalk_next: nextId		walk: self.	(returnCode ~= LGitReturnCodeEnum git_iterover and: [ 		returnCode ~= LGitReturnCodeEnum git_ok ]) ifTrue: [ returnCode handleLGitReturnCode ].	hasNext := returnCode ~= LGitReturnCodeEnum git_iterover.		^ nextId! !!LGitRevwalk methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!basicSort: sortingEnum	sorting := sorting		ifNil: [ sortingEnum value ]		ifNotNil: [ sorting bitOr: sortingEnum value ].			self withReturnHandlerDo: [		self			revwalk_sorting: self			sort_mode: sorting ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!beSortedByCommitTime	self basicSort: LGitRevwalkSortTypeEnum git_sort_time! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!beSortedParentsBeforeChildren	self basicSort: LGitRevwalkSortTypeEnum git_sort_topological! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!beSortedReverse	self basicSort: LGitRevwalkSortTypeEnum git_sort_reverse! !!LGitRevwalk methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!createNew	self withReturnHandlerDo: [		self			revwalk_new: self			repo: self repository ]! !!LGitRevwalk methodsFor: 'walking' stamp: ' 7/24/2017 12:50:03'!do: aBlock	[ self hasNext ] whileTrue: [ 		aBlock value: self next	]! !!LGitRevwalk methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!hasNext	^ hasNext ifNil: [		self basicNext.		hasNext ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!hideCommit: aLGitId	self withReturnHandlerDo: [ self revwalk_hide: aLGitId ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!hideReference: aReference	self withReturnHandlerDo: [		self			revwalk_hide_ref: self			refname: aReference name ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!next	self hasNext ifFalse: [ ^ LGit_GIT_ITEROVER signal ].		^ self basicNext! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!pushCommit: aLGitId 	self withReturnHandlerDo: [ self revwalk_push: aLGitId ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!pushHead	self withReturnHandlerDo: [ self revwalk_push_head: self ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!pushReference: aReference	self withReturnHandlerDo: [		self			revwalk_push_ref: self			refname: aReference name ]! !!LGitRevwalk methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!reset	self withReturnHandlerDo: [ self revwalk_reset: self ]! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!revwalk_hide: commitId	^ self 		call:			#(LGitReturnCodeEnum git_revwalk_hide #(self , LGitId * commitId))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!revwalk_hide_ref: walk refname: refname		^ self		call:			#(LGitReturnCodeEnum git_revwalk_hide_ref #(self , String refname))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!revwalk_new: out repo: repo		^ self		callUnchecked:			#(LGitReturnCodeEnum git_revwalk_new #(LGitRevwalk * self , LGitRepository repo))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!revwalk_next: out walk: walk		^ self		call: #(LGitReturnCodeEnum git_revwalk_next #(LGitId * out , self))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!revwalk_push: commitId	^ self 		call:			#(LGitReturnCodeEnum git_revwalk_push #(self , LGitId * commitId))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!revwalk_push_head: walk		^ self		call: #(LGitReturnCodeEnum git_revwalk_push_head #(self))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!revwalk_push_ref: walk refname: refname		^ self		call:			#(LGitReturnCodeEnum git_revwalk_push_ref #(self , String refname))		options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!revwalk_reset: revwalk		^ self call: #(void git_revwalk_reset #(self)) options: #()! !!LGitRevwalk methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!revwalk_sorting: walk sort_mode: sort_mode		^ self		call: #(void git_revwalk_sorting #(self , uint sort_mode))		options: #()! !!LGitRevwalk methodsFor: 'walking' stamp: ' 7/24/2017 12:50:03'!select: selectionBlock thenDo: actionBlock	self do: [ :result | 		(selectionBlock value: result) 			ifTrue: [ actionBlock value: result ] ]! !!LGitStatusList class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #status_list_free:! !!LGitStatusList class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!status_list_free: handle		^ self		call: #(void git_status_list_free #(void *handle))		options: #()! !!LGitStatusList methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!status_list_get_perfdata: out status: status		^ self		call:			#(LGitReturnCodeEnum git_status_list_get_perfdata #(LGitPerfData * out , self))		options: #()! !!LGitTreeBuilder class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #treebuilder_free:! !!LGitTreeBuilder class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!fromTree: aTree	self validate: aTree shouldBe: LGitTree.	^ self of: aTree repository fromTree: aTree! !!LGitTreeBuilder class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!of: repository fromTree: aTree	^ (self of: repository)		initializeWithTree: aTree;		yourself! !!LGitTreeBuilder class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!treebuilder_free: handle		^ self		call: #(void git_treebuilder_free #(void *handle))		options: #()! !!LGitTreeBuilder methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!addEntry: aLGitObject filename: aString	self 		addEntryWithId: aLGitObject id 		filename: aString 		filemode: aLGitObject class defaultFilemode! !!LGitTreeBuilder methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!addEntryWithId: oidStruct filename: aString filemode: anInteger	self withReturnHandlerDo: [ 			self				treebuilder_insert: (LGitTreeEntry of: self repository)				bld: self				filename: aString				id: oidStruct				filemode: anInteger ]! !!LGitTreeBuilder methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!clear	self treebuilder_clear: self! !!LGitTreeBuilder methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!createNew	self withReturnHandlerDo: [ 		self 			treebuilder_new: self			repo: self repository			source: self ffiNull handle ]! !!LGitTreeBuilder methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!getEntryNamed: aString	| entry |	entry := self		treebuilder_get: self		filename: aString.	entry repository: self repository.		^ entry! !!LGitTreeBuilder methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!initializeWithTree: aTree	self withReturnHandlerDo: [		self			treebuilder_new: self			repo: self repository			source: (aTree ifNotNil: #handle) ]! !!LGitTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!newTree	^ LGitTree of: self repository fromId: self write! !!LGitTreeBuilder methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!treebuilder_clear: bld		^ self call: #(void git_treebuilder_clear #(self)) options: #()! !!LGitTreeBuilder methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!treebuilder_get: bld filename: filename		^ self		call: #(LGitTreeEntry git_treebuilder_get #(self , String filename))		options: #()! !!LGitTreeBuilder methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!treebuilder_insert: out bld: bld filename: filename id: id filemode: filemode		^ self		call:			#(LGitReturnCodeEnum git_treebuilder_insert #(LGitTreeEntry * out , self , String filename , LGitId * id , LGitFilemodeEnum filemode))		options: #()! !!LGitTreeBuilder methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!treebuilder_new: out repo: repo source: source	^ self		callUnchecked:			#(LGitReturnCodeEnum git_treebuilder_new #(LGitTreeBuilder * out , LGitRepository repo , void * source))		options: #(+ optCoerceNilToNull)! !!LGitTreeBuilder methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!treebuilder_write: id bld: bld		^ self		call: #(LGitReturnCodeEnum git_treebuilder_write #(LGitId * id , self))		options: #()! !!LGitTreeBuilder methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!write	| id errorCode |	id := LGitId new.	errorCode := self		treebuilder_write: id		bld: self.			errorCode ~= 0 ifTrue: [ LGitWritingTreeFailed ].		^ id! !!LGitTreeEntry class methodsFor: 'libgit-finalization' stamp: ' 7/24/2017 12:50:03'!freeFunctionSelector	^ #tree_entry_free:! !!LGitTreeEntry class methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_entry_free: handle		^ self		call: #(void git_tree_entry_free #(void *handle))		options: #()! !!LGitTreeEntry methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:03'!= anObject	^ self == anObject or: [		self class == anObject class and: [ 			self isReady and: [ 				anObject isReady and: [ 					self compare: anObject ] ] ] ]! !!LGitTreeEntry methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!compare: aTreeEntry	^ (self		tree_entry_cmp: self		e2: aTreeEntry) isZero! !!LGitTreeEntry methodsFor: 'traversing' stamp: ' 7/24/2017 12:50:03'!entries	^ self object entries! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!entryByPath: aString 	^ self object entryByPath: aString! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!entryByPath: aString ifAbsent: aBlock	^ self object entryByPath: aString ifAbsent: aBlock! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fileMode	^ self tree_entry_filemode: self! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!filename	^ self tree_entry_name: self! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!object	| object |	object := (LGitObject classFor: self type) of: self repository.	self withReturnHandlerDo: [		self			tree_entry_to_object: object			repo: self repository			entry: self ].			^ object! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!objectId	^ LGitId fromExternalAddress: (self tree_entry_id: self)! !!LGitTreeEntry methodsFor: 'printing' stamp: ' 7/24/2017 12:50:03'!objectPrintOn: aStream 	aStream nextPutAll: self filename surroundedBySingleQuotes! !!LGitTreeEntry methodsFor: 'traversing' stamp: ' 7/24/2017 12:50:03'!subTreeEntries	^ self object subTreeEntries! !!LGitTreeEntry methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_entry_cmp: e1 e2: e2		^ self		call: #(int git_tree_entry_cmp #(self , LGitTreeEntry e2))		options: #()! !!LGitTreeEntry methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_entry_filemode: entry		^ self		call: #(LGitFilemodeEnum git_tree_entry_filemode #(self))		options: #()! !!LGitTreeEntry methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_entry_id: entry		^ self call: #(void * git_tree_entry_id #(self)) options: #()! !!LGitTreeEntry methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_entry_name: entry		^ self call: #(String git_tree_entry_name #(self)) options: #()! !!LGitTreeEntry methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_entry_to_object: object_out repo: repo entry: entry		^ self		call:			#(LGitReturnCodeEnum git_tree_entry_to_object #(LGitObject * object_out , LGitRepository repo , self))		options: #()! !!LGitTreeEntry methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!tree_entry_type: entry		^ self		call: #(LGitObjectTypeEnum git_tree_entry_type #(self))		options: #()! !!LGitTreeEntry methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!type	^ self tree_entry_type: handle! !!LGitWriteBackValue class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isAbstract	^ self == LGitWriteBackValue! !!LGitWriteBackValueInt class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!typeDecl	^ 'int'! !!LGitWriteBackValueSizeT class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!typeDecl	^ 'size_t'! !!LGitWriteBackValueUInt class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!typeDecl	^ 'uint'! !!LGitAbstractError class methodsFor: 'signalling' stamp: ' 7/24/2017 12:50:03'!signalWith: anObject	^ self new		object: anObject;		signal;		yourself! !!LGitAbstractError methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!initialize	super initialize.	self messageText: LGitError lastMessage! !!LGitAbstractError methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!object	^ object! !!LGitAbstractError methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!object: anObject	object := anObject! !!LGitCallError class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isAbstract	^ self == LGitCallError! !!LGitCallReturnHandler class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!canHandle: aReturnCode	^ self handledReturnCodes anySatisfy: [ :symbol | 		aReturnCode symbol = symbol ]! !!LGitCallReturnHandler class methodsFor: 'lookup' stamp: ' 7/24/2017 12:50:03'!for: aReturnCode	^ (self allSubclasses reject: #isAbstract)		detect: [ :class | class canHandle: aReturnCode ]		ifNone: [ LGitNoReturnCodeHandlerDefined signal ]! !!LGitCallReturnHandler class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!handledReturnCodes	^ { (self name allButFirst: 5) asLowercase asSymbol }! !!LGitCallReturnHandler class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isAbstract	^ self == LGitCallReturnHandler! !!LGitCallReturnHandler class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isError	^ true! !!LGitCallReturnHandler class methodsFor: 'signalling' stamp: ' 7/24/2017 12:50:03'!signalWith: anError	^ self new		messageText: anError message;		object: anError type;		signal;		yourself! !!LGit_GIT_ITEROVER methodsFor: 'signaling' stamp: ' 7/24/2017 12:50:03'!signal	"don't signal, everything is fine"	^ self! !!LGit_GIT_OK class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isError	^ false! !!LGit_GIT_OK methodsFor: 'signaling' stamp: ' 7/24/2017 12:50:03'!signal	"don't signal, everything is fine"	^ self! !!LGitIllegalArgument class methodsFor: 'signalling' stamp: ' 7/24/2017 12:50:03'!signalWith: anObject shouldBe: aClass	^ self new		object: anObject;		expectedClass: aClass;		signal;		yourself! !!LGitIllegalArgument methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!expectedClass	^ expectedClass! !!LGitIllegalArgument methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!expectedClass: anObject	expectedClass := anObject! !!LGitIllegalArgument methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!messageText	^ 'libgit2 ffi call expects a(n) {1} but instead received {2}'			format: {self expectedClass. self object}! !!ManifestLibGitCore class methodsFor: 'meta data' stamp: ' 7/24/2017 12:50:03'!rejectClasses^ #()! !!ManifestLibGitCore class methodsFor: 'meta data' stamp: ' 7/24/2017 12:50:03'!rejectRules^ #()! !!ManifestLibGitCore class methodsFor: 'meta data' stamp: ' 7/24/2017 12:50:03'!ruleIfTrueBlocksRuleV1FalsePositive^ #(#(#(#RGMethodDefinition #(#LGitExternalObject #ifNotReady: #false)) #'2014-11-14T16:52:32.831129+01:00') )! !!ManifestLibGitCore class methodsFor: 'meta data' stamp: ' 7/24/2017 12:50:03'!ruleIfTrueReturnsRuleV1FalsePositive^ #(#(#(#RGMethodDefinition #(#LGitReference #= #false)) #'2014-11-14T16:52:32.91457+01:00') #(#(#RGMethodDefinition #(#LGitReference #= #false)) #'2014-11-14T16:52:32.915066+01:00') )! !!ManifestLibGitCore class methodsFor: 'code-critics' stamp: ' 7/24/2017 12:50:03'!ruleRBAbstractClassRuleV1FalsePositive^ #(#(#(#RGMetaclassDefinition #(#'LGitExternalEnumerationUInt32 class' #LGitExternalEnumerationUInt32)) #'2015-07-18T14:21:49.402159+02:00') )! !!ManifestLibGitCore class methodsFor: 'code-critics' stamp: ' 7/24/2017 12:50:03'!ruleRBNoClassCommentRuleV1FalsePositive^ #(#(#(#RGClassDefinition #(#LGitPushOptions)) #'2015-07-17T12:59:06.388548+02:00') )! !!LGitBufferSignatureCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(int (void **out, LGitDiffFile *file, char *buf, size_t buflen, void *payload))! !!LGitCallback class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!null	^ self new initializeNull! !!LGitCallback class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:03'!on: aBlock	^ self 		signature: self fnSpec 		block: aBlock ! !!LGitCallback methodsFor: 'as yet unclassified' stamp: ' 7/24/2017 12:50:03'!initializeNull	thunk := ExternalAddress null! !!LGitCheckoutNotifyCallback class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (LGitCheckoutNotifyTypeEnum why, String path, LGitDiffFile *baseline, LGitDiffFile *target, LGitDiffFile *workdir, void *payload))! !!LGitCheckoutPerfDataCallback class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(void (LGitCheckoutPerfData *perfdata, void *payload))! !!LGitCheckoutProgressCallback class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(void (String path, size_t completed_steps, size_t total_steps, void *payload))! !!LGitCompletionCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (LGitRemoteCompletionTypeEnum type, void *argument))! !!LGitCredAcquireCallback class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (LGitCredentials **cred, String url, String username_from_url, uint allowed_types, void *data))! !!LGitCredAcquireCallback methodsFor: 'as yet unclassified' stamp: ' 7/24/2017 12:50:03'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitCredAcquireCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!wrapBlock: aBlock	^[ :credAddress :url :username_from_url :allowed_types :data |		aBlock valueWithArguments: (Array			with: (LGitCredentials fromHandle: credAddress) 			with: url			with: username_from_url			with: allowed_types 			with: data) ]! !!LGitDiffBinaryCallback class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (LGitDiffDelta *delta, LGitDiffBinary *binary, void *payload))! !!LGitDiffBinaryCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitDiffBinaryCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!wrapBlock: aThreeArgBlock	^[ :deltaAddress :binary :payload |		aThreeArgBlock 			value: (LGitDiffDelta fromHandle: deltaAddress) 			value: (LGitDiffBinary fromHandle: binary) 			value: payload ]! !!LGitDiffFileCallback class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (LGitDiffDelta * delta, float progress, void *payload))! !!LGitDiffFileCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitDiffFileCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!wrapBlock: aThreeArgBlock	^[ :deltaAddress :progress :payload |		aThreeArgBlock 			value: (LGitDiffDelta fromHandle: deltaAddress) 			value: progress			value: payload ]! !!LGitDiffHunkCallback class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (LGitDiffDelta *delta, LGitDiffHunk *hunk, void *payload))! !!LGitDiffHunkCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitDiffHunkCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!wrapBlock: aBlock	^[ :deltaAddress :hunkAddress :payload |		aBlock 			value: (LGitDiffDelta fromHandle: deltaAddress) 			value: (LGitDiffHunk fromHandle: hunkAddress)			value: payload ]! !!LGitDiffLineCallback class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (LGitDiffDelta *delta, LGitDiffHunk *hunk, LGitDiffLine *line, void *payload))! !!LGitDiffLineCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitDiffLineCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!wrapBlock: aFourArgBlock	^[ :deltaAddress :hunkAddress :lineAddress :payload |		aFourArgBlock 			value: (LGitDiffDelta fromHandle: deltaAddress) 			value: (LGitDiffHunk fromHandle: hunkAddress)			value: (LGitDiffLine fromHandle: lineAddress)			value: payload ]! !!LGitDiffNotifyCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (LGitDiff *diff_so_far, LGitDiffDelta *delta_to_add, String matched_pathspec, void *payload))! !!LGitFileSignatureCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(int (void **out, LGitDiffFile *file, String fullpath, void *payload))! !!LGitFreeSignatureCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(void (void *sig, void *payload))! !!LGitIndexMatchedPathCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(int (String path, String matched_pathspec, void *payload))! !!LGitPackbuilderForeachCallback class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (void *buffer, int length, void *payload))! !!LGitPackbuilderForeachCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitPackbuilderForeachCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!wrapBlock: aBlock	^[ :buffer :length :payload |		aBlock 			value: buffer 			value: length			value: payload ]! !!LGitPackbuilderProgressCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(int (int stage, uint32 current, uint32 total, void *payload))! !!LGitPushNegotiationCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(int (LGitPushUpdate **updates, size_t len, void *payload))! !!LGitPushStatusForeachCallback class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (char *arg1, char *arg2, void *arg3))! !!LGitPushTransferProgressCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(int (uint current, uint total, size_t bytes, void *payload))! !!LGitPushUpdateReferenceCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(int (String refname, String status, void *data))! !!LGitRemoteCreateCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(int (void **out, LGitRepository repo, String name, String url, void *payload))! !!LGitRepositoryCreateCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(int (LGitRepository **out, String path, Boolean bare, void *payload))! !!LGitSimilarityCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(int (int *score, void *siga, void *sigb, void *payload))! !!LGitStatusCallback class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (String path, uint status_flags, void *payload))! !!LGitTransferProgressCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (LGitTransferProgress *stats, void *payload))! !!LGitTransportCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int git_transport_cb(LGitTransport *out, LGitRemote owner, void *param))! !!LGitTransportCertificateCheckCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(int (void *cert, int valid, String host, void *payload))! !!LGitTransportMessageCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (String str, int len, void *payload))! !!LGitTreewalkCallback class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!fnSpec	^#(int (String name, LGitTreeEntry entry, void *payload))! !!LGitTreewalkCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!signature: signature "<String>" block: aBlock "<BlockClosure>"	super signature: signature block: (self wrapBlock: aBlock)! !!LGitTreewalkCallback methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:03'!wrapBlock: aThreeArgBlock	^[ :rootPath :entryAddress :payload |		aThreeArgBlock 			value: rootPath 			value: (LGitTreeEntry fromHandle: entryAddress)			value: payload ]		! !!LGitUpdateTipsCallback class methodsFor: 'callback spec' stamp: ' 7/24/2017 12:50:03'!fnSpec	^ #(int (String refname, LGitId *a, LGitId *b, void * data))! !!LGitLibrary class methodsFor: 'class initialization' stamp: ' 7/24/2017 12:50:03'!initialize	"Required to reset the Initialized flag on image startup"	Smalltalk addToStartUpList: self! !!LGitLibrary class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:03'!isInitialized	"Answer true when git_libgit2_init has been called in the current session."	^ Initialized ifNil: [ false ]! !!LGitLibrary class methodsFor: 'system startup' stamp: ' 7/24/2017 12:50:03'!shutDown: quitting	quitting ifFalse: [ ^ self ].	self isInitialized ifFalse: [ ^self ].	self uniqueInstance shutdownLibGit2.! !!LGitLibrary class methodsFor: 'system startup' stamp: ' 7/24/2017 12:50:03'!startUp: isImageStarting	isImageStarting		ifTrue: [ Initialized := false ]! !!LGitLibrary methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!initializeLibGit2	self libgit2_init.	Initialized := true! !!LGitLibrary methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!libgit2_features	"Query compile time options for libgit2."		^self ffiCall: #(int git_libgit2_features())! !!LGitLibrary methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!libgit2_featuresAlt	"Query compile time options for libgit2."		| fnc |		fnc := ExternalLibraryFunction		name: 'git_libgit2_features'		module: 'libgit2.0.dylib'		callType: 0		returnType: FFIInt32 new externalTypeWithArity		argumentTypes: {}.			^fnc invokeWithArguments: { }! !!LGitLibrary methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!libgit2_init	^self ffiCall: #(int git_libgit2_init())! !!LGitLibrary methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!libgit2_shutdown	^self ffiCall: #(int git_libgit2_shutdown())! !!LGitLibrary methodsFor: 'libgit-calls' stamp: ' 7/24/2017 12:50:03'!libgit2_version: major minor: minor rev: rev	"Return the version of the libgit2 library being currently used."	^self ffiCall: #(void git_libgit2_version(LGitWriteBackValueInt major, LGitWriteBackValueInt minor, LGitWriteBackValueInt rev))! !!LGitLibrary methodsFor: 'accessing platform' stamp: ' 7/24/2017 12:50:03'!macModuleName	| pluginDir |	pluginDir := Smalltalk vm binary parent / 'Plugins'.	#('libgit2.dylib' 'libgit2.0.dylib')		detect: [ :each | (pluginDir / each) exists ] 		ifFound: [ :libName | ^ libName ].	self error: 'Module not found.'! !!LGitLibrary methodsFor: 'operations' stamp: ' 7/24/2017 12:50:03'!shutdownLibGit2	| initsRemaining |		initsRemaining := self libgit2_shutdown.	initsRemaining <= 0		ifTrue: [ Initialized := false ].	^ initsRemaining! !!LGitLibrary methodsFor: 'accessing platform' stamp: ' 7/24/2017 12:50:03'!unixModuleName	| pluginDir |	pluginDir := Smalltalk vm binary parent.	#('libgit2.so' 'libgit2.so.0')		detect: [ :each | (pluginDir / each) exists ] 		ifFound: [ :libName | ^ libName ].	self error: 'Module not found.'! !!LGitLibrary methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:03'!version	"self uniqueInstance version"	| major minor rev |		major := LGitWriteBackValueInt new.	minor := LGitWriteBackValueInt new.	rev := LGitWriteBackValueInt new.		self libgit2_version: major minor: minor rev: rev.	^Array with: major value with: minor value with: rev value! !!LGitLibrary methodsFor: 'accessing platform' stamp: ' 7/24/2017 12:50:03'!win32ModuleName	^ 'libgit2.dll'! !!LGitExternalStructureFieldParser methodsFor: 'parsing' stamp: ' 7/24/2017 12:50:03'!parseFields: fields structure: structClass	| stream type fieldName generator |		stream := fields readStream.	generator := FFICallout new requestor: structClass.	fieldSpec := FFIExternalStructureFieldSpec new.	[ stream atEnd ] whileFalse: [ | arity |		type := generator resolveType: stream next. 		arity := 0.		[stream peek = #* ] whileTrue: [			arity := arity + 1.			stream next ].		type pointerArity: arity.				fieldName := ('prim_', stream next) asSymbol.		fieldName isSymbol ifFalse: [ self error: 'invalid field name'].		(fieldSpec fieldNames includes: fieldName) ifTrue: [ self error: 'duplicate field name' ].		"align := type typeSize min: byteAlign." "if byte align == 1, struct is packed"		"add padding between fields, if needed"		"self sizeAlignedTo: align with: type." 		fieldSpec addField: fieldName type: type. 			stream peek == #';' ifTrue: [ stream next ]].		^ self fieldSpec! !!LGitSafeFFICalloutMethodBuilder methodsFor: 'private' stamp: ' 7/24/2017 12:50:03'!generateFFICallout: builder spec: functionSpec	"Before the actual ffi call generate a check to see if the object is ready."	builder 		pushReceiver;		send: #signalIfNotReady.	^ super generateFFICallout: builder spec: functionSpec! !!Trait method!call: fnSpec	^ (self ffiCalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec	^ (self ffiCalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec	^ (self ffiCalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec	^ (self ffiCalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibrary! !!Trait method!call: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibrary! !!Trait method!ffiLibrary	^LGitLibrary ! !!Trait method!ffiLibrary	^LGitLibrary ! !!Trait method!ffiLibrary	^LGitLibrary ! !!Trait method!ffiLibrary	^LGitLibrary ! !!Trait method!ffiLibraryName	^self ffiLibrary! !!Trait method!ffiLibraryName	^self ffiLibrary! !!Trait method!ffiLibraryName	^self ffiLibrary! !!Trait method!ffiLibraryName	^self ffiLibrary! !!Trait method!validate: anObject shouldBe: aClass	"I allow for nil values."	(anObject isNil or: [ anObject isKindOf: aClass ])		ifFalse: [ LGitIllegalArgument signalWith: anObject shouldBe: aClass ]! !!Trait method!validate: anObject shouldBe: aClass	"I allow for nil values."	(anObject isNil or: [ anObject isKindOf: aClass ])		ifFalse: [ LGitIllegalArgument signalWith: anObject shouldBe: aClass ]! !!Trait method!validate: anObject shouldBe: aClass	"I allow for nil values."	(anObject isNil or: [ anObject isKindOf: aClass ])		ifFalse: [ LGitIllegalArgument signalWith: anObject shouldBe: aClass ]! !!Trait method!validate: anObject shouldBe: aClass	"I allow for nil values."	(anObject isNil or: [ anObject isKindOf: aClass ])		ifFalse: [ LGitIllegalArgument signalWith: anObject shouldBe: aClass ]! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!call: fnSpec	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec options: options	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec options: options	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec options: options	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!call: fnSpec options: options	^ (self safeFFICalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!callUnchecked: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!callUnchecked: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!callUnchecked: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!callUnchecked: fnSpec options: options	^ (self ffiCalloutIn: thisContext sender)		cdecl;		options: options;		function: fnSpec module: self ffiLibraryName! !!Trait method!ffiLibrary	^self class ffiLibrary! !!Trait method!ffiLibrary	^self class ffiLibrary! !!Trait method!ffiLibrary	^self class ffiLibrary! !!Trait method!ffiLibrary	^self class ffiLibrary! !!Trait method!ffiLibraryName	^self class ffiLibrary! !!Trait method!ffiLibraryName	^self class ffiLibrary! !!Trait method!ffiLibraryName	^self class ffiLibrary! !!Trait method!ffiLibraryName	^self class ffiLibrary! !!Trait method!ffiNull	^FFIExternalObject null! !!Trait method!ffiNull	^FFIExternalObject null! !!Trait method!ffiNull	^FFIExternalObject null! !!Trait method!ffiNull	^FFIExternalObject null! !!Trait method!ifNotReady: aBlock	"use extra block so compiler can optimize"	self isReady ifFalse: [ aBlock value ]! !!Trait method!ifNotReady: aBlock	"use extra block so compiler can optimize"	self isReady ifFalse: [ aBlock value ]! !!Trait method!ifNotReady: aBlock	"use extra block so compiler can optimize"	self isReady ifFalse: [ aBlock value ]! !!Trait method!ifNotReady: aBlock	"use extra block so compiler can optimize"	self isReady ifFalse: [ aBlock value ]! !!Trait method!isReady	^ true! !!Trait method!isReady	^ true! !!Trait method!isReady	^ true! !!Trait method!isReady	^ true! !!Trait method!safeFFICalloutIn: aContext	^ LGitSafeFFICalloutAPI inContext: aContext! !!Trait method!safeFFICalloutIn: aContext	^ LGitSafeFFICalloutAPI inContext: aContext! !!Trait method!safeFFICalloutIn: aContext	^ LGitSafeFFICalloutAPI inContext: aContext! !!Trait method!safeFFICalloutIn: aContext	^ LGitSafeFFICalloutAPI inContext: aContext! !!Trait method!signalIfNotReady	self ifNotReady: [ self signalNotReady ]! !!Trait method!signalIfNotReady	self ifNotReady: [ self signalNotReady ]! !!Trait method!signalIfNotReady	self ifNotReady: [ self signalNotReady ]! !!Trait method!signalIfNotReady	self ifNotReady: [ self signalNotReady ]! !!Trait method!signalNotReady	LGitObjectNotInitialized signalWith: self! !!Trait method!signalNotReady	LGitObjectNotInitialized signalWith: self! !!Trait method!signalNotReady	LGitObjectNotInitialized signalWith: self! !!Trait method!signalNotReady	LGitObjectNotInitialized signalWith: self! !!Trait method!validate: anObject shouldBe: aClass	self class validate: anObject shouldBe: aClass! !!Trait method!validate: anObject shouldBe: aClass	self class validate: anObject shouldBe: aClass! !!Trait method!validate: anObject shouldBe: aClass	self class validate: anObject shouldBe: aClass! !!Trait method!validate: anObject shouldBe: aClass	self class validate: anObject shouldBe: aClass! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!withReturnHandlerDo: callBlock	^ callBlock value handleLGitReturnCode! !!Trait method!objectPrintOn: aStream! !!Trait method!objectPrintOn: aStream! !!Trait method!printOn: aStream	| title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: [ 'an ' ] ifFalse: [ 'a ' ]);		nextPutAll: title.			(self shouldContinuePrintingOn: aStream) ifFalse: [ ^ self ].		aStream nextPutAll: ' ('.	self objectPrintOn: aStream.	aStream nextPut: $)! !!Trait method!printOn: aStream	| title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: [ 'an ' ] ifFalse: [ 'a ' ]);		nextPutAll: title.			(self shouldContinuePrintingOn: aStream) ifFalse: [ ^ self ].		aStream nextPutAll: ' ('.	self objectPrintOn: aStream.	aStream nextPut: $)! !!Trait method!shouldContinuePrintingOn: aStream	^ true! !!Trait method!shouldContinuePrintingOn: aStream	^ true! !"LibGit-Core"!!TIceRepositoryBackend commentStamp: 'NicoPasserini 7/4/2016 17:39' prior: 0!Common functionality for Ice repository backends.!!IceMCVersionInfo commentStamp: 'NicoPasserini 9/7/2016 15:19' prior: 0!Adapter to produce an MCVersionInfo that knows how to (lazily) load ancestors from an Iceberg repository.!!ManifestIceberg commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!IceError commentStamp: 'NicoPasserini 8/3/2016 14:52' prior: 0!Base class for all errors in Iceberg.!!CannotIdentifyVersionForCommit commentStamp: 'NicoPasserini 7/26/2016 14:05' prior: 0!This error is signaled when looking for a version in a commit (and its ancestry) has found two versions and can not decide which of them is the desired one. This should not happen if the repository is consistent.!!IceDuplicatedRepository commentStamp: 'NicoPasserini 8/3/2016 14:50' prior: 0!When trying to create a repository I found another one with a conflicting location (i.e. the same director on disk).!!IceGitUsernameOrEmailNotFound commentStamp: '<historical>' prior: 0!I'm an error to be sent when the error that comes from external library can be guessed to be the absense of user.name and user.mail properties.!!IceLocalRepositoryMissing commentStamp: 'NicoPasserini 10/4/2016 17:44' prior: 0!The repository code directory does not exist, maybe because the image was moved. Default action is to clone the repository again, but signal an error and allow for other components to react accordingly.!!IceMergeAborted commentStamp: 'NicoPasserini 8/9/2016 16:35' prior: 0!Attempting to merge arised a conflict so merge was aborted.!!IceMissingRepositoryEntry commentStamp: 'NicoPasserini 11/28/2016 14:05' prior: 0!Directory does not exist in the specified version in the repository.!!IceNoRemoteBranch commentStamp: 'NicoPasserini 8/3/2016 14:51' prior: 0!The operation you tried (for example push) requires that your branch has a configured upstream (something like origin/branchName), but is has none.!!IceVersionDoesNotExist commentStamp: 'NicoPasserini 11/28/2016 14:39' prior: 0!Version does not exist, probably the package was created in a later commit or it was deleted.!!IceWrongUrl commentStamp: 'NicoPasserini 8/3/2016 14:52' prior: 0!We can not parse the origin URL you have introduced. Maybe you made a typo, or maybe we do not support that kind of URLs.!!IceRepositoryAnnouncement commentStamp: 'NicoPasserini 10/5/2016 15:53' prior: 0!Groupes different announcements that can happen in a repository.!!IceCommited commentStamp: 'NicoPasserini 10/5/2016 15:53' prior: 0!Announces when a repository has commited.!!IcePushed commentStamp: 'NicoPasserini 10/5/2016 15:53' prior: 0!Announces when a repository has been pushed.!!IceRepositoryModified commentStamp: 'NicoPasserini 10/5/2016 15:56' prior: 0!Announces an unspecified change to a repository.!!IceAbstractCommitWalk commentStamp: 'NicoPasserini 9/21/2016 14:25' prior: 0!Base class for shared code between different commit walk implementations.!!IceAbstractDiff commentStamp: 'NicoPasserini 5/12/2016 17:23' prior: 0!Parent class for any comparison between two versions of the code (working copy, commit or other) and comprising any level of granularity (a whole repository, a package, a class, etc.).!!IceChangeSet commentStamp: 'NicoPasserini 5/9/2016 18:11' prior: 0!I represent a (maybe unitary) set of changes to be handled by the Iceberg framework. I am the top class of a composite pattern.A change should be defined as1. the difference between two versions of the code (currently two MCSnapthots for an IcePackageChangeSet)2. a filter from a bigger change set (for example we can create a class change set which is a subset of a package change set, all other subclasses from IceStructuralChangeSet).3. an explicit set of changes (see IceSimpleChangeSet).Public API and Key Messages- elements: returns a set of change sets which are my children, for example the change set related to a package contains the change sets for each class in the package.- (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	elements:		<Object>    Implementation Points!!IcePackageChangeSet commentStamp: 'NicoPasserini 5/12/2016 17:32' prior: 0!Provides a filtered version of a diff, restricted to a package.!!IceDiff commentStamp: 'NicoPasserini 5/12/2016 17:10' prior: 0!I model (and track) the diff between the working copy and the last commit in a given repository.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!IceAbstractVersion commentStamp: 'NicoPasserini 10/20/2016 15:48' prior: 0!Base class for different types of versions, namely: IceVersion (normal versions) and IceForeignVersion (versions not managed by Ice).!!IceForeignVersion commentStamp: 'NicoPasserini 9/14/2016 18:01' prior: 0!Place holder for an Iceberg version. When you get an instance of me instead of a real ice package version, this means that we can not correlate the current version of the code loaded into the image with a version in the corresponding Iceberg repository.!!IceSavedPackageVersion commentStamp: 'NicoPasserini 9/26/2016 11:11' prior: 0!A version of a package as saved in a repository. We have one of this for each commit in a repository which modifies the specified package.Internal representation- commit is the commit from which I loaded this version. - originatingCommit is the commit in which this version was first introduced, it is useful for comparing this version to another one.!!IceTemporaryVersion commentStamp: 'NicoPasserini 11/28/2016 14:49' prior: 0!Temporary versions are created in two situations:1) As  a temporary place holder for a version. Someone asked for a version but the package is still being loaded, at some point a real version will replace me. In the meanwhile I can respond to some messages as a version would do.2) For packages that are added to the repository but not yet saved. In this case the version will be replaced with a real version on next commit.!!IceBackendWriterAdapter commentStamp: 'NicoPasserini 9/26/2016 15:01' prior: 0!Adapter for having MCFileTreeWriters being able to write into Iceberg backend repositories without introducing unpleasant modifications in them.!!IceClassReference commentStamp: 'NicoPasserini 5/18/2016 12:20' prior: 0!This class is just for organizing class references together in a hierarchy, see subclases for more info.!!IceRemovedClassReference commentStamp: 'NicoPasserini 5/18/2016 12:19' prior: 0!A reference to a class that has been removed, but can be handled polymorphically with references to existing classes (see IceSimpleClassReference)!!IceSimpleClassReference commentStamp: 'NicoPasserini 5/18/2016 12:18' prior: 0!Wraps a Pharo class, to allow to handle it polymorphicaly with other references to classes (see IceRemovedClassReference)!!IceCommitish commentStamp: 'NicoPasserini 9/16/2016 14:08' prior: 0!A commit-ish is some object that ultimately points to a commit in a repository: could be a real commit, a branch, a tag.!!IceBranch commentStamp: 'NicoPasserini 12/6/2016 11:40' prior: 0!This can be a local o remote branch, see subclasses. When I am used as a commitish, you must understand that the commit I point to can change over time.!!IceLocalBranch commentStamp: 'NicoPasserini 12/6/2016 11:40' prior: 0!Models a local branch in the repository.!!IceRemoteBranch commentStamp: 'NicoPasserini 12/6/2016 11:42' prior: 0!Models a remote tracking branch.Please note that a "remote tracking" branch is in fact in the local repository, but it is not intended to work on it, but just to mirror a branch in a remote repository. You can not really checkout this branch, neither commit on it, it is read only.When cheking out a branch, if it is a remote tracking branch, a local branch will be created.!!IceCommitInfo commentStamp: 'NicoPasserini 6/6/2016 17:30' prior: 0!Holds the information about a commit in a git repository.!!IceLoadedCode commentStamp: 'NicoPasserini 9/16/2016 14:14' prior: 0!The loaded code of a repository can have three different shapes:- Nothing is loaded yet (represented by an instance of me).- All loaded packages using versions from the same commit (should be the most common situation).- You cherry-picked versions comming from differents commits (not recomended but supported).As commitish, I point to the code as it was loaded from the repository. Notice that after that moment both the code in the image as well as the origin of the code could have changed (in case that I load a branch, the branch can have new commits after I loaded it).!!IceTag commentStamp: 'NicoPasserini 11/3/2016 17:20' prior: 0!Representation of a tag!!IceUnbornBranch commentStamp: 'NicoPasserini 12/5/2016 16:47' prior: 0!I represent the "HEAD commit" of a new repository, i.e. one without any branches or commits. Once you commit on me, your repository will have just one commit and one branch named 'master'.!!IceUnknownBranch commentStamp: 'EstebanLorenzano 7/19/2017 14:20' prior: 0!I'm an unknown branch. I implement an "null pattern" to provide correct output for non-existing local repositories.!!IceWorkingCopy commentStamp: 'NicoPasserini 9/16/2016 14:13' prior: 0!A commitish pointing to the current version of the code.!!IceCredentialsProvider commentStamp: 'NicoPasserini 11/7/2016 15:01' prior: 0!I am in charge of remembering credentials information, configuration and providing it as required by the different backend implementations.I have a counter to avoid for trying for ever with the same credentials.!!IceMetacelloRepositoryAdapter commentStamp: 'NicoPasserini 9/30/2016 15:01' prior: 0!Adapter for allowing metacello to use Iceberg to download packages and versions.!!IcePackageReference commentStamp: 'NicoPasserini 5/25/2016 12:00' prior: 0!I represent a package, that could be in an IceRepository or in the image.Public API and Key Messages- isLoaded tells if the package is currently loaded in the image.In the future we should add load/unload here.We could also add commit, but in general is better to commit at the project level and not at the package level.!!IcePlaintextCredentials commentStamp: 'NicoPasserini 11/22/2016 14:35' prior: 0!I keep a username and a password for connecting to a repository.!!IceRemote commentStamp: 'NicoPasserini 11/17/2016 12:30' prior: 0!I represent a reference to an upstream repository, i.e. the repository to which you want to push/pull. Usually I am called a  'remote' but I could also be local. Most frequently each repository has at least one remote named 'origin'.I am abstract, my subclasses provide access to different kinds of remotes.Right now I just provide information about the different parts of the url, I could get smarter in the future.Internal Representation and Key Implementation Points.    Instance Variables	url:		<String>!!IceFileRemote commentStamp: 'NicoPasserini 7/1/2016 11:41' prior: 0!I am a 'remote' repository which is stored locally in your machine and accessed through a 'file://' url.!!IceNetworkRemote commentStamp: 'NicoPasserini 11/18/2016 13:39' prior: 0!Base abstract class for SCP and HTTPS remotes.!!IceHttpRemote commentStamp: 'TorstenBergmann 2/23/2017 10:33' prior: 0!A remote repository created out of a HTTP  url, such as 'http://localhost/owner/repository.git'.!!IceHttpsRemote commentStamp: 'NicoPasserini 11/18/2016 12:39' prior: 0!A remote repository created out of a HTTPS  url, such as 'https://github.com/npasserini/iceberg.git'.!!IceScpRemote commentStamp: 'NicoPasserini 7/1/2016 11:40' prior: 0!A remote repository created out of a SCP url, such as 'git@github.com:npasserini/iceberg.git'.!!IceUndefinedRemote commentStamp: 'EstebanLorenzano 3/29/2017 17:32' prior: 0!I'm an undefined remote. I exist when a repository is created from scratch and then there is no remote assigned to it yet.!!IceRepository commentStamp: 'NicoPasserini 10/25/2016 15:10' prior: 0!I represent an interface to a git repository. My main responsibilities are:- Load/update both baselines and individual packages from the repository.- Commit changes to the local repository and publish them to a remote repository.- Browse other versions of the loaded packages.- Handle branchesFor the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- loadPackage: packageName- createBranch: newBranchNameSample usage:    Git new origin: 'git@github.com:npasserini/pharo-git-test.git'.    git loadPackage: 'Pharo-Git-Test'. Instance Variables- origin: A string representing the url of a remote git repository (used as origin)- repository:	An IceGitTreeGitRemoteRepository, which provides underlying git operations.- location: <FileReference> The directory of the local repository.- commitDictionary: <Dictionary of IceCommitInfo> Cached dictonary from commitId (hex string) to  all commits in the current branch (in the local repo).- subdirectory: <String> The subdirectory of the local repository which is handled by the underlying GitFileTree- versionDescriptors: <List of GitFileTreePackageEntry> cached list of all package versions saved in the (currently selected branch) of the (local) repository.- announcer: <Announcer>- branch: <IceBranch> currently selected branch. - loadedCode:  <IceLoadedCode> Contains information about the loaded code for each package in this repository. (TODO: maybe handle special cases about loading different versions loaded for different packages, see: https://github.com/npasserini/iceberg/issues/139).Implementation Points!!IceRepositoryCreator commentStamp: 'EstebanLorenzano 12/7/2016 18:46' prior: 0!I create repositories. I do this (trying in this order):- with a location and url defined, I check if it can be a repository and in positive case, I answer the repository, or I can do a clone+checkout (into location) and answer the resulting repository.- with a remote defined , I can take url and location and perform the correct actions.You can also define  branchName to checkout a specific branch.!!IceSavedPackage commentStamp: 'NicoPasserini 6/13/2016 15:57' prior: 0!Can give information about a package that is saved in a repository, for example: - isLoaded if the package has been loaded into the image.- isModified if the package has local changes to be commited- incommingCommigs information about commits in the repository that are newer than the version loaded into the image.!!IceSshCredentials commentStamp: 'NicoPasserini 11/22/2016 14:34' prior: 0!I am a container for the credentials needed for connecting to a git repository via ssh/scp.!!Iceberg commentStamp: 'NicoPasserini 4/28/2016 14:10' prior: 0!I am a cache providing access to several Ice objects, such as packages, repositories, working copies, etc.Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!TIceRepositoryBackend classTrait methodsFor: 'class initialization' stamp: ' 7/24/2017 12:50:04'!initialize	IceRepository defaultBackendType ifNil: [ 		IceRepository defaultBackend: self ]! !!TIceRepositoryBackend methodsFor: 'requirements' stamp: ' 7/24/2017 12:50:04'!basicCodeDirectory	^ self subdirectory isEmptyOrNil 		ifTrue: [ self repositoryDirectory ]		ifFalse: [ self repositoryDirectory / self subdirectory  ].! !!TIceRepositoryBackend methodsFor: 'requirements' stamp: ' 7/24/2017 12:50:04'!codeDirectory	"Code repository might have been deleted or image might have been moved."	self repositoryDirectory exists		ifTrue: [ ^ self basicCodeDirectory ]		ifFalse: [ IceLocalRepositoryMissing signalFor: self frontend ]! !!TIceRepositoryBackend methodsFor: 'descriptions' stamp: ' 7/24/2017 12:50:04'!description	"Use local directory as description, as Monticello uses this to determine if two repositories are the same. This allows for having multiple local clones of the same remote repositories, which in turn could allow for using standard Pharo tools, for example to compare versions."	^ self basicCodeDirectory pathString, ' (', self class description, ')'! !!TIceRepositoryBackend methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!iceCommitFrom: aCommitish	"The type of 'aCommitish' depends on how each backend internal representation. "	^ self frontend		commitAt: (self commitIdFrom: aCommitish )		ifAbsentPut: [ self class parseCommitInfo: aCommitish ]! !!TIceRepositoryBackend methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!isMissing	^ self repositoryDirectory isNil 		or: [ self repositoryDirectory exists not ]! !!TIceRepositoryBackend methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!isPackageEntry: entry	^ entry isDirectory and: [ self canReadFileNamed: entry name ]	! !!TIceRepositoryBackend methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!lookupPackages	^ (self packageEntries		collect: [ :entry |			entry packageName -> (IceSavedPackage 				named: entry packageName				repository: self frontend).		])		asDictionary! !!TIceRepositoryBackend methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!merge: aCommitId into: aBranchName	| currentBranchName |	currentBranchName := self branch name.	[ 		self checkoutBranch: aBranchName.		self merge: aCommitId ]	ensure: [ 		self checkoutBranch: currentBranchName ]! !!TIceRepositoryBackend methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!packageEntries	self codeDirectory exists ifFalse: [ ^ #() ].	^ self codeDirectory entries 		select: [ :entry | self isPackageEntry: entry ]	! !!LGitCredentialsSSH methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!readFrom: credentials	self username: credentials username.	self passphrase: credentials keyPassphrase.  	self publicKeyReference: credentials publicKey asFileReference.	self privateKeyReference: credentials privateKey asFileReference! !!MCWorkingCopy methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!loadedVersion	self ancestors do: [ :ancestor |		(self repositoryGroup 			versionWithInfo: ancestor			ifNone: [ MCRepositoryGroup default versionWithInfo: ancestor ifNone: [] ])			ifNotNil: [ :version | ^ version ]	].! !!IceMCVersionInfo class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!package: package message: commitMessage	^ self new fromPackage: package message: commitMessage! !!IceMCVersionInfo class methodsFor: 'utility' stamp: ' 7/24/2017 12:50:04'!uuidFromCommit: aCommit package: aPackage.	^ self uuidFromSHA: (SHA1 new hashStream: (ReadStream on: aCommit id, aPackage name))! !!IceMCVersionInfo class methodsFor: 'utility' stamp: ' 7/24/2017 12:50:04'!uuidFromSHA: cid	"Return an adequate uuid from a git commit ID. Copied from GitFileTree."	^ UUID nilUUID		in: [ :uuid |			1 to: 16 do: [ :i | uuid at: i put: (cid at: i) ].			uuid at: 9 put: (16r80 bitOr: ((uuid at: 9) bitAnd: 16r3F)).	"Type"			uuid at: 7 put: (16r50 bitOr: ((uuid at: 7) bitAnd: 16r0F)).	"Version 5 : SHA-1 Namespace (git)."			uuid ]! !!IceMCVersionInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commit	^ commit! !!IceMCVersionInfo methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!fromCommit: aCommit package: aPackage	"This method can be used for first initializing a version info or to update a partially initialized version info."	"See #fromPackage:message:"	commit := aCommit.	package := aPackage.	   	date := commit datetime asDate.   	time := commit datetime asTime.		name := ('{1}-{2}.{3}' format: {		package name. 		commit compatibleUsername. 		commit datetime asUnixTime 	}).		id := self class uuidFromCommit: aCommit package: aPackage.   	message := commit comment.   	author := commit compatibleUsername! !!IceMCVersionInfo methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!fromPackage: package message: commitMessage	"This creates a partial version info. Full version info can not be created until we commit into a repository, 	but current fileout tools require it, so we first create an incomplete info and after committing it will be completed	by sending #fromCommit:package:		To improve this implementation we should review the fileout process."	name := ('{1}-{2}.{3}' format: {package name. Author fullName. 'unknown'}).	message := commitMessage.! !!IceMCVersionInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!iceVersion	^ commit versionFor: package! !!IceMCVersionInfo methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!loadAncestorsAndStepChildren	self shouldBeImplemented ! !!IceMCVersionInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!package	^ package! !!MCClassDefinition methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!classCategory	"Avoid direct use of #category, because MCClassDefinitions and 	MCMethodDefinition use the same message for different things. "	^ self category! !!MCVersion methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!directoryName	^ (MCFileTreeRepository parseName: self info name) first , '.package'! !!ManifestIceberg class methodsFor: 'code-critics' stamp: ' 7/24/2017 12:50:04'!ruleRBReturnsBooleanAndOtherRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#IceRepositoryModel #canPush #false)) #'2016-10-25T18:44:14.262953+02:00') )! !!ManifestIceberg class methodsFor: 'code-critics' stamp: ' 7/24/2017 12:50:04'!ruleRBTempsReadBeforeWrittenRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#IceRepository #outgoingCommits #false)) #'2016-06-16T17:24:18.524965+02:00') #(#(#RGMethodDefinition #(#IceMCGitRepository #outgoingCommits #false)) #'2016-07-06T15:14:46.350843+02:00') )! !!ManifestIceberg class methodsFor: 'code-critics' stamp: ' 7/24/2017 12:50:04'!ruleRBUtilityMethodsRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#IceGitFileTreeCommitWalk)) #'2016-09-21T17:13:36.812598+02:00') )! !!IceMetadatalessStCypressWriter class methodsFor: 'writing' stamp: ' 7/24/2017 12:50:04'!on: aStream	^ self new stream: aStream! !!IceMetadatalessStCypressWriter methodsFor: 'writing' stamp: ' 7/24/2017 12:50:04'!writeClassDefinition: definition to: classPath	self		writeInDirectoryName: classPath		fileName: 'README'		extension: '.md'		visit: [ self writeClassComment: definition ].	self		writeInDirectoryName: classPath		fileName: 'properties'		extension: self propertyFileExtension		visit: [ self writeClassDefinition: definition ]! !!IceMetadatalessStCypressWriter methodsFor: 'writing' stamp: ' 7/24/2017 12:50:04'!writeDefinitions: aCollection	| classDirExtension extensionClasses extensionMethodDefinitions extensionMethodMap methodHolders |	self writeBasicDefinitions: aCollection.	extensionClasses := OrderedCollection new.	extensionMethodDefinitions := OrderedCollection new.	methodHolders := self classDefinitions , self traitDefinitions.	self methodDefinitions		keysAndValuesDo:			[ :className :extensionMethods | 			methodHolders				at: className				ifAbsent:					[ extensionClasses add: className.					extensionMethodDefinitions addAll: extensionMethods ] ].	extensionClasses		do: [ :className | self methodDefinitions removeKey: className ].	self		writeMethodHolderDefinitions: self traitDefinitions		extension: '.trait'		to: ''		do:			[ :definition :classPath | self writeTraitDefinition: definition to: classPath ].	self		writeMethodHolderDefinitions: self classDefinitions		extension: '.class'		to: ''		do:			[ :definition :classPath | self writeClassDefinition: definition to: classPath ].	classDirExtension := '.extension'.	extensionMethodMap := Dictionary new.	extensionMethodDefinitions		do:			[ :methodDefinition | 			| classPath |			(extensionMethodMap				at: methodDefinition className				ifAbsent:					[ extensionMethodMap						at: methodDefinition className						put: OrderedCollection new ]) add: methodDefinition.			classPath := methodDefinition className , classDirExtension				, self fileUtils pathNameDelimiter asString.			self writeExtensionClassDefinition: methodDefinition to: classPath ].	extensionMethodMap		keysAndValuesDo:			[ :className :classMethodDefinitions | 			| classPath filenameMetaMap |			filenameMetaMap := self fileNameMapFor: classMethodDefinitions.			classMethodDefinitions				do:					[ :methodDefinition | 					| filename methodPath |					filename := (filenameMetaMap at: methodDefinition classIsMeta)						at: methodDefinition selector.					classPath := methodDefinition className , classDirExtension						, self fileUtils pathNameDelimiter asString.					methodPath := classPath						,							(methodDefinition classIsMeta								ifTrue: [ 'class' ]								ifFalse: [ 'instance' ])						, self fileUtils pathNameDelimiter asString.					self						writeMethodDefinition: methodDefinition						to: methodPath						filename: filename ] ]! !!IceMetadatalessStCypressWriter methodsFor: 'writing' stamp: ' 7/24/2017 12:50:04'!writeMethodProperties: classMethodDefinitions	"We don't want to write that."	self shouldNotImplement! !!IceMetadatalessStCypressWriter methodsFor: 'writing' stamp: ' 7/24/2017 12:50:04'!writeTraitDefinition: definition to: classPath	self		writeInDirectoryName: classPath		fileName: 'README'		extension: '.md'		visit: [ self writeClassComment: definition ].	self		writeInDirectoryName: classPath		fileName: 'properties'		extension: self propertyFileExtension		visit: [ self writeTraitDefinition: definition ]! !!MCDefinition methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!addAnalysisToPackageChangeSet: aPackageChangeSet change: aChange	aPackageChangeSet addChange: aChange! !!MCDefinition methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!addToPackageChangeSet: anIcePackageChangeSet 	anIcePackageChangeSet addChangedClass: self iceClass! !!MCDefinition methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!iceClass	^ IceClassReference forDefinition: self! !!MCDefinition methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!icePackage	^ self iceClass ifNotNil: #package! !!MCPostscriptDefinition methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!addToPackageChangeSet: anIcePackageChangeSet 	"By doing nothing, this definition will not be shown in the changes tree."! !!MCMethodDefinition methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!classCategory	^ self actualClass ifNotNil: #category ifNil: [ RPackage defaultPackageName ]! !!MCMethodDefinition methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!icePackage	^ self isExtensionMethod 		ifTrue: [ Iceberg packageForCategoryNamed: (self protocol withoutPrefix: '*') ]		ifFalse: [ self iceClass package ] ! !!MCMethodDefinition methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!method	^ self actualClass >> self selector! !!IceMetadatalessFileTreeWriter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!snapshotWriterClass	^ IceMetadatalessStCypressWriter! !!IceMetadatalessFileTreeWriter methodsFor: 'visiting' stamp: ' 7/24/2017 12:50:04'!writeVersion: aVersion	"We have to do that to avoid writing the version info."	| members |	directory := (members := MCFileTreeRepository		parseName: aVersion info name) last.	self deleteExistingPackageStructureFor: members.	self fileUtils ensureDirectoryExists: self packageFileDirectory.	self initializePackageFileDirectoryCache.	self writeFormat.	self writePackage: aVersion package.	self writeDefinitions: aVersion.	aVersion dependencies do: [ :ea | self writeVersionDependency: ea ]! !!MCGitHubRepository class methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!commitIdFor: aWorkingCopy	^ aWorkingCopy repositoryGroup repositories 		detect: [ :repo | repo isKindOf: self ] 		ifFound: #commitId		ifNone: nil! !!MCGitHubRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!commitId	"This kind of repo is associated to a specific commit that was downloaded, 	sadly the only way to know it is to parse the directory name."	| repoRoot |	repoRoot := self repoPath isEmpty ifTrue: [ self directory ] ifFalse: [ self directory parent ].	^ repoRoot basename copyAfterLast: $-.! !!MCGitHubRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!commitIdFor: aMCWorkingCopy ifFound: aBlockClosure 	(aMCWorkingCopy repositoryGroup includes: self)		ifTrue: [ aBlockClosure value: self commitId ]! !!MCGitHubRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!getOrCreateIcebergRepository	| remoteUrl remote |	remoteUrl := self perform: Iceberg remoteTypeSelector.	remote := IceRemote url: remoteUrl.	^ IceRepository registry 		detect: [ :repo | repo origin referencesSameRemoteLocationAs: remote ]		ifNone: [			(IceRepositoryCreator new 				url: remoteUrl;				subdirectory: repoPath;				branchName: self projectVersion;				createRepository)				register ]! !!MCGitHubRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!httpsUrl	^ 'https://github.com/', projectPath, '.git'! !!MCGitHubRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!scpUrl	^ 'git@github.com:', projectPath, '.git'! !!MCRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!commitIdFor: aMCWorkingCopy ifFound: aBlockClosure 	"Do nothing. By default MCRepositories can not provide a commitId for you."! !!RPackage methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!iceRepository	^ Iceberg repositoryForPackage: self! !!MCClassTraitDefinition methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!classCategory	^ self category! !!LGitCommit methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!asIcebergObjectInRepository: backend	^ backend iceCommitFrom: self! !!LGitCommit methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!changesFileNamed: fileName	| lookup myVersion parentVersions |	lookup := [:commit | [ commit entryByPath: fileName ] on: Error do: [ nil ]].	myVersion := lookup value: self.	parentVersions := self parents collect: lookup.		^ (myVersion 		ifNil: [ parentVersions includes: nil ]		ifNotNil: [ parentVersions anySatisfy: [ :version | 				version notNil and: [ version objectId = myVersion objectId ]]]) not! !!FileSystemDirectoryEntry methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!packageName 	^ self asFileReference basenameWithoutExtension! !!LGitDiff methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!files	| deltaFiles |		deltaFiles := Set new.	self filesDo: [ :delta :ignored1 :ignored2 | 		deltaFiles add: delta newFile path.		0 "Continue" ].	^ deltaFiles! !!LGitDiff methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!filesDo: aBlockClosure 	^ self filesDo: aBlockClosure binaryFilesDo: aBlockClosure hunksDo: nil linesDo: nil		! !!LGitDiff methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!includesFileNamed: path	^ (self filesDo: [ :delta :second :third | 		| modifiedFileName |		modifiedFileName := delta newFile path.		(modifiedFileName beginsWith: path) asAlien	]) asBoolean.! !!LGitTreeEntry methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!name	^ self filename! !!LGitTreeEntry methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!readStreamDo: aBlock	aBlock value: (ReadStream on: self object contents asString)! !!LGitTreeEntry methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!tree	^ self object! !!LGitTag methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!asIcebergObjectInRepository: backend	^ IceTag named: self name inRepository: backend frontend! !!IceGitUsernameOrEmailNotFound class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!guessKind: anError ifNot: notBlock 	(anError messageText = 'Config value ''user.name'' was not found' 		or: [ anError messageText = 'Config value ''user.email'' was not found' 		or: [ anError messageText = 'Failed to parse signature - Signature cannot have an empty name or email' ] ])		ifTrue: [ self signal ].	notBlock value! !!IceLocalRepositoryMissing class methodsFor: 'exceptioninstantiator' stamp: ' 7/24/2017 12:50:04'!signalFor: repository	^ self new 		repository: repository;		signal! !!IceLocalRepositoryMissing methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceLocalRepositoryMissing methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!IceMissingRepositoryEntry methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!messageText	^ self name! !!IceMissingRepositoryEntry methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name	^ name! !!IceMissingRepositoryEntry methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name: anObject	name := anObject! !!IceMissingRepositoryEntry methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!owner	^ owner! !!IceMissingRepositoryEntry methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!owner: anObject	owner := anObject! !!IceVersionDoesNotExist methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!messageText	^ 'There is no version for package: {1} in  commit {2}' 		format: { 			self version packageName.			self version commit shortId		}! !!IceVersionDoesNotExist methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!version	^ version! !!IceVersionDoesNotExist methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!version: anObject	version := anObject! !!LGitReturnCodeEnum methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!asBoolean	^ self value = 0 ifTrue: false ifFalse: 		[ self value = 1 ifTrue: true ifFalse: 		[ self error: self printString, ' can''t be converted to a boolean' ]]! !!IcePackageLoaded class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!version: version 	^ self new loadedVersion: version! !!IcePackageLoaded methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!loadedVersion	^ loadedVersion! !!IcePackageLoaded methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!loadedVersion: anObject	loadedVersion := anObject! !!IceRepositoryAnnouncement class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!for: repository	^ self new repository: repository; yourself! !!IceRepositoryAnnouncement methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceRepositoryAnnouncement methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!IceRepositoryRegistryModified class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!repository: aRepository	^ self new repository: aRepository; yourself! !!IceRepositoryRegistryModified methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceRepositoryRegistryModified methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!LGitCredentialsPlaintext methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!readFrom: credentials	self username: credentials username.	self passphrase: credentials password.  ! !!MCOrganizationDefinition methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!addAnalysisToPackageChangeSet: aPackageChangeSet change: aChange	aPackageChangeSet addOrganisationChange: aChange! !!MCOrganizationDefinition methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!iceClass	^ nil! !!MCOrganizationDefinition methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!icePackage	"TODO: Refactor this, see https://github.com/npasserini/iceberg/issues/42"	self categories 		ifNotEmpty: [ ^ Iceberg packageForCategoryNamed: (self categories anyOne) ]	 	ifEmpty: nil! !!MCPatchOperation methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!addToPackageChangeSet: anIcePackageChangeSet 	self definition addToPackageChangeSet: anIcePackageChangeSet ! !!MCPatchOperation methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!asIceChangeSet	^ IceMethodChange new 		operation: self; 		yourself.! !!MCPatchOperation methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!iceClass	^ self definition iceClass! !!MCPatchOperation methodsFor: '*Iceberg-Core' stamp: ' 7/24/2017 12:50:04'!icePackage	^ self definition icePackage! !!IceAbstractCommitWalk class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!forRepository: repository	^ self new repository: repository; yourself! !!IceAbstractCommitWalk methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!commitFrom: result	^ self repository iceCommitFrom: result! !!IceAbstractCommitWalk methodsFor: 'walking' stamp: ' 7/24/2017 12:50:04'!commits	| commits |	commits := OrderedCollection new.	self commitsDo: [ :commit | commits add: commit ].	^ commits! !!IceAbstractCommitWalk methodsFor: 'walking' stamp: ' 7/24/2017 12:50:04'!commitsDo: aBlock 	self rawResultsDo: [ :result | aBlock value: (self commitFrom: result) ]! !!IceAbstractCommitWalk methodsFor: 'walking' stamp: ' 7/24/2017 12:50:04'!includesCommit: aCommit	self commitsDo: [ :commit | 		commit id = aCommit id ifTrue: [ ^ true ]].	^ false! !!IceAbstractCommitWalk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!maxNumber	^ maxNumber! !!IceAbstractCommitWalk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!maxNumber: anObject	maxNumber := anObject! !!IceAbstractCommitWalk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!modifyingPackage	^ modifyingPackage! !!IceAbstractCommitWalk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!modifyingPackage: anObject	modifyingPackage := anObject! !!IceAbstractCommitWalk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceAbstractCommitWalk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!IceAbstractCommitWalk methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!upto: aCommitish	aCommitish hideYourselfFromCommitWalk: self! !!IceAbstractCommitWalk methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!uptoBranch: anIceBranch 	self uptoCommit: anIceBranch lastCommit! !!IceAbstractCommitWalk methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!uptoBranches: branches	^ branches do: [ :branch | self uptoBranch: branch ]! !!IceAbstractCommitWalk methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!uptoCommits: commits	commits do: [ :commit | self uptoCommit: commit  ]! !!IceAbstractCommitWalk methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!uptoVersion: version	version hideYourselfFromCommitWalk: self! !!IceAbstractCommitWalk methodsFor: 'walking' stamp: ' 7/24/2017 12:50:04'!versionsFor: package	self modifyingPackage: package.	^ self commits collect: [ :commit | commit versionFor: package ]! !!IceAbstractCommitWalk methodsFor: 'walking' stamp: ' 7/24/2017 12:50:04'!versionsFor: package detect: selectBlock ifNone: ifNoneBlock	self modifyingPackage: package.	self commitsDo: [ :commit | 		| version | 		version := commit versionFor: package.		(selectBlock value: version) ifTrue: [ ^ version ]	].	^ ifNoneBlock value  ! !!IceAbstractDiff methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!announcer	^ announcer! !!IceAbstractDiff methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!description	^ self name! !!IceAbstractDiff methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!elements	^ elements ifNil: [ 		elements := self initialElements sorted: [ :a :b | a description < b description ] ]! !!IceAbstractDiff methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialElements	^ self subclassResponsibility ! !!IceAbstractDiff methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	super initialize.	announcer := Announcer new.! !!IceAbstractDiff methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!refresh	elements ifNotNil: [ elements do: #refresh ].	elements := nil.	announcer announce: IceChangeSetChanged new.! !!IceAbstractDiff methodsFor: 'events' stamp: ' 7/24/2017 12:50:04'!whenChangedDo: aBlock	announcer when: IceChangeSetChanged do: aBlock! !!IceChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!updateDiff: aDiffModel 	aDiffModel		contextClass: nil;		leftText: '';		rightText: ''.! !!IcePackageOrganizationChange methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!myVersion	^ self organizationDescription: self newOrganization! !!IcePackageOrganizationChange methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!newOrganization	^ newOrganization ifNil: #()! !!IcePackageOrganizationChange methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!newOrganization: anObject	newOrganization := anObject! !!IcePackageOrganizationChange methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!oldOrganization	^ oldOrganization ifNil: #()! !!IcePackageOrganizationChange methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!oldOrganization: anObject	oldOrganization := anObject! !!IcePackageOrganizationChange methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!organizationDescription: tags 	^ String streamContents: [ :stream |		stream nextPutAll:	'Package tags: '.		tags do: [ :elem | 			stream nextPutAll: String crlf;				nextPutAll: String tab;				nextPutAll: elem.	]]! !!IcePackageOrganizationChange methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!removedCategories	^ self oldOrganization difference: self newOrganization ! !!IcePackageOrganizationChange methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!theirVersion	^ self organizationDescription: self oldOrganization! !!IcePackageOrganizationChange methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!updateDiff: aDiffModel	aDiffModel		contextClass: nil;		leftText: (self organizationDescription: self newOrganization);		rightText: (self organizationDescription: self oldOrganization).! !!IceClassChangeSet class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!class: aClass parent: anIcePackageChangeSet 	^ self new 		targetClass: aClass; 		parent: anIcePackageChangeSet; 		yourself.! !!IceClassChangeSet methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!analyseChanges	| newChanges |	newChanges := self parent changes select: [ :operation | 		operation iceClass = self targetClass ].		newChanges		detect: [ :operation | operation definition isClassDefinition ]		ifFound: [ :classDef | 			classDefinition := classDef. 			changes := newChanges copyWithout: classDef.		]		ifNone: [ changes := newChanges ].! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!browse	self targetClass browse! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!browseReferences	self targetClass browseReferences! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!canBeBrowsed	^ self targetClass canBeBrowsed! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!canBrowseReferences	^ self targetClass canBrowseReferences! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!changes	^ changes ifNil: [ self analyseChanges. changes ]! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!classDefinition	^ classDefinition ifNil: [ self analyseChanges. classDefinition ]! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!description	^ self targetClass description! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!icon	^ self classDefinition 		ifNotNil: #icon		ifNil: [	self isExtension			ifTrue: [ Smalltalk ui icons iconNamed: #protocolExtension ] 			ifFalse: [ self targetClass icon ]]! !!IceClassChangeSet methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialElements	^ self changes collect: #asIceChangeSet! !!IceClassChangeSet methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!isExtension	^ parent package name ~= self packageName! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!myVersion	^ self classDefinition ifNotNil: #diffToSource! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!operation	^ self classDefinition! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!package	^ self targetClass package! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageName	^ self targetClass packageName! !!IceClassChangeSet methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream 		print: self class;		nextPut: $(;		nextPutAll: targetClass description;		nextPut: $)		! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!targetClass	^ targetClass! !!IceClassChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!targetClass: anObject	targetClass := anObject! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!theirVersion	^ self classDefinition ifNotNil: #diffFromSource! !!IceClassChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!updateDiff: aDiffModel	self classDefinition		ifNil: [ super updateDiff: aDiffModel ]		ifNotNil: [ :cd |			aDiffModel				contextClass: nil;				leftText: cd diffToSource;				rightText: cd diffFromSource		]! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!browse	self method browse! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!canBeBrowsed	^ self operation canBeBrowsed! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!canBrowseReferences	^ false! !!IceMethodChange methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!description	^ operation definition selector! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!icon	^ self operation icon! !!IceMethodChange methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialElements	^ {}! !!IceMethodChange methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!method	^ self operation definition method! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!myVersion	^ self operation diffToSource! !!IceMethodChange methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!operation	^ operation! !!IceMethodChange methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!operation: anObject	operation := anObject! !!IceMethodChange methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!package	^ self operation definition actualClass package! !!IceMethodChange methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageName	^ self package name! !!IceMethodChange methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream nextPutAll: self class name;		nextPut: $(;		nextPutAll: operation definition summary;		nextPut: $)! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!theirVersion	^ self operation diffFromSource! !!IceMethodChange methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!updateDiff: aDiffModel	aDiffModel		contextClass: self operation targetClass;		leftText: self operation diffToSource;		rightText: self operation diffFromSource.! !!IcePackageChangeSet class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!package: aPackage parent: anIceDiff 	^ self new 		package: aPackage;		parent: anIceDiff;		yourself! !!IcePackageChangeSet methodsFor: 'private dispatch' stamp: ' 7/24/2017 12:50:04'!addChange: change	changes add: change! !!IcePackageChangeSet methodsFor: 'visiting' stamp: ' 7/24/2017 12:50:04'!addChangedClass: anIceClassReference 	changedClasses add: anIceClassReference ! !!IcePackageChangeSet methodsFor: 'private dispatch' stamp: ' 7/24/2017 12:50:04'!addOrganisationChange: change	change isAddition ifTrue: [ ^ self newOrganization: change definition categories ].	change isRemoval ifTrue: [ ^ self oldOrganization: change definition categories ].	self error: 'Can not handle definition'.! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!analyseChanges	| newChanges |	newChanges := self basicChanges.	newChanges ifEmpty: [ 		(self package isLoaded 			and: [ self package isModified			and: [(self parent myVersion isKindOf: IceWorkingCopy) 			and: [ self parent theirVersion isKindOf: IceLoadedCode ]]])			ifTrue: [ self package workingCopy modified: false ]].		changes := OrderedCollection new.	newChanges do: [ :change | 		change definition 			addAnalysisToPackageChangeSet: self			change: change ]! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!basicChanges	| mine theirs |	self package isLoaded ifFalse: [ ^ #() ].	mine := self parent mySnapshot: self package.	theirs := (self package isExported 		ifTrue: [ self parent theirSnapshot: self package ]		ifFalse: [ MCSnapshot empty ]).	^ (mine notNil and: [ theirs notNil ]) 		ifTrue: [ (MCPatch fromBase: theirs target: mine) operations ]		ifFalse: [ #() ]! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!basicOrganizationChange	^ organizationChange ifNil: [ organizationChange := IcePackageOrganizationChange new. ]! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!browse	self package browse! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!canBeBrowsed	^ true! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!canBrowseReferences	^ false! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!changedClasses	^ (self changes collect: #iceClass as: Set) 		sorted: [ :a :b | a description > b description ]! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!changes	^ changes ifNil: [ 		self analyseChanges. 		changes ]! !!IcePackageChangeSet methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!description	^ self package packageName! !!IcePackageChangeSet methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!hasChanged	^ self changes notEmpty or: [ self organizationChange notNil ]! !!IcePackageChangeSet methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!hasChanges	^ self elements notEmpty! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!icon	^ Smalltalk ui icons iconNamed: 		(self hasChanges 			ifTrue: [ #dirtyMonticelloPackage ]			ifFalse: [ #emptyPackage  ])! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialElements	changedClasses := Set new.	self changes do: [ :change | change addToPackageChangeSet: self ].	^ changedClasses collect: [:class | IceClassChangeSet class: class parent: self ]! !!IcePackageChangeSet methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isExtension: changeSet	^  changeSet package ~= self package correspondingRPackage! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!myVersion	^ organizationChange ifNotNil: #myVersion! !!IcePackageChangeSet methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!newOrganization: aCollectionOfTags	self basicOrganizationChange newOrganization: aCollectionOfTags ! !!IcePackageChangeSet methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!oldOrganization: aCollectionOfTags	self basicOrganizationChange oldOrganization: aCollectionOfTags ! !!IcePackageChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!operation	"This operation is not modeled in MC"	^ nil! !!IcePackageChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!organizationChange	^ organizationChange ifNil: [ self analyseChanges. organizationChange ]! !!IcePackageChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!package	^ package! !!IcePackageChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!package: anObject	package := anObject! !!IcePackageChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageName	^ self package name! !!IcePackageChangeSet methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream nextPutAll: self class name;		nextPut: $(;		nextPutAll: self package packageName;		nextPut: $)! !!IcePackageChangeSet methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!refresh	changes := nil.	organizationChange := nil.	super refresh.! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!theirVersion	^ organizationChange ifNotNil: #theirVersion! !!IcePackageChangeSet methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!updateDiff: aDiffModel	organizationChange 		ifNotNil: [ :change | change updateDiff: aDiffModel ]		ifNil: [ super updateDiff: aDiffModel ]! !!IceStructuralChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!description	^ self asString! !!IceStructuralChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!operation	^ self subclassResponsibility! !!IceStructuralChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageName	^ self subclassResponsibility! !!IceStructuralChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!parent	^ parent! !!IceStructuralChangeSet methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!parent: anObject	parent := anObject! !!IceDiff class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!forRepository: aRepository 	^ self new 		repository: aRepository;		myVersion: IceCommitish image;		theirVersion: aRepository loadedCode;		yourself.! !!IceDiff class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!forRepository: aRepository commit: anIceCommitInfo	^ self new 		repository: aRepository;		theirVersion: anIceCommitInfo;		yourself.! !!IceDiff class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!from: myCommitish to: theirsCommitish	^ self new 		repository: myCommitish repository;		myVersion: myCommitish;		theirVersion: theirsCommitish;		yourself.! !!IceDiff methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!canRevertChanges	^ self myVersion canRevertChanges ! !!IceDiff methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!changedPackages	^ self elements select: #hasChanged thenCollect: #package! !!IceDiff methodsFor: 'private factory' stamp: ' 7/24/2017 12:50:04'!createChangeSetFor: package	^ IcePackageChangeSet package: package parent: self! !!IceDiff methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialElements	| changedPackages |	changedPackages := self myVersion changedPackagesTo: self theirVersion.	^ changedPackages collect: [ :package | self createChangeSetFor: package ]! !!IceDiff methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	super initialize.	myVersion := IceCommitish image.! !!IceDiff methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!mySnapshot: package	^ self myVersion snapshotFor: package	! !!IceDiff methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!myVersion	^ myVersion! !!IceDiff methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!myVersion: anObject	myVersion := anObject! !!IceDiff methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut: $(;		nextPutAll: self repository location pathString;		nextPut: $)! !!IceDiff methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!refresh	self repository refresh.	elements ifNotNil: [ elements do: #refresh ].	announcer announce: IceChangeSetChanged new.! !!IceDiff methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceDiff methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject.	repository announcer weak		subscribe: IceCommited send: #refresh to: self! !!IceDiff methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!revertChange: anIceMethodChange 	self myVersion revertChange: anIceMethodChange.	self refresh.! !!IceDiff methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!theirSnapshot: package 	^ theirVersion ifNotNil: [ 		theirVersion snapshotFor: package ]! !!IceDiff methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!theirVersion	^ theirVersion! !!IceDiff methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!theirVersion: anObject	theirVersion := anObject! !!IceAbstractVersion class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!forPackage: package	^ self new package: package; yourself! !!IceAbstractVersion methodsFor: 'as yet unclassified' stamp: ' 7/24/2017 12:50:04'!beCurrent	"By default do not to anything, version should have a package manager that makes them current without Iceberg intervention."! !!IceAbstractVersion methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!incomingCommits	^ #()! !!IceAbstractVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!package	^ package! !!IceAbstractVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!package: anObject	package := anObject! !!IceAbstractVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ self package repository! !!IceAbstractVersion methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!snapshot	^ [ self mcVersion snapshot ] on: IceVersionDoesNotExist do: [ MCSnapshot empty ]! !!IceAbstractVersion methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!updated	^ self! !!IceForeignVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commit	^ nil! !!IceForeignVersion methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!description	^ self package workingCopy gtDisplayString ! !!IceForeignVersion methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!hideYourselfFromCommitWalk: commitWalk	"Do nothing. I can't filter a commit walk because I do not know my commit."! !!IceForeignVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!mcVersion	^ mcVersion ifNil: [ mcVersion := self package workingCopy loadedVersion ]! !!IceForeignVersion methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream print: self class;		nextPut: $(;		nextPutAll: 			(mcVersion 				ifNotNil: [ mcVersion printString ] 				ifNil: [ self package name ]);		nextPut: $).! !!IceSavedPackageVersion class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!forPackage: package	"Use fromCommit:package: instead"	self shouldNotImplement ! !!IceSavedPackageVersion class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!fromCommit: commit package: package	^ self new		commit: commit;		package: package;		yourself! !!IceSavedPackageVersion methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!= another	self species = another species ifFalse: [ ^ false ].		"If I both load commits are equal, we are the same version."	self commit = another commit ifTrue: [ ^ true ]. 	"If not, look for actual origination commits and compare them."	^ self originatingCommit = another originatingCommit.! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!author	^ self info author! !!IceSavedPackageVersion methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!beCurrent 	"Ensure that the working copy points to the right info."	self package workingCopy versionInfo: self info.	! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commit	^ commit! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commit: anIceCommit	commit := anIceCommit ! !!IceSavedPackageVersion methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!description	^ self commit description ! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!entry	^ entry! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!entry: anObject	entry := anObject.	entry repository: self repository! !!IceSavedPackageVersion methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!hideYourselfFromCommitWalk: commitWalk	commitWalk uptoCommit: self commit! !!IceSavedPackageVersion methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!incomingCommits	"Returns only the commits modifying this package."	^ self repository newCommitWalk 		fromHead;		uptoVersion: self; 		versionsFor: self package! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!info	^ info ifNil: [ info := IceMCVersionInfo new fromCommit: self commit package: package ]! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!info: anObject	info := anObject! !!IceSavedPackageVersion methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!isAncestorOf: anotherVersion	^ self commit isAncestorOf: anotherVersion commit! !!IceSavedPackageVersion methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!isAncestorOfCommitId: anotherCommitId	^ self commit isAncestorOf: (self repository commitAt: anotherCommitId)! !!IceSavedPackageVersion methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!isNewerThan: another	^ self info timeStamp > another info timeStamp! !!IceSavedPackageVersion methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!load	self mcVersion load.	self repository versionLoaded: self.! !!IceSavedPackageVersion methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!mcVersion	^ self repository backend mcVersionFor: self! !!IceSavedPackageVersion methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!nextVersionName	^ ('{1}-{2}.{3}' format: {		self package packageName. 		self author. 		self info versionNumber + 1	})! !!IceSavedPackageVersion methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!originatingCommit	^ originatingCommit ifNil: [ originatingCommit := 		self repository newCommitWalk 			fromCommit: self commit;			modifyingPackage: self package;			firstCommit 		]! !!IceSavedPackageVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageName	^ self package packageName! !!IceSavedPackageVersion methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!parent	^ (self repository newCommitWalk 		fromCommit: self commit; 		modifyingPackage: self package;		maxNumber: 2;		commits)		second "First commit will be my own commit, the second is my parent"		versionFor: self package.! !!IceSavedPackageVersion methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream print: self class;		nextPut: $(;		nextPutAll: self package name.	commit ifNotNil: [ 		aStream 		nextPutAll: ', loaded from: ';		nextPutAll: commit shortId ].			originatingCommit ifNotNil: [ 		aStream 			nextPutAll: ', committed in: ';			nextPutAll: originatingCommit shortId ].			aStream nextPut: $).! !!IceTemporaryVersion methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!commit	"I am a temporary version, I am not related to any commit or it is unknown. 	When computing a reference commit I must be ignored."	^ nil! !!IceTemporaryVersion methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!snapshot	"I am only a temporary version, I can't provide a meaningful snapshot"	^ MCSnapshot empty! !!IceTemporaryVersion methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!updated	| newVersion |	newVersion := self package computeLoadedVersion.	self package repository loadedCode versionLoaded: newVersion.	^ newVersion! !!IceBackendWriterAdapter class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!for: anIceBackend	^ self new backend: anIceBackend; yourself.! !!IceBackendWriterAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!backend	^ backend! !!IceBackendWriterAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!backend: anObject	backend := anObject! !!IceBackendWriterAdapter methodsFor: 'accesing' stamp: ' 7/24/2017 12:50:04'!directory	^ self backend codeDirectory ! !!IceBackendWriterAdapter methodsFor: 'acessing' stamp: ' 7/24/2017 12:50:04'!propertyFileExtension	^ MCFileTreeRepository defaultPropertyFileExtension! !!IceClassReference class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!forDefinition: anMCDefinition	^ anMCDefinition actualClass 		ifNil: [ IceRemovedClassReference for: anMCDefinition ]		ifNotNil: [:class | IceSimpleClassReference new targetClass: class ]! !!IceClassReference methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!= other	^ other class = self class and: [ other description = self description ]! !!IceClassReference methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!hash	^ self description hash! !!IceRemovedClassReference class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!for: aMCClassDefinition 	^ self new		targetClassName: aMCClassDefinition className;		packageName: aMCClassDefinition classCategory		yourself! !!IceRemovedClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!browse	IceTool uiManager 		abort: ('Class {1} was removed from the system' format: { self targetClassName })		title: 'Unable to browse class'! !!IceRemovedClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!canBeBrowsed	^ false! !!IceRemovedClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!canBrowseReferences	^ false! !!IceRemovedClassReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!description	^ self targetClassName ! !!IceRemovedClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!icon	^ Smalltalk ui icons iconNamed: #changeRemove ! !!IceRemovedClassReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageName	^ packageName! !!IceRemovedClassReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageName: anObject	packageName := anObject! !!IceRemovedClassReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!targetClassName	^ targetClassName! !!IceRemovedClassReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!targetClassName: anObject	targetClassName := anObject! !!IceSimpleClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!browse	self targetClass browse! !!IceSimpleClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!browseReferences	self systemNavigation browseAllCallsOnClass: self targetClass! !!IceSimpleClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!canBeBrowsed	^ true! !!IceSimpleClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!canBrowseReferences	^ true! !!IceSimpleClassReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!description	^ self targetClass name! !!IceSimpleClassReference methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!icon	^ Smalltalk ui icons iconNamed: #class! !!IceSimpleClassReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageName	^ self targetClass package name! !!IceSimpleClassReference methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream 		print: self class;		nextPut: $(;		print: self targetClass;		nextPut: $)! !!IceSimpleClassReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!targetClass	^ targetClass! !!IceSimpleClassReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!targetClass: anObject	targetClass := anObject! !!IceBranch class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isRemoteBranchName: branchName	^ ((branchName beginsWith: 'refs/remotes/') 		or: [ branchName beginsWith: 'remotes/' ])! !!IceBranch class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!named: branchName inRepository: repo	^ self 		named: branchName		local: (self isRemoteBranchName: branchName) not		inRepository: repo! !!IceBranch class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!named: branchName local: isLocal inRepository: repo	^ (isLocal ifTrue: IceLocalBranch ifFalse: IceRemoteBranch)		named: branchName inRepository: repo.! !!IceBranch methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!= anotherBranch	self species = anotherBranch species ifFalse: [ ^ false ].	self repository = anotherBranch repository ifFalse: [ ^ false ].	^ self name = anotherBranch name! !!IceBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!backend	^ self repository backend! !!IceBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!changedPackagesToCommitInfo: aCommitish	^ aCommitish changedPackagesToCommitInfo: self lastCommit! !!IceBranch methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!commits	^ self repository newCommitWalk fromBranch: self; commits! !!IceBranch methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!commitsNotIn: anotherBranch	^ self repository newCommitWalk		fromBranch: self;		uptoBranch: anotherBranch;		commits! !!IceBranch methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!includesCommit: commit	^ self lastCommit isDescendantOf: commit! !!IceBranch methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isLocal	^ false! !!IceBranch methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isRemote	^ false! !!IceBranch methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!lastCommit	"The first commit in the list was the last in time."	^ self repository newCommitWalk fromBranch: self; firstCommit! !!IceBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name	^ name! !!IceBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name: anObject	name := anObject! !!IceBranch methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut: $(;		nextPutAll: self name;		nextPut: $).! !!IceBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!IceBranch methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!snapshotFor: package	^ self lastCommit snapshotFor: package! !!IceBranch methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!versionsFor: package	"Will only produce versions for commits that have actual changes for the package"	^ self repository newCommitWalk 		fromBranch: self;		versionsFor: package! !!IceBranch methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!versionsFor: package detect: selectBlock ifNone: ifNoneBlock 	"Will only produce versions for commits that have actual changes for the package"	^ self repository newCommitWalk 		fromBranch: self;		versionsFor: package detect: selectBlock ifNone: ifNoneBlock ! !!IceLocalBranch class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!named: branchName inRepository: repo	^ self new 		name: (branchName withoutPrefix: 'refs/heads/'); 		repository: repo; 		yourself! !!IceLocalBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!basename	^ self name! !!IceLocalBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!committish	^ (self name includesSubstring: 'detached')		ifTrue: [ ('\(detached from ([0-9a-f]+)\)' asRegex) matches: self name; subexpression: 2 ]		ifFalse: [ self name ]! !!IceLocalBranch methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!incomingCommits	^ self upstream		ifNotNil: [ self upstream commitsNotIn: self ]		ifNil: [ #() ]! !!IceLocalBranch methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!incomingCommitsFrom: aRemote 	^ (self upstreamFor: aRemote) 		ifNotNil: [ :remoteUpstream | remoteUpstream commitsNotIn: self ]		ifNil: [ #() ]! !!IceLocalBranch methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isLocal	^ true! !!IceLocalBranch methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!outgoingCommits: aBlock	| walk | 	walk := self repository newCommitWalk fromBranch: self.	self upstream 		ifNotNil: [ walk uptoBranch: self upstream ]		ifNil: [ walk uptoBranches: (			self repository localBranches copyWithout: self) ].	aBlock cull: walk.	^ walk commits.! !!IceLocalBranch methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!outgoingCommitsTo: aRemote do: aBlock	| walk | 	walk := self repository newCommitWalk fromBranch: self.	(self upstreamFor: aRemote)		ifNotNil: [ :aRemoteBranch | walk uptoBranch: aRemoteBranch ].	aBlock cull: walk.	^ walk commits.! !!IceLocalBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!upstream	^ upstream ifNil: [ 		self backend upstream 			ifNotNil: [ :upstreamName |				upstream := (IceRemoteBranch named: upstreamName inRepository: self repository) ] ]! !!IceLocalBranch methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!upstreamFor: aRemote	^ aRemote 		upstreamForBranch: self		backend: self backend! !!IceRemoteBranch class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!named: branchName inRepository: repo	^ self new 		name: ((branchName withoutPrefix: 'refs/') withoutPrefix: 'remotes/'); 		repository: repo; 		yourself! !!IceRemoteBranch class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!remoteName: remoteName branchName: branchName inRepository: aRepository 	^ self new 		name: remoteName, '/', branchName; 		repository: aRepository; 		yourself! !!IceRemoteBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!basename	^ self name copyAfterLast: $/! !!IceRemoteBranch methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isRemote	^ true! !!IceRemoteBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remoteName	^ self name copyUpToLast: $/! !!IceCommitInfo class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!createFrom: aGitLogLine	^ self new 		initializeFrom: aGitLogLine;		yourself.! !!IceCommitInfo methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!= another	^ another species = self species and: [ self commitId = another commitId ]! !!IceCommitInfo methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!backend	^ self repository backend! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!changedPackagesTo: aCommitish	"If is first commit, it will have no parents. Answer all packages because 	 all are 'changed'"	aCommitish ifNil: [ ^ self repository savedPackages ].	^ aCommitish changedPackagesToCommitInfo: self ! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!changedPackagesToCommitInfo: aCommitInfo	| files packageNames |	files := self backend changedFilesBetween: self and: aCommitInfo.	packageNames := (files 		select: [ :each | each includesSubstring: '.package' ] 		thenCollect: [ :each | | packageName |			packageName := each copyFrom: 1 to: (each findString: '.package') - 1.			(packageName includesSubstring: '/') 				ifTrue: [ packageName copyAfterLast: $/ ]				ifFalse: [ packageName ] ])		asSet.	^ packageNames sorted		select: [ :each | self repository includesPackageNamed: each  ] 		thenCollect: [ :each | self repository packageNamed: each ]! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!comment	^ comment! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!comment: anObject	comment := anObject! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commitId	^ commitId! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commitId: anObject	commitId := anObject! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!compatibleTimestamp	"I'm a timestamp as system: likes authorname MM/DD/YYYY HH:MM"	^ String streamContents: [ :stream |		stream 			<< self compatibleUsername 			<< ' '		 	<< self datetime asStringYMDHM  ]! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!compatibleUsername	"Timestamp of method has a very precise format that needs to be fulfiled: 				'FirstnameLastname MM/DD/YYYY HH/MM' 		Problem is that git username is different: Firstname Lastname.	To make this compatible, we remove spaces... but this can be a problem in the future... 	we'll see."	^ self username reject: [ :each | each = Character space ]	! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!datetime	^ datetime! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!datetime: anObject	datetime := anObject! !!IceCommitInfo methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!description	^ String streamContents: [ :stream | 		stream 			nextPutAll: self shortId; 			nextPutAll: ' (';			nextPutAll: self printShortTime;			nextPut: $) ]! !!IceCommitInfo methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!diffFromHead	^ IceDiff from: self repository headCommit to: self! !!IceCommitInfo methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!diffTo: aCommitInfo	^ IceDiff from: self to: aCommitInfo! !!IceCommitInfo methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!diffToParent	^ self diffTo: (self parents 			ifNotEmpty: #first			ifEmpty: [ nil ])! !!IceCommitInfo methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!hash	^ self id hash! !!IceCommitInfo methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!hideYourselfFromCommitWalk: commitWalk	commitWalk uptoCommit: self	! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!id	^ commitId! !!IceCommitInfo methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeFrom: aGitLogLine	"Reads commit info out of a git commit log line, such as: '|f659e2851cb84eb6812b19e5a820c06fb509b0d5|Nicolás Passerini|2016-05-27 09:20:49 +0200|ea6c151|Updated test method with version 2'. 	This lines are obtained with git log options: '--format=|%H|%an|%ai|%p|%s' as in IceRepository>>incomingCommits. "	| elements |	elements := $| split: aGitLogLine.	self		commitId: (elements at: 2);		username: (elements at: 3);		datetime: (DateAndTime readFrom: (elements at: 4) readStream );		parentIds: ((Character space split: (elements at: 5) trim) select: #notEmpty);		comment: (elements at: 6)! !!IceCommitInfo methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!isAncestorOf: anotherCommit	"Warning: this method considers that a commit is ancestor of itself."	^ self = anotherCommit 		or: [ anotherCommit isDescendantOf: self]! !!IceCommitInfo methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!isCurrent	^ repository loadedCode referenceCommit = self ! !!IceCommitInfo methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!isDescendantOf: aCommit	^ self repository newCommitWalk		fromCommit: self;		includesCommit: aCommit! !!IceCommitInfo methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!isLoaded	^ self isAncestorOf: repository loadedCode referenceCommit! !!IceCommitInfo methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!isMerged	^ repository branch includesCommit: self! !!IceCommitInfo methodsFor: 'detached head' stamp: ' 7/24/2017 12:50:04'!lastCommit	^ self! !!IceCommitInfo methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!load	(self changedPackagesTo: self repository loadedCode referenceCommit)		collect: [ :package | self versionFor: package ]		thenDo: [:version | version load ]! !!IceCommitInfo methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!merge	self repository merge: self! !!IceCommitInfo methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!mergeBaseWith: anotherCommit	^ self repository commitAt: 		(self repository backend mergeBaseBetween: self id and: anotherCommit id)! !!IceCommitInfo methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!mergeInto: aBranch	self repository 		merge: self		into: aBranch! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name	^ self shortId! !!IceCommitInfo methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!ownVersions	^ self repository savedPackages collect: [ :package | 		self versionFor: package ]! !!IceCommitInfo methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!packageNames	^ self repository backend packagesPresentOn: self! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!parentIds	^ parentIds! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!parentIds: anObject	parentIds := anObject! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!parents	^ parents ifNil: [ 		parents := parentIds 			collect: [ :parentId | self repository commitAt: parentId ] ]! !!IceCommitInfo methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream nextPutAll: self class name;		nextPut: $(;		nextPutAll: (self commitId first: 7);		nextPutAll: ', ';		print: self datetime;		nextPutAll: ', ';		nextPutAll: comment;		nextPut: $)		 ! !!IceCommitInfo methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printShortTime	^ self datetime asDate = Date today	ifTrue: [ self datetime asTime asString ]	ifFalse: [ self datetime asDate asString ]! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!shortId	^ commitId first: 7! !!IceCommitInfo methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!snapshotFor: package 	^ (self versionFor: package) ifNotNil: #snapshot! !!IceCommitInfo methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!status	self isCurrent ifTrue: [ ^ 'Current' ].	self isLoaded ifTrue: [ ^ 'Loaded' ].	self isMerged ifTrue: [ ^ 'Not loaded' ].	^ 'Not merged'! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!username	^ username! !!IceCommitInfo methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!username: anObject	username := anObject! !!IceCommitInfo methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!versionFor: package	^ IceSavedPackageVersion fromCommit: self package: package! !!IceCommitInfo methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!versionsChangedSince: anotherCommit	| changes | 		changes := OrderedCollection new.	self repository loadedPackages do: [ :package | 		| myVersion theirVersion |		myVersion := self versionFor: package.		theirVersion := anotherCommit versionFor: package.		(myVersion = theirVersion)			ifFalse: (changes add: myVersion)	].		^ changes! !!IceCommitInfo methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!versionsFor: package	"Will only produce versions for commits that have actual changes for the package"	^ self repository newCommitWalk 		fromCommit: self;		versionsFor: package! !!IceCommitish class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!image	^ IceWorkingCopy instance! !!IceCommitish methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!canRevertChanges	^ false! !!IceCommitish methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!changedPackagesTo: aCommitish	"This method will implement a double dispatch, since the strategies to resolve deltas 	 change if you are comparing: 		- loaded code -> working copy		- a commit -> a branch 		- a commit -> a commit	 and they need to be treated differently"	^ self subclassResponsibility! !!IceCommitish methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!diffWith: aCommitish	^ IceDiff from: self to: aCommitish ! !!IceCommitish methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!incomingCommits	^ #()! !!IceCommitish methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!incomingCommitsFrom: aRemote	^ #()! !!IceCommitish methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!outgoingCommits	^ self outgoingCommits: []! !!IceCommitish methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!outgoingCommits: aBlockClosure 	^ #()! !!IceCommitish methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!outgoingCommitsTo: aRemote 	^ self outgoingCommitsTo: aRemote do: []! !!IceCommitish methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!outgoingCommitsTo: aRemote do: aBlock	^ #()! !!IceCommitish methodsFor: 'detached head' stamp: ' 7/24/2017 12:50:04'!refresh	"Do nothing. This provides polymorphism with IceBranches, in a repo with a detached head."! !!IceLoadedCode class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!repository: repository	^ self basicNew 		repository: repository; 		initialize; 		yourself! !!IceLoadedCode methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!changedPackagesToWorkingCopy: aWorkingCopy	| lastCommit commitPackageNames loadedPackageNames added removed |		lastCommit := self repository branch lastCommit.	commitPackageNames := lastCommit packageNames.	loadedPackageNames := self repository loadedPackages collect: #name.	added := (loadedPackageNames \ commitPackageNames) 		collect: [ :each | self repository packageNamed: each ]. 	"this will give me the removals, but I'm still don't know what to do with them	 (because if I just add it it will show them as added not as removed)"	"removed := (commitPackageNames \ loadedPackageNames)		reject: [ :each | self repository includesPackageNamed: each ]		thenCollect: [ :each | IceSavedPackage named: each repository: self repository ]."	^ added, (self loadedVersions keys select: #isModified)! !!IceLoadedCode methodsFor: 'events' stamp: ' 7/24/2017 12:50:04'!commited: newCommit changingPackages: packages	self repository addCommit: newCommit.	packages do: [ :package | self versionLoaded: (newCommit versionFor: package) ].	referenceCommit := newCommit.	repository announcer announce: IceCommited new.! !!IceLoadedCode methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!commitsNotLoaded	^ self repository newCommitWalk		fromHead;		upto: self referenceCommit;		commits ! !!IceLoadedCode methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!computeReferenceCommit	| candidates |		"1. If no code has been loaded, take HEAD commit as reference."	self loadedVersions isEmpty ifTrue: [ ^ self repository headCommit ].			"2. Happy path: see if all loaded code has the same updation commit. 	If we can't compute an updation commit for some loaded code, it means that it has been 	probably loaded from another kind of repository, we just ignore it."	candidates := (self loadedVersions collect: [:version | version commit] as: Set) reject: #isNil.	candidates size = 1 ifTrue: [ ^ candidates anyOne ].	"3. None of the loaded versions produced a non nil candidate, just use the HEAD commit"		candidates isEmpty ifTrue: [ ^ self repository headCommit ].	"4. We could try other strategies... but this should be good for now."		^ candidates detectMax: #datetime! !!IceLoadedCode methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!description	^ self loadedVersions 		ifEmpty: ['No package loaded']		ifNotEmpty: [ self referenceCommit description ] ! !!IceLoadedCode methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!loadedVersions	^ loadedVersions ifNil: [ 		loadedVersions := Dictionary new.		repository loadedPackages do: [ :pkg | self versionLoaded: pkg computeLoadedVersion ].			loadedVersions 	]! !!IceLoadedCode methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!mergeBaseWith: aCommit	^ self referenceCommit mergeBaseWith: aCommit! !!IceLoadedCode methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!referenceCommit	^ referenceCommit ifNil: [ referenceCommit := self computeReferenceCommit ]! !!IceLoadedCode methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!refresh	loadedVersions := nil.	referenceCommit := nil.! !!IceLoadedCode methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceLoadedCode methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!IceLoadedCode methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!snapshotFor: package	^ (self versionFor: package) snapshot! !!IceLoadedCode methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!versionFor: package 	^ self loadedVersions 		at: package 		ifPresent: #updated		ifAbsent: [ self loadedVersions at: package put: package computeLoadedVersion ]		! !!IceLoadedCode methodsFor: 'events' stamp: ' 7/24/2017 12:50:04'!versionLoaded: version	self loadedVersions at: version package put: version.	version beCurrent.	"Reset reference commit so that it gets recomputed the next time it is needed"	referenceCommit := nil.! !!IceTag class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!named: aTagName inRepository: anIceRepository 	^ self new name: aTagName; repository: anIceRepository; yourself! !!IceTag methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!commit	^ commit ifNil: [ commit := self repository newCommitWalk fromTag: self; firstCommit ]! !!IceTag methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!lastCommit	^ self repository backend revparseCommit: self name! !!IceTag methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name	^ name! !!IceTag methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name: anObject	name := anObject! !!IceTag methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceTag methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!IceTag methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!versionFor: package	^ self commit versionFor: package! !!IceTag methodsFor: 'as yet unclassified' stamp: ' 7/24/2017 12:50:04'!versionsFor: package 	^ self commit versionsFor: package! !!IceUnbornBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!description	^ self name! !!IceUnbornBranch methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!hideYourselfFromCommitWalk: commitWalk 	"Do nothing, I do not have commits."! !!IceUnbornBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!lastCommit	^ self ! !!IceUnbornBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name	^ '<New branch>'! !!IceUnbornBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!nameForFirstCommit	"When doing 'first commit' of an unborn branch, we need to declare the branch name, 	 we take by default 'master', because this is what most people do."	^ 'master'! !!IceUnbornBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageNames	^ #()! !!IceUnbornBranch methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!versionsFor: aPackage 	^ #()! !!IceUnknownBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!description	^ self name! !!IceUnknownBranch methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!hideYourselfFromCommitWalk: commitWalk 	"Do nothing, I do not have commits."! !!IceUnknownBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!lastCommit	^ self ! !!IceUnknownBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name	^ '<Unknown>'! !!IceUnknownBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!nameForFirstCommit	"When doing 'first commit' of an unborn branch, we need to declare the branch name, 	 we take by default 'master', because this is what most people do."	^ 'master'! !!IceUnknownBranch methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageNames	^ #()! !!IceUnknownBranch methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!versionsFor: aPackage 	^ #()! !!IceWorkingCopy class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!instance	^ Instance ifNil: [ Instance := self new ]! !!IceWorkingCopy methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!canRevertChanges	^ true! !!IceWorkingCopy methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!changedPackagesTo: aCommitish	^ aCommitish changedPackagesToWorkingCopy: self! !!IceWorkingCopy methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!revertChange: anIceMethodChange	| loader |	loader := MCPackageLoader new.	anIceMethodChange operation inverse applyTo: loader.	loader load.! !!IceWorkingCopy methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!snapshotFor: package	^ package workingCopy snapshot! !!IceCredentialsProvider class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!default	^ self providerType new! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!plaintextCredentials	^ PlaintextCredentials ifNil: [ PlaintextCredentials := IcePlaintextCredentials new ]! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!plaintextCredentials: anObject	PlaintextCredentials := anObject! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!providerType	^ ProviderType ifNil: [ ProviderType := IceCredentialsProvider ]! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!providerType: anObject	ProviderType := anObject! !!IceCredentialsProvider class methodsFor: 'settings' stamp: ' 7/24/2017 12:50:04'!settingsOn: aBuilder 	<systemsettings>	(aBuilder setting: #useCustomSsh)		parent: #Iceberg;		noOrdering;		target: self;		label: 'Use custom SSH keys';		description: 'Check if you want to have your own pair of keys (id_rsa and id_rsa.pub), without using the ssh-agent';		with: [			(aBuilder setting: #username)				target: self;				targetSelector: #sshCredentials;				label: 'SSH Username';				description: 'If you are trying to connect to github through ssh (something like git@github.com:owner/projectName), the username should be `git`'.			(aBuilder setting: #publicKey)				target: self;				targetSelector: #sshCredentials;				type: #FilePathEncoder;				label: 'Public SSH key';				description: 'The path to your private ssh key, probably /home/<userName>/.ssh/id_rsa.pub'.			(aBuilder setting: #privateKey)				target: self;				targetSelector: #sshCredentials;				type: #FilePathEncoder;				label: 'Private SSH key';				description: 'The path to your private ssh key, probably /home/<userName>/.ssh/id_rsa'.			(aBuilder setting: #keyPassphrase)				target: self;				targetSelector: #sshCredentials;				label: 'Passphrase of your SSH key'.		].		(aBuilder group: #'Plaintext Credentials')		parent: #Iceberg;		noOrdering;		with: [ 			(aBuilder setting: #username)				target: self;				targetSelector: #plaintextCredentials;				label: 'Github username';				description: 'Your github username'.			(aBuilder setting: #password)				target: self;				targetSelector: #plaintextCredentials;				type: #Password;				label: 'Your github password, if you want Iceberg to remember it, but be aware that this does not pretend to be safe.'.		]! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!sshCredentials	^ SshCredentials ifNil: [ SshCredentials := IceSshCredentials new ]! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!sshCredentials: anObject	SshCredentials := anObject! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!sshCredentialsClass	self useCustomSsh ifTrue: [ ^ LGitCredentialsSSH ].	^ LGitCredentialsSSHAgent	! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!useCustomSsh	^ UseCustomSsh ifNil: [ UseCustomSsh := false ]! !!IceCredentialsProvider class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!useCustomSsh: aBoolean	UseCustomSsh := aBoolean! !!IceCredentialsProvider methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	tries := 0.! !!IceCredentialsProvider methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!plaintextCredentials	^ self class plaintextCredentials! !!IceCredentialsProvider methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!sshCredentials	^ self class sshCredentials! !!IceCredentialsProvider methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!sshCredentialsClass	^ self class sshCredentialsClass! !!IceMetacelloRepositoryAdapter class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!for: anIceRepository 	^ self new repository: anIceRepository; yourself! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!addTo: aMCRepositoryGroup 	^ aMCRepositoryGroup addBasicRepository: self! !!IceMetacelloRepositoryAdapter methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!canUpgradeTo: anMCGitBasedRepository 	"Copied from MCGitBasedNetworkRepository"  (anMCGitBasedRepository isKindOf: self class) ifFalse: [ ^ false ].  ^ self projectPath = anMCGitBasedRepository projectPath 	and: [ self repoPath = anMCGitBasedRepository repoPath ]! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commitIdFor: aWorkingCopy ifFound: aBlock	self flag: #todo. "Do nothing?"! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!description	^ self repository backend description! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!getOrCreateIcebergRepository	^ self repository! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!goferPriority	^ 8! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!goferReferences	^ self repository savedPackages collect: [ :package | 		GoferResolvedReference name: package latestVersion info name repository: self ]! !!IceMetacelloRepositoryAdapter methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!hasNoLoadConflicts: anMCGitBasedRepository	"Copied from MCGitBasedNetworkRepository"  	(anMCGitBasedRepository isKindOf: self class) ifFalse: [ ^ false ].	^ self projectPath = anMCGitBasedRepository projectPath and: [		self repoPath = anMCGitBasedRepository repoPath and: [ 			self projectVersion = anMCGitBasedRepository projectVersion ] ]! !!IceMetacelloRepositoryAdapter methodsFor: 'compatibility' stamp: ' 7/24/2017 12:50:04'!isCache	"User for Kommiter and Versionner"	^ false! !!IceMetacelloRepositoryAdapter methodsFor: 'compatibility' stamp: ' 7/24/2017 12:50:04'!isRemote	"User for Komitter"	^ false! !!IceMetacelloRepositoryAdapter methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isValid	^ true! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!projectPath	^ self repository origin projectPath! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!projectVersion	^ self repository branchName! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repoPath	^ self repository subdirectory ! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!IceMetacelloRepositoryAdapter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repositoryDescription	^ self repository description! !!IceMetacelloRepositoryAdapter methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!repositoryVersionString	^ self repository headCommit id! !!IceMetacelloRepositoryAdapter methodsFor: 'versions' stamp: ' 7/24/2017 12:50:04'!versionFrom: aVersionName 	| packageName package version |	packageName := (MCFileTreeRepository parseName: aVersionName) first.	package := self repository packageNamed: packageName.		version := package latestVersion.	version info name = aVersionName ifFalse: [		version := package versions detect: [ :ver | ver info name = aVersionName ]].		^ version mcVersion				! !!IcePackageReference class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!named: aPackageName	^ self new 		packageName: aPackageName;		yourself! !!IcePackageReference methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!= anotherPackage	^ anotherPackage species = self species 	and: [ self packageName = anotherPackage packageName ]! !!IcePackageReference methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!browse	(RPackageOrganizer default packageNamed: self name) browse! !!IcePackageReference methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!changesIn: commitish comparedToBase: baseCommitish	^ (MCPatch 		fromBase: (baseCommitish snapshotFor: self)		target: (commitish snapshotFor: self))		operations! !!IcePackageReference methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!isLoaded	^ RPackageOrganizer default includesPackageNamed: packageName! !!IcePackageReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name	^ packageName! !!IcePackageReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageName	^ packageName! !!IcePackageReference methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageName: anObject	packageName := anObject! !!IcePackageReference methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printDescriptionOn: aStream	aStream nextPut: $(;		nextPutAll: packageName;		nextPutAll: ', ';		nextPutAll: (self isLoaded ifTrue: 'loaded' ifFalse: 'not loaded');		nextPut: $)		! !!IcePackageReference methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream nextPutAll: self class name.	self printDescriptionOn: aStream! !!IcePackageReference methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!workingCopy	^ self isLoaded ifTrue: [		MCWorkingCopy forPackage: (MCPackage named: self packageName)]! !!IcePlaintextCredentials methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isPresent	^ self username isEmpty not and: [ self password isEmpty not ]! !!IcePlaintextCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!password	^ password ifNil: [ password := '' ]! !!IcePlaintextCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!password: anObject	password := anObject! !!IcePlaintextCredentials methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!readFrom: credentials	self username: credentials username.	self password: credentials password! !!IcePlaintextCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!username	^ username ifNil: [ username := '' ]! !!IcePlaintextCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!username: anObject	username := anObject! !!IceFileRemote class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!canHandleUrl: aRepositoryUrl	^ aRepositoryUrl beginsWith: 'file:'! !!IceFileRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!detailedInfo	^ { 'Origin' -> path pathString }! !!IceFileRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!host	^ 'local filesystem'! !!IceFileRemote methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!organizer	^ 'local'! !!IceFileRemote methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!parseUrl	| matcher |	matcher := 'file\://(.*)' asRegex.	(matcher matches: url) 		ifTrue: [ 			path := (matcher subexpression: 2) asFileReference.			projectName := path basename.		]		ifFalse: [ IceWrongUrl signal: 'Could not parse  "file:" url: ', url ]! !!IceFileRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!projectName	^ path basename! !!IceHttpRemote class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!canHandleUrl: aRepositoryUrl	^ (aRepositoryUrl beginsWith: self protocolID, '://') ! !!IceHttpRemote class methodsFor: 'defaults' stamp: ' 7/24/2017 12:50:04'!defaultPort	"Returns the HTTP default port"		^80! !!IceHttpRemote class methodsFor: 'defaults' stamp: ' 7/24/2017 12:50:04'!protocolID	"Return the protocol identifier"		^'http'! !!IceHttpRemote methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!parseUrl	| matcher |	matcher := '((http|https)\://)(([\w]+)@)*([\w.]+)(\:([\d]+))*(/[\w]+)*/([\w\-]+)/([\w\-.]+(.git)?)' asRegex.	(matcher matches: url) 		ifTrue: [					user := matcher subexpression: 5.			host := matcher subexpression: 6.			port := (matcher subexpression: 8)				ifNotNil: [: x | x asInteger ] 				ifNil: [ self class defaultPort ].				 			path := (matcher subexpressions: 9)				inject: OrderedCollection new 				into: [:coll :each  | coll add: each allButFirst. coll ]. 			owner := matcher subexpression: 10.			projectName := self stripPossibleExtension: (matcher subexpression: 11) ]		ifFalse: [ IceWrongUrl signal: 'Could not parse URL: ', url ]! !!IceHttpRemote methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!stripPossibleExtension: aString	^ (aString endsWith: '.git')		ifTrue: [ aString allButLast: 4 ]		ifFalse: [ aString ]! !!IceHttpsRemote class methodsFor: 'defaults' stamp: ' 7/24/2017 12:50:04'!defaultPort	"Returns the HTTPS default port"		^443! !!IceHttpsRemote class methodsFor: 'defaults' stamp: ' 7/24/2017 12:50:04'!protocolID	"Return the protocol identifier"		^'https'! !!IceHttpsRemote methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!referencesSameRemoteLocationAs: aRemote	^ (super referencesSameRemoteLocationAs: aRemote)		or: [ self url = aRemote httpsUrl ] ! !!IceNetworkRemote class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!canHandleUrl: aString 	"I am abstract I can't handle any url."	^ false! !!IceNetworkRemote class methodsFor: 'defaults' stamp: ' 7/24/2017 12:50:04'!defaultPort	^self subclassResponsibility! !!IceNetworkRemote methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!basicUrl: aString	url := (aString endsWith: '.git') 		ifTrue: [ aString ]		ifFalse: [ aString, '.git' ]! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!detailedInfo	^ { 		'Origin' -> self url.		'Remote User' -> self userName.		'Remote host' -> (self port = self class defaultPort ifTrue: [ self host ] ifFalse: [self host, ':', self portName]).		'Repo Owner' -> self owner.	} ! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!host	^ host! !!IceNetworkRemote methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!organizer	^ self owner! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!owner	 ^ owner! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!path	^path ifNil: [ path := OrderedCollection new ].! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!port	^port ifNil: [ self class defaultPort ]! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!portName	^self port asString! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!projectPath	^ self owner, '/', self projectName! !!IceNetworkRemote methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!referencesSameRemoteLocationAs: another	^ (self url withoutSuffix: '.git') = (another url withoutSuffix: '.git')! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!user	^user! !!IceNetworkRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!userName	^user ifNil: [ '' ]	! !!IceScpRemote class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!canHandleUrl: aRepositoryUrl	"Very simplistic implementation that does not cover all cases"	^ (aRepositoryUrl beginsWith: 'git@' )		or: [aRepositoryUrl beginsWith: 'ssh://']! !!IceScpRemote class methodsFor: 'defaults' stamp: ' 7/24/2017 12:50:04'!defaultPort	^ 22! !!IceScpRemote methodsFor: 'private - patches' stamp: ' 7/24/2017 12:50:04'!httpsUrl	^ 'https://{1}/{2}.git' format: { self host . self projectPath }! !!IceScpRemote methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!parseUrl	| matcher |	matcher := '(ssh\://)?(git@)?([\w.]+)(\:|/)/?([\w\-]+)/([\w\-]+)(\.git)?' asRegex.	(matcher matches: url) 		ifTrue: [			host := matcher subexpression: 4.			owner := matcher subexpression: 6.			projectName := matcher subexpression: 7.		]		ifFalse: [ IceWrongUrl signal: 'Could not parse URL: ', url ]! !!IceScpRemote methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!referencesSameRemoteLocationAs: aRemote	^ ((super referencesSameRemoteLocationAs: aRemote)		or: [ self httpsUrl = aRemote httpsUrl ])			! !!IceRemote class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!canHandleUrl: aRepositoryUrl	^ self subclassResponsibility ! !!IceRemote class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!name: aName url: anUrl	^ (self url: anUrl)		remoteName: aName;		yourself! !!IceRemote class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!url: aRepositoryUrl	self allSubclasses  		detect: [ :subclass | subclass canHandleUrl: aRepositoryUrl ]		ifFound: [ :subclass | ^ subclass new url: aRepositoryUrl ]		ifNone: [ IceWrongUrl signal: 'Remote repository scheme not supported: ', aRepositoryUrl ]! !!IceRemote methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!= another	^ self species = another species and: [ self referencesSameRemoteLocationAs: another ]	! !!IceRemote methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!basicUrl: aString	url := aString! !!IceRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!detailedInfo	^ #()! !!IceRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!host	^ self subclassResponsibility! !!IceRemote methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!httpsUrl	"This method is used to compare exchangeable addresses (https:// and git@). 	 So it has sense in my children, and is notably used on #isSameUrl: 	 implementations"	^ self url! !!IceRemote methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isOrigin	^ self remoteName = 'origin'! !!IceRemote methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isSame: aRemote	^ (self referencesSameRemoteLocationAs: aRemote)		and: [ self remoteName = aRemote remoteName ]! !!IceRemote methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!parseUrl	^ self subclassResponsibility ! !!IceRemote methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: stream	stream 		<< (self remoteName ifNil: [ 'noname' ]) 		<< ' (' << self url << ')'! !!IceRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!projectBasename	^ self projectName withoutSuffix: '.git'! !!IceRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!projectName	^ projectName! !!IceRemote methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!referencesSameRemoteLocationAs: another	"Base/trivial implementation is that two urls are the same if they are equal, 	but some subclasses have more complicated logic to detect two urls pointing to the same remote"	^ self url = another url	! !!IceRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remoteName	^ remoteName! !!IceRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remoteName: anObject	remoteName := anObject! !!IceRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!upstreamForBranch: aBranch backend: backend	^ backend 		lookupBranchNamed: aBranch name 		inRemote: self remoteName! !!IceRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!url	^ url! !!IceRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!url: aString	self basicUrl: aString.	self parseUrl! !!IceUndefinedRemote class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!canHandleUrl: aRepositoryUrl	^ false! !!IceUndefinedRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!host	^ nil! !!IceUndefinedRemote methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	super initialize.	url := 'No remote url'.	projectName := 'No name'.	remoteName := 'No remote'! !!IceUndefinedRemote methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!upstreamForBranch: aBranch backend: backend	^ nil! !!IceRepository class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!backend: aBackend	"This should be the only way to create a repository. Usually, this creator is called on 	 IceRepositoryCreator>>#createRepository."	^ self new 		backend: aBackend;		yourself! !!IceRepository class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultBackend	^ self defaultBackendType		ifNotNil: [ :className | 			Smalltalk				at: className				ifAbsent: [ IceError signal: 'Selected Iceberg backend is missing: ', className ] ]				ifNil: [ 			| backend | 			backend := self detectDefaultBackend.			self defaultBackend: backend.			backend ]! !!IceRepository class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultBackend: class	self defaultBackendType: class name! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/24/2017 12:50:04'!defaultBackendType	^ DefaultBackendType ifNil: [ DefaultBackendType := #IceLibgitLocalRepository ]! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/24/2017 12:50:04'!defaultBackendType: anObject	DefaultBackendType := anObject! !!IceRepository class methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!detectDefaultBackend	"Error if not backend"	TIceRepositoryBackend traitUsers 		ifEmpty: [ ^ IceError signal: 'There are no configured backend type' ].		"Detect default backend"	Smalltalk globals 		at: #IceLibgitLocalRepository		ifPresent: [ :class | ^ class ].		^ TIceRepositoryBackend traitUsers anyOne! !!IceRepository class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!localRepositoriesLocation	^ ((FileLocator respondsTo: #localDirectory) 		ifTrue: [ FileLocator localDirectory / #iceberg ]		ifFalse: [ FileLocator imageDirectory / #'iceberg-cache' ]) asFileReference! !!IceRepository class methodsFor: 'registry' stamp: ' 7/24/2017 12:50:04'!registerRepository: aRepository	^ self registry add: aRepository! !!IceRepository class methodsFor: 'registry' stamp: ' 7/24/2017 12:50:04'!registry	^ Registry ifNil: [ Registry := OrderedCollection new ]! !!IceRepository class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repositoriesLocation 	^ self shareRepositoriesBetweenImages 		ifTrue: [ self sharedRepositoriesLocation ]		ifFalse: [ self localRepositoriesLocation ] ! !!IceRepository class methodsFor: 'registry' stamp: ' 7/24/2017 12:50:04'!reset	Registry := nil.	Iceberg announcer announce: IceRepositoryForgotten new.! !!IceRepository class methodsFor: 'settings' stamp: ' 7/24/2017 12:50:04'!settingsOn: aBuilder 	<systemsettings>	(aBuilder pickOne: #'defaultBackendType')		parent: #Iceberg;		target: self;		label: 'Backend type';		description: 'Select your preferred way to access git repositories from Iceberg: the git command line (OSSubprocess) or the libgit2 library';		domainValues: 			((TIceRepositoryBackend traitUsers collect: [:class | class description -> class name ]) 				ifEmpty: { 'No backend' -> nil }).		(aBuilder setting: #shareRepositoriesBetweenImages)		parent: #Iceberg;		target: self;		label: 'Share repositories between images';		description: 'Check if you want to have your git repositories cloned by default in a single location that is shared between all your Pharo images';		with: [			(aBuilder setting: #sharedRepositoriesLocationString)				target: self;				type: #Directory;				label: 'Location for shared repositories';				description: 'A directory where you have your git repositories'.		].		! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/24/2017 12:50:04'!shareRepositoriesBetweenImages	^ ShareRepositoriesBetweenImages ifNil: [ ShareRepositoriesBetweenImages := false ]! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/24/2017 12:50:04'!shareRepositoriesBetweenImages: anObject	ShareRepositoriesBetweenImages := anObject! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/24/2017 12:50:04'!sharedRepositoriesLocation	^ SharedRepositoriesLocation ifNil: [ 		SharedRepositoriesLocation := (FileLocator home / #iceberg) asFileReference ]! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/24/2017 12:50:04'!sharedRepositoriesLocation: anObject	SharedRepositoriesLocation := anObject! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/24/2017 12:50:04'!sharedRepositoriesLocationString	^ self sharedRepositoriesLocation fullName! !!IceRepository class methodsFor: 'accessing settings' stamp: ' 7/24/2017 12:50:04'!sharedRepositoriesLocationString: aString	SharedRepositoriesLocation := aString asFileReference! !!IceRepository class methodsFor: 'registry' stamp: ' 7/24/2017 12:50:04'!unregisterRepository: aRepository ifAbsent: aBlock	^ self registry 		remove: aRepository 		ifAbsent: aBlock ! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!addCommit: newCommit	newCommit repository: self.	self commitDictionary 		at: newCommit id 		put: newCommit! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!addFilesToIndex: aListOfPaths	^ self backend 		addFilesToIndex: aListOfPaths! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!addPackage: aWorkingCopy	^ self savedPackagesDictionary		at: aWorkingCopy packageName		ifAbsentPut: [			IceSavedPackage 				named: aWorkingCopy packageName 				repository: self ]! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!addPackageNamed: packageName	^ self savedPackagesDictionary		at: packageName		ifAbsentPut: [ IceSavedPackage named: packageName repository: self ]! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/24/2017 12:50:04'!addRemote: aRemote  	^ self backend addRemote: aRemote! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!allBranches	^ self backend allBranches	! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!announcer	^ announcer! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!announcer: anObject	announcer := anObject! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!backend	^ backend! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!backend: aBackend	aBackend validate.	aBackend frontend: self.	backend := aBackend! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!basicMerge: aCommitish	"Try automatic merge handled by the (git?) repository itself. 	Will raise an IceMergeAborted in case that automatic merge 	detects conflicts that have to be solved manually."	| currentCommit |	currentCommit := self loadedCode referenceCommit.	self backend merge: aCommitish id.	(self headCommit changedPackagesTo: currentCommit) do: #loadLatest! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!basicOrigin	self isValid ifFalse: [ ^ nil ].	^ [ self backend origin ]		on: LGit_GIT_ENOTFOUND 		do: [ :e | nil ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!beSystemRepository	system := true! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branch	self isValid ifFalse: [ ^ IceUnknownBranch new ].	^ self backend branch! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branchName	^ self branch name! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!branchesForCheckout	"Returns a list of the most useful branches for being checked out"	| branches |	branches := self backend allBranches.	^ branches select: [ :br |		br isLocal or: [ branches noneSatisfy: [:b | b isLocal and: [ b basename = br basename ]]]	].! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!branchesForMerge: aCommit	"Returns a list of local branches to which we could merge the received commit"	^ self allBranches		select: [:each | (each includesCommit: aCommit) not ].! !!IceRepository methodsFor: 'repository handling' stamp: ' 7/24/2017 12:50:04'!checkForRegistryConflicts	self class registry 		detect: [ :repo | repo location = self location ]		ifFound: [ :repo | self origin = repo origin			ifTrue: [ 				IceDuplicatedRepository signal: 					('You already have an Iceberg repository at {1} and with the same origin URL. If you really whant create another one, please locate it in a different directory.'					 format: {self location pathString}) ]			ifFalse: [				IceDuplicatedRepository signal: 					('You already have an Iceberg repository at {1} but with a different origin URL.You provided {2} and the original repository''s url is {3}.'					 format: {self location. self origin. repo origin}) ]].! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!checkoutBranch: branchName	self backend checkoutBranch: branchName! !!IceRepository methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!commitAt: commitId	commitId size = 40 		ifTrue: [ 			^ self commitDictionary 				at: commitId				ifAbsent: [ self lookupCommit: commitId ]].	"Commit id is an abbreviation, sequential search"		(self commitDictionary keys 		select: [ :key | key beginsWith: commitId ]) 		in: [ :possibleKeys | 			possibleKeys size = 1 				ifTrue: [ ^ self commitDictionary at: possibleKeys anyOne ] 				ifFalse: [ possibleKeys isEmpty 					ifTrue: [ ^ self lookupCommit: commitId ] 					ifFalse: [ self error: 'Ambiguous commit hexString: ', commitId  ]]		]! !!IceRepository methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!commitAt: commitId ifAbsentPut: aBlock	^ self commitDictionary at: commitId ifAbsentPut: [ 		| newCommit |		newCommit := aBlock value.		newCommit repository: self; yourself 	]! !!IceRepository methodsFor: 'actions - utility' stamp: ' 7/24/2017 12:50:04'!commitCherryPick: pickedCollection withMessage: message	^ self 		commitCherryPick: pickedCollection		withMessage: message		andParents: { self headCommit }! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!commitCherryPick: pickedCollection withMessage: message andParents: parentCommitishList	"Commits a snapshot of definitions (can be a cherry-pick). 	 I need to group definitions in packages and create new versions for those packages, 	 which is annoying but is the price of using MC definitions :)"	| changesByPackage versions |		versions := OrderedCollection new.	changesByPackage := SmallDictionary new.	"Collect changes by package"	pickedCollection 		do: [ :each | (changesByPackage at: each packageName ifAbsentPut: [ Set new ]) add: each ].		"Create patched versions for each package"	changesByPackage 		keysAndValuesDo: [ :packageName :changes | | workingCopy snapshot patcher |			workingCopy := (RPackageOrganizer default packageNamed: packageName) mcWorkingCopy.			snapshot := (self packageNamed: packageName) loadedVersion snapshot.			patcher := MCPatcher snapshot: snapshot.			pickedCollection 				select: [ :each | each operation notNil ]				thenDo: [ :each | each operation applyTo: patcher ].			versions add: (MCVersion new				setPackage: workingCopy package				info: (IceMCVersionInfo package: workingCopy package message: message)				snapshot: patcher patchedSnapshot				dependencies: #()) ].		"save versions"	versions do: [ :each | self backend internalStoreVersion: each ].	"now perform commit"	self doCommitMcVersions: versions withMessage: message andParents: parentCommitishList! !!IceRepository methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!commitDictionary	^ commitDictionary! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!commitIndexWithMessage: message andParents: parentCommitishList	| packages newCommit |	packages := self stagedPackages.	newCommit := self backend		commitIndexWithMessage: message andParents: parentCommitishList.	self loadedCode 		commited: newCommit changingPackages: packages.	^ newCommit! !!IceRepository methodsFor: 'actions - utility' stamp: ' 7/24/2017 12:50:04'!commitPackages: packagesToCommit withMessage: message	^ self 		commitPackages: packagesToCommit		withMessage: message		andParents: { self headCommit }! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!commitPackages: packagesToCommit withMessage: message andParents: parentCommitishList	| savedVersions |		savedVersions := packagesToCommit collect: [ :package | 		self internalSavePackage: package withMessage: message ].		self		doCommitMcVersions: savedVersions 		withMessage: message 		andParents: parentCommitishList! !!IceRepository methodsFor: 'actions - utility' stamp: ' 7/24/2017 12:50:04'!commitPackagesAndMarkAsMerged: aCommitish	^ self 		commitPackages: self modifiedPackages		withMessage: 'Merging with ', aCommitish id		andParents: { self headCommit . aCommitish }! !!IceRepository methodsFor: 'actions - utility' stamp: ' 7/24/2017 12:50:04'!commitPackagesWithMessage: message	self modifiedPackages 		ifEmpty: [ NothingToCommitException signal ]		ifNotEmpty: [ :packages |			self 				commitPackages: packages				withMessage: message ]! !!IceRepository methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!commitsNotLoaded	self backend isUnborn ifTrue: [ ^ #() ].	^ self loadedCode commitsNotLoaded! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!contentOfFileNamed: aPathString commit: aCommitId	^ self backend 		contentOfFileNamed: aPathString		commit: aCommitId! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!createBranch: branchName	self backend createBranch: branchName.! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!description	^ self origin url, '[', self branchName, ']'! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!detachRemote: aRemote	(self pushRemote isSame: aRemote) ifTrue: [ self pushRemote: nil ].	(self pullRemote isSame: aRemote) ifTrue: [ self pullRemote: nil ]! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!directoryForPackage: mcPackage	| package |	package := self packageNamed: mcPackage name.	^ self subdirectory isEmptyOrNil		ifTrue: [ package directoryName ]		ifFalse: [ self subdirectory, '/', package directoryName ]! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!doCommitMcVersions: versions withMessage: message andParents: parentCommitishList	self addFilesToIndex: (versions collect: [ :version | self directoryForPackage: version package ]).	^ self commitIndexWithMessage: message andParents: parentCommitishList! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!ensureBranch: branchName	(self hasLocalBranchNamed: branchName)		ifFalse: [ self createBranch: branchName ]! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!fetch	self fetchFrom: self pullRemote! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!fetchFrom: aRemote		self backend fetchFrom: aRemote.	self refresh.! !!IceRepository methodsFor: 'repository handling' stamp: ' 7/24/2017 12:50:04'!forget	(self class unregisterRepository: self ifAbsent: [ nil ])		ifNotNil: [ Iceberg announcer announce: (IceRepositoryForgotten repository: self) ]! !!IceRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!hasLocalBraches	^ self localBranches isNotEmpty! !!IceRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!hasLocalBranchNamed: aString	^ self backend localBranchNames includes: aString! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!headCommit	^ self branch lastCommit! !!IceRepository methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!includesCommit: anIceCommit	^ [ self commitAt: anIceCommit id. true ] 		on: LGit_GIT_ENOTFOUND do: [ false ]! !!IceRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!includesPackageNamed: aString	^ self savedPackagesDictionary includesKey: aString! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!incomingCommits	self pullRemote ifNil: [ ^ #() ].	^ self incomingCommitsFrom: self pullRemote! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!incomingCommitsFrom: aRemote	^ (SortedCollection sortBlock: [ :a :b | a datetime > b datetime ])		addAll: self commitsNotLoaded;		addAll: (self branch incomingCommitsFrom: aRemote);		yourself! !!IceRepository methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	super initialize.	system := false. "by default, this is not a system repository"	commitDictionary := Dictionary new.	self initializeAnnouncer.	loadedCode := IceLoadedCode repository: self.! !!IceRepository methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeAnnouncer	announcer 		ifNil: [ announcer := Announcer new ]		ifNotNil: [	announcer subscriptions reset ].	announcer weak		when: IceCommited, IcePackageLoaded 		send: #refresh 		to: self! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!internalSavePackage: package withMessage: commitMessage	"Save a package to the underlying store but do not commit"	| workingCopy newVersion |	workingCopy := 	package workingCopy.	"This hack is copied from MCWorkingCopy code, I do not know why it is necessary."	workingCopy modified: true; modified: false.		(workingCopy repositoryGroup includes: self backend) 		ifFalse: [ workingCopy repositoryGroup addRepository: self backend ].	newVersion := MCVersion new		setPackage: workingCopy package		info: (IceMCVersionInfo package: package message: commitMessage)		snapshot: workingCopy package snapshot		dependencies: #(). "Note we do not track Monticello dependencies."	self backend internalStoreVersion: newVersion.	SystemAnnouncer uniqueInstance		announce: (MCVersionSaved version: newVersion repository: self backend).		^ newVersion ! !!IceRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isCodeMissing	^ self backend isCodeMissing! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!isFilePartOfAPackage: aFileReferenceRelativeToRepositoryDirectory	| packageSuffix segments |	packageSuffix := '.package'.	segments := aFileReferenceRelativeToRepositoryDirectory path segments.	^ self subdirectory isEmptyOrNil		ifTrue: [ segments first endsWith: packageSuffix ]		ifFalse: [  (segments first = self subdirectory) and: [ segments second endsWith: packageSuffix ] ]! !!IceRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isMissing	^ self backend isMissing ! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!isModified	^ self loadedPackages anySatisfy: #isModified! !!IceRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isPullRemote: aRemote	^ self pullRemote isSame: aRemote! !!IceRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isPushRemote: aRemote	^ self pushRemote isSame: aRemote! !!IceRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isSystemRepository	"Indicated if this repository is a system repository (for example, 'pharo' itself).	 This is useful because we do not want to treat all repositories the same. System 	 repositories, although present, shouldn't be visible by default (unless desired), 	 for example"	^ system! !!IceRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isValid	self flag: #todo. "Make this tests more solid"	^ self isMissing not		and: [ self isCodeMissing not ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!loadedCode	^ loadedCode! !!IceRepository methodsFor: 'working copies' stamp: ' 7/24/2017 12:50:04'!loadedPackages	^ self savedPackages select: #isLoaded! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!localBranches	^ self backend localBranchNames collect: [ :branchName | 		IceLocalBranch named: branchName inRepository: self ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location	^ self backend location! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location: aFileReference	self backend location: aFileReference.	aFileReference ifNil: [ ^ self ].	name := nil. "New location may mean new repository with new name"	self refresh.	! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!lookupCommit: commitId	^ self backend newCommitWalk 		fromCommitId: commitId; 		firstCommit! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!merge: aCommitish	"Currently a commitish can only be an IceCommitInfo, but we should be prepared for other types of commitish."	[ self basicMerge: aCommitish ]		on: IceMergeAborted		do: [ :error | self mergeConflictsWith: aCommitish ] ! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!merge: aCommitish into: aBranch	"Currently a commitish can only be an IceCommitInfo, but we should be prepared for other 	 types of commitish."	self backend 		merge: aCommitish id 		into: aBranch basename! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!mergeBaseBetween: anId and: otherId	^ self backend 		mergeBaseBetween: anId 		and: otherId! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!mergeBaseWith: aCommitInfo	^ self loadedCode mergeBaseWith: aCommitInfo! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!mergeConflictsWith: aCommitish	"Use version merger to create a new version. 	If all conflicts are resolved, commit it to the repository, 	marking it as parent to the received commitish."	| versionsChangedInCommit |	versionsChangedInCommit := aCommitish versionsChangedSince: (self mergeBaseWith: aCommitish).	(MCVersionMerger new		addVersions: (versionsChangedInCommit collect: #mcVersion);		merge)		ifTrue: [ self commitPackagesAndMarkAsMerged: aCommitish ]! !!IceRepository methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!metacelloAdapter	^ IceMetacelloRepositoryAdapter for: self! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!modifiedPackages	^ self loadedPackages 		select: [ :package | package workingCopy needsSaving ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name	^ name ifNil: [ name := self origin projectBasename ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name: aString	"Change the name of the repository as is seen inside image (real project name resides 	 externally, in repository). This can be confusing, but some times you need it to create new 	 repositories from image (before creating repository externally... which means no remote)"	name := aString! !!IceRepository methodsFor: 'commits' stamp: ' 7/24/2017 12:50:04'!newCommitWalk	^ self backend newCommitWalk! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/24/2017 12:50:04'!origin	^ self basicOrigin 		ifNil: [ IceUndefinedRemote new ]! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!outgoingCommits	^ self branch outgoingCommits ! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!outgoingCommitsTo: aRemote	^ self branch outgoingCommitsTo: aRemote! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!packageNamed: packageName	^ self savedPackagesDictionary at: packageName! !!IceRepository methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream nextPutAll: self class name;		nextPut: $(;		nextPutAll: self origin url;		nextPut: $)! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!pull	self pullFrom: self pullRemote! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!pullFrom: aRemote	| currentCommit |	currentCommit := self loadedCode referenceCommit.	self backend pullFrom: aRemote.	self refresh.	(self headCommit changedPackagesTo: currentCommit) do: #loadLatest! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/24/2017 12:50:04'!pullRemote	^ pullRemote ifNil: [ pullRemote := self pushRemote ]! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/24/2017 12:50:04'!pullRemote: aRemote	pullRemote := aRemote! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!push	self pushTo: self pushRemote! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/24/2017 12:50:04'!pushRemote	^ pushRemote ifNil: [ pushRemote := self basicOrigin ]! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/24/2017 12:50:04'!pushRemote: aRemote	pushRemote := aRemote! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!pushTo: aRemote		self backend pushTo: aRemote.	self refresh.	self announcer announce: IcePushed new! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!refresh	self branch refresh.	self loadedCode refresh.	commitDictionary := Dictionary new.	savedPackages := nil.	self announcer announce: (IceRepositoryModified for: self)! !!IceRepository methodsFor: 'repository handling' stamp: ' 7/24/2017 12:50:04'!register	self checkForRegistryConflicts.	self class registerRepository: self.	Iceberg announcer announce: (IceRepositoryCreated repository: self).	^ self ! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/24/2017 12:50:04'!remotes	self isValid ifFalse: [ ^ #() ].	^ self backend remotes ! !!IceRepository methodsFor: 'accessing remotes' stamp: ' 7/24/2017 12:50:04'!removeRemote: aRemote	self backend removeRemote: aRemote.	self detachRemote: aRemote! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!revparse: aString 	"Right now this is necessary because Metacello provides a tag objectId instead of a commitId"	^ self backend revparse: aString! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!saveContent: aString inWorkingCopyFile: aRelativePathString	| outputFile |	outputFile := (self backend repositoryDirectory fullName , '/' , aRelativePathString) asFileReference.	outputFile writeStreamDo: 		[ :stream |		stream nextPutAll: aString ].	self addFilesToIndex: { aRelativePathString }.	^ outputFile! !!IceRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!savedPackages	^ self savedPackagesDictionary values! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!savedPackagesDictionary	^ savedPackages ifNil: [ savedPackages := self backend lookupPackages ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!stagedFiles	^ self backend stagedFiles! !!IceRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!stagedPackageNames	^ self stagedFiles 		select: [ :fileRef | self isFilePartOfAPackage: fileRef ]		thenCollect: [ :fileRef | 			self subdirectory isEmptyOrNil 				ifTrue: [ fileRef path segments first asFileReference basenameWithoutExtension ] 				ifFalse: [ fileRef path segments second asFileReference basenameWithoutExtension ] ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!stagedPackages	^ self stagedPackageNames		select: [ :each | self includesPackageNamed: each ]		thenCollect: [ :packageName | self packageNamed: packageName ]! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!subdirectory	^ self backend subdirectory! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!subdirectory: aString	self backend subdirectory: aString.	self refresh! !!IceRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!updatePackage: packageName 	self backend pull.	(self packageNamed: packageName) loadLatest.! !!IceRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!username: aName email: anEmail global: globalBoolean	^ self backend 		username: aName 		email: anEmail 		global: globalBoolean! !!IceRepository methodsFor: 'versions handling' stamp: ' 7/24/2017 12:50:04'!versionLoaded: version 	loadedCode versionLoaded: version.	self announcer announce: (IcePackageLoaded version: version).	self refresh! !!IceRepository methodsFor: 'working copies' stamp: ' 7/24/2017 12:50:04'!workingCopies	^ self loadedPackages collect: #workingCopy! !!IceRepository methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!workingCopyDiff	^ IceDiff forRepository: self! !!IceRepository methodsFor: '*Iceberg-Changes' stamp: ' 7/24/2017 12:50:04'!workingCopyDiffToCommit: anIceCommitInfo	^ IceDiff forRepository: self commit: anIceCommitInfo! !!IceRepositoryCreator class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultSubdirectory	^ ''! !!IceRepositoryCreator class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isGitRoot: aReference	self flag: #todo. "This does not understand submodules"	^ aReference isDirectory 		and: [ (aReference directoriesMatching: '.git') notEmpty		and: [ (aReference / '.git' / 'config') exists ] ]! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branchName	^ branchName! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branchName: anObject	branchName := anObject! !!IceRepositoryCreator methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!createNewRepositoryNamed: aString	| backend locationToUse |		self validate.	locationToUse := self locationToUse.	(locationToUse exists 		and: [ locationToUse hasChildren ])		ifTrue: [ IceError signal: ('{1} is not empty.' format: {locationToUse fullName}) ].			locationToUse ensureCreateDirectory.	self subdirectory  		ifNotEmpty: [ (locationToUse / self subdirectory) ensureCreateDirectory ].	backend := self storageClass 		newRepositoryAt: locationToUse		subdirectory: self subdirectory.	backend init.	^ (IceRepository backend: backend)		name: aString;		yourself! !!IceRepositoryCreator methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!createRepository	| backend locationToUse |		self validate.	locationToUse := self locationToUse.	backend := self storageClass 		newRepositoryAt: locationToUse		subdirectory: self subdirectory.	(locationToUse exists not or: [ locationToUse hasChildren not ])		ifTrue: [ 			backend 				cloneRepositoryFrom: self remoteToUse 				branch: self branchName ].	^ IceRepository backend: backend! !!IceRepositoryCreator methodsFor: 'private accessing' stamp: ' 7/24/2017 12:50:04'!defaultLocation	| remoteToUse |	remoteToUse := self remoteToUse.	^ IceRepository repositoriesLocation 		/ remoteToUse organizer 		/ remoteToUse projectName! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location	^ location! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location: anObject	location := anObject! !!IceRepositoryCreator methodsFor: 'private accessing' stamp: ' 7/24/2017 12:50:04'!locationToUse	^ self location ifNil: [ self defaultLocation ]! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote	^ remote! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote: anObject	remote := anObject! !!IceRepositoryCreator methodsFor: 'private accessing' stamp: ' 7/24/2017 12:50:04'!remoteToUse	self remote ifNotNil: [ ^ self remote ].	self url ifNotNil: [ ^ IceRemote url: self url ]. 	^ nil! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!storageClass	^ storageClass ifNil: [ storageClass := IceRepository defaultBackend ]! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!storageClass: aClass	storageClass := aClass! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!subdirectory	^ subdirectory ifNil: [ self class defaultSubdirectory ]! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!subdirectory: anObject	subdirectory := anObject! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!url	^ url! !!IceRepositoryCreator methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!url: anObject	url := anObject! !!IceRepositoryCreator methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!validate	"Validate something is provided to create the repo (I need url OR location OR remote), 	 but the 3 cannot be nil"	(self location isNil 		and: [ self remoteToUse isNil ])		ifTrue: [ IceError signal: 'No location/url or remote defined.' ].			"Validate if I will add a local repository (url isNil and location isNotNil)... testing the 	 local directory actually exists"	(self remoteToUse isNil 		and: [ self location notNil 		and: [ self location exists 		and: [ (self class isGitRoot: self location) not ] ] ])		ifTrue: [ IceError signal: ('"{1}" is not a git directory' format: { self location fullName }) ]! !!IceSavedPackage class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!named: packageName repository: repository	^ self new 		package: (IcePackageReference named: packageName); 		repository: repository; 		yourself! !!IceSavedPackage methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!= another	^ self species = another species 		and: [ self repository = another repository 		and: [ self name = another name ]]! !!IceSavedPackage methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!browse	^ self package browse! !!IceSavedPackage methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!computeLoadedVersion	| workingCopyAncestors |	workingCopyAncestors := self package workingCopy ancestors.	workingCopyAncestors ifEmpty: [ ^ IceTemporaryVersion forPackage: self ].	self workingCopy ancestors		detect: [ :ancestor | 			(ancestor respondsTo: #iceVersion) and: [ 			(ancestor commit notNil) and: [			self repository includesCommit: ancestor commit ]]]		ifFound: [ :ancestor | ^ ancestor iceVersion ].	self workingCopy repositoryGroup repositories do: [ :mcRepo |		mcRepo 			commitIdFor: self workingCopy 			ifFound: [ :commitish | 				[ 					| commit |					commit := (self repository revparse: commitish).					^ commit versionFor: self 				] 				on: LGit_GIT_ENOTFOUND 				do: [					"If we cannot parse commitish, we asume that it is a commit ID which is unknown for this repo, 					so we just ignore it. Maybe we should consider other cases and handle them adecquately."				]]	].			^ IceForeignVersion forPackage: self.! !!IceSavedPackage methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!directoryName	^ package packageName, '.package'! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!directoryPathString	^ self repository subdirectory isEmptyOrNil 		ifTrue: [ self directoryName ]		ifFalse: [ self repository subdirectory, '/',  self directoryName ].! !!IceSavedPackage methodsFor: 'comparing' stamp: ' 7/24/2017 12:50:04'!hash	^ self name hash! !!IceSavedPackage methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!incomingCommits	^ self loadedVersion incomingCommits ! !!IceSavedPackage methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isExported	| location |	location := self location.	^ location exists and: [ location hasChildren ]! !!IceSavedPackage methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isLoaded	^ self package isLoaded! !!IceSavedPackage methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isModified	^ self package workingCopy modified! !!IceSavedPackage methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!latestVersion	^ self repository headCommit versionFor: self! !!IceSavedPackage methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!loadLatest	self latestVersion load.	! !!IceSavedPackage methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!loadedVersion	^ self repository loadedCode versionFor: self! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location	| location |	 	location := self repository location.	(self directoryPathString substrings: '/')		do: [ :each | location := location / each ].	^ location! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!name	^ self package packageName! !!IceSavedPackage methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!outgoingCommits	^ self repository branch outgoingCommits: [ :walk | walk modifyingPackage: self ]! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!package	^ package! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!package: anObject	package := anObject! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageName	^ self package packageName! !!IceSavedPackage methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream nextPutAll: self class name.	self package printDescriptionOn: aStream! !!IceSavedPackage methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!reload	self latestVersion load.	! !!IceSavedPackage methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!removeFromDisk	self isLoaded ifTrue: [ 		IceError signal: 'You can''t remove a loaded package.' ].	self location ensureDeleteAll.	self repository refresh.! !!IceSavedPackage methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!removeFromDisk: force	(self isLoaded and: [ force not ]) ifTrue: [ 		IceError signal: 'You can''t remove a loaded package.' ].	self location ensureDeleteAll.	self repository refresh.! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!IceSavedPackage methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!unload	self workingCopy unload.	self repository announcer 		announce: IcePackageUnloaded new.	self repository refresh! !!IceSavedPackage methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!versionFor: aCommitId	^ (self repository commitAt: aCommitId) versionFor: self! !!IceSavedPackage methodsFor: 'versions' stamp: ' 7/24/2017 12:50:04'!versionLike: selectBlock ifNone: ifNoneBlock	"Return all versions of this package in the current branch, latest first. 	Containing info in the repo makes it easier to refresh."	^ self repository branch 		versionsFor: self 		detect: selectBlock 		ifNone: ifNoneBlock ! !!IceSavedPackage methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!versions	"Return all versions of this package in the current branch, latest first. 	Containing info in the repo makes it easier to refresh."	^ self repository branch versionsFor: self! !!IceSavedPackage methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!workingCopy	^ self package workingCopy! !!IceSshCredentials class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultPrivateKey 		self flag: #todo. "In fact this is different for windows. We need to change this."	^ (FileLocator home asFileReference / '.ssh' / 'id_rsa') pathString! !!IceSshCredentials class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultPublicKey	self flag: #todo. "In fact this is different for windows. We need to change this."	^ (FileLocator home asFileReference / '.ssh' / 'id_rsa.pub') pathString! !!IceSshCredentials class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultUsername	^ 'git'! !!IceSshCredentials methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isPresent	^ self username notEmpty 		and: [ self publicKey notEmpty 		and: [ self privateKey notEmpty ] ]! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!keyPassphrase	^ keyPassphrase ifNil: [ keyPassphrase := '' ]! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!keyPassphrase: anObject	keyPassphrase := anObject! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!privateKey	^ privateKey ifNil: [ privateKey := self class defaultPrivateKey ]! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!privateKey: anObject	privateKey := anObject! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!publicKey	^ publicKey ifNil: [ publicKey := self class defaultPublicKey ]! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!publicKey: anObject	publicKey := anObject! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!username	^ username ifNil: [ username := self class defaultUsername ]! !!IceSshCredentials methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!username: anObject	username := anObject! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!announcer	^ icebergAnnouncer ifNil: [ icebergAnnouncer := Announcer new ]! !!Iceberg class methodsFor: 'settings' stamp: ' 7/24/2017 12:50:04'!enableMetacelloIntegration	^ EnableMetacelloIntegration ifNil: [ EnableMetacelloIntegration := true ]! !!Iceberg class methodsFor: 'settings' stamp: ' 7/24/2017 12:50:04'!enableMetacelloIntegration: anObject	EnableMetacelloIntegration := anObject! !!Iceberg class methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!icebergRepositoriesURLs	^ {		'git@github.com:pharo-vcs/iceberg.git'. 		'git@github.com:pharo-vcs/filetree.git'.		'git@github.com:pharo-vcs/libgit2-pharo-bindings.git'	}! !!Iceberg class methodsFor: 'class initialization' stamp: ' 7/24/2017 12:50:04'!initialize	| tree nodes |	tree := SystemSettingsPersistence default settingTree.	nodes := tree deeplySelect: [ :node | node receiverPackage name beginsWith: 'Iceberg' ].	SystemSettingsPersistence updateSettingNodes: nodes.! !!Iceberg class methodsFor: '*Iceberg-Adapters' stamp: ' 7/24/2017 12:50:04'!mcRepositoryFor: aLocationString	^ (IceMetacelloRepositoryType for: aLocationString) mcRepository ! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageForCategoryNamed: categoryName	| systemPackage |	systemPackage := RPackageOrganizer default packageMatchingExtensionName: categoryName.	^ self packageNamed: systemPackage name! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageNamed: packageName	^ IcePackageReference named: packageName! !!Iceberg class methodsFor: 'maintenance' stamp: ' 7/24/2017 12:50:04'!rebuildRepositories	IceRepository registry do: [ :repo | 		repo initialize.		"repo branch: nil."		repo commitDictionary.		repo loadedPackages do: [ :pkg | repo versionLoaded: pkg computeLoadedVersion ] ]! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remoteTypeSelector	"Should be #scpURL or #httpsURL"	^ RemoteTypeSelector ifNil: [ RemoteTypeSelector := #scpUrl ]! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remoteTypeSelector: anObject	RemoteTypeSelector := anObject! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repositoryForPackage: anRPackage 	| existingRepositories possibleRepositoryTypes |		existingRepositories := (MCWorkingCopy forPackage: anRPackage mcPackage) repositoryGroup repositories.	possibleRepositoryTypes := TIceRepositoryBackend traitUsers, 		{ IceMetacelloRepositoryAdapter. 		  MCGitHubRepository }.		possibleRepositoryTypes do: [ :class |		existingRepositories 			detect: [ :repo | repo isKindOf: class ]			ifFound: [ : repo |  ^ repo getOrCreateIcebergRepository ] ].	self error: ('Could not find a git repository for {1}' format: {anRPackage name})	! !!Iceberg class methodsFor: 'settings' stamp: ' 7/24/2017 12:50:04'!settingsOn: aBuilder 	<systemsettings>	(aBuilder group: #Iceberg)		parent: #SCM;		with: [ 			(aBuilder setting: #enableMetacelloIntegration)				target: self;				order: 0.1;				label: 'Enable Metacello integration';				description: 'If selected, Metacello github// repositories will be loaded using iceberg';"				icon: (Smalltalk ui icons iconNamed: #smallConfigurationIcon);"				with: [ 					(aBuilder pickOne: #remoteTypeSelector)						label: 'Remote type';						description: 'When creating an Iceberg repository out of a github:// URL choose whether you want to user an SCP URL (i.e. with the form ''git@github.com:<username>/<project>.git'') or an HTTPS URL (i.e. with the form ''https://github.com/<username>/<project>.git''';						domainValues: {							'SCP (git@github.com:<username>/<project>.git)' -> #scpUrl.							'HTTPS (https://github.com/<username>/<project>.git)' -> #httpsUrl						}.				].			(aBuilder setting: #showSystemRepositories) 				order: 0.2;				label: 'Include system repositories by default';				description: 'If checked then system repositories (like ''pharo'') will be shown in repositories list by default';				target: self.		]! !!Iceberg class methodsFor: 'settings' stamp: ' 7/24/2017 12:50:04'!showSystemRepositories	^ ShowSystemRepositories ifNil: [ ShowSystemRepositories := false ]! !!Iceberg class methodsFor: 'settings' stamp: ' 7/24/2017 12:50:04'!showSystemRepositories: aBoolean	ShowSystemRepositories := aBoolean! !!Iceberg class methodsFor: 'updating' stamp: ' 7/24/2017 12:50:04'!update	#(Iceberg LGitRepository MCFileTreeGitRepository) do: [:className | 		Smalltalk 			at: className 			ifPresent: [ :class | class package iceRepository pull ] ]! !!Iceberg class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!workingCopyForPackageNamed: packageName	^ (self packageNamed: packageName) workingCopy! !"Iceberg"!!IcePlugin commentStamp: '<historical>' prior: 0!I'm a base for all kind of plugins. I can define - repositoryActions (actions that will be added to IceRepositoriesBrowser, repositories section)- ... (TBD)!!IceBaselineInstallerPlugin commentStamp: 'EstebanLorenzano 4/7/2017 12:36' prior: 0!I'm a plugin who allows Baselines to be installed from Iceberg (just right-click and install).It adds two options to packages tab of repositories browser: - Install baseline (default)- Install baseline...2nd one allows to pick groups to install!!IcePharoFogbugzPlugin commentStamp: 'EstebanLorenzano 2/13/2017 16:59' prior: 0!I'm a pluging to handle fogbugz issues integration. It just add options to easily handle the creation of branchs with the "convention" issue naming format (number-plus-normalised-title): 12345-a-sample-of-issue-branchNOTE: In the future we can add other fogbugz elements (like list issues, etc.), but since API is very slow we will consider it very carefully. !!IcePluginManager commentStamp: '<historical>' prior: 0!I keep plugins configured for a repository. WARNING: Managers are kept in a week dictionary with Repository as a key, reason why plugins can't have any kind of reference that could cause a memory leak. Consider using stateless plugins or instance copies of relevant information instead.!!IcePharoFogbugzModel commentStamp: '<historical>' prior: 0!I'm a dialog to ask for issue number to create correct branchs for Pharo Development.!!IceRepository methodsFor: '*Iceberg-Plugin' stamp: ' 7/24/2017 12:50:04'!pluginManager	^ IcePluginManager managerFor: self! !!IceBaselineInstallerPlugin class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!baselinePrefix	^ 'BaselineOf'! !!IceBaselineInstallerPlugin class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isAvailableFor: aRepository	^ true! !!IceBaselineInstallerPlugin methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!installBaseline: icePackage groups: anArray	| packageDir baselineName |		packageDir := icePackage location parent fullName.	baselineName := icePackage name allButFirst: self class baselinePrefix size.	Metacello new		repository: 'gitlocal://', packageDir;		baseline: baselineName;		load: anArray! !!IceBaselineInstallerPlugin methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!installBaselineGroups: icePackage	| groupsString groups |		groupsString := self pickGroupsOnCancel: [ ^ self ].	groups := groupsString 		ifNotNil: [ (groupsString substrings: ',') collect: #trimBoth as: Array ]		ifNil: [ #() ].	self installBaseline: icePackage groups: groups! !!IceBaselineInstallerPlugin methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!installDefaultBaseline: icePackage	self installBaseline: icePackage groups: #()! !!IceBaselineInstallerPlugin methodsFor: 'private actions' stamp: ' 7/24/2017 12:50:04'!installDefaultBaselineAction	^ GLMGenericAction new		action: [ :presentation | self installDefaultBaseline: presentation selection entity ];		showTitle: 'Install baseline (default)'; 		yourself	! !!IceBaselineInstallerPlugin methodsFor: 'private actions' stamp: ' 7/24/2017 12:50:04'!installGroupsBaselineAction	^ GLMGenericAction new		action: [ :presentation | self installBaselineGroups: presentation selection entity ];		showTitle: 'Install baseline...'; 		yourself	! !!IceBaselineInstallerPlugin methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageActionsFor: icePackage	^ (icePackage packageName beginsWith: self class baselinePrefix) 		ifTrue: [ { self installDefaultBaselineAction. self installGroupsBaselineAction } ]		ifFalse: [ #() ]! !!IceBaselineInstallerPlugin methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!pickGroupsOnCancel: aBlock	| result |	result := UIManager default 		request: 'Groups to install (a comma separated string)' 		initialAnswer: '' 		title: 'Enter groups to install'.	result ifNil: [ ^ aBlock value ].	^ result! !!IcePharoFogbugzPlugin class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isAvailableFor: aRepository	"ATTENTION: Bad practice!!		We cannot resolve remotes during repository creation so we unfortunately need this	pluggin enabled for all repositories. Please do not create own pluggins enabled for all	repositories unless you have a very, very, very good reason."		^ true! !!IcePharoFogbugzPlugin methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!hasPharoInOrigin: aRepository	| origin |	origin := aRepository origin.	^ (origin host = 'github.com')		and: [ origin owner = 'pharo-project'		and: [ origin projectName = 'pharo' ] ]! !!IcePharoFogbugzPlugin methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!hasPharoInRemotes: aRepository	^ aRepository remotes anySatisfy: [ :aRemote |		self pharoURLs includes: aRemote url ].! !!IcePharoFogbugzPlugin methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isAvailableFor: aRepository	^ (self hasPharoInOrigin: aRepository) or: [ self hasPharoInRemotes: aRepository ]! !!IcePharoFogbugzPlugin methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!newFogbugzIssue: aRepository then: aBlock	IcePharoFogbugzModel new 		onAccept: [ :branchName | 			aRepository createBranch: branchName.			aBlock value ];		openWithSpec.! !!IcePharoFogbugzPlugin methodsFor: 'private actions' stamp: ' 7/24/2017 12:50:04'!newIssueFixAction	^ GLMGenericAction new		action: [ :presentation | 			self 				newFogbugzIssue: presentation selection repository				then: [ presentation pane browser update ] ];		category: 'Pharo';		showTitle: 'Create new branch from FogBugz issue...'; 		condition: [ :presentation | self isAvailableFor: presentation selection repository]		yourself	! !!IcePharoFogbugzPlugin methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!newPullRequest: aRepository	"(IceGitHubNewPullRequestCommand repository: aRepository) 		remote: aRepository pushRemote;		execute"! !!IcePharoFogbugzPlugin methodsFor: 'private actions' stamp: ' 7/24/2017 12:50:04'!newPullRequestAction	"This actions are copied from GitHub plugin, but presented here to make it easier"	^ GLMGenericAction new		action: [ :presenter | self newPullRequest: presenter selection repository ];		category: 'Pharo';		showTitle: 'Create pull request...'; 		condition: [ :presentation | self isAvailableFor: presentation selection repository]		yourself! !!IcePharoFogbugzPlugin methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!pharoURLs	"list of repository URLs for official Pharo upstream"	^ #(		'git@github.com:pharo-project/pharo.git' 		'https://github.com/pharo-project/pharo.git'	)! !!IcePharoFogbugzPlugin methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repositoryActions	^ { 	self newIssueFixAction.	}! !!IcePlugin class methodsFor: 'as yet unclassified' stamp: ' 7/24/2017 12:50:04'!allAvailableFor: aRepository	^ self allSubclasses select: [ :each | each isAvailableFor: aRepository ]! !!IcePlugin class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isAvailableFor: aRepository	^ self subclassResponsibility! !!IcePlugin methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageActionsFor: aPackage	"answer a list of glamour actions (GLMAction) that defines operations in the packages panel	 (in IceRepositoriesBrowser)"	^ #()! !!IcePlugin methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remoteActionsFor: aRemote	"answer a list of glamour actions (GLMAction) that defines operations in the remotes tab panel	 (in IceRepositoriesBrowser)"	^ #()! !!IcePlugin methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repositoryActions	"answer a list of glamour actions (GLMAction) that defines operations in the repository panel	 (in IceRepositoriesBrowser)"	^ #()! !!IcePluginManager class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!managerFor: aRepository	^ self managers 		at: aRepository 		ifAbsentPut: [ self basicNew initializeRepository: aRepository ].! !!IcePluginManager class methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!managers 	^ Managers ifNil: [ Managers := WeakKeyDictionary new ]! !!IcePluginManager class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!new	self error: 'Use #managerFor:'! !!IcePluginManager methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!addPlugin: aPlugin 	plugins := plugins copyWith: aPlugin! !!IcePluginManager methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!availablePluginsFor: aRepository	^ (IcePlugin allAvailableFor: aRepository) 		collect: #new		as: Array! !!IcePluginManager methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeRepository: aRepository.	self initialize.	plugins := self availablePluginsFor: aRepository! !!IcePluginManager methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!packageActionsFor: aPackage	^ self plugins		inject: #() 		into: [ :all :each | all, (each packageActionsFor: aPackage) ]! !!IcePluginManager methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!plugins 	^ plugins! !!IcePluginManager methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!remoteActionsFor: aRemote	^ self plugins 		inject: #() 		into: [ :all :each | all, (each remoteActionsFor: aRemote) ]! !!IcePluginManager methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!repositoryActions	^ self plugins 		inject: #() 		into: [ :all :each | all, (each repositoryActions) ]			! !!IcePharoFogbugzModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultExtent	^ 660@35! !!IcePharoFogbugzModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec	<spec>		^ SpecLayout composed		newRow: [ :row |			row 				add: #issueNumberText width: 50;				add: #issueText;				add: #createButton width: 80 ] height: self inputTextHeight! !!IcePharoFogbugzModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ 'New branch from FogBugz issue'! !!IcePharoFogbugzModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!unknownTitle	^ 'INVALID-ISSUE'! !!IcePharoFogbugzModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!createBranch	| branchName |		branchName := '{1}-{2}' format: { 		issueNumberText text trim. 		issueText text trim }.	acceptBlock ifNotNil: [ acceptBlock value: branchName ].	self window delete! !!IcePharoFogbugzModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!createButton	^ createButton! !!IcePharoFogbugzModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!createButton: anObject	createButton := anObject! !!IcePharoFogbugzModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ self class defaultExtent! !!IcePharoFogbugzModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	issueNumberText := self newTextInput autoAccept: true.	issueText := self newTextInput autoAccept: true.	createButton := self newButton enabled: false.			issueNumberText whenBuiltDo: [ :w | w widget wrapFlag: false ]. 	issueText whenBuiltDo: [ :w | w widget wrapFlag: false ]. 	issueNumberText textHolder 		whenChangedDo: [ :text | self validateIssue: text ].		createButton 		label: 'Create';		icon: #add asIcon;		action: [ self createBranch ].			self focusOrder 		add: issueNumberText;		add: issueText;		add: createButton! !!IcePharoFogbugzModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!issueNumberText	^ issueNumberText! !!IcePharoFogbugzModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!issueNumberText: anObject	issueNumberText := anObject! !!IcePharoFogbugzModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!issueText	^ issueText! !!IcePharoFogbugzModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!issueText: anObject	issueText := anObject! !!IcePharoFogbugzModel methodsFor: 'events' stamp: ' 7/24/2017 12:50:04'!onAccept: aBlock 	acceptBlock := aBlock! !!IcePharoFogbugzModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!sanitizeTitle: aString	| separators safeSeparator |		aString isEmptyOrNil ifTrue: [ ^ self class unknownTitle ].		safeSeparator := $-.	separators := { Character space. Character tab. $_. safeSeparator }.	^ String streamContents: [ :str | 		aString do: [ :c |			(separators includes: c) ifTrue: [ str nextPut: safeSeparator ].			c isAlphaNumeric ifTrue: [ str nextPut: c ] ] ]! !!IcePharoFogbugzModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!title	^ self class title! !!IcePharoFogbugzModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!updateText: aString 	issueText text: aString! !!IcePharoFogbugzModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!validateIssue: aString	| number |	aString size = 5 ifFalse: [ ^ self ].	aString isAllDigits ifFalse: [ ^ self ].	number := aString asNumber.		(issue isNil or: [ issue number ~= number ])		ifTrue: [ 			issue := PharoIssue number: number.			[ 	"Fork to allow UI to continue"				issue downloadTitle.				UIManager default defer: [ 					self updateText: (self sanitizeTitle: issue title).					self createButton enabled: true ] ] fork ]	! !"Iceberg-Plugin"!!IceMetacelloRepositoryType commentStamp: '<historical>' prior: 0!I'm a base class to provide different type of MCRepositories from iceberg, so metacello can do his work of installing packages.My children define specific types, visit them to have more details of what you can do.!!IceGitLocalRepositoryType commentStamp: 'EstebanLorenzano 12/12/2016 10:43' prior: 0!I resolve git local repositories (repositories already existing on your disk).A gitlocal repositoy is composed of: gitlocal://full/path/to/repositorygitlocal  		- The git local identifierfull/path/...	- This is a path to the place where the sources are. 	For example, if you have a  repository in '/dev/voyage', which also has sources in subdirectory 'mc', your full path will be: '/dev/voyage/mc'. A part of my responsibilities is to find the git root  in the path provided.Example: ------------A script to install voyage using this would like more or less like this:Metacello new	repository: 'gitlocal://Users/esteban/Dev/Repository/voyage/mc';	baseline: 'Voyage';	load: 'mongo tests'.!!IceProviderRepositoryType commentStamp: '<historical>' prior: 0!I 'm a base class to resolve provider-based repositories.A provider repositoy is composed of: provider://username/repository[:commitish][/subdir]provider  	- The provider identifier (e.g. github, bitbucket, etc.)username 	- The provider userrepository	- The provider repositorycommitish	- an optional commitish (a branch, a tag, a commit id)subdir		- an optional subdirectory where the packages exist.		Example: ------------A script to install voyage using this would like more or less like this:Metacello new	repository: 'github//pharo-nosql/voyage:master/mc';	baseline: 'Voyage';	load: 'mongo tests'.!!IceBitbucketRepositoryType commentStamp: 'EstebanLorenzano 7/23/2017 13:18' prior: 0!I resolve Bitbucket repositories!!IceGithubRepositoryType commentStamp: 'EstebanLorenzano 7/23/2017 13:18' prior: 0!I resolve Github repositories!!IceGitlabRepositoryType commentStamp: 'EstebanLorenzano 7/23/2017 13:18' prior: 0!I resolve Gilab repositories!!IceMetacelloPharoPlatform commentStamp: '<historical>' prior: 0!I'm a class to add support for iceberg to metacello.!!IceGitLocalRepositoryType class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!type	^ 'gitlocal'! !!IceGitLocalRepositoryType methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isGitRoot: aReference	^ IceRepositoryCreator isGitRoot: aReference! !!IceGitLocalRepositoryType methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!mcRepository	| repository tuple extractedLocation |		tuple := self splitRootAndSubdirectoryFromLocation.	extractedLocation := tuple first asFileReference asAbsolute.	repository := IceRepository registry 		detect: [ :each | each location asAbsolute = extractedLocation ]		ifNone: [ 			(IceRepositoryCreator new 				location: tuple first;				subdirectory: tuple second;				createRepository)				register ].				^ repository metacelloAdapter! !!IceGitLocalRepositoryType methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!splitRootAndSubdirectoryFromLocation	| root subDir |		(self location beginsWith: (self class type, '://'))			ifFalse: [ self error: 'Invalid URL (It should be ', self class type, '://...)' ].	root := (self location allButFirst: self class type size + 3) asFileReference.	subDir := #().	[ root isNil or: [ self isGitRoot: root ] ] 		whileFalse: [ 			subDir := subDir copyWithFirst: root basename.			root := root parent ].	root ifNil: [ self error: 'I can''t find a .git/config file.' ].		^ { 		root. "a FileReference"		String streamContents: [ :stream | subDir asStringOn: stream delimiter: '/' ] "a String" }! !!IceMetacelloRepositoryType class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!allTypes	^ self allSubclasses select: [ :each | each isAbstract not ]! !!IceMetacelloRepositoryType class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!canHandleType: aType 	^ self allTypes		anySatisfy: [ :each | each isSuitableForType: aType ]  	! !!IceMetacelloRepositoryType class methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!extractTypeOf: aString 	^ aString copyUpTo: $:! !!IceMetacelloRepositoryType class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!for: aLocationString	^ (self allTypes		detect: [ :each | each isSuitableForLocation: aLocationString ])		location: aLocationString! !!IceMetacelloRepositoryType class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isAbstract	^ self = IceMetacelloRepositoryType! !!IceMetacelloRepositoryType class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isSuitableForLocation: aLocationString	^ self isSuitableForType: (self extractTypeOf: aLocationString) ! !!IceMetacelloRepositoryType class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isSuitableForType: aType	^ self type = aType! !!IceMetacelloRepositoryType class methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!location: aLocationString	self = IceMetacelloRepositoryType 		ifTrue: [ self error: 'I''m an abstract class, use one of my children instead.' ].		^ self basicNew		initializeLocation: aLocationString;		yourself! !!IceMetacelloRepositoryType class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!type	^ self subclassResponsibility! !!IceMetacelloRepositoryType methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeLocation: aString	location := aString.	self initialize! !!IceMetacelloRepositoryType methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location	^ location! !!IceMetacelloRepositoryType methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!mcRepository	self subclassResponsibility! !!IceBitbucketRepositoryType class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!type	^ 'bitbucket'! !!IceGithubRepositoryType class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!type	^ 'github'! !!IceGithubRepositoryType methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!mcRepository	| baseRepo |		baseRepo := MCGitHubRepository location: self location.	^ (Iceberg icebergRepositoriesURLs includes: baseRepo scpUrl)		ifTrue: [ 			"Do not use Iceberg to load iceberg code, 			see https://github.com/pharo-vcs/iceberg/issues/168"			baseRepo ]		ifFalse: [  			baseRepo getOrCreateIcebergRepository metacelloAdapter ]		! !!IceGitlabRepositoryType class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!type	^ 'gitlab'! !!IceProviderRepositoryType class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isAbstract	^ super isAbstract		or: [ self = IceProviderRepositoryType ]! !!IceProviderRepositoryType methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!mcRepository	| baseRepo |		baseRepo := MCGitHubRepository location: self location.	^ baseRepo getOrCreateIcebergRepository metacelloAdapter! !!IceMetacelloPharoPlatform class methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	 self select! !!IceMetacelloPharoPlatform methodsFor: 'repository creation' stamp: ' 7/24/2017 12:50:04'!createRepository: aRepositorySpec	| type |	type := aRepositorySpec type.	type = 'ftp' ifTrue: [ | description headerSize index host directory |		description := aRepositorySpec description.		headerSize := 'ftp://' size.		index := description indexOf: $/ startingAt: headerSize + 1.		host := description copyFrom: headerSize + 1 to: index - 1.		directory := description copyFrom: index + 1 to: description size.		^ MCFtpRepository			host: host 			directory: directory 			user: aRepositorySpec username			password: aRepositorySpec password ].				(Iceberg enableMetacelloIntegration 		and: [ IceMetacelloRepositoryType canHandleType: type ])		ifTrue: [ ^ Iceberg mcRepositoryFor: aRepositorySpec description ].				^ super createRepository: aRepositorySpec! !!IceMetacelloPharoPlatform methodsFor: 'repository creation' stamp: ' 7/24/2017 12:50:04'!extractTypeFromDescription: description	(description beginsWith: 'ftp://') ifTrue: [ ^'ftp' ].	IceMetacelloRepositoryType allTypes 		detect:  [ :each | each isSuitableForLocation: description  ] 		ifFound: [ :class | ^ class type ].	^ super extractTypeFromDescription: description! !"Iceberg-Metacello-Integration"!!TIceTool commentStamp: 'NicoPasserini 9/2/2016 15:27' prior: 0!Utilities for Iceberg GUI tools.!!IceAskForPlaintextCredentialsModel commentStamp: 'NicoPasserini 11/15/2016 15:25' prior: 0!A dialog for asking plaintext credentials (username and password) to the user.!!IceAskForSshCredentialsModel commentStamp: 'EstebanLorenzano 2/8/2017 17:52' prior: 0!A dialog for asking ssh credentials to the user.!!IceAskForUsernameAndEmailModel commentStamp: '<historical>' prior: 0!I'm a dialog for asking "user.name" and "user.email" .!!IceCommitInfoModel commentStamp: '<historical>' prior: 0!I'm a simple spec model to show IceCommitInfo details. (self for: aCommitInfo) openWithSpec.!!IceCommitModel commentStamp: 'NicoPasserini 8/25/2016 14:47' prior: 0!Spec model for commit (and related) operations.!!IceCherryPickCommitModel commentStamp: '<historical>' prior: 0!Spec model for commit (and related) operations using cherry-pick.!!IceCreateRepositoryModel commentStamp: 'NicoPasserini 8/3/2016 17:51' prior: 0!Base class for avoiding code duplications between dialogs that create repositories. !!IceCloneRepositoryModel commentStamp: 'NicoPasserini 8/3/2016 18:44' prior: 0!Dialog for cloning a repository from a remote URL!!IceEditRepositoryModel commentStamp: '<historical>' prior: 0!I'm an edition dialog. I allow users to edit what is editable on an IceRepository. !!IceImportLocalRepositoryModel commentStamp: 'NicoPasserini 8/3/2016 18:45' prior: 0!Dialog for creating an Iceberg repository out of an existing local git repository.!!IceNewRepositoryModel commentStamp: '<historical>' prior: 0!I'm a repository creation dialog. I allow users to create a repository from scratch. !!IceLocationModel commentStamp: '<historical>' prior: 0!I'm an abstract model to provide locations (directories or files). I need to be included in other components (search references to my children for examples)!!IceDirectoryModel commentStamp: '<historical>' prior: 0!I'm a model to choose directories.!!IceFileModel commentStamp: '<historical>' prior: 0!I'm a model to choose files.!!IceRemoteModel commentStamp: '<historical>' prior: 0!I'm a dialog for adding remotes to repositories.!!IceGlamourSynchronizer commentStamp: 'EstebanLorenzano 2/2/2017 16:22' prior: 0!I am the syncronizer window. I am called to perform any of the basic operations of iceberg: - commit (save changes)- update (load new changes from incomming commit versions)- publish (send to central repository local commits)usually I'm called from the repositories browser, when selecting the "syncronize" option from contextual menu.!!IceTool commentStamp: 'NicoPasserini 9/2/2016 15:26' prior: 0!Utility base class for building Iceberg GUI tools.It might be better to use TIceTool instead.!!IceGlamourCommitBrowser commentStamp: '<historical>' prior: 0!I allow userts to commit current changes.!!IceGlamourPublishBrowser commentStamp: '<historical>' prior: 0!I allow users to see and publish existing local commits.!!IceGlamourUpdateBrowser commentStamp: 'NicoPasserini 10/13/2016 17:28' prior: 0!This browser allows you to see the new commits  in your [upstream](../../../wiki/Some-keys-to-understand-Git-nomenclature#upstream), browse the changes and merge them into your current branch (or load them without merging).!!IceHistoryBrowser commentStamp: 'NicoPasserini 8/23/2016 14:34' prior: 0!Shows information about branches, history of commits and the changes in each commit.!!IceBranchBrowser commentStamp: '<historical>' prior: 0!I'm a browser to compare a branch with current installed sources.!!IceRepositoriesBrowser commentStamp: 'NicoPasserini 7/24/2016 20:12' prior: 0!Main entry point to the Iceberg UI tools, shows the list of the known repositories, allows to see a resume of the status of each of them and to open the repository synchronizer.Shows- all known repositorires- resume of the status of each package in each repositoryActions - create and forget repositories- refresh repository status- synchronize a repository- load / unload packages in a repository!!IceInteractiveCredentialsProvider commentStamp: 'NicoPasserini 11/15/2016 12:15' prior: 0!A credentials provider that asks the user for credentials.!!IceRemoteAdded commentStamp: 'EstebanLorenzano 1/6/2017 09:12' prior: 0!I'm an announce that happens  when a remote has been added.!!SwappedColorDiffMorph commentStamp: 'YuriyTymchuk 4/7/2017 11:32' prior: 0!I swap colors for the original giff morph, so the additions are green and removals are red!!GLMSwappedColorDiffPresentation commentStamp: 'EstebanLorenzano 5/8/2017 13:57' prior: 0!A glamour presentation  for the swapped diff morph!!IceAbstractBranchModel commentStamp: 'CyrilFerlicot 7/9/2017 03:25' prior: 0!Description--------------------I am an abstract class to define a common API for my subclasses that will manage some actions for some branch view of Iceberg. My subclasses will encapsulate a branch or a remote.I am use in the branch view of the main browser of Iceberg.Public API and Key Messages--------------------- #children				It should return the children of my element. It will probably return the branches of a remote for the remotes and nothing for the branches.- #nameToDisplay		String to show to the user.- #status 				Status to show to the user about incomming/unpublished commits.!!IceBranchGroupModel commentStamp: 'CyrilFerlicot 7/9/2017 03:35' prior: 0!Description--------------------I represent a group of branches. I am used in two principal cases. 1) We want to group the branches of a remote2) We want to group the local branchesExamples--------------------	"For a remote"	IceBranchGroupModel repository: anIceRepository remote: anIceRemote.		"For local branches"	IceBranchGroupModel localFromRepository: anIceRepository Internal Representation and Key Implementation Points.--------------------    Instance Variables	branches:		<aBlockOrSymbol>	This block takes the repository as parameter and should return the branches of the group	groupName:		<aString>			Name of the group. In case I represent a remote it will be the remote name, else it will probably be "Local"	repository:		<anIceRepository>	The repository where to get the branches!!IceBranchModel commentStamp: 'CyrilFerlicot 7/9/2017 03:36' prior: 0!Description--------------------I represent an unique branch. I should be contained in an IceBranchGroupModel.Examples--------------------	IceBranchModel parent: anIceBranchGroupModel branch: anIceBranch Internal Representation and Key Implementation Points.--------------------    Instance Variables	branch:				<anIceBranch>				The branch I should display info for.	parentGroup:		<anIceBranchGroupModel>	The branch group inside of which I am.!!IceChangesTreeResetSelectionHelper commentStamp: '<historical>' prior: 0!I am a helper to reset selections on changes tree browser.My purpose is to allow weaks to work properly, since the browser needs to do something like this: 		onChangeOfPort: #entity act: [ :presentation :diff | 			diff ifNotNil: [ 				diff announcer weak 					subscribe: IceChangeSetChanged 					do: [ presentation selection: nil ] ] ]... but the problem is that blocks and weak announcements do not work well, because when declaring a block you take all the outer context with you, hence creating a de-facto strong reference . So we need a replacement, and I'm that replacement :)Then, that code will look like this: 	onChangeOfPort: #entity act: [ :presentation :diff | 			diff ifNotNil: [ 				diff announcer weak 					subscribe: IceChangeSetChanged 					send: #execute:					to: (IceChangesTreeResetSelectionHelper for: presentation) ] ]removing the outer context problems .!!IceDiffChangeTreeBuilder commentStamp: '<historical>' prior: 0!I'm a builder to help users to build reusable diff-changes-tree elements.I'm used in several parts, notable in the syncronize window and in th e history browser.!!IceMergeTool commentStamp: 'NicoPasserini 12/13/2016 11:44' prior: 0!This is a very basic merge tool, just for keeping some state and coordinating interation between the 'real' merge tools. Internal Representation- source: <IceCommit> indicating the source of the changes to be merged (TODO: should be a commitish).- targetBranch: <IceBranch> where we want to merge the commits. If not provided the tool will raise a dialog to ask for it.- onMerge: <block or symbol> will be executed after a successfull merge.!!IceRepositoryUpdateHelper commentStamp: 'EstebanLorenzano 12/23/2016 15:50' prior: 0!I am a helper to create update cycles on repositories browser.My purpose is to allow weaks to work properly, since the browser needs to do something like this: 		Iceberg announcer weak 		subscribe: IceRepositoryCreated 		do: [ :ann | 			table 				updateOn: IceRepositoryAnnouncement 				from: ann repository announcer ].... but the problem is that blocks and weak announcements do not work well, because when declaring a block you take all the outer context with you, hence creating a de-facto strong reference . So we need a replacement, and I'm that replacement :)Then, that code will look like this: 	Iceberg announcer weak 		subscribe: IceRepositoryCreated 		send: #execute:		to: (IceRepositoryUpdateHelper for: table).removing the outer context problems :)!!GLMMorphicSwappedColorDiffRenderer commentStamp: 'EstebanLorenzano 5/5/2017 12:19' prior: 0!A glamour renderer for the swapped diff morph!!TIceTool classTrait methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!uiManager	^ UIManager default! !!TIceTool methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!mergeIntoAnotherBranch: aCommit andThen: aBlock	"Merge selected commit into another branch"	| branches selection repository |	repository := aCommit repository.		repository isModified ifTrue: [ 		(self uiManager			confirm:'Your repository has uncommited changes. Merge will change your current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.'			label: 'You might loose your current changes!!'			trueChoice: 'Proceed anyway'			falseChoice: 'Cancel'			cancelChoice: nil			default: false) 			ifFalse: [ ^ self ].	 ].		branches := repository branchesForMerge: aCommit.	selection := self uiManager		chooseFrom: (branches collect: #name)		values: branches		message: ('Select the branch into you want to merge commit {1}' format: { aCommit shortId })		title: 'Merge your changes into another branch'.	selection ifNotNil: [ 		[ aCommit mergeInto: selection ]			on: IceMergeAborted			do: [ 				selection name = repository branchName 					ifTrue: [ repository mergeConflictsWith: aCommit ]					ifFalse: [ 						self uiManager 						abort: 'Automatic (fast-forward) merge is not possible, to merge manually please first checkout branch ', selection name, ' and then retry.' 						title: 'Automatic merge failed' ]			].		aBlock value 	]! !!TIceTool methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!pushRepository: repository andThen: aBlock	[ UIManager default informUserDuring: [ :bar | | remote |		remote := repository pushRemote.		bar label: ('Publishing local commits to {1}' format: {remote}).		repository pushTo: remote. 		aBlock value.	]] 	on: YouShouldPullBeforePush	do: [ 		self uiManager			abort: 'Publish operation is not possible because your repository is out of date. Please update your local repository and retry.'			title: 'Publishing aborted' 	]! !!TIceTool methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!uiManager	^ self class uiManager! !!MCModification methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!icon	^ Smalltalk ui icons iconNamed: #changeUpdate! !!GLMGenericAction methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!selectionAction: actionSelector	"action selector will be sent to the presentation selection. 	If it accepts one argument, the presentation will be sent."	^ self		action: [ :presentation | 			presentation selection				ifNotNil: [ :sel | (MessageSend receiver: sel selector: actionSelector) cull: presentation ] ];		enabledCondition:				[ :presentation | "This is a minimal condition, that can be overriden (refined) later" presentation selection notNil ]! !!GLMGenericAction methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!selectionCondition: selectionCondition	"selectionCondition can be anything that can respond #cull: such as a block or unary symbol.	It will only be evaluated if the presentation has a (not nil) selected element."		^ self enabledCondition: [ :presentation | 		presentation selection notNil and: [ 			selectionCondition cull: presentation selection ]]! !!GLMGenericAction methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!showTitle: aTitle	^ self title: aTitle; showTitle! !!GLMMorphicCherryPickTreeRenderer methodsFor: 'callbacks' stamp: ' 7/24/2017 12:50:04'!actOnPresentationRefreshRequest: anAnnouncement	tableMorph window ifNil: [ ^ self ].	tableMorph window isActive ifFalse: [ ^ self ].	(tableMorph window boundsInWorld containsRect: tableMorph boundsInWorld) ifFalse: [ ^ self ].  " tableModel resetElements."	tableModel resetDataCache.	tableMorph refresh! !!GLMMorphicCherryPickTreeRenderer methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!createDataSourceFrom: aPresentation	^ GLMCherryPickTreeDataSource new! !!GLMMorphicCherryPickTreeRenderer methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!specificTableMorphInitializiation	super specificTableMorphInitializiation.	tableModel glamourPresentation isAllSelected		ifTrue: [ tableModel selectAll ]! !!IceAskForPlaintextCredentialsModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec	<spec: #default>	^ SpecLayout composed newColumn: [ :col |		col newRow: [:row | row add: #usernameLabel width: 80; add: #usernameInput ] height: self inputTextHeight;			newRow: [:row | row add: #passwordLabel width: 80; add: #passwordInput ] height: self inputTextHeight;			add: #storeCheckbox height: self inputTextHeight	]! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!acceptButton	^ acceptButton! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!credentials	^ IcePlaintextCredentials new 		username: self username;		password: self password;		yourself.! !!IceAskForPlaintextCredentialsModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ (350@(		self class inputTextHeight * 3 		+ self class buttonHeight 		+ 50 "Yes, a magic number"		))! !!IceAskForPlaintextCredentialsModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	usernameLabel := self newLabel label: 'Username: '.	usernameInput := self newTextInput autoAccept: true.		passwordLabel := self newLabel label: 'Password: '.	passwordInput := self newTextInput beEncrypted; autoAccept: true.	storeCheckbox := self newCheckBox		label: 'Do you want this credentials to be stored for future use?';		help: 'Please note that storing your credentials is handy but unsafe';		state: true.		self focusOrder		add: usernameInput;		add: passwordInput;		add: storeCheckbox! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!password 	^ passwordInput text! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!passwordInput	^ passwordInput! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!passwordLabel	^ passwordLabel! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!storeCheckbox	^ storeCheckbox ! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!storeCredentials	^ storeCheckbox state ! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ 'Please log in to git'! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!username	^ usernameInput text! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!usernameInput	^ usernameInput! !!IceAskForPlaintextCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!usernameLabel	^ usernameLabel! !!IceAskForSshCredentialsModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec	<spec: #default>	^ SpecLayout composed newColumn: [ :col |		col 			newRow: [:row | row add: #usernameLabel width: 100; add: #usernameInput ] height: self inputTextHeight;			newRow: #publicKeyLocation height: self inputTextHeight;			newRow: #privateKeyLocation  height: self inputTextHeight;			newRow: [:row | row add: #passwordLabel width: 100; add: #passwordInput ] height: self inputTextHeight;			add: #storeCheckbox height: self inputTextHeight ]! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!acceptButton	^ acceptButton! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!acceptButton: anObject	acceptButton := anObject! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!credentials	^ IceSshCredentials new 		username: self username;		publicKey: self publicKey;		privateKey: self privateKey;		keyPassphrase: self password;		yourself.! !!IceAskForSshCredentialsModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ (500@(		self class inputTextHeight * 5		+ self class buttonHeight 		+ 50 "Yes, a magic number"		))! !!IceAskForSshCredentialsModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	usernameLabel := self newLabel label: 'SSH Username: '.	usernameInput := self newTextInput autoAccept: true.		publicKeyLocation := self instantiate: IceFileModel.	publicKeyLocation 		label: 'Public SSH Key: ';		chooseTitle: 'Public SSH Key (id_rsa.pub)'.	privateKeyLocation := self instantiate: IceFileModel.	privateKeyLocation 		label: 'Private SSH Key: ';		chooseTitle: 'Private SSH Key (id_rsa)'.	passwordLabel := self newLabel label: 'SSH Passphrase: '.	passwordInput := self newTextInput beEncrypted; autoAccept: true.	storeCheckbox := self newCheckBox		label: 'Do you want this credentials to be stored for future use?';		state: true.		self focusOrder		add: usernameInput;		add: publicKeyLocation;		add: privateKeyLocation;		add: passwordInput;		add: storeCheckbox! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!password 	^ passwordInput text! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!passwordInput	^ passwordInput! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!passwordInput: anObject	passwordInput := anObject! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!passwordLabel	^ passwordLabel! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!passwordLabel: anObject	passwordLabel := anObject! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!privateKey	^ privateKeyLocation location! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!privateKeyLocation	^ privateKeyLocation! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!privateKeyLocation: anObject	privateKeyLocation := anObject! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!publicKey	^ publicKeyLocation location! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!publicKeyLocation	^ publicKeyLocation! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!publicKeyLocation: anObject	publicKeyLocation := anObject! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!storeCheckbox	^ storeCheckbox ! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!storeCredentials	^ storeCheckbox state ! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ 'Please provide SSH keys'! !!IceAskForSshCredentialsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!username	^ usernameInput text! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!usernameInput	^ usernameInput! !!IceAskForSshCredentialsModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!usernameLabel	^ usernameLabel! !!IceAskForUsernameAndEmailModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec	<spec: #default>	^ SpecLayout composed newColumn: [ :col |		col 			newRow: [:row | row add: #nameLabel width: 100; add: #nameInput ] height: self inputTextHeight;			newRow: [:row | row add: #emailLabel width: 100; add: #emailInput ] height: self inputTextHeight;			add: #globalCheckbox height: self inputTextHeight;			add: #acceptButton height: self buttonHeight  ]! !!IceAskForUsernameAndEmailModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!accept	self username isEmptyOrNil ifTrue: [ ^ UIManager default alert: 'user.name is required.' ].	self email isEmptyOrNil ifTrue: [ ^ UIManager default alert: 'user.email is required.' ].			acceptBlock 		value: self username 		value: self email		value: self isGlobal.		self window delete.! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!acceptButton	^ acceptButton! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!acceptButton: anObject	acceptButton := anObject! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!email	^ self emailInput text trimBoth! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!emailInput	^ emailInput! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!emailInput: anObject	emailInput := anObject! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!emailLabel	^ emailLabel! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!emailLabel: anObject	emailLabel := anObject! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!globalCheckbox	^ globalCheckbox! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!globalCheckbox: anObject	globalCheckbox := anObject! !!IceAskForUsernameAndEmailModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ (400@(		self class inputTextHeight * 3		+ self class buttonHeight 		+ 50 "Yes, a magic number"		))! !!IceAskForUsernameAndEmailModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	nameLabel := self newLabel label: 'user.name'.	nameInput := self newTextInput 		ghostText: 'John Doe';		autoAccept: true.	emailLabel := self newLabel label: 'user.email'.	emailInput := self newTextInput 		ghostText: 'johndoe@mail.net';				autoAccept: true.	globalCheckbox := self newCheckBox		label: 'Save properties as global?';		state: false.	acceptButton := self newButton		label: 'Set properties';		action: [ self accept ];		yourself.					self focusOrder		add: nameInput;		add: emailInput;		add: globalCheckbox;		add: acceptButton! !!IceAskForUsernameAndEmailModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isGlobal	^ self globalCheckbox state! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!nameInput	^ nameInput! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!nameInput: anObject	nameInput := anObject! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!nameLabel	^ nameLabel! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!nameLabel: anObject	nameLabel := anObject! !!IceAskForUsernameAndEmailModel methodsFor: 'events' stamp: ' 7/24/2017 12:50:04'!onAccept: aBlock	"aBlock will receive 3 arguments: name, email, global flag"	acceptBlock := aBlock! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ 'Please provide required properties'! !!IceAskForUsernameAndEmailModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!username	^ self nameInput text trimBoth! !!IceCommitInfoModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec 	<spec>	^ SpecLayout composed		newColumn: [ :c |			c 				newRow: [:row | row add: #dateLabel width: 80; add: #datePanel ] height: 25;				newRow: [:row | row add: #idLabel width: 80; add: #idPanel ] height: 25;				newRow: [:row | row add: #parentsLabel width: 80; add: #parentsPanel ] height: 25;				newRow: [:row | row add: #authorLabel width: 80; add: #authorPanel ] height: 25;				newRow: [:row | row add: #commentLabel width: 80; add: #commentPanel ] ];		yourself! !!IceCommitInfoModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!for: aCommit	^ self basicNew 		initializeCommit: aCommit;		yourself! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!authorLabel	^ authorLabel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!authorLabel: anObject	authorLabel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!authorPanel	^ authorPanel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!authorPanel: anObject	authorPanel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commentLabel	^ commentLabel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commentLabel: anObject	commentLabel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commentPanel	^ commentPanel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commentPanel: anObject	commentPanel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commit	^ commit! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!dateLabel	^ dateLabel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!dateLabel: anObject	dateLabel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!datePanel	^ datePanel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!datePanel: anObject	datePanel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!idLabel	^ idLabel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!idLabel: anObject	idLabel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!idPanel	^ idPanel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!idPanel: anObject	idPanel := anObject! !!IceCommitInfoModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeCommit: aCommit	commit := aCommit.	self initialize! !!IceCommitInfoModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	idLabel := self newLabel.	idPanel := self newTextInput enabled: false.	dateLabel := self newLabel.	datePanel := self newTextInput enabled: false.	authorLabel := self newLabel.	authorPanel := self newTextInput enabled: false.	commentLabel := self newLabel.	commentPanel := self newText enabled: false.	parentsLabel := self newLabel.	parentsPanel := self newTextInput enabled: false.		idLabel label: 'Commit Id'.	idPanel text: self commit id asString, ' [', self commit shortId, ']'.	dateLabel label: 'Date & time'.	datePanel text: self commit datetime asLocalStringYMDHM.	authorLabel label: 'Author'.	authorPanel text: self commit username.	commentLabel label: 'Comment'.	commentPanel text: self commit comment.	parentsLabel label: 'Parent(s)'.	parentsPanel text: (self commit parents collect: #shortId) asCommaString	! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!parentsLabel	^ parentsLabel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!parentsLabel: anObject	parentsLabel := anObject! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!parentsPanel	^ parentsPanel! !!IceCommitInfoModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!parentsPanel: anObject	parentsPanel := anObject! !!IceCherryPickCommitModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!basicCommitWithMessage: aString	| picked |	self flag: #todo. "I need to check if picked = all changes (in that case, is not 	needed the pick and I can just go 'business as usual')"	cherryPickBlock ifNotNil: [ picked := cherryPickBlock value ].	"Nothing was picked, continue as usual"	picked ifNil: [ ^ super basicCommitWithMessage: aString ].	self repository 		commitCherryPick: picked  		withMessage: aString! !!IceCherryPickCommitModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!withSelectedCherryPick: aBlock	cherryPickBlock := aBlock! !!IceCommitModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec	<spec: #default>	^ SpecLayout composed newColumn:		[ :col | col			add: #message;			newRow: [ :row | row				add: #commitButton;				add: #commitPushButton			] height: self toolbarHeight		]! !!IceCommitModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!messageGhostText	^ 'Please enter commit message.'! !!IceCommitModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!basicCommitWithMessage: aString	self repository 		commitPackages: self model changedPackages		withMessage: aString! !!IceCommitModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!basicCommitWithMessage: text ifCancel: cancelBlock	[		[ self basicCommitWithMessage: text asString ]		on: IceGitUsernameOrEmailNotFound 		do: [ :e |			self configGitUsernameAndEmailOnCancel: cancelBlock.			e retry ].		self resetText ]	on: NothingToCommitException 	do: [ :e | UIManager default inform: 'There is nothing to commit.' ]! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branchName	^ self model repository branchName! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commitButton	^ commitButton! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commitPushButton	^ commitPushButton! !!IceCommitModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!commitPushing: pushBoolean	| text |		(text := self messageText) ifEmpty: [ ^ self ].	UIManager default		informUserDuring: [ :bar | 			bar label: ('Commiting changes to {1}' format: {self repository}).			self basicCommitWithMessage: text ifCancel: [ ^ self ].			pushBoolean ifTrue: [ | remote |				remote := self repository pushRemote.				bar label: ('Pushing changes to {1}' format: {remote}).				self pushRepository: self repository andThen: [ ]. 				UIManager default inform: ('Uploaded changes to {1}' format: {remote}) ] ]! !!IceCommitModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!configGitUsernameAndEmailOnCancel: cancelBlock	| passed |	passed := false.	(IceAskForUsernameAndEmailModel new 		onAccept: [ :username :email :global |			self repository 				username: username				email: email				global: global.			passed := true ];			openWithSpec)		modalRelativeTo: World.			passed ifFalse: cancelBlock! !!IceCommitModel methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!contractedNameFor: diff	"If the name of a branch is too long it is better to contract it in order to limit the UI glitches."	^ diff repository branchName contractTo: 20! !!IceCommitModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	model := nil asValueHolder.	model whenChangedDo: [ :diff | commitButton label: 'Commit onto ' , (self contractedNameFor: diff) ].	model whenChangedDo: [ :diff | commitPushButton label: 'Commit and Push onto ' , (self contractedNameFor: diff) ].	super initialize! !!IceCommitModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializePresenter	commitButton action: [ self commitPushing: false ].	commitPushButton action: [ self commitPushing: true ]! !!IceCommitModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	message := self newText		autoAccept: true;		whenBuiltDo: [ :this | this widget withGhostText: self class messageGhostText ];		whenTextChanged: [ | enable |			enable := self messageText notEmpty.			commitButton enabled: enable.			commitPushButton enabled: enable ];		yourself.	commitButton := self newButton		label: 'Commit';		enabled: false;		yourself.	commitPushButton := self newButton		label: 'Commit and push';		enabled: false;		yourself.			self focusOrder 		add: message;		add: commitButton;		add: commitPushButton! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!message	^ message! !!IceCommitModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!messageText	^ self message text! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!model	^ model value! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!model: aDiff	model value: aDiff ! !!IceCommitModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ self model repository! !!IceCommitModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!resetText	self message text: ''! !!IceCloneRepositoryModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!buildDefaultSpec: col	col		newRow: [:row | row			add: #remoteUrlLabel width: 100;			add: #remoteUrl ]		height: self inputTextHeight.			super buildDefaultSpec: col! !!IceCloneRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!createRepository	[		| repository |				repository := IceRepositoryCreator new 			remote: (IceRemote url: remoteUrl text trim);			location: self location;			subdirectory: subdirectory text;			createRepository.		repository register.					self window delete. 	]	on: IceError 	do: [ :error | 		UIManager default 			abort: error messageText 			title: 'Could not create repository' ]! !!IceCloneRepositoryModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ (500@(		self class inputTextHeight * 3 		+ self class buttonHeight 		+ 37 "Yes, a magic number"		))! !!IceCloneRepositoryModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	remoteUrlLabel := self newLabel label: 'Remote URL'.	remoteUrl := self newTextInput ghostText: 'git@github.com:user/project.git'; autoAccept: true.	self focusOrder add: remoteUrl.	super initializeWidgets.	! !!IceCloneRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!remoteUrl	^ remoteUrl! !!IceCloneRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!remoteUrlLabel	^ remoteUrlLabel! !!IceCloneRepositoryModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!title	^ 'Clone repository by URL'! !!IceCreateRepositoryModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!buildDefaultSpec: col	col		newRow: #localDirectoryLocation		height: self inputTextHeight;				newRow: [:row | row 			add: #subdirectoryLabel width: 100;			add: #subdirectory ]		height: self inputTextHeight;					add: #createButton height: self buttonHeight ! !!IceCreateRepositoryModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!buttonLabel	^ 'Create repository'! !!IceCreateRepositoryModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec	<spec: #default>	^ SpecLayout composed newColumn:		[ :col | self buildDefaultSpec: col ]! !!IceCreateRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!createButton	^ createButton! !!IceCreateRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!createButton: anObject	createButton := anObject! !!IceCreateRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!createRepository	self subclassResponsibility! !!IceCreateRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultLocation	^ IceRepository repositoriesLocation pathString! !!IceCreateRepositoryModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializePresenter	createButton action: [ self createRepository ]! !!IceCreateRepositoryModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	localDirectoryLocation := self instantiate: IceDirectoryModel.	localDirectoryLocation 		label: 'Local directory';		chooseTitle: 'Choose local repository';		location: self defaultLocation.		subdirectoryLabel := self newLabel label: 'Code subdirectory'.	subdirectory := self newTextInput autoAccept: true.		createButton := self newButton		label: self class buttonLabel;		yourself.		self focusOrder 		add: localDirectoryLocation;		add: subdirectory;		add: createButton! !!IceCreateRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!localDirectoryLocation	^ localDirectoryLocation! !!IceCreateRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!localDirectoryLocation: anObject	localDirectoryLocation := anObject! !!IceCreateRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location	| location |	location := localDirectoryLocation location.	^ (location notNil and: [ location pathString ~= self defaultLocation ])		ifTrue: [ ^ location ]		ifFalse: [ nil ]! !!IceCreateRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location: anObject	localDirectoryLocation location: anObject! !!IceCreateRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!subdirectory	^ subdirectory! !!IceCreateRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!subdirectoryLabel	^ subdirectoryLabel! !!IceEditRepositoryModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!buttonLabel	^ 'Edit repository'! !!IceEditRepositoryModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!new 	self error: 'Use #repository:'! !!IceEditRepositoryModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!repository: aRepository	^ self basicNew		initializeRepository: aRepository;		yourself! !!IceEditRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!codeDirectory	^ self subdirectory text	! !!IceEditRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!codeDirectory: aString	self subdirectory text: aString	! !!IceEditRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!createRepository	self repository location = self location 		ifFalse: [ self repository location: self location ].	self repository subdirectory = self codeDirectory		ifFalse: [ self repository subdirectory: self codeDirectory ].	self window delete. 	acceptBlock ifNotNil: [ acceptBlock cull: self ]! !!IceEditRepositoryModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ (500@(		self class inputTextHeight * 2		+ self class buttonHeight 		+ 37 "Yes, a magic number"		))! !!IceEditRepositoryModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializePresenter	super initializePresenter.	self location: (self repository location ifNil: [ IceRepository repositoriesLocation ]).	self codeDirectory: self repository subdirectory.! !!IceEditRepositoryModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeRepository: aRepository	repository := aRepository.	self initialize! !!IceEditRepositoryModel methodsFor: 'events' stamp: ' 7/24/2017 12:50:04'!onAccept: aBlock 	acceptBlock := aBlock! !!IceEditRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceEditRepositoryModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!title	^ 'Edit repository'! !!IceImportLocalRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!createRepository	self location ifNil: [ 		UIManager default 			abort: 'Please select a repository location'			title: 'Could not create repository'. 		^ self ].	[		| repository |				repository := IceRepositoryCreator new 			location: self location;			subdirectory: subdirectory text;			createRepository.		repository register.					self window delete. 	]	on: IceError 	do: [ :error | 		UIManager default 			abort: error messageText 			title: 'Could not create repository' ]! !!IceImportLocalRepositoryModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ (500@(		self class inputTextHeight * 2		+ self class buttonHeight 		+ 37 "Yes, a magic number"		))! !!IceImportLocalRepositoryModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!title	^ 'Import local repository into Iceberg'! !!IceNewRepositoryModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!buildDefaultSpec: col	col		newRow: [:row | row			add: #projectNameLabel width: 100;			add: #projectNameInput ]		height: self inputTextHeight.			super buildDefaultSpec: col! !!IceNewRepositoryModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!buttonLabel	^ 'Create repository'! !!IceNewRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!createRepository	[		| repository |			self projectName isEmptyOrNil 		ifTrue: [ Error signal: 'Project name is required' ].		repository := IceRepositoryCreator new 			location: self location / self projectName;			subdirectory: subdirectory text;			createNewRepositoryNamed: self projectName.		repository register.		self window delete.		acceptBlock ifNotNil: [ acceptBlock cull: self ] ]	on: IceError 	do: [ :error | 		UIManager default 			abort: error messageText 			title: 'Could not create repository' ].! !!IceNewRepositoryModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ (500@(		self class inputTextHeight * 3		+ self class buttonHeight 		+ 37 "Yes, a magic number"		))! !!IceNewRepositoryModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	projectNameLabel := self newLabel label: 'Project name'.	projectNameInput := self newTextInput 		ghostText: 'project'; 		autoAccept: true.	self focusOrder add: projectNameInput.	super initializeWidgets! !!IceNewRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location	^ localDirectoryLocation location! !!IceNewRepositoryModel methodsFor: 'events' stamp: ' 7/24/2017 12:50:04'!onAccept: aBlock	acceptBlock := aBlock! !!IceNewRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!projectName	^ self projectNameInput text! !!IceNewRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!projectNameInput	^ projectNameInput! !!IceNewRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!projectNameInput: anObject	projectNameInput := anObject! !!IceNewRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!projectNameLabel	^ projectNameLabel! !!IceNewRepositoryModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!projectNameLabel: anObject	projectNameLabel := anObject! !!IceNewRepositoryModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!title	^ 'New repository'! !!IceDirectoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!chooseReference	^ UIManager default 		chooseDirectory: self chooseTitle 		path: self location! !!IceFileModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!chooseReference	^ (UIManager default 		chooseFileName: self chooseTitle 		extensions: nil 		path: self location 		preview: nil)		ifNotNil: [ :file | file asFileReference  ]! !!IceLocationModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultChooseDialogTitle	^ 'Choose directory'! !!IceLocationModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultLabel	^ 'Directory'! !!IceLocationModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec 	<spec>	^ SpecLayout composed		newRow: [ :row | 			row 				add: #locationLabel width: 100; 			 	add: #locationInput; 				add: #chooseButton width: self iconWidth ]! !!IceLocationModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!iconWidth	^ 24! !!IceLocationModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!choose	self chooseReference ifNotNil: [ :reference | 		self location: reference.		self locationInput text: reference pathString ]! !!IceLocationModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!chooseButton	^ chooseButton! !!IceLocationModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!chooseButton: anObject	chooseButton := anObject! !!IceLocationModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!chooseReference 	self subclassResponsibility! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!chooseTitle	^ chooseTitle ifNil: [ self class defaultChooseDialogTitle ]! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!chooseTitle: aString	chooseTitle := aString! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!icon	^ #open asIcon! !!IceLocationModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	locationLabel := self newLabel label: self label.	locationInput := self newTextInput autoAccept: true.	chooseButton := self newButton icon: self icon.		locationInput whenBuiltDo: [ :w | w widget wrapFlag: false ]. 	chooseButton action: [ self choose ].		self focusOrder add: locationInput	! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!label	^ label ifNil: [ self class defaultLabel ]! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!label: aString	label := aString.	self locationLabel label: aString	! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location	^ locationInput text trim 		ifNotEmpty: [ :value | value asFileReference ]		ifEmpty: [ nil ]! !!IceLocationModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location: aReferenceOrString	locationInput text: aReferenceOrString asFileReference pathString! !!IceLocationModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!locationInput	^ locationInput! !!IceLocationModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!locationInput: anObject	locationInput := anObject! !!IceLocationModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!locationLabel	^ locationLabel! !!IceLocationModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!locationLabel: anObject	locationLabel := anObject! !!IceRemoteModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec 	<spec>	^ SpecLayout composed		newColumn: [ :c |			c 				newRow: [:row | row add: #nameLabel width: 80; add: #namePanel ] height: 25;				newRow: [:row | row add: #urlLabel width: 80; add: #urlPanel ] height: 25;				add: #addButton height: self buttonHeight ];		yourself! !!IceRemoteModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!title	^ 'Add remote'! !!IceRemoteModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!accept	| remoteName remoteUrl |		remoteName := self namePanel text trim.	remoteName ifEmpty: [ 		UIManager default alert: 'You need to specify a remote name.' title: 'Error'. ^ self ].	remoteUrl := self urlPanel text trim.	remoteUrl ifEmpty: [		UIManager default alert: 'You need to specify a remote url.' title: 'Error'. ^ self ].		self window delete.	acceptBlock ifNotNil: [ 		acceptBlock cull: (IceRemote name: remoteName url: remoteUrl) ]! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!addButton	^ addButton! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!addButton: anObject	addButton := anObject! !!IceRemoteModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ (500@(		self class inputTextHeight * 2		+ self class buttonHeight 		+ 37 "Yes, a magic number"		))! !!IceRemoteModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	nameLabel := self newLabel. 	namePanel := self newTextInput ghostText: 'user-remote'; autoAccept: true.	urlLabel := self newLabel.	urlPanel := self newTextInput ghostText: 'git@github.com:user/project.git'; autoAccept: true.	addButton := self newButton.		nameLabel label: 'Remote name'.	urlLabel label: 'Remote URL'.	addButton label: 'Add remote'.	addButton action: [ self accept ].		self focusOrder 		add: namePanel;		add: urlPanel;		add: addButton! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!nameLabel	^ nameLabel! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!nameLabel: anObject	nameLabel := anObject! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!namePanel	^ namePanel! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!namePanel: anObject	namePanel := anObject! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!onAccept: aBlock 	acceptBlock := aBlock! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!urlLabel	^ urlLabel! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!urlLabel: anObject	urlLabel := anObject! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!urlPanel	^ urlPanel! !!IceRemoteModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!urlPanel: anObject	urlPanel := anObject! !!ToolShortcutsCategory methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!openIceberg	<shortcut>	^ KMKeymap shortcut: PharoShortcuts current openIcebergShortcut action: [ IceRepositoriesBrowser  open ]! !!IceRemote methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!branchesFrom: aRepository	"I return all the branches of my remote from a repository"	^ aRepository branches		select: [ :branch | branch isRemote and: [ branch remoteName = self remoteName ] ]! !!DateAndTime methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!asLocalStringYMDHM	^ self asLocal asStringYMDHM! !!DateAndTime methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!asStringYMDHM	^ String streamContents: [ :aStream |		self printYMDOn: aStream.		aStream nextPut: Character space.		self hour printOn: aStream base: 10 length: 2 padded: true.		aStream nextPut: $:.		self minute printOn: aStream base: 10 length: 2 padded: true ]! !!GLMMorphicRenderer methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!renderCherryPickTreePresentation: aPresentation 	^ GLMMorphicCherryPickTreeRenderer render: aPresentation from: self! !!GLMMorphicRenderer methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!renderSwappedColorDiffPresentation: aPresentation	^ GLMMorphicSwappedColorDiffRenderer render: aPresentation from: self! !!GLMCherryPickTreePresentation methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!allSelected	allSelected := true! !!GLMCherryPickTreePresentation methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!cherryPick	^ (self pane port: #cherryPick) value! !!GLMCherryPickTreePresentation methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!cherryPick: aValuable	^ (self pane port: #cherryPick) value: aValuable! !!GLMCherryPickTreePresentation methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	super initialize.	allSelected := false! !!GLMCherryPickTreePresentation methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isAllSelected	^ allSelected! !!GLMCherryPickTreePresentation methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!onChangeOfCherryPick: aBlock	self onChangeOfPort: #cherryPick act: aBlock! !!GLMCherryPickTreePresentation methodsFor: 'rendering' stamp: ' 7/24/2017 12:50:04'!renderGlamorouslyOn: aRenderer 	self registerAnnouncements.	^ aRenderer renderCherryPickTreePresentation: self! !!GLMCompositePresentation methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!cherryPickTree	^ self custom: GLMCherryPickTreePresentation new! !!GLMCompositePresentation methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!swappedColorDiff	^ self custom: GLMSwappedColorDiffPresentation new	! !!IceGlamourSynchronizer class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultExtent	^ 850@600! !!IceGlamourSynchronizer class methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!synchronize: anIceRepository	self new openOn: anIceRepository.! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branch	^ self repository branch! !!IceGlamourSynchronizer methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!compose	(self custom: GLMStacker new) with: [ :browser |		browser initialExtent: self initialExtent.		browser updateOn: Announcement from: [ :repo | repo announcer weak ].		browser aPane: #commit.		browser transmit 			transformed: #workingCopyDiff; 			to: #commit;			andShow: [ :a | a 				title: 'Commit your changes'; 				custom: IceGlamourCommitBrowser new ].		browser aPane: #update.		browser transmit 			to: #update;			andShow: [ :a | a 				title: 'Update'; 				custom: IceGlamourUpdateBrowser new ].		browser aPane: #publish.		browser transmit 			to: #publish;			andShow: [ :a | a 				title: 'Push'; 				custom: IceGlamourPublishBrowser new ].	]! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ self class defaultExtent! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location	^ self repository location! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote	^ remote ifNil: [ self repository pushRemote ]! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote: aRemote	remote := aRemote! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ (self pane port: #entity) value! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ 'Synchronizing {1} -- branch: {2} -- remote: {3}' 		format: {			self location gtDisplayString.			self branch.			self remote }		! !!IceGlamourSynchronizer methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!titleIcon	^ IceTool icon! !!IceAbstractBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!addCommitInfoTo: browser	browser transmit 		from: #commits; 		to: #diff; 		andShow: [ :a |			a morph				title: 'Commit info';				display: [ :commitInfo | (IceCommitInfoModel for: commitInfo) buildWithSpec ] ].! !!IceAbstractBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!addDiffTo: browser withTitle: diffTitle	browser transmit 		from: #changes; 		to: #diff; 		andShow: [ :a | 			a swappedColorDiff				title: diffTitle;				display: [:change | self buildDiffInput: change ]]! !!IceAbstractBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!buildDiffInput: change	^ { 		change myVersion ifNil: ''. 		change theirVersion ifNil: ''	}! !!IceEmbeddedBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!configureBrowser: browser	"Do nothing, since the purpose of this browsers is to be embedded"! !!IceEmbeddedBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!titleIcon	"Do nothing, since the purpose of this browsers is to be embedded"	^ nil! !!IceGlamourCommitBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeBrowserOn: browser	browser		row: [ :row | 			row				column: #changes; 				column: #commit ];		row: #diff.	browser transmit 		to: #changes;  		andShow: [ :a :diff |			self selectedElements: nil.			(IceDiffCherryPickChangeTreeBuilder new 				diff: diff;				onSelectCherryPick: [ :aSet | self selectedElements: aSet ];				buildOn: a)				title: 'Local changes' ].	browser transmit 		to: #commit;		andShow: [ :a :diff | 			a morph				title: 'Commit changes';				morph: [					IceCherryPickCommitModel new 						model: diff;						withSelectedCherryPick: [ self selectedElements ];						buildWithSpec ] ].	self addDiffTo: browser withTitle: 'Left: working copy / Right: local repository'! !!IceGlamourCommitBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!selectedElements	^ selectedElements! !!IceGlamourCommitBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!selectedElements: anObject	selectedElements := anObject! !!IceGlamourPublishBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!addDiffTo: browser	browser transmit 		from: #commits; 		from: #changes; 		to: #diff; 		andShow: [ :a | 			a swappedColorDiff 				title: 'Left: working copy / Right: incoming updates';				display: [ :commitInfo :change | self buildDiffInput: change ]. 			a morph 				title: 'Commit info';				display: [ :commitInfo | (IceCommitInfoModel for: commitInfo) buildWithSpec ] ]! !!IceGlamourPublishBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeBrowserOn: browser	browser		row: [ :top | top			column: #commits; 			column: #changes ];		row: #diff.	browser transmit		to: #commits;		andShow: [ :a | self composeCommitsListIn: a ].	browser transmit		fromOutsideEntityPort;		from: #commits; 		to: #changes; 		andShow: [ :a :repo :commitInfo | 			(IceDiffChangeTreeBuilder new				entity: commitInfo; 				diff: (commitInfo ifNotNil: [ commitInfo diffWith: repo branch upstream ]);				buildOn: a)				title: 'Outgoing changes' ].	self addDiffTo: browser.	self addCommitInfoTo: browser 	! !!IceGlamourPublishBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeCommitsListIn: composite	composite fastTable		title: 'New local commits to be published';		display: #outgoingCommits;		column: 'User' evaluated: #username width: 120;		column: 'Date & time' evaluated: [:commit | commit datetime asLocal asStringYMDHM ] width: 120;		column: 'Comment' evaluated: #comment;		updateOn: IceCommited, IcePushed from: #announcer;		addAction: self pushAction;		addSelectionAction: self mergeIntoAction! !!IceGlamourPublishBrowser methodsFor: 'action creators' stamp: ' 7/24/2017 12:50:04'!mergeIntoAction	^ GLMGenericAction new		action: [ :presentation |			self 				mergeIntoAnotherBranch: presentation selection				andThen: [					presentation selection: nil.					presentation pane browser update 				]];		icon: GLMUIThemeExtraIcons glamorousLeftSide;		shortcut: $m;		title: 'Merge into another branch...'; 		showTitle! !!IceGlamourPublishBrowser methodsFor: 'action creators' stamp: ' 7/24/2017 12:50:04'!pushAction	 ^ GLMGenericAction new			action: [ :presentation :repository | 				self 					pushRepository: repository					andThen: [ presentation selection: nil ]];			icon: GLMUIThemeExtraIcons glamorousRightSide;			shortcut: $p;			showTitle: 'Publish all'				! !!IceGlamourUpdateBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!addDiffTo: browser	browser transmit 		from: #commits; 		from: #changes; 		to: #diff; 		andShow: [ :a | 			a swappedColorDiff 				title: 'Left: working copy / Right: incoming updates';				display: [ :commitInfo :change | self buildDiffInput: change ]. 			a morph 				title: 'Commit info';				display: [ :commitInfo | (IceCommitInfoModel for: commitInfo) buildWithSpec ] ]	! !!IceGlamourUpdateBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!buildDiffInput: change	"The diff from an incoming change comes with the versions switched, 	so I have to switch them again."	^ { 		change theirVersion ifNil: ''.		change myVersion ifNil: ''. 	}! !!IceGlamourUpdateBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeBrowserOn: browser	browser		row: [ :top | top			column: #commits; 			column: #changes ];		row: #diff.	browser transmit		to: #commits;		andShow: [ :a | self composeCommitsListIn: a ].	browser transmit		fromOutsideEntityPort;		from: #commits; 		to: #changes; 		andShow: [ :a :repo :commitInfo |.			(IceDiffChangeTreeBuilder new				entity: commitInfo;				diff: (commitInfo ifNotNil: [ commitInfo diffWith: (repo mergeBaseWith: commitInfo) ]); 				buildOn: a)				title: 'Incoming changes' ].	self addDiffTo: browser.	self addCommitInfoTo: browser ! !!IceGlamourUpdateBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeCommitsListIn: composite	composite fastTable		title: 'New commits to be imported';		display: #incomingCommits;		column: 'User' evaluated: #username width: 120;		column: 'SHA' evaluated: #shortId width: 60;		column: 'Date & time' evaluated: [:commit | commit datetime asLocalStringYMDHM ] width: 100;		column: 'Status' evaluated: #status width: 80;		column: 'Comment' evaluated: #comment;		updateOn: IcePackageLoaded from: #announcer;		addAction: self fetchAction;		addAction: self pullAction;		addSelectionAction: self loadAction;		addSelectionAction: self mergeAction! !!IceGlamourUpdateBrowser methodsFor: 'action creators' stamp: ' 7/24/2017 12:50:04'!fetchAction	^ GLMGenericAction new		action: [ :presentation :repository | 			repository fetch.			presentation update ];		icon: #glamorousLeftSide asIcon;		shortcut: $f;		title: 'Fetch new versions'; 		showTitle! !!IceGlamourUpdateBrowser methodsFor: 'action creators' stamp: ' 7/24/2017 12:50:04'!loadAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection load. 			presentation selection: nil ];		condition: [ :presentation | 			presentation selection notNil 				and: [ presentation selection isMerged ]];		icon: #changeBlock asIcon;		shortcut: $l;		title: 'Load'; showTitle! !!IceGlamourUpdateBrowser methodsFor: 'action creators' stamp: ' 7/24/2017 12:50:04'!mergeAction	^ GLMGenericAction new		action: [ :presentation |			presentation selection merge.			presentation selection: nil.			presentation pane browser update. ];		condition: [ :presentation | 			presentation selection notNil 				and: [ presentation selection isMerged not ] ];		icon: GLMUIThemeExtraIcons glamorousLeftSide;		shortcut: $m;		title: 'Merge and load'; showTitle! !!IceGlamourUpdateBrowser methodsFor: 'action creators' stamp: ' 7/24/2017 12:50:04'!pullAction	^ GLMGenericAction new		action: [ :presentation :repository | 			repository pull.			presentation update ];		icon: #glamorousLeftSide asIcon;		shortcut: $p;		title: 'Pull'; 		showTitle! !!IceBranchBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeBrowserOn: browser	browser 		row: [:row | 			row 				column: #commits; 				column: #changes ]; 		row: #diff.		browser transmit to: #commits; andShow: [ :a | self composeCommitsIn: a ].	self addChangesTreesTo: browser.	self addDiffTo: browser.	self addCommitInfoTo: browser! !!IceBranchBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ 'Branch browser'! !!IceHistoryBrowser class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultExtent	^ 850@600! !!IceHistoryBrowser class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ 'History browser'! !!IceHistoryBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!addChangesTreeTo: a with: commitInfo	(IceDiffChangeTreeBuilder new 		entity: commitInfo;		diff: (commitInfo ifNotNil: [ commitInfo diffFromHead ]); 		buildOn: a)		title: 'Changes since selection'.	(IceDiffChangeTreeBuilder new		entity: commitInfo;		diff: (commitInfo ifNotNil: [ commitInfo diffToParent ]);		buildOn: a)		title: 'Changes vs. parent' ! !!IceHistoryBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!addChangesTreesTo: browser	browser transmit 		from: #commits;		to: #changes; 		andShow: [ :a :commitInfo |			self addChangesTreeTo: a with: commitInfo ].! !!IceHistoryBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!addDiffTo: browser	browser transmit 		from: #commits; 		from: #changes; 		to: #diff; 		andShow: [ :a | 			a swappedColorDiff 				title: 'Left: working copy / Right: incoming updates';				display: [ :commitInfo :change | self buildDiffInput: change ]. 			a morph 				title: 'Commit info';				display: [ :commitInfo | (IceCommitInfoModel for: commitInfo) buildWithSpec ] ]	! !!IceHistoryBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeBranchesIn: composite	composite fastTable		title: 'Branches';		display: #branchesForCheckout;		column: 'Name' evaluated: [ :branch :repo | 			self 				descriptionTextForBranch: branch				repository: repo ]		! !!IceHistoryBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeBrowserOn: browser	browser 		row: [:row | 			row 				column: #branches span: 2; 				column: #commits span: 3; 				column: #changes span: 3]; 		row: #diff.		browser transmit to: #branches; andShow: [ :a | self composeBranchesIn: a ].	browser transmit from: #branches; to: #commits; andShow: [ :a | self composeCommitsIn: a ].	self addChangesTreesTo: browser.	self addDiffTo: browser.	self addCommitInfoTo: browser! !!IceHistoryBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeCommitsIn: composite	composite fastTable		title: 'Commits';		display: #commits;		column: 'Date & time' 			evaluated: [:commit | 				commit datetime asLocalStringYMDHM asText 					in: [ :text | 						commit isLoaded 							ifTrue: [ text ] 							ifFalse: [ text allBold ] ] ] 			width: 120;		column: 'Id' evaluated: #shortId width: 50;		column: 'User' evaluated: #username width: 120;		column: 'Parents' evaluated: [ :commit | ', ' join: (commit parents collect: #shortId) ] width: 100;		column: 'Comment' evaluated: #comment width: 300;				addSelectionAction: self inspectAction;		addSelectionAction: self mergeIntoCurrentBranchAction;		addSelectionAction: self mergeIntoAction.! !!IceHistoryBrowser methodsFor: 'private accessing' stamp: ' 7/24/2017 12:50:04'!descriptionTextForBranch: aBranch repository: repo	| text |		self flag: #todo. "This is a duplication of IceRepositoryModel>>descriptionTextForBranch:. 	This can be solved by using an IceBranchModel instead the branch directly"	text := aBranch name asText.	(repo branch = aBranch)		ifTrue: [ text allBold ].			^ text! !!IceHistoryBrowser methodsFor: 'action creations' stamp: ' 7/24/2017 12:50:04'!inspectAction	^ GLMGenericAction new		action: [ :presentation | presentation selection inspect ]; 		shortcut: $i; 		title: 'Inspect'; 		yourself! !!IceHistoryBrowser methodsFor: 'action creations' stamp: ' 7/24/2017 12:50:04'!mergeIntoAction	^ GLMGenericAction new		action: [ :presentation |			self 				mergeIntoAnotherBranch: presentation selection				andThen: [					presentation selection: nil.					presentation pane browser update 				]];		icon: GLMUIThemeExtraIcons glamorousLeftSide;		shortcut: $m;		title: 'Merge into another branch...'; 		showTitle! !!IceHistoryBrowser methodsFor: 'action creations' stamp: ' 7/24/2017 12:50:04'!mergeIntoCurrentBranchAction	^ GLMGenericAction new		action: [ :presentation |			IceMergeTool new 				source: presentation selection;				targetBranch: presentation selection repository branch;				onMerge: [					presentation selection: nil.					presentation pane browser update ];				run ];		icon: GLMUIThemeExtraIcons glamorousLeftSide;		shortcut: $M;		title: 'Merge into current branch'; 		showTitle! !!IceRepositoriesBrowser class methodsFor: 'world menu' stamp: ' 7/24/2017 12:50:04'!icon	^ #komitterSmalltalkhubRemote asIcon! !!IceRepositoriesBrowser class methodsFor: 'world menu' stamp: ' 7/24/2017 12:50:04'!menuCommandOn: aBuilder 	"Add a custom menu item to the world menu"		<worldMenu> 		(aBuilder item: #'Iceberg')		order: 0.18; 		icon: self icon;  		parent: #'Tools';		keyText: 'o, i';		action: [ self open ].! !!IceRepositoriesBrowser class methodsFor: 'opening' stamp: ' 7/24/2017 12:50:04'!open	"self open"	^ self new open! !!IceRepositoriesBrowser class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ 'Iceberg repositories'! !!IceRepositoriesBrowser methodsFor: 'private utilities' stamp: ' 7/24/2017 12:50:04'!abort: message	self uiManager		abort: message		title: 'Iceberg Repositories Browser'! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!addGlobalMenu	self		act: [ 			SettingBrowser new 				changePackageSet: { (RPackageOrganizer default packageNamed: 'Iceberg') }; 				open; 				expandAll ] 		icon: #configuration asIcon		entitled: 'Global Settings'! !!IceRepositoriesBrowser methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!addLocalRepository	IceImportLocalRepositoryModel new openWithSpec! !!IceRepositoriesBrowser methodsFor: 'menu actions - repositories list' stamp: ' 7/24/2017 12:50:04'!addLocalRepositoryAction	^ GLMGenericAction new		action: [ self addLocalRepository ];		icon: #packageAdd asIcon;		shortcut: $a;		title: 'Add local repository'; showTitle! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/24/2017 12:50:04'!addPackageAction	^ GLMGenericAction new		action: [ :presentation :repo | 			self addPackageToRepository: repo repository.			presentation update ];		icon: #add asIcon;		shortcut: $a;		title: 'Add package'; showTitle! !!IceRepositoriesBrowser methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!addPackageToRepository: repo	| options descriptionBlock |		descriptionBlock := [ :wc | 		wc modified 			ifTrue: ['* ', wc packageName]			ifFalse: [ wc packageName ]].	options := MCWorkingCopy allManagers difference: repo workingCopies.	(self class chooseFrom: options displaying: descriptionBlock) 		ifNotNil: [ :workingCopy | repo addPackage: workingCopy ]! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!addRemoteAction	^ GLMGenericAction new		action: [ :presenter | 			presenter selection addRemoteThen: [ :remote | 				self announce: (IceRemoteAdded remote: remote) ] ];		selectionCondition: #isOperative;		showTitle: 'Add remote...'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!addRepositoryBranchesTo: composite	| branches |	(branches := composite fastTreeTable)		title: 'Branches';		display: [ :repository | 			| localisations |			localisations := repository remotes collect: [ :remote | IceBranchGroupModel repository: repository remote: remote ] as: OrderedCollection.			repository hasLocalBraches				ifTrue: [ localisations addFirst: (IceBranchGroupModel localFromRepository: repository) ].			localisations ];		children: #children;		column: 'Name' evaluated: #nameToDisplay;		column: 'Status' evaluated: #status;		allExpanded.	"actions"	branches addAction: self branchCreateNewAction.		"selection actions"	branches		addSelectionAction: self branchSwitchAction;		addSelectionAction: self branchCompareWithCurrentAction! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!addRepositoryInfoTo: composite	composite fastTable		title: 'General';		display: #detailedInfo;		column: 'Name' evaluated: #key width: 80;		column: 'Value' evaluated: #value! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!addRepositoryRemotesTo: composite	| remotes |		(remotes := composite fastTable)		title: 'Remotes';		display: #remotes;		column: 'Name' evaluated: [ :remote :model | model descriptionTextForRemote: remote] width: 80;		column: 'URL' evaluated: #url width: 380;		column: 'Status' evaluated: [ :remote :model | model statusForRemote: remote ];		updateOn: IceRemoteAdded from: #announcer.			"actions"	remotes addAction: self remoteAddAction.	"selection actions"	remotes 		addSelectionAction: self remoteMakePullingAction;		addSelectionAction: self remoteMakePushingAction;		addSelectionAction: self remoteFetchAction;		addSelectionAction: self remotePullAction;		addSelectionAction: self remotePushAction;		addSelectionAction: self remoteRemoveAction.	"Plugin actions"	remotes dynamicActionsOnSelection: [ :presentation | 		presentation entity pluginRemoteActionsFor: presentation selection ]! !!IceRepositoriesBrowser methodsFor: 'private utilities' stamp: ' 7/24/2017 12:50:04'!alert: message	self uiManager		abort: message		title: 'Iceberg Repositories Browser'! !!IceRepositoriesBrowser methodsFor: 'menu actions - branches' stamp: ' 7/24/2017 12:50:04'!branchCompareWithCurrentAction	^ GLMGenericAction new		action: [ :presentation :model | 			presentation selection compareCurrentToMe.			presentation pane browser update ];		enabledCondition: [ :presentation :model | (model isCurrentBranch: presentation selection branch) not ];		condition: [ :presentation | presentation selection ifNil: [ false ] ifNotNil: #isBranchModel ];		showTitle: 'Compare with current branch';		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - branches' stamp: ' 7/24/2017 12:50:04'!branchCreateNewAction	^ GLMGenericAction new		action: [ :presentation :model | 			model createNewBranchThen: [ presentation pane browser update ] ];		icon: #add asIcon;		showTitle: 'Create branch'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - branches' stamp: ' 7/24/2017 12:50:04'!branchSwitchAction	^ GLMGenericAction new		action: [ :presentation :model | 			presentation selection switchToMe.			presentation pane browser update ];		showTitle: 'Switch to this branch';		enabledCondition: [ :presentation :model | (model isCurrentBranch: presentation selection branch) not ];		condition: [ :presentation | presentation selection ifNil: [ false ] ifNotNil:  #isBranchModel ];		shortcut: $b;		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/24/2017 12:50:04'!browsePackageAction	^ GLMGenericAction new		selectionAction: #browse;		selectionCondition: #isLoaded;		showTitle: 'Browse package';		shortcut: $b;		yourself! !!IceRepositoriesBrowser methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!cloneRepository	IceCloneRepositoryModel new openWithSpec! !!IceRepositoriesBrowser methodsFor: 'menu actions - repositories list' stamp: ' 7/24/2017 12:50:04'!cloneRepositoryAction	^ GLMGenericAction new		action: [ self cloneRepository ];		icon: #add asIcon;		shortcut: $c;		title: 'Clone repository'; showTitle! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!cloneRepositoryAgainAction	^ GLMGenericAction new		selectionAction: #restore;		selectionCondition: #isMissing;		showTitle: 'Clone repository again';		shortcut: $R;		yourself! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!compose	self addGlobalMenu.	super compose! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeBrowserOn: browser	browser 		row: #repositories; 		row: #info.	browser transmit 		to: #repositories; 		andShow: [ :presentation | 			self composeRepositoriesIn: presentation ].	browser transmit 		from: #repositories; 		to: #info; 		andShow: [ :a |			(a custom: GLMWrapper new)				show: [ :wrapper | self composeRepositoryInfoIn: wrapper ];				when: [ :model | model isValid ].			(a custom: GLMWrapper new) 				show: [ :wrapper | self composeNotValidIn: wrapper ];				when: [ :model | model isValid not ] ].		! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeNotValidIn: composite	composite actionList		title: [ :repo | 'Repository {1} is invalid.' format: { repo descriptionText } ];		beVertical;		act: [ :presentation :model | 			model editRepositoryThen: [ 				"scale to top browser"				presentation pane browser pane browser update ] ] entitled: 'Edit...';		act: [ :presentation :model | 				model restore. 				presentation pane browser pane browser update ] entitled: 'Clone';		act: [ :presentation :model | 			model forgetThen: [ 				presentation pane browser pane browser update ] ] entitled: 'Forget'! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composePackagesListIn: composite	composite fastTable		title: 'Packages';		display: #savedPackages;		column: 'Name' evaluated: #nameText width: 200;		column: 'Status' evaluated: #status;		addAction: self reloadAllPackagesAction;		addAction: self addPackageAction;		addSelectionAction: self browsePackageAction;		addSelectionAction: self loadPackageAction;		addSelectionAction: self unloadPackageAction;		addSelectionAction: self reloadPackageAction;		addSelectionAction: self unloadAndRemovePackageAction;		addSelectionAction: self removePackageAction;		addSelectionAction: self removePackageFromDiskAction;		enableFilter: [ :packageModel :pattern | packageModel packageName includesSubstring: pattern caseSensitive: false ];		"Plugin actions"		dynamicActionsOnSelection: [ :presentation | 			presentation selection ifNotNil: [ 				presentation entity pluginPackageActionsFor: presentation selection entity ]];		updateOn: IceCommited from: #announcer! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeRepositories: repositories in: composite	| table |	table := composite fastTable.	table		title: 'Repositories';		display: [ self visibleRepositoryModels  ];		column: 'Name' evaluated: #descriptionText width: 200;		column: 'Current branch' evaluated: #branchName width: 120;		column: 'Loaded version' evaluated: #loadedCodeDescription width: 200;		column: 'Status' evaluated: #status width: 150.	table updateOn: IceRepositoryRegistryModified from: [ Iceberg announcer weak ].	repositories do: [ :repo | 		table updateOn: IceRepositoryAnnouncement from: repo announcer ].	table updateOn: MCPackageModified from: MCPackageManager announcer.		Iceberg announcer weak 		subscribe: IceRepositoryCreated 		send: #execute:		to: (IceRepositoryUpdateHelper for: table).	table				"Task bar menu"		addAction: self newRepositoryAction;		addAction: self cloneRepositoryAction;		addAction: self addLocalRepositoryAction;		addAction: self fetchAllRepositoriesAction;		"Repository pop up menu"		addSelectionAction: self synchronizeRepositoryAction;		addSelectionAction: self showHistoryAction;		addSelectionAction: self switchBranchAction;		addSelectionAction: self createNewBranchAction;		addSelectionAction: self addRemoteAction;		addSelectionAction: self fetchAction;		addSelectionAction: self pullAction;		addSelectionAction: self pullFromAction;		addSelectionAction: self pushAction;		addSelectionAction: self pushToAction;		addSelectionAction: self cloneRepositoryAgainAction;		addSelectionAction: self refreshRepositoryAction;		addSelectionAction: self editRepositoryAction;		addSelectionAction: self forgetRepositoryAction;		"Plugin actions"		dynamicActionsOnSelection: [ :presentation | 			presentation selection pluginActions ];		"Double click action"		onChangeOfPort: #strongSelection act: [ :presentation | 			self synchronize: presentation selection repository ]! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeRepositoriesIn: composite	| table |	table := composite fastTable.	table		title: 'Repositories';		display: [ self visibleRepositoryModels  ];		column: 'Name' evaluated: #descriptionText width: 200;		column: 'Current branch' evaluated: #branchName width: 120;		column: 'Loaded version' evaluated: #loadedCodeDescription width: 200;		column: 'Status' evaluated: #status width: 150.	table updateOn: IceRepositoryRegistryModified from: [ Iceberg announcer weak ].	self repositoryRegistry do: [ :repo | 		table updateOn: IceRepositoryAnnouncement from: repo announcer ].	table updateOn: MCPackageModified from: MCPackageManager announcer.		Iceberg announcer weak 		subscribe: IceRepositoryCreated 		send: #execute:		to: (IceRepositoryUpdateHelper for: table).	table				"Task bar menu"		addAction: self newRepositoryAction;		addAction: self cloneRepositoryAction;		addAction: self addLocalRepositoryAction;		addAction: self fetchAllRepositoriesAction;		"Repository pop up menu"		addSelectionAction: self synchronizeRepositoryAction;		addSelectionAction: self showHistoryAction;		addSelectionAction: self switchBranchAction;		addSelectionAction: self createNewBranchAction;		addSelectionAction: self addRemoteAction;		addSelectionAction: self fetchAction;		addSelectionAction: self pullAction;		addSelectionAction: self pullFromAction;		addSelectionAction: self pushAction;		addSelectionAction: self pushToAction;		addSelectionAction: self cloneRepositoryAgainAction;		addSelectionAction: self refreshRepositoryAction;		addSelectionAction: self editRepositoryAction;		addSelectionAction: self forgetRepositoryAction;		"Plugin actions"		dynamicActionsOnSelection: [ :presentation | 			presentation selection pluginActions ];		"Double click action"		onChangeOfPort: #strongSelection act: [ :presentation | 			self synchronize: presentation selection repository ]! !!IceRepositoriesBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeRepositoryInfoIn: composite	self addRepositoryInfoTo: composite.	self composePackagesListIn: composite.	self addRepositoryRemotesTo: composite.	self addRepositoryBranchesTo: composite.	! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!createNewBranchAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection createNewBranchThen: [] ];		selectionCondition: #isOperative;		showTitle: 'Create new branch...';		shortcut: $B.! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!editRepositoryAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection editRepositoryThen: [				presentation pane browser pane update ] ];		showTitle: 'Edit repository...';		shortcut: $e;		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!fetchAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection fetch.			presentation update ];		selectionCondition: #isOperative;		icon: #glamorousLeftSide asIcon;		showTitle: 'Fetch incoming comits';		yourself! !!IceRepositoriesBrowser methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!fetchAllRepositories	UIManager default informUserDuring: [ :bar |		| repositoriesCount |		repositoriesCount := IceRepository registry size.		bar max: repositoriesCount + 1.				IceRepository registry doWithIndex: [ :repository :index|			bar label: 				('Looking for incoming commigs in all repositories ({1} of {2})'					format: {index. repositoriesCount}).			bar current: index.						repository fetch.		]]	 ! !!IceRepositoriesBrowser methodsFor: 'menu actions - repositories list' stamp: ' 7/24/2017 12:50:04'!fetchAllRepositoriesAction	^ GLMGenericAction new 		action: [ self fetchAllRepositories ];		icon: #glamorousLeftSide asIcon;		shortcut: $F;		showTitle: 'Fetch all'		! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!forgetRepositoryAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection forgetThen: [ 				presentation pane browser pane update ] ];		showTitle: 'Forget repository...'; 		shortcut: $x; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!inspectRepositoryAction	^ GLMGenericAction new		selectionAction: #inspectRepository;		showTitle: 'Inspect';		shortcut: $i;		yourself! !!IceRepositoriesBrowser methodsFor: 'private testing' stamp: ' 7/24/2017 12:50:04'!isRepositoryVisible: aRepository	^ aRepository isSystemRepository not 		or: [ Iceberg showSystemRepositories ]! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/24/2017 12:50:04'!loadPackageAction	^ GLMGenericAction new		action: [ :presentation :repo | 			presentation selection loadLatest.			presentation update ]; 		icon: #add asIcon;		shortcut: $l; 		title: 'Load package'; 		condition: [ :presentation | presentation selection notNil and: [ presentation selection isLoaded not ]];		yourself! !!IceRepositoriesBrowser methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!newRepository	IceNewRepositoryModel new openWithSpec! !!IceRepositoriesBrowser methodsFor: 'menu actions - repositories list' stamp: ' 7/24/2017 12:50:04'!newRepositoryAction	^ GLMGenericAction new		action: [ :presentation | self newRepository ];		icon: #smallNew asIcon;		shortcut: $n;		title: 'New repository'; showTitle! !!IceRepositoriesBrowser methodsFor: 'scripting opening' stamp: ' 7/24/2017 12:50:04'!open	IceRepository defaultBackend 		verifyBackendAvailabilityIfNot: [ :requiredVersion :currentVersion | 			^ UIManager default 				alert: ('This version of Iceberg requires libgit2 {1} to run (you have {2}).Please update your PharoVM before continue.' format: { requiredVersion. currentVersion }) ].	self openOn: Object new! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!pullAction	^ GLMGenericAction new		selectionAction: #pull;		selectionCondition: #isOperative;		icon: GLMUIThemeExtraIcons glamorousLeftSide;		showTitle: 'Pull incoming commits'; 		shortcut: $p; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!pullFromAction	^ GLMGenericAction new		selectionAction: #pullFrom;		selectionCondition: #isOperative;		showTitle: 'Pull from...'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!pushAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection pushThen: [ presentation pane browser update ]];		selectionCondition: #canPush;		icon: #glamorousRightSide asIcon;		showTitle: 'Push outgoing commits'; 		shortcut: $P; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!pushToAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection pushToThen: [ presentation pane browser update ]];		selectionCondition: #isOperative;		"icon: GLMUIThemeExtraIcons glamorousRightSide;"		showTitle: 'Push to...';		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!refreshRepositoryAction	^ GLMGenericAction new		selectionAction: #refresh;		showTitle: 'Refresh repository';		shortcut: $r! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/24/2017 12:50:04'!reloadAllPackagesAction	^ GLMGenericAction new		action: [ :presentation :model | 			model reloadAllLoadedPackages. 			presentation update ];		condition: [ :presentation :repo | (repo entity savedPackages select: #isLoaded) notEmpty ];		icon: #refresh asIcon;		shortcut: $e;		title: 'Reload all'; showTitle! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/24/2017 12:50:04'!reloadPackageAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection reload.			presentation update ]; 		icon: #refresh asIcon;		shortcut: $r; 		title: 'Reload package'; 		condition: [ :presentation | presentation selection notNil and: [ presentation selection isLoaded ]];		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/24/2017 12:50:04'!remoteAddAction	^ GLMGenericAction new		action: [ :presentation :model | 			model addRemoteThen: [ presentation pane browser update ] ];		icon: #add asIcon;		showTitle: 'Add remote'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/24/2017 12:50:04'!remoteFetchAction	^ GLMGenericAction new		action: [ :presentation :model | 			model fetchRemote: presentation selection. 			presentation pane browser update ];		icon: #glamorousLeftSide asIcon;		showTitle: 'Fetch'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/24/2017 12:50:04'!remoteMakePullingAction	^ GLMGenericAction new		action: [ :presentation :model | 			model makePullRemote: presentation selection. 			presentation pane browser update ];		showTitle: 'Make default pull remote'; 		enabledCondition: [ :presentation :model | 			(model isPullRemote: presentation selection) not ];		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/24/2017 12:50:04'!remoteMakePushingAction	^ GLMGenericAction new		action: [ :presentation :model | 			model makePushRemote: presentation selection. 			presentation pane browser update ];		showTitle: 'Make default push remote'; 		enabledCondition: [ :presentation :model | 			(model isPushRemote: presentation selection) not ];		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/24/2017 12:50:04'!remotePullAction	^ GLMGenericAction new		action: [ :presentation :model | 			model pullRemote: presentation selection. 			presentation pane browser update ];		icon: #glamorousLeftSide asIcon;		showTitle: 'Pull'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/24/2017 12:50:04'!remotePushAction	^ GLMGenericAction new		action: [ :presentation :model | 			model pushRemote: presentation selection. 			presentation pane browser update ];		icon: #glamorousRightSide asIcon;		showTitle: 'Push'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - remotes' stamp: ' 7/24/2017 12:50:04'!remoteRemoveAction	^ GLMGenericAction new		action: [ :presentation :model | 			model 				removeRemote: presentation selection				then: [ presentation pane browser update ] ];		icon: #remove asIcon;		showTitle: 'Remove'; 		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/24/2017 12:50:04'!removePackageAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection 				removeFromDiskThen: [ presentation update ] ]; 		icon: #smallDelete asIcon;		title: 'Remove package from repository (do not unload)'; 		condition: [ :presentation | 			presentation selection notNil and: [ presentation selection isLoaded ] ];		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/24/2017 12:50:04'!removePackageFromDiskAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection 				removeFromDiskThen: [ presentation update ] ]; 		icon: #smallDelete asIcon;		title: 'Remove package from disk'; 		condition: [ :presentation | 			presentation selection notNil and: [ presentation selection isLoaded not ] ];		yourself! !!IceRepositoriesBrowser methodsFor: 'private accessing' stamp: ' 7/24/2017 12:50:04'!repositoryRegistry 	^ IceRepository registry! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!showHistoryAction	^ GLMGenericAction new		selectionAction: #browseHistory;		selectionCondition: #isOperative;		icon: #glamorousBrowse asIcon;		showTitle: 'Show history...';		shortcut: $h! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!switchBranchAction	^ GLMGenericAction new		action: [ :presentation |			presentation selection ifNotNil: [:repo | repo switchBranch ].			presentation pane browser pane update ];		enabledCondition: [ :presentation | 			presentation selection notNil ];			selectionCondition: #isOperative;		showTitle: 'Switch branch...';		shortcut: $b.! !!IceRepositoriesBrowser methodsFor: 'private utilities' stamp: ' 7/24/2017 12:50:04'!synchronize: repository	"This hack is a workaround because port #strongSelection of glamour generates multiple events for a single double-click."	(lastSynchronization isNil 		or: [ (DateAndTime current - lastSynchronization first) seconds > 1		or: [ lastSynchronization second  ~= repository ]])		ifTrue: [ 			lastSynchronization := { DateAndTime current. repository }.			IceGlamourSynchronizer synchronize: repository ]	! !!IceRepositoriesBrowser methodsFor: 'menu actions - selected repository' stamp: ' 7/24/2017 12:50:04'!synchronizeRepositoryAction	^ GLMGenericAction new		selectionAction: #synchronize;		selectionCondition: #isOperative;		icon: #glamorousBrowse asIcon;		shortcut: $s;		title: 'Synchronize repository...'; showTitle! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/24/2017 12:50:04'!unloadAndRemovePackageAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection 				unloadAndRemoveFromDiskThen: [ presentation update ] ]; 		icon: #smallDelete asIcon;		title: 'Unload & remove package from disk'; 		condition: [ :presentation | 			presentation selection notNil and: [ presentation selection isLoaded ] ];		yourself! !!IceRepositoriesBrowser methodsFor: 'menu actions - package' stamp: ' 7/24/2017 12:50:04'!unloadPackageAction	^ GLMGenericAction new		action: [ :presentation | 			presentation selection unload.			presentation update ]; 		icon: #delete asIcon;		shortcut: $u; 		title: 'Unload package'; 		condition: [ :presentation | 			presentation selection notNil and: [ presentation selection isLoaded ]];		yourself! !!IceRepositoriesBrowser methodsFor: 'private accessing' stamp: ' 7/24/2017 12:50:04'!visibleRepositoryModels	^ self repositoryRegistry 		select: [ :each | self isRepositoryVisible: each  ]		thenCollect: [ :repo | IceRepositoryModel modelFor: repo ]! !!IceTool class methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!chooseFrom: options displaying: descriptionBlock 	"Description block is used both for sorting and for displaying"		| sortedOptions index  |	sortedOptions := options asSortedCollection: [:wc1 :wc2 | (descriptionBlock value: wc1) < (descriptionBlock value: wc2) ].	index := self uiManager chooseFrom: (sortedOptions collect: descriptionBlock).	^ index > 0 		ifTrue: [ sortedOptions at: index ]		ifFalse: [ nil ]! !!IceTool class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultExtent	^ RealEstateAgent standardWindowExtent! !!IceTool class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!icon	^ #komitterSmalltalkhubRemote asIcon! !!IceTool class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ nil! !!IceTool methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!compose 	self tabulator with: [ :browser |		self configureBrowser: browser.		self composeBrowserOn: browser  ]! !!IceTool methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeBrowserOn: browser 	self subclassResponsibility! !!IceTool methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!configureBrowser: browser	"hack to add initial properties (as initialExtent) to browsers"		browser initialExtent: self initialExtent! !!IceTool methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ self class defaultExtent! !!IceTool methodsFor: 'action creators' stamp: ' 7/24/2017 12:50:04'!mergeIntoAction	^ GLMGenericAction new		action: [ :presentation |			IceMergeTool new 				source: presentation selection;				onMerge: [					presentation selection: nil.					presentation pane browser update 				];				run		];		icon: GLMUIThemeExtraIcons glamorousLeftSide;		shortcut: $m;		title: 'Merge into another branch...'; 		showTitle! !!IceTool methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ self class title! !!IceTool methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!titleIcon	^ self class icon! !!IceInteractiveCredentialsProvider class methodsFor: 'class initialization' stamp: ' 7/24/2017 12:50:04'!initialize	"self initialize"	IceCredentialsProvider providerType: self.! !!IceInteractiveCredentialsProvider methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!askForPlaintextCredentials: response	| model cancelled |		cancelled := false.	(model := IceAskForPlaintextCredentialsModel new)		openDialogWithSpec		okAction: [			| credentials | 			credentials := model credentials.			model storeCredentials 				ifTrue: [ self class plaintextCredentials: credentials ].			response readFrom: credentials.		];		cancelAction: [ cancelled := true ];		centered;		modalRelativeTo: World.	cancelled ifTrue: [ LGitNoCredentialsProvided signal ]! !!IceInteractiveCredentialsProvider methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!askForSshCredentials: response	| model cancelled |		cancelled := false.	(model := IceAskForSshCredentialsModel new)		openDialogWithSpec		okAction: [			| credentials | 			credentials := model credentials.			model storeCredentials 				ifTrue: [ self class sshCredentials: credentials ].			response readFrom: credentials ];		cancelAction: [ cancelled := true ];		centered;		modalRelativeTo: World.	cancelled ifTrue: [ LGitNoCredentialsProvided signal ]! !!IceInteractiveCredentialsProvider methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	tries := 0! !!IceInteractiveCredentialsProvider methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!providePlaintextCredentialsTo: credentials	tries := tries + 1.	tries >= 3 ifTrue: [ 		Transcript show: 'aborting'; cr.		LGitNoCredentialsProvided signal: 'There where already three failed attempts, aborting' ].		tries = 1 & self plaintextCredentials isPresent		ifTrue: [ credentials readFrom: self plaintextCredentials ]		ifFalse: [ self askForPlaintextCredentials: credentials ].! !!IceInteractiveCredentialsProvider methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!provideSshAgentCredentialsTo: credentials	"Just check for tries to ensure we do not enter an infinite cycle in libgit2"	tries := tries + 1.	tries >= 3 ifTrue: [ 		Transcript show: 'aborting'; cr.		LGitNoCredentialsProvided signal: 'No ssh-agent credentials found.' ].! !!IceInteractiveCredentialsProvider methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!provideSshCredentialsTo: credentials	tries := tries + 1.	tries >= 3 ifTrue: [ 		Transcript show: 'aborting'; cr.		LGitNoCredentialsProvided signal: 'There where already three failed attempts, aborting' ].		tries = 1 & self sshCredentials isPresent		ifTrue: [ credentials readFrom: self sshCredentials ]		ifFalse: [ self askForSshCredentials: credentials ].! !!GLMCherryPickTreeDataSource methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!cellColumn: column row: rowIndex	| item cell |	item := self elementAt: rowIndex.	cell := FTIndentedCellMorph new.	cell indentBy: item depth * 16.	cell 		addMorphBack: (self buttonFor: item);		addMorphBack: (CheckboxButtonMorph new			selected: (self isSelected: item data);			target: [ self toggleSelectionOf: item ];			actionSelector: #value;			yourself);		addMorphBack: (self createCellMorphFor: item).	^ cell! !!GLMCherryPickTreeDataSource methodsFor: 'private factory' stamp: ' 7/24/2017 12:50:04'!createCellMorphFor: item	| morph rowElements |	rowElements := OrderedCollection new.	(self iconFor: item data) ifNotNil: [ :icon | rowElements add: icon asMorph ].	rowElements		add: (self formatedDisplayValueOf: item data) asMorph asReadOnlyMorph;		addAll: (self tagMorphsFrom: self glamourPresentation for: item data).	morph := self createInnerCellMorph.	rowElements do: [ :each | morph addMorphBack: each ].	^ morph				! !!GLMCherryPickTreeDataSource methodsFor: 'private factory' stamp: ' 7/24/2017 12:50:04'!createInnerCellMorph	^ Morph new 		layoutPolicy: TableLayout new;		color: Color transparent;		hResizing: #spaceFill;		vResizing: #spaceFill;		listDirection: #leftToRight;		cellPositioning: #leftCenter;		cellInset: 5;		listCentering: #leftCenter;		wrapCentering: #leftCenter;		yourself! !!GLMCherryPickTreeDataSource methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!deselectAllChildrenOf: item	(self withAllChildrenOf: item) 		do: [ :each | selection remove: each data ifAbsent: [] ].	self tableRefresh! !!GLMCherryPickTreeDataSource methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	super initialize.	selection := Set new! !!GLMCherryPickTreeDataSource methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!isSelected: anObject	^ selection includes: anObject! !!GLMCherryPickTreeDataSource methodsFor: 'updating' stamp: ' 7/24/2017 12:50:04'!selectAll	self rootsItems do: [ :each | 		self selectAllChildrenOf: each ]! !!GLMCherryPickTreeDataSource methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!selectAllChildrenOf: item	(self withAllChildrenOf: item) 		do: [ :each | selection add: each data ]! !!GLMCherryPickTreeDataSource methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!selectAllWithChildren: aCollection	selection := Set new.	aCollection do: [ :each | self selectAllChildrenOf: each ]! !!GLMCherryPickTreeDataSource methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!selected: aCollection	selection := aCollection asSet! !!GLMCherryPickTreeDataSource methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!selection	^ selection! !!GLMCherryPickTreeDataSource methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!tableRefresh	self table ifNil: [ ^ self ].	super tableRefresh! !!GLMCherryPickTreeDataSource methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!toggleSelectionOf: item	(self isSelected: item data) 		ifTrue: [ self deselectAllChildrenOf: item ]		ifFalse: [ self selectAllChildrenOf: item ].	self glamourPresentation cherryPick: selection.	self tableRefresh! !!GLMCherryPickTreeDataSource methodsFor: 'updating' stamp: ' 7/24/2017 12:50:04'!updateSelectionWithCollectBlock: aBlock	self table ifNil: [ ^ self ].	super updateSelectionWithCollectBlock: aBlock! !!GLMCherryPickTreeDataSource methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!withAllChildrenOf: item	^ item children		inject: { item }		into: [ :all :each | all, (self withAllChildrenOf: each) ]! !!IceRemoteAdded class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!remote: aRemote	^ self new remote: aRemote! !!IceRemoteAdded methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote	^ remote! !!IceRemoteAdded methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote: anObject	remote := anObject! !!SwappedColorDiffMorph methodsFor: 'accessing colors' stamp: ' 7/24/2017 12:50:04'!additionColor	^ super removalColor! !!SwappedColorDiffMorph methodsFor: 'accessing colors' stamp: ' 7/24/2017 12:50:04'!removalColor	^ super additionColor ! !!GLMSwappedColorDiffPresentation methodsFor: 'rendering' stamp: ' 7/24/2017 12:50:04'!renderGlamorouslyOn: aRenderer 	self registerAnnouncements.	^ aRenderer renderSwappedColorDiffPresentation: self! !!MCRemoval methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!canBeBrowsed	^ false! !!MCRemoval methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!icon	^ Smalltalk ui icons iconNamed: #changeRemove! !!MCAddition methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!icon	^ Smalltalk ui icons iconNamed: #changeAdd! !!MCPatchOperation methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!canBeBrowsed	^ true! !!IceAbstractBranchModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!children	"It should return the children of my element. It will probably return the branches of a remote for the remotes and nothing for the branches."	^ self subclassResponsibility! !!IceAbstractBranchModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isBranchModel	^ false! !!IceAbstractBranchModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!nameToDisplay	^ self subclassResponsibility ! !!IceAbstractBranchModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ self subclassResponsibility! !!IceAbstractBranchModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!status	^ self subclassResponsibility! !!IceBranchGroupModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!localFromRepository: aRepository	^ self		repository: aRepository		branches: #localBranches		groupName:			('Local' asText				allBold;				yourself)! !!IceBranchGroupModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!repository: aRepository branches: aCollection groupName: aString	^ self new		repository: aRepository;		branches: aCollection;		groupName: aString;		yourself! !!IceBranchGroupModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!repository: aRepository remote: aRemote	^ self repository: aRepository branches: [ :repository | aRemote branchesFrom: repository ] groupName: aRemote asString! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branches	^ branches cull: self repository! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branches: aBlockOrSymbol	branches := aBlockOrSymbol! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!children	^ self branches collect: [ :branch | IceBranchModel parent: self branch: branch ]! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!groupName	^ groupName! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!groupName: aString	groupName := aString! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!nameToDisplay	^ self groupName! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anIceRepository	repository := anIceRepository! !!IceBranchGroupModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!status	^ self branches size asString , ' branches'! !!IceBranchModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!parent: anIceBranchGroupModel branch: anIceBranch	^ self new		parentGroup: anIceBranchGroupModel;		branch: anIceBranch;		yourself! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branch	^ branch! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branch: anIceBranch	branch := anIceBranch! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!children	^ #()! !!IceBranchModel methodsFor: 'action' stamp: ' 7/24/2017 12:50:04'!compareCurrentToMe	self repository compareCurrentBranchWithBranch: self branch! !!IceBranchModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isBranchModel	^ true! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!nameToDisplay	^ self repository descriptionTextForBranch: self branch! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!parentGroup	^ parentGroup! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!parentGroup: anIceBranchGroupModel	parentGroup := anIceBranchGroupModel! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ self parentGroup repository! !!IceBranchModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!status	| incoming outgoing allStatus |		incoming := self branch incomingCommits size.	outgoing := self branch outgoingCommits size.		allStatus := OrderedCollection new.	(incoming = 0 and: [ outgoing = 0 ]) ifTrue: [ allStatus add: 'Up to date' ].	incoming > 0 ifTrue: [ allStatus add: ('{1} incoming' format: {incoming}) ].	outgoing > 0 ifTrue: [ allStatus add: ('{1} not published' format: {outgoing}) ].	^ allStatus asCommaString! !!IceBranchModel methodsFor: 'action' stamp: ' 7/24/2017 12:50:04'!switchToMe	self repository switchBranchTo: self branch! !!IceAbstractModel class methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!clearModels	"Clear the model cache, this is needed for correct testing"	modelCache := nil.! !!IceAbstractModel class methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!compactIfNeeded	| newModelCache |	self models size > 250 ifFalse: [ ^ self ].	newModelCache := self models select: [ :each | each notNil ].	modelCache := newModelCache	! !!IceAbstractModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!modelFor: entity	| model |	"We are using WeakValueDictionary to keep this sinchronized (in case you have more than 	 one window open, you want always same model). Now, it has to be cleaned when windows are 	 no longer around, but associations will be nil... so we cannot use a simple ifAbsentPut:. 	 Yep, ugly... but effective."		model := self models at: entity name ifAbsent: [ nil ].	^ model ifNil: [ 		self compactIfNeeded.		self models 			at: entity name			put: (self basicNew 				entity: entity; 				initialize; 				yourself) ]! !!IceAbstractModel class methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!models	"since a repository can have same name as a package (and we keep models by name), 	 I need to keep this as an instance of class and not a variable (who would be 	 shared by all hierarchy and because of that prone to errors)"	^ modelCache ifNil: [ modelCache := WeakValueDictionary new ]! !!IceAbstractModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!new	self error: 'Use #modelFor:'! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!announcer	^ self entity announcer! !!IceAbstractModel methodsFor: 'highlighting' stamp: ' 7/24/2017 12:50:04'!colorError	^ Color red! !!IceAbstractModel methodsFor: 'highlighting' stamp: ' 7/24/2017 12:50:04'!colorIncoming	^ Color brown! !!IceAbstractModel methodsFor: 'highlighting' stamp: ' 7/24/2017 12:50:04'!colorModified	^ Color r: 0 g: 0.5 b: 0! !!IceAbstractModel methodsFor: 'highlighting' stamp: ' 7/24/2017 12:50:04'!colorNotLoaded	^ Color darkGray! !!IceAbstractModel methodsFor: 'highlighting' stamp: ' 7/24/2017 12:50:04'!colorOutgoing	^ Color blue! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!entity	^ entity! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!entity: anObject	entity := anObject! !!IceAbstractModel methodsFor: 'highlighting' stamp: ' 7/24/2017 12:50:04'!highlight: aString	[ 		| text modified incoming outgoing |			text := Text fromString: aString.		self repository isMissing ifTrue: [ ^ text allBold; makeAllColor: self colorError ].		self isLoaded ifFalse: [ ^ text makeAllColor: self colorNotLoaded ].		modified := entity isModified.		incoming := self incomingCommits notEmpty.		outgoing := self outgoingCommits notEmpty.		modified ifTrue: [ text prepend: '* ' ].		modified | incoming | outgoing ifTrue: [ text allBold ].		modified ifTrue: [ ^ text makeAllColor: self colorModified ].		incoming ifTrue: [ ^ text makeAllColor: self colorIncoming ].		outgoing ifTrue: [ ^ text makeAllColor: self colorOutgoing ].		^ text	]	on: Error do: [ ^ aString ]! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!incomingCommits	^ incomingCommits value! !!IceAbstractModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	"NOTE: this was before [ self entity incomingCommits ], but this is not happy 	 with weak announcements (they will remain forever)... so we change them for 	 WeakMessageSend instances to avoid problems"	incomingCommits := (IceCachedValue		for: (WeakMessageSend receiver: self entity selector: #incomingCommits))			invalidateOn: IceRepositoryAnnouncement 			from: self repository announcer weak.		outgoingCommits := (IceCachedValue		for: (WeakMessageSend receiver: self entity selector: #outgoingCommits))			invalidateOn: IceRepositoryAnnouncement 			from: self repository announcer weak! !!IceAbstractModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isLoaded	self subclassResponsibility ! !!IceAbstractModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isMissing	^ self repository isMissing! !!IceAbstractModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isOperative	^ self repository isMissing not! !!IceAbstractModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!makeError: aString	^ aString asText allBold makeAllColor: self colorError	! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!outgoingCommits	^ outgoingCommits value	! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	self subclassResponsibility! !!IceAbstractModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!status	"entity could be a repository or a package"	[		| status incoming outgoing | 		self verifyDirectoryStructureIfMissing: [ :message | ^ message ].				self isLoaded ifFalse: [ ^ 'Not loaded' ].		status := OrderedCollection new.		entity isModified ifTrue: [ status add: 'Uncommited changes' ].				incoming := self incomingCommits size.		incoming > 0 ifTrue: [ status add: ('{1} incoming' format: { incoming })].				outgoing := self outgoingCommits size.		outgoing > 0 ifTrue: [ status add: ('{1} not published' format: { outgoing })].		^ status ifEmpty: 'Up to date' ifNotEmpty: [ ', ' join: status ]	] 	on: Error do: [ :error | ^ self makeError: error description ]! !!IceAbstractModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!verifyDirectoryStructureIfMissing: aBlock	self repository isMissing 		ifTrue: [ ^ aBlock value: (self makeError: 'Local repository missing') ].	self repository isCodeMissing		ifTrue: [ ^ aBlock value: (self makeError: 'Code directory missing') ].! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!browse	^ self package browse! !!IcePackageModel methodsFor: 'highlighting' stamp: ' 7/24/2017 12:50:04'!highlight: aString	[ 		| text modified |			text := Text fromString: aString.		self repository isMissing ifTrue: [ ^ text allBold; makeAllColor: self colorError ].		self isLoaded ifFalse: [ ^ text makeAllColor: self colorNotLoaded ].		modified := entity isModified.		modified ifTrue: [ text prepend: '* ' ].		modified ifTrue: [ text allBold ].		modified ifTrue: [ ^ text makeAllColor: self colorModified ].		^ text	]	on: Error do: [ ^ aString ]! !!IcePackageModel methodsFor: 'acessing' stamp: ' 7/24/2017 12:50:04'!isLoaded	^ self package isLoaded! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!loadLatest	self package loadLatest! !!IcePackageModel methodsFor: 'acessing' stamp: ' 7/24/2017 12:50:04'!nameText	^ self highlight: self packageName! !!IcePackageModel methodsFor: 'acessing' stamp: ' 7/24/2017 12:50:04'!package	^ entity! !!IcePackageModel methodsFor: 'acessing' stamp: ' 7/24/2017 12:50:04'!packageName	^ self package name! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!reload	self package reload! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!removeFromDisk	self entity removeFromDisk! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!removeFromDiskThen: aBlock	(UIManager default confirm: ('You are going to remove package {1} from disk. Are you sure?' format: { self entity name }))		ifFalse: [ ^ self ].	self entity removeFromDisk: true.	aBlock value! !!IcePackageModel methodsFor: 'acessing' stamp: ' 7/24/2017 12:50:04'!repository	^ self entity repository! !!IcePackageModel methodsFor: 'acessing' stamp: ' 7/24/2017 12:50:04'!status	"entity could be a repository or a package"	[		| status | 		self repository isMissing ifTrue: [ ^ 'Local repository missing' asText allBold makeAllColor: self colorError ].		self isLoaded ifFalse: [ ^ 'Not loaded' ].		status := OrderedCollection new.		entity isModified ifTrue: [ status add: 'Uncommited changes' ].				^ status 			ifNotEmpty: [ status asCommaString ]			ifEmpty: [ 'Up to date' ] ] 	on: Error do: [ :error | ^ error description asText makeAllColor: self colorError ]! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!unload	self package unload! !!IcePackageModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!unloadAndRemoveFromDiskThen: aBlock	self unload.	self removeFromDiskThen: [].	aBlock value! !!IceRepositoryModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!registry	^ IceRepository registry collect: [ :repository | self modelFor: repository ]! !!IceRepositoryModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!tagDefaultPull	^ 'Pull'! !!IceRepositoryModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!tagDefaultPush	^ 'Push'! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/24/2017 12:50:04'!addRemoteThen: aBlock	IceRemoteModel new 		setModal: true;		repository: self repository;		onAccept: [ :remote |			self repository addRemote: remote. 			aBlock cull: remote ];		openWithSpec! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branchName	^ self repository branch name! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branches	^ self repository allBranches! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!browseHistory	IceHistoryBrowser openOn: self repository! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!canPush	[ 		^ self isOperative 			and: [ self outgoingCommits notEmpty 			and: [ self incomingCommits isEmpty ] ]	]	on: Error do: [ ^ false ]! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!compareCurrentBranchWithBranch: aBranch	IceBranchBrowser openOn: aBranch! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!createNewBranchThen: aBlock	| selection |	selection := UIManager default		request: 'Please provide the name of the new branch to be created'		initialAnswer: ''		title: 'Create new branch'.	selection ifNotNil: [ 		selection 			ifEmpty: [ 				UIManager default 					abort: 'Branch name can not be empty.' 					title: 'Create new branch'. ]			ifNotEmpty: [ 				self repository createBranch: selection.				aBlock cull: self repository branch ] ]! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!descriptionText	^ self highlight: self repository name! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!descriptionTextForBranch: aBranch	^ aBranch isRemote		ifTrue: [ aBranch basename ]		ifFalse: [ | text |			text := aBranch name asText.			(self isCurrentBranch: aBranch)				ifTrue: [ text allBold ].			text ]! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!descriptionTextForRemote: aRemote	^ aRemote remoteName! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!detailedInfo	^ 	self repository origin detailedInfo, { 		'Location' -> self repository location pathString. 		'Pulling from' -> (self repository pullRemote 			ifNotNil: [ :r | r remoteName ]			ifNil: [ self repository origin remoteName ]). 		'Pushing to' -> (self repository pushRemote 			ifNotNil: [ :r | r remoteName ]			ifNil: [ self repository origin remoteName ]).		'On branch' -> self repository branchName.	} ! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!editRepositoryThen: aBlock	(IceEditRepositoryModel repository: self repository) 		onAccept: aBlock;		openWithSpec! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!fetch	^ self repository fetch! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/24/2017 12:50:04'!fetchRemote: aRemote 	self repository fetchFrom: aRemote! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!forgetThen: aBlock	(UIManager default confirm:			('Are you sure to remove repository: {1}?(Packages will not be deleted, nor the repository from the file system)'				format: { self repository origin url })		label: 'Removing Iceberg Repository')	ifTrue: [ 		self repository forget.		aBlock cull: self ]! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!hasLocalBraches	^ self repository hasLocalBraches! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!inspectRepository	self repository inspect! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isCurrentBranch: aBranch	^ self repository branch = aBranch! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isLoaded	^ self repository loadedPackages isNotEmpty ! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isPullRemote: aRemote	^ self repository isPullRemote: aRemote! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isPushRemote: aRemote	^ self repository isPushRemote: aRemote! !!IceRepositoryModel methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isValid	^ self repository isValid! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!loadedCodeDescription	self verifyDirectoryStructureIfMissing: [ :message | ^ message ].	^ self repository loadedCode description! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!localBranches	^ self repository localBranches! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/24/2017 12:50:04'!makePullRemote: aRemote	self repository pullRemote: aRemote! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/24/2017 12:50:04'!makePushRemote: aRemote	self repository pushRemote: aRemote! !!IceRepositoryModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!pickBranch 	| branches |	 	branches := self repository branchesForCheckout.	^ UIManager default		chooseFrom: (branches collect: #name)		values: branches		message: 'Select the new branch you want to switch to:' 		title: 'Checkout branch'! !!IceRepositoryModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!pickRemote: aTitle	| remotes |	 	remotes := self repository remotes.	^ UIManager default		chooseFrom: (remotes collect: #remoteName)		values: remotes		message: 'Select the remote you want to use:' 		title: aTitle! !!IceRepositoryModel methodsFor: 'accessing plugins' stamp: ' 7/24/2017 12:50:04'!pluginActions	^ self repository pluginManager repositoryActions! !!IceRepositoryModel methodsFor: 'accessing plugins' stamp: ' 7/24/2017 12:50:04'!pluginPackageActionsFor: icePackage	^ self repository pluginManager packageActionsFor: icePackage! !!IceRepositoryModel methodsFor: 'accessing plugins' stamp: ' 7/24/2017 12:50:04'!pluginRemoteActionsFor: aRemote	^ self repository pluginManager remoteActionsFor: aRemote! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!pull	self validateCanPull ifFalse: [ ^ self ].	self repository pull! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!pullFrom	| remote |	self validateCanPull ifFalse: [ ^ self ].	remote := self pickRemote: 'Pull from'.	remote ifNil: [ ^ self ].	self repository pullFrom: remote.! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/24/2017 12:50:04'!pullRemote: aRemote	self repository pullFrom: aRemote! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/24/2017 12:50:04'!pushRemote: aRemote	self repository pushTo: aRemote! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!pushThen: aBlock	self 		pushTo: self repository pushRemote 		then: aBlock! !!IceRepositoryModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!pushTo: aRemote then: aBlock	"We need an existing remote as premise to do the push (new repositories can have this 	 situation)"	aRemote ifNil: [ 		^ UIManager default			abort: 'There is no remote to publish, please add one (in "remotes" tab).'			title: 'Publishing aborted' ].	[ 		UIManager default informUserDuring: [ :bar | 			bar label: ('Publishing local commits to {1}' format: { aRemote url }).			self repository pushTo: aRemote. 			aBlock value ] ] 	on: YouShouldPullBeforePush	do: [ 		UIManager default			abort: 'Publish operation is not possible because your repository is out of date. Please update your local repository and retry.'			title: 'Publishing aborted' ]! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!pushToThen: aBlock	| remote |	remote := self pickRemote: 'Push to'.	remote ifNil: [ ^ self ].	self pushTo: remote then: aBlock! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!refresh	self repository refresh! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!reloadAllLoadedPackages	self repository savedPackages 		select: #isLoaded 		thenDo: [ :each | each reload ].! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remotes	^ self repository remotes! !!IceRepositoryModel methodsFor: 'actions remotes' stamp: ' 7/24/2017 12:50:04'!removeRemote: aRemote then: aBlock	(self confirm: (('You are going to remove remote {1}. Are you sure?') format: {aRemote}))		ifFalse: [ ^ self ].	self repository removeRemote: aRemote.	aBlock cull: aRemote! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ self entity! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!restore	self repository backend cloneRepository.	self repository refresh.! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!savedPackages	^ [self repository savedPackages collect: [ :package | IcePackageModel modelFor: package ]]		on: Error do: [ :error | 			self inform: ('Error computing saved packages for repository: {1}. {2}'				format: { self repository name. error }).			#()		]! !!IceRepositoryModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!shouldCreateLocalBranchFromRemote 	^ UIManager default		confirm: 'You are trying to switch to a remote branch.' , String cr , 			'Do you want to create a local branch for it?' , String cr ,			'Note: if you do not create a local branch, you will be in a detached head and you won''t be abe to commit code!!'		label: 'Checkout remote branch'! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!statusForRemote: aRemote	| incoming outgoing allStatus |		incoming := (self repository incomingCommitsFrom: aRemote) size.	outgoing := (self repository outgoingCommitsTo: aRemote) size.		allStatus := OrderedCollection new.	(incoming = 0 and: [ outgoing = 0 ]) ifTrue: [ allStatus add: 'Up to date' ].	incoming > 0 ifTrue: [ allStatus add: ('{1} incoming' format: {incoming}) ].	outgoing > 0 ifTrue: [ allStatus add: ('{1} not published' format: {outgoing}) ].	^ ((self tagsForRemote: aRemote), allStatus) asCommaString! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!switchBranch	| branch |	branch := self pickBranch.	branch ifNil: [ ^ self ].	self switchBranchTo: branch! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!switchBranchTo: branch	branch isRemote		ifTrue: [ self repository localBranches 				detect: [:aBranch | aBranch name = branch basename ]				ifFound: [ UIManager default inform: 'Cannot switch to this branch. A local branch with the same name already exists!!'.								self flag: 'We should probably go into detached head state.' ]				ifNone: [ self shouldCreateLocalBranchFromRemote 					ifTrue: [ self repository backend withRepoDo: [ :repo | repo createBranchFromOrigin: branch basename ].								self repository checkoutBranch: branch basename ]					ifFalse: [ self shouldBeImplemented ] ] ]		ifFalse: [ self repository checkoutBranch: branch basename ]! !!IceRepositoryModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!synchronize	IceGlamourSynchronizer synchronize: self repository! !!IceRepositoryModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!tagsForRemote: aRemote	| tags |		tags := OrderedCollection new.	(self isPushRemote: aRemote) ifTrue: [ tags add: self class tagDefaultPush ]. 	(self isPullRemote: aRemote) ifTrue: [ tags add: self class tagDefaultPull ]. 		^ tags asArray! !!IceRepositoryModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!validateCanPull	self repository isModified		ifTrue: [ 			^ IceTool uiManager				confirm:					'Your repository has uncommited changes. Merging incoming commits will changeyour current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.'				label: 'You might loose your current changes!!'				trueChoice: 'Proceed anyway'				falseChoice: 'Cancel'				cancelChoice: nil				default: false ].	^ true! !!IceCachedValue class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!for: aBlock	^ self new updateAction: aBlock! !!IceCachedValue class methodsFor: 'settings' stamp: ' 7/24/2017 12:50:04'!timeout	^ 30 seconds! !!IceCachedValue methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	updating := false! !!IceCachedValue methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!invalidateOn: announcementType from: announcer	announcer subscribe: announcementType send: #reset to: self! !!IceCachedValue methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!isValid	^ lastUpdated isNotNil and: [ (DateAndTime current - lastUpdated) < self class timeout ]! !!IceCachedValue methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!reset	lastUpdated := nil! !!IceCachedValue methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!updateAction: anObject	updateAction := anObject! !!IceCachedValue methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!value	self isValid ifTrue: [ ^ value ].	updating ifTrue: [ ^ 'Loading...' asText allItalic ].	[ 		updating := true.		value := updateAction value.		lastUpdated := DateAndTime current.		^ value	]	ensure: [ updating := false ]! !!IceChangesTreeResetSelectionHelper class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!for: aPresentation	^ self new 		presentation: aPresentation;		yourself! !!IceChangesTreeResetSelectionHelper methodsFor: 'executing' stamp: ' 7/24/2017 12:50:04'!execute: ann	self presentation selection: nil! !!IceChangesTreeResetSelectionHelper methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!presentation	^ presentation! !!IceChangesTreeResetSelectionHelper methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!presentation: anObject	presentation := anObject! !!IceDiffChangeTreeBuilder methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!browseAction	^ GLMGenericAction new		action: [ :presentation | presentation selection browse ];		condition: [ :presentation :entity | 			presentation selection notNil 				and: [ presentation selection canBeBrowsed ]];		icon: #nautilus asIcon;		shortcut: $b;		title: 'Browse'; 		showTitle! !!IceDiffChangeTreeBuilder methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!browseReferencesAction	^ GLMGenericAction new		action: [ :presentation | presentation selection browseReferences ];		condition: [ :presentation | 			presentation selection notNil 				and: [ presentation selection canBrowseReferences ]];		shortcut: $n;		title: 'Browse references'; 		showTitle! !!IceDiffChangeTreeBuilder methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!buildOn: aPresenter	^ aPresenter fastTree		allExpanded;		children: #elements;		icon: #icon;		format: #description;		display: [ self elements ];		updateOn: IceChangeSetChanged from: #announcer;		addAction: self refreshTreeAction;		addSelectionAction: self browseAction;		addSelectionAction: self browseReferencesAction;		addSelectionAction: self revertChangeAction;		onChangeOfPort: #entity act: [ :presentation | 			self diff ifNotNil: [  				self diff announcer 					subscribe: IceChangeSetChanged 					send: #execute:					to: (IceChangesTreeResetSelectionHelper for: presentation) ] ];		yourself! !!IceDiffChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!diff	^ diff! !!IceDiffChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!diff: anObject	diff := anObject! !!IceDiffChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!elements 	^ self diff elements select: #hasChanges! !!IceDiffChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!entity	^ entity ifNil: [ self diff ]! !!IceDiffChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!entity: anObject	entity := anObject! !!IceDiffChangeTreeBuilder methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!refreshTreeAction	^ GLMGenericAction new		action: [ self entity refresh ];		icon: #glamorousRefresh asIcon;		shortcut: $r;		title: 'Refresh tree'; showTitle! !!IceDiffChangeTreeBuilder methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!revertChangeAction	^ GLMGenericAction new		action: [ :presentation | self entity revertChange: presentation selection ];		condition: [ self entity canRevertChanges ];		icon: #glamorousUndo asIcon;		title: 'Revert change'; 		showTitle! !!IceDiffCherryPickChangeTreeBuilder methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!buildOn: aPresenter	^ aPresenter cherryPickTree		allExpanded;		children: #elements;		icon: #icon;		format: #description;		display: [ self elements ];		allSelected;		onChangeOfCherryPick: [ :presentation | self selectedCherryPick: presentation cherryPick ];		updateOn: IceChangeSetChanged from: #announcer;		addAction: self refreshTreeAction;		addSelectionAction: self browseAction;		addSelectionAction: self browseReferencesAction;		addSelectionAction: self revertChangeAction;		onChangeOfPort: #entity act: [ :presentation | 			self diff ifNotNil: [				self diff announcer 					subscribe: IceChangeSetChanged					send: #execute:					to: (IceChangesTreeResetSelectionHelper for: presentation) ] ];		yourself! !!IceDiffCherryPickChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!onSelectCherryPick: aBlock	cherryPickBlock := aBlock! !!IceDiffCherryPickChangeTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!selectedCherryPick: aSet	cherryPickBlock ifNil: [ ^ self ].	cherryPickBlock value: aSet! !!IceMergeTool methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!chooseTargetBranch	| branches |		self targetBranch ifNotNil: [ ^ self targetBranch ].		branches := self repository branchesForMerge: self source.	^ targetBranch := self uiManager		chooseFrom: (branches collect: #name)		values: branches		message: ('Select the branch into you want to merge commit {1}' format: { source shortId })		title: 'Merge your changes into another branch'.! !!IceMergeTool methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!confirmContinueWithDirtyRepository	^ self uiManager		confirm:'Your repository has uncommited changes. Merge will change your current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.'		label: 'You might loose your current changes!!'		trueChoice: 'Proceed anyway'		falseChoice: 'Cancel'		cancelChoice: nil		default: false! !!IceMergeTool methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!informAutomaticMergeImpossible	self uiManager		abort: 'Automatic merge is not possible, to merge manually please first checkout branch ', self targetBranch name, ' and then retry.' 		title: 'Automatic merge impossible'! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!onMerge	^ onMerge! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!onMerge: anObject	onMerge := anObject! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository ifNil: [ repository := self source repository ]! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	^ repository := anObject! !!IceMergeTool methodsFor: 'merging' stamp: ' 7/24/2017 12:50:04'!run	"Merge selected commit into another branch"	self repository isModified ifTrue: [ 		self confirmContinueWithDirtyRepository ifFalse: [ ^ self ]].	self chooseTargetBranch ifNil: [ ^ self ].	[ source mergeInto: self targetBranch ]		on: IceMergeAborted		do: [ 			self targetBranch name = repository branchName 				ifTrue: [ repository mergeConflictsWith: source ]				ifFalse: [ self informAutomaticMergeImpossible. ^ self ]].	self onMerge value ! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!source	^ source! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!source: anObject	source := anObject! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!targetBranch	^ targetBranch! !!IceMergeTool methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!targetBranch: anObject	targetBranch := anObject! !!IceRepositoryUpdateHelper class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!for: aPresentation	^ self new 		presentation: aPresentation;		yourself! !!IceRepositoryUpdateHelper methodsFor: 'executing' stamp: ' 7/24/2017 12:50:04'!execute: ann	self presentation		updateOn: IceRepositoryAnnouncement 		from: [ ann repository announcer weak ]! !!IceRepositoryUpdateHelper methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!presentation	^ presentation! !!IceRepositoryUpdateHelper methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!presentation: anObject	presentation := anObject! !!PharoShortcuts methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!openIcebergShortcut	^ $o meta, $i meta! !!Text methodsFor: '*Iceberg-UI' stamp: ' 7/24/2017 12:50:04'!allItalic	"Force this whole text to be italic."	string isEmpty ifTrue: [ ^ self ].	^ self addAttribute: TextEmphasis italic from: 1 to: string size.! !!GLMMorphicSwappedColorDiffRenderer methodsFor: 'rendering' stamp: ' 7/24/2017 12:50:04'!render: aPresentation	| textMorph |	textMorph := (SwappedColorDiffMorph		from: aPresentation displayValue first		to: aPresentation displayValue last		contextClass: aPresentation contextClassValue)			layoutFrame: (LayoutFrame identity);			vResizing: #spaceFill;			hResizing: #spaceFill;			yourself.	^textMorph! !!Trait method!uiManager	^ UIManager default! !!Trait method!uiManager	^ UIManager default! !!Trait method!uiManager	^ UIManager default! !!Trait method!mergeIntoAnotherBranch: aCommit andThen: aBlock	"Merge selected commit into another branch"	| branches selection repository |	repository := aCommit repository.		repository isModified ifTrue: [ 		(self uiManager			confirm:'Your repository has uncommited changes. Merge will change your current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.'			label: 'You might loose your current changes!!'			trueChoice: 'Proceed anyway'			falseChoice: 'Cancel'			cancelChoice: nil			default: false) 			ifFalse: [ ^ self ].	 ].		branches := repository branchesForMerge: aCommit.	selection := self uiManager		chooseFrom: (branches collect: #name)		values: branches		message: ('Select the branch into you want to merge commit {1}' format: { aCommit shortId })		title: 'Merge your changes into another branch'.	selection ifNotNil: [ 		[ aCommit mergeInto: selection ]			on: IceMergeAborted			do: [ 				selection name = repository branchName 					ifTrue: [ repository mergeConflictsWith: aCommit ]					ifFalse: [ 						self uiManager 						abort: 'Automatic (fast-forward) merge is not possible, to merge manually please first checkout branch ', selection name, ' and then retry.' 						title: 'Automatic merge failed' ]			].		aBlock value 	]! !!Trait method!mergeIntoAnotherBranch: aCommit andThen: aBlock	"Merge selected commit into another branch"	| branches selection repository |	repository := aCommit repository.		repository isModified ifTrue: [ 		(self uiManager			confirm:'Your repository has uncommited changes. Merge will change your current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.'			label: 'You might loose your current changes!!'			trueChoice: 'Proceed anyway'			falseChoice: 'Cancel'			cancelChoice: nil			default: false) 			ifFalse: [ ^ self ].	 ].		branches := repository branchesForMerge: aCommit.	selection := self uiManager		chooseFrom: (branches collect: #name)		values: branches		message: ('Select the branch into you want to merge commit {1}' format: { aCommit shortId })		title: 'Merge your changes into another branch'.	selection ifNotNil: [ 		[ aCommit mergeInto: selection ]			on: IceMergeAborted			do: [ 				selection name = repository branchName 					ifTrue: [ repository mergeConflictsWith: aCommit ]					ifFalse: [ 						self uiManager 						abort: 'Automatic (fast-forward) merge is not possible, to merge manually please first checkout branch ', selection name, ' and then retry.' 						title: 'Automatic merge failed' ]			].		aBlock value 	]! !!Trait method!mergeIntoAnotherBranch: aCommit andThen: aBlock	"Merge selected commit into another branch"	| branches selection repository |	repository := aCommit repository.		repository isModified ifTrue: [ 		(self uiManager			confirm:'Your repository has uncommited changes. Merge will change your current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.'			label: 'You might loose your current changes!!'			trueChoice: 'Proceed anyway'			falseChoice: 'Cancel'			cancelChoice: nil			default: false) 			ifFalse: [ ^ self ].	 ].		branches := repository branchesForMerge: aCommit.	selection := self uiManager		chooseFrom: (branches collect: #name)		values: branches		message: ('Select the branch into you want to merge commit {1}' format: { aCommit shortId })		title: 'Merge your changes into another branch'.	selection ifNotNil: [ 		[ aCommit mergeInto: selection ]			on: IceMergeAborted			do: [ 				selection name = repository branchName 					ifTrue: [ repository mergeConflictsWith: aCommit ]					ifFalse: [ 						self uiManager 						abort: 'Automatic (fast-forward) merge is not possible, to merge manually please first checkout branch ', selection name, ' and then retry.' 						title: 'Automatic merge failed' ]			].		aBlock value 	]! !!Trait method!pushRepository: repository andThen: aBlock	[ UIManager default informUserDuring: [ :bar | | remote |		remote := repository pushRemote.		bar label: ('Publishing local commits to {1}' format: {remote}).		repository pushTo: remote. 		aBlock value.	]] 	on: YouShouldPullBeforePush	do: [ 		self uiManager			abort: 'Publish operation is not possible because your repository is out of date. Please update your local repository and retry.'			title: 'Publishing aborted' 	]! !!Trait method!pushRepository: repository andThen: aBlock	[ UIManager default informUserDuring: [ :bar | | remote |		remote := repository pushRemote.		bar label: ('Publishing local commits to {1}' format: {remote}).		repository pushTo: remote. 		aBlock value.	]] 	on: YouShouldPullBeforePush	do: [ 		self uiManager			abort: 'Publish operation is not possible because your repository is out of date. Please update your local repository and retry.'			title: 'Publishing aborted' 	]! !!Trait method!pushRepository: repository andThen: aBlock	[ UIManager default informUserDuring: [ :bar | | remote |		remote := repository pushRemote.		bar label: ('Publishing local commits to {1}' format: {remote}).		repository pushTo: remote. 		aBlock value.	]] 	on: YouShouldPullBeforePush	do: [ 		self uiManager			abort: 'Publish operation is not possible because your repository is out of date. Please update your local repository and retry.'			title: 'Publishing aborted' 	]! !!Trait method!uiManager	^ self class uiManager! !!Trait method!uiManager	^ self class uiManager! !!Trait method!uiManager	^ self class uiManager! !"Iceberg-UI"!!IceGitHubPullRequestBrowser commentStamp: '<historical>' prior: 0!I'm a browser to show a pull request in detailt. Since a PR is not much more than a branch, I extend the branch browser :)!!IceGitHubPullRequestListBrowser commentStamp: '<historical>' prior: 0!I'm a browser to show all open pull requests in a repository.!!IceGitHubError commentStamp: 'EstebanLorenzano 2/1/2017 17:15' prior: 0!I'm an error that happens when something fails when performing a GitHub action.!!IceGitHubBadCredentialsError commentStamp: '<historical>' prior: 0!I'm an error that happens when credentials are bad.!!IceGitHubGenericError commentStamp: '<historical>' prior: 0!I'm an error that happens when something went wrong on GitHub API operations.!!IceGitHubJSONDataSource commentStamp: '<historical>' prior: 0!I'm a generic datasource to show in a table results of a JSON. I'm intended to be used to show information from GitHub API, but I'm generic enough to be used which any kind of JSON structure.!!IceGitHubPullRequestDataSource commentStamp: '<historical>' prior: 0!I'm a datasource for pull request status, to be used when showing pull requests details. See IceGitHubPullRequestDetailModel!!IceGitHubAcceptPullRequestModel commentStamp: '<historical>' prior: 0!I'm a dialog for collecting data to accept a pull request.!!IceGitHubCreatePullRequestModel commentStamp: '<historical>' prior: 0!I'm a dialog to ask for data relevant to create a pull request.!!IceGitHubPullRequestActionsModel commentStamp: '<historical>' prior: 0!I'm an actions toolbar, to be used with IceGitHubPullRequestBrowser.!!IceGitHubPullRequestDetailModel commentStamp: '<historical>' prior: 0!I'm a spec model to present a detailed view of a Pull Request.!!IceGitHubRejectPullRequestModel commentStamp: '<historical>' prior: 0!I'm a dialog to collect data about a pull request rejection.!!IceGitHubSelectListModel commentStamp: '<historical>' prior: 0!I'm a dialog to select a list of anything (used by branches now).!!IceGitHubAPI commentStamp: '<historical>' prior: 0!I represent an access point to the GitHub API. I provide different high level abstractions to interact with GitHub, following the speciphications you can find here: https://developer.github.com/v3/!!IceGitHubAPIPaginatedResult commentStamp: '<historical>' prior: 0!I'm a paginated answer from github (he sends results in pages and includes information in headers)!!IceGitHubCommand commentStamp: '<historical>' prior: 0!I'm a generic command to perform plugin actions for GitHub.My children define the real behavior, and they need to implement #execute.!!IceGitHubNewPullRequestCommand commentStamp: '<historical>' prior: 0!I'm a command to create a Pull Request!!IceGitHubRemoveBranchesCommand commentStamp: '<historical>' prior: 0!I'm a command to remove branches from remotes.!!IceGitHubViewPullRequestCommand commentStamp: '<historical>' prior: 0!I'm a command to show the pull request review browser.!!IceGitHubPullRequest commentStamp: '<historical>' prior: 0!I'm a pull request from github API. I represent (more or less), what is described here: https://developer.github.com/v3/pulls/#list-pull-requests!!IceGitHubPullRequestDefinition commentStamp: '<historical>' prior: 0!I am a pull request. I can be sent using ==#sendWithCredentials:== protocol.!!IceGitHubSelectItem commentStamp: '<historical>' prior: 0!I'm a helper to keep selected items in a list.!!IceGitHubPullRequestPlugin commentStamp: '<historical>' prior: 0!I define the plugin GitHub - Pull Request!!IceGitHubPullRequestBrowser methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!acceptPullRequest	IceGitHubAcceptPullRequestModel new 		onAccept: [ :model | 			self pullRequest 				acceptMessage: model message 				type: model type ];		openWithSpec	! !!IceGitHubPullRequestBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!addChangesTreeTo: a with: commitInfo	(IceDiffChangeTreeBuilder new		entity: commitInfo;		diff: (commitInfo ifNotNil: [ 			commitInfo diffTo: (self mergeBaseCommitFor: commitInfo) ]);		buildOn: a)		title: 'Changes vs. destination' .	super addChangesTreeTo: a with: commitInfo! !!IceGitHubPullRequestBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!baseSHA	^ self pullRequest baseSHA! !!IceGitHubPullRequestBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!composeBrowserOn: browser	browser 		row: [:row | 			row 				column: #commits; 				column: #changes ]; 		row: #diff;		row: #actions size: 35.		browser transmit to: #commits; andShow: [ :a | self composeCommitsIn: a ].	self addChangesTreesTo: browser.	self addDiffTo: browser.	self addCommitInfoTo: browser.		browser transmit to: #actions; andShow: [ :a | 		a morph			morph: [ 				IceGitHubPullRequestActionsModel new 					onMerge: [ self mergePullRequestIntoImage ];					onAccept: [ self acceptPullRequest ];					onReject: [ self rejectPullRequest ];					buildWithSpec ] ]! !!IceGitHubPullRequestBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!mergeBaseCommitFor: commitInfo	^ commitInfo repository commitAt: (self mergeBaseFor: commitInfo)! !!IceGitHubPullRequestBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!mergeBaseFor: commitInfo	^ commitInfo repository		mergeBaseBetween: commitInfo commitId 		and: self baseSHA! !!IceGitHubPullRequestBrowser methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!mergePullRequestIntoImage	(UIManager default confirm: ('I will create a new local branch named {1}. Should I continue?' format: { self pullRequest branchName }))	ifFalse: [ ^ self ].	self pullRequest mergeIntoImage! !!IceGitHubPullRequestBrowser methodsFor: 'scripting opening' stamp: ' 7/24/2017 12:50:04'!open	self openOn: self pullRequest branch! !!IceGitHubPullRequestBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!pullRequest	^ pullRequest! !!IceGitHubPullRequestBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!pullRequest: anObject	pullRequest := anObject! !!IceGitHubPullRequestBrowser methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!rejectPullRequest	IceGitHubRejectPullRequestModel new 		onAccept: [ :model | 			self pullRequest 				rejectMessage: model message  ];		openWithSpec! !!IceGitHubPullRequestBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ 'Browsing pull request: #{1} {2}' format: { self pullRequest number. self pullRequest title  }! !!IceGitHubPullRequestListBrowser class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultExtent	^ 700@700! !!IceGitHubPullRequestListBrowser class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!icon	^ #komitterSmalltalkhubRemote asIcon! !!IceGitHubPullRequestListBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!buildOn: browser	browser 		row: #pullRequests;		row: #detail span: 2.			browser transmit to: #pullRequests; andShow: [ :a |		a fastTable 			title: 'Open pull requests';			addAction: self refreshAction;			selectionAct: [ :presentation | 				self viewPullRequest: presentation selection ] 				entitled: 'Review pull request...';			onChangeOfPort: #strongSelection act: [ :presentation | 				self viewPullRequest: presentation selection ];			column: '#' evaluated: #number width: 50;			column: 'State' evaluated: #state width: 50;			column: 'Author' evaluated: #author width: 120;			column: 'Title' evaluated: #title ].			browser transmit from: #pullRequests; to: #detail; andShow: [ :a |		a morph 			title: [ :pr | '#{1} {2}' format: {pr number. pr title} ];			morph: [ :presentation :pr | (IceGitHubPullRequestDetailModel for: pr) buildWithSpec ] ]! !!IceGitHubPullRequestListBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!compose	self tabulator with: [ :browser |		browser initialExtent: self initialExtent.		self buildOn: browser ]! !!IceGitHubPullRequestListBrowser methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!fetchPullRequests	^ (IceGitHubAPI new		getPullRequests: self remote owner project: self remote projectName) all		collect: [ :each | 			(IceGitHubPullRequest fromJSON: each)				repository: self repository;				yourself ]! !!IceGitHubPullRequestListBrowser methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ self class defaultExtent! !!IceGitHubPullRequestListBrowser methodsFor: 'scripting opening' stamp: ' 7/24/2017 12:50:04'!open	^ self openOn: self pullRequests! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!pullRequests	^ pullRequests! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!pullRequests: anObject	pullRequests := anObject! !!IceGitHubPullRequestListBrowser methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!refreshAction	^ GLMGenericAction new		action: [ :presentation |			UIManager default				informUser: 'Refreshing pull request list' 				during: [ self refreshPullRequests ].			presentation update ];		icon: #refresh asIcon;		title: 'Refresh'; 		showTitle! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!refreshPullRequests	self pullRequests: self fetchPullRequests! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote	^ remote! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote: anObject	remote := anObject! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ 'Pull requests on {1} ({2})' format: { self remote remoteName. self remote url }! !!IceGitHubPullRequestListBrowser methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!titleIcon	^ self class icon! !!IceGitHubPullRequestListBrowser methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!viewPullRequest: aPullRequest	UIManager default 		informUser: ('Opening pull request {1} {2}' format: { aPullRequest number. aPullRequest title })		during: [  			IceGitHubPullRequestBrowser new 			pullRequest: aPullRequest;			open ]! !!IceGitHubBadCredentialsError class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isAppropriateFor: aResponse 	^ aResponse status = 401! !!IceGitHubBadCredentialsError methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!messageBody	^ 'Credentials provided are wrong'! !!IceGitHubError class methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!errorClassFor: aResponse	^ self allSubclasses 		detect: [ :each | each isAppropriateFor: aResponse  ]		ifNone: [ self ]! !!IceGitHubError class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!for: aResponse	^ (self errorClassFor: aResponse) new 		response: aResponse;		yourself	! !!IceGitHubError class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isAppropriateFor: aResponse	^ false! !!IceGitHubError class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!signalFor: aResponse	^ (self for: aResponse) signal! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!code	^ self response status! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!contents	^ self response contents! !!IceGitHubError methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!customError: aDictionary	^ aDictionary at: #message		! !!IceGitHubError methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!errorToString: aDictionary 	(aDictionary at: #code) = 'custom' ifTrue: [ ^ self customError: aDictionary ].	(aDictionary at: #code) = 'invalid' ifTrue: [ ^ self invalidError: aDictionary ].		^ self unknownError: aDictionary	! !!IceGitHubError methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!invalidError: aDictionary	^ 'Invalid field: ', (aDictionary at: #field)			! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!jsonContents	^ jsonContents ifNil: [ jsonContents := STON fromString: self contents ]		! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!messageBody	| errors |	errors := self jsonContents at: #errors ifAbsent: [ ^ '' ].	^ String streamContents: [ :stream | 		errors			do: [ :each | stream << (self errorToString: each) ] 			separatedBy: [ stream cr ] ].! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!messageText	^ self jsonContents at: #message! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!response	^ response! !!IceGitHubError methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!response: anObject	response := anObject! !!IceGitHubError methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!unknownError: aDictionary	^ String streamContents: [ :stream | 		(aDictionary associations sorted: [ :a :b | a key < b key  ])			do: [ :each | stream << each key << ': ' << each value ]			separatedBy: [ stream << ', ' ] ]! !!IceGitHubGenericError class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isAppropriateFor: aResponse	^ aResponse status = 422! !!IceGitHubJSONDataSource methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!actionColumn: column	elements := elements sorted: [ :a :b |		(a at: column id) < (b at: column id) ]		! !!IceGitHubJSONDataSource methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!cellColumn: column row: rowIndex 	^ FTCellMorph new  		addMorphBack: ((self elementAt: rowIndex) at: column id) asStringMorph;		yourself	! !!IceGitHubJSONDataSource methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!columnTitleFor: column	^ column id capitalized! !!IceGitHubJSONDataSource methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!headerColumn: column	column id ifNil: [ ^ nil ].	^ SimpleButtonMorph new		layoutPolicy: RowLayout new; 		listDirection: #leftToRight; 		wrapCentering: #center;		cellInset: 5@0;		layoutInset: 5@0;		label: (self columnTitleFor: column);		target: self;		actionSelector: #actionColumn:;		arguments: {column};		yourself! !!IceGitHubPullRequestDataSource methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!actionColumn: column	column id = #target_url ifTrue: [ ^ self ].	^ super actionColumn: column	! !!IceGitHubPullRequestDataSource methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!cellColumn: column row: rowIndex 	column id = #target_url ifTrue: [ ^ self targetUrlCellColumn: column rowIndex: rowIndex ].	column id = #state ifTrue: [ ^ self statusCellColumn: column rowIndex: rowIndex ].	column id = #context ifTrue: [ ^ self contextCellColumn: column rowIndex: rowIndex ].	^ super cellColumn: column row: rowIndex ! !!IceGitHubPullRequestDataSource methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!columnTitleFor: column	column id = #target_url ifTrue: [ ^ '' ].	^ super columnTitleFor: column! !!IceGitHubPullRequestDataSource methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!contextCellColumn: column rowIndex: rowIndex	| context |	context := (self elementAt: rowIndex) at: column id.	(context includesSubstring: 'travis-ci')		ifTrue: [ context := 'travis-ci' ].	^ FTCellMorph new  		addMorphBack: context asMorph;		yourself		! !!IceGitHubPullRequestDataSource methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!copyToClipboard: url	Clipboard clipboardText: url.	UIManager default inform: ('Url {1} copied to clipboard' format: { url })! !!IceGitHubPullRequestDataSource methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!iconForStatus: status	status = 'success' ifTrue: [ ^ #testGreen asIcon ].	status = 'failure' ifTrue: [ ^ #testRed asIcon ].	status = 'pending' ifTrue: [ ^ #testYellow asIcon ].		^ #testNotRun asIcon! !!IceGitHubPullRequestDataSource methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!statusCellColumn: column rowIndex: rowIndex	| status |	status := (self elementAt: rowIndex) at: column id.	^ FTCellMorph new  		cellInset: 5;		addMorphBack: (self iconForStatus: status) asMorph;		addMorphBack: status asStringMorph;		yourself	! !!IceGitHubPullRequestDataSource methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!targetUrlCellColumn: column rowIndex: rowIndex	| url |	url := (self elementAt: rowIndex) at: column id.	^ FTCellMorph new  		addMorphBack: (			IconicButton new				target: self;				actionSelector: #copyToClipboard:;				arguments: { url };				labelGraphic: (#smallCopy asIcon scaledToSize: 12@12);				color: Color transparent;				helpText: ('Copy url {1} to clipboard' format: { url });				borderWidth: 0;				yourself);		yourself	! !!IceGitHubAcceptPullRequestModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!availableTypes	^ #('merge' 'squash' 'rebase')! !!IceGitHubAcceptPullRequestModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec 	<spec>	^ SpecLayout composed		newColumn: [ :col |			col 				newRow: [:row | row add: #messageLabel width: 80; add: #messageText ];				newRow: [:row | row add: #typeLabel width: 80; add: #typeList ] height: 25;				add: #acceptButton height: self buttonHeight  ];		yourself! !!IceGitHubAcceptPullRequestModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultType	^ 'merge'! !!IceGitHubAcceptPullRequestModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!messageGhostText	^ 'Commit titleAdd an optional extented description'! !!IceGitHubAcceptPullRequestModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!title	^ 'Accept pull request'! !!IceGitHubAcceptPullRequestModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!accept	acceptBlock ifNotNil: [ 		acceptBlock cull: self ].		self window delete! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!acceptButton	^ acceptButton! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!acceptButton: anObject	acceptButton := anObject! !!IceGitHubAcceptPullRequestModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ 500@250! !!IceGitHubAcceptPullRequestModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializePresenter	super initializePresenter.	self typeList 		items: self class availableTypes;		displayBlock: [ :each | each  ];		setSelectedItem: self class defaultType! !!IceGitHubAcceptPullRequestModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	messageLabel := self newLabel.	messageText := self newText autoAccept: true.	typeLabel := self newLabel.	typeList := self newDropList.	acceptButton := self newButton.			messageLabel label: 'Comment'.	messageText 	whenBuiltDo: [ :this | this widget withGhostText: self class messageGhostText ].	typeLabel label: 'Merge type'.	acceptButton label: 'Accept pull request'.	acceptButton action: [ self accept ].		self focusOrder 		add: messageText;		add: typeList;		add: acceptButton! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!message	^ self messageText text asString! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!messageLabel	^ messageLabel! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!messageLabel: anObject	messageLabel := anObject! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!messageText	^ messageText! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!messageText: anObject	messageText := anObject! !!IceGitHubAcceptPullRequestModel methodsFor: 'events' stamp: ' 7/24/2017 12:50:04'!onAccept: aBlock	acceptBlock := aBlock! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!type	^ self typeList selectedItem! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!typeLabel	^ typeLabel! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!typeLabel: anObject	typeLabel := anObject! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!typeList	^ typeList! !!IceGitHubAcceptPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!typeList: anObject	typeList := anObject! !!IceGitHubCreatePullRequestModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec 	<spec>	^ SpecLayout composed		newColumn: [ :col |			col 				newRow: [:row | row add: #titleLabel width: 80; add: #titlePanel ] height: 25;				newRow: [:row | 					row 						newColumn: #headLabel width: 80;						newColumn: [ :col2 | 							col2 newRow: [ :row2 | 								row2									add: #headForkList;									add: #headBranchList ] ] ] height: 25;				newRow: [:row | 					row 						newColumn: #baseLabel width: 80;						newColumn: [ :col2 |							col2 newRow: [ :row2 |								row2 									add: #baseForkList;									add: #baseBranchList ] ] ] height: 25;				newRow: [:row | row add: #bodyLabel width: 80; add: #bodyPanel ];				add: #addButton height: self buttonHeight  ];		yourself! !!IceGitHubCreatePullRequestModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!new	self error: 'Use #repository:credentials:'! !!IceGitHubCreatePullRequestModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!repository: aRepository credentials: aCredentials headRemote: aRemote	^ self basicNew 		initializeRepository: aRepository 			credentials: aCredentials			headRemote: aRemote;		yourself! !!IceGitHubCreatePullRequestModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!title	^ 'New pull request'! !!IceGitHubCreatePullRequestModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!accept	| title |		title := self titlePanel text trim.	title ifEmpty: [ 		UIManager default alert: 'You need to specify a title for the pull request.' title: 'Error'. 		^ self ].		acceptBlock ifNotNil: [ 		acceptBlock cull: self createPullRequest ].		self window delete! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!addButton	^ addButton! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!addButton: anObject	addButton := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!availableBranchNames	^ availableBranchNames ifNil: [ availableBranchNames := self obtainAvailableBranchNames ]! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!availableRemotes	"retrieves available remotes to perform the PR"	^ availableRemotes ifNil: [ availableRemotes := self obtainAvailableRemotes ]! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!baseBranchList	^ baseBranchList! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!baseBranchList: anObject	baseBranchList := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!baseBranchNames	^ self baseBranches collect: [ :each | each at: #name ]! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!baseBranches	^ baseBranches ifNil: [ 		baseBranches := self requestBaseBranches ]! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!baseDefaultBranchName	^ self gitBase at: #'default_branch' ! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!baseForkList	^ baseForkList! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!baseForkList: anObject	baseForkList := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!baseLabel	^ baseLabel! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!baseLabel: anObject	baseLabel := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!baseRemote	"This is the 'base' remote (the place where the repository is forked). This is used to 	 suggest fork PR destination (base)"	^ baseRemote ifNil: [ baseRemote := self obtainBaseRemote ]! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!bodyLabel	^ bodyLabel! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!bodyLabel: anObject	bodyLabel := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!bodyPanel	^ bodyPanel! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!bodyPanel: anObject	bodyPanel := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branch	^ self repository branch! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!createPullRequest	^ IceGitHubPullRequestDefinition new 		credentials: self credentials;		title: self titlePanel text trim;		headRemote: self headForkList selectedItem;		headBranchName: self headBranchList selectedItem;		baseRemote: self baseForkList selectedItem;		baseBranchName: self baseBranchList selectedItem;		body: self bodyPanel text asString trim;		yourself! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!credentials	^ credentials! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!credentials: aCredentials	credentials := aCredentials! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultBaseBranchName	self hasParent ifFalse: [ ^ self baseDefaultBranchName ].	^ self baseBranchNames 		detect: [ :each | each = self branch basename ] 		ifNone: [ self baseDefaultBranchName ]! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultHeadBranchName	^ self branch basename ! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!gitBase	| info |	^ (info := self gitRepositoryInfo) 		at: #parent		ifAbsent: [ info ]! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!gitRepositoryInfo	^ gitRepositoryInfo ifNil: [ 		gitRepositoryInfo := self requestGitRepositoryInfo ]! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!hasParent	^ self gitRepositoryInfo includesKey: #parent! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!headBranchList	^ headBranchList! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!headBranchList: anObject	headBranchList := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!headForkList	^ headForkList! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!headForkList: anObject	headForkList := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!headLabel	^ headLabel! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!headLabel: anObject	headLabel := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!headRemote 	^ headRemote  ifNil: [ self repository pushRemote ]! !!IceGitHubCreatePullRequestModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ 500@300! !!IceGitHubCreatePullRequestModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializePresenter	super initializePresenter.	self titlePanel text: self branch basename.	self headForkList		items: self availableRemotes;		displayBlock: [ :each | each owner, '/', each projectName ];		setSelectedItem: self headRemote.	self headBranchList 		items: self availableBranchNames;		displayBlock: [ :each | each ];		setSelectedItem: self defaultHeadBranchName.	self baseForkList		items: self availableRemotes;		displayBlock: [ :each | each owner, '/', each projectName ];		setSelectedItem: self baseRemote.	self baseBranchList 		items: self availableBranchNames;		displayBlock: [ :each | each ];		setSelectedItem: self defaultBaseBranchName! !!IceGitHubCreatePullRequestModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeRepository: aRepository credentials: aCredentials headRemote: aRemote	repository := aRepository.	credentials := aCredentials.	headRemote := aRemote.	self initialize! !!IceGitHubCreatePullRequestModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	titleLabel := self newLabel.	titlePanel := self newTextInput autoAccept: true.	headLabel := self newLabel.	headForkList := self newDropList.	headBranchList := self newDropList.	baseLabel := self newLabel.	baseForkList := self newDropList.	baseBranchList := self newDropList.	bodyLabel := self newLabel.	bodyPanel := self newText autoAccept: true.	addButton := self newButton.			titleLabel label: 'Title'.	headLabel label: 'From (Head)'.	baseLabel label: 'To (Base)'.	bodyLabel label: 'Comment'.	addButton label: 'Create pull request'.	addButton action: [ self accept ].		self focusOrder 		add: titlePanel;		add: headForkList;		add: headBranchList;		add: baseForkList;		add: baseBranchList;		add: bodyPanel;		add: addButton! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!obtainAvailableBranchNames	^ ((self repository allBranches 		collect: #basename as: Set)		addAll: self baseBranchNames;		asArray)		sort.	! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!obtainAvailableRemotes	| remotes |		remotes := self repository remotes.	(remotes includes: self baseRemote)		ifFalse: [ remotes := remotes copyWith: self baseRemote ].	^ remotes	! !!IceGitHubCreatePullRequestModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!obtainBaseRemote	| base |	base := self gitBase.	^ IceRemote url: ((base at: #'git_url') copyReplaceAll: 'git://' with: 'https://')! !!IceGitHubCreatePullRequestModel methodsFor: 'events' stamp: ' 7/24/2017 12:50:04'!onAccept: aBlock	acceptBlock := aBlock! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceGitHubCreatePullRequestModel methodsFor: 'private request' stamp: ' 7/24/2017 12:50:04'!requestBaseBranches	^ IceGitHubAPI new 		credentials: self credentials;		getBranches: self baseRemote owner project: self baseRemote projectBasename ! !!IceGitHubCreatePullRequestModel methodsFor: 'private request' stamp: ' 7/24/2017 12:50:04'!requestGitRepositoryInfo	| remote |	remote := self headRemote.	^ IceGitHubAPI new 		credentials: self credentials;		getRepository: remote owner 			project: remote projectBasename! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!titleLabel	^ titleLabel! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!titleLabel: anObject	titleLabel := anObject! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!titlePanel	^ titlePanel! !!IceGitHubCreatePullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!titlePanel: anObject	titlePanel := anObject! !!IceGitHubPullRequestActionsModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec	<spec>	^ SpecLayout composed		newRow: [ :row | 			row				add: #mergeButton;				add: #acceptButton;				add: #rejectButton ]! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!acceptButton	^ acceptButton! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!acceptButton: anObject	acceptButton := anObject! !!IceGitHubPullRequestActionsModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	mergeButton := self newButton.	acceptButton := self newButton.	rejectButton := self newButton.			mergeButton 		label: 'Merge into image';		action: [ mergeBlock value ].	acceptButton 		label: 'Accept pull request';		action: [ acceptBlock value ].	rejectButton 		label: 'Reject pull request';		action: [ rejectBlock value ]! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!mergeButton	^ mergeButton! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!mergeButton: anObject	mergeButton := anObject! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!onAccept: aBlock	acceptBlock := aBlock! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!onMerge: aBlock	mergeBlock := aBlock! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!onReject: aBlock	rejectBlock := aBlock! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!rejectButton	^ rejectButton! !!IceGitHubPullRequestActionsModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!rejectButton: anObject	rejectButton := anObject! !!IceGitHubPullRequestDetailModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec 	<spec>	^ SpecLayout composed		newColumn: [ :c |			c 				newRow: [:row | row add: #urlLabel width: 80; add: #urlText ] height: 25;				newRow: [:row | row add: #authorLabel width: 80; add: #authorText ] height: 25;				newRow: [:row | row add: #fromLabel width: 80; add: #fromText ] height: 25;				newRow: [:row | row add: #toLabel width: 80; add: #toText ] height: 25;				newRow: [:row | row add: #mergeableLabel width: 80; add: #mergeablePanel ] height: 25;				newRow: [:row | row add: #statusLabel width: 80; add: #statusPanel ] height: 25;				newRow: [:row | row add: #checksTable ];				newRow: [:row | row add: #bodyText ] ];		yourself! !!IceGitHubPullRequestDetailModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!for: aPullRequest	^ self basicNew 		initializePullRequest: aPullRequest;		yourself! !!IceGitHubPullRequestDetailModel class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!new	self error: 'Use #for:'! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!authorLabel	^ authorLabel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!authorLabel: anObject	authorLabel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!authorText	^ authorText! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!authorText: anObject	authorText := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!bodyText	^ bodyText! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!bodyText: anObject	bodyText := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!checksTable	^ checksTable! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!checksTable: anObject	checksTable := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!fromLabel	^ fromLabel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!fromLabel: anObject	fromLabel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!fromText	^ fromText! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!fromText: anObject	fromText := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!iconForMergeable: mergeable	mergeable = true ifTrue: [ ^ #smallOk asIcon ].	^ #smallCancel asIcon! !!IceGitHubPullRequestDetailModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!iconForStatus: status	status = 'success' ifTrue: [ ^ #testGreen asIcon ].	status = 'failure' ifTrue: [ ^ #testRed asIcon ].	status = 'pending' ifTrue: [ ^ #testYellow asIcon ].		^ #testNotRun asIcon! !!IceGitHubPullRequestDetailModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	super initialize.	self retrieveStatuses.	self retrieveDetail.! !!IceGitHubPullRequestDetailModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializePullRequest: aPullRequest	pullRequest := aPullRequest.	self initialize	! !!IceGitHubPullRequestDetailModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	urlLabel := self newLabel label: 'Url'.	authorLabel := self newLabel label: 'Author'.	fromLabel := self newLabel label: 'From'.	toLabel := self newLabel label: 'Into'.	mergeableLabel := self newLabel label: 'Mergeable'.	statusLabel := self newLabel label: 'Status'.	urlText := self newTextInput 		enabled: false;		text: self pullRequest url.	authorText  := self newTextInput 		enabled: false;		text: self pullRequest author.	fromText  := self newTextInput 		enabled: false;		text: self pullRequest headLabel.	toText  := self newTextInput 		enabled: false;		text: self pullRequest baseLabel.	mergeablePanel := self newMergeablePanel.	statusPanel := self newStatusPanel.	checksTable := self newChecksTable.	bodyText := self newText 		enabled: false;		text: self pullRequest body.! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!mergeableLabel	^ mergeableLabel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!mergeableLabel: anObject	mergeableLabel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!mergeablePanel	^ mergeablePanel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!mergeablePanel: anObject	mergeablePanel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'private factory' stamp: ' 7/24/2017 12:50:04'!newChecksTable	^ FTTableMorph new 		addColumn: ((FTColumn id: #target_url) width: 18);		addColumn: ((FTColumn id: #state) width: 65);		addColumn: ((FTColumn id: #context) width: 100);		addColumn: (FTColumn id: #description);		cellInset: 5;		beResizable;		vResizing: #spaceFill;		hResizing: #spaceFill;		asSpecAdapter		! !!IceGitHubPullRequestDetailModel methodsFor: 'private factory' stamp: ' 7/24/2017 12:50:04'!newMergeablePanel	^ PanelMorph new 		color: Color transparent;		layoutPolicy: TableLayout new;		listDirection: #leftToRight;		cellInset: 5;		vResizing: #spaceFill;		hResizing: #spaceFill;		asSpecAdapter! !!IceGitHubPullRequestDetailModel methodsFor: 'private factory' stamp: ' 7/24/2017 12:50:04'!newStatusPanel	^ PanelMorph new 		color: Color transparent;		layoutPolicy: TableLayout new;		listDirection: #leftToRight;		cellInset: 5;		vResizing: #spaceFill;		hResizing: #spaceFill;		asSpecAdapter! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!pullRequest	^ pullRequest! !!IceGitHubPullRequestDetailModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!retrieveDetail		self mergeablePanel widget addMorphBack: 'Loading...' asMorph.	[ | detail mergeable |  		[  			detail := self pullRequest detail.			mergeable := detail at: #mergeable ]		on: Error do: [ :e | mergeable := nil ].		UIManager default defer: [ 			self mergeablePanel widget				removeAllMorphs;				addMorphBack: (self iconForMergeable: mergeable) asMorph;				addMorphBack: (self textForMergeable: mergeable) asMorph ]	] fork! !!IceGitHubPullRequestDetailModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!retrieveStatuses	self statusPanel widget addMorphBack: 'Loading...' asMorph.	[ 	| status generalStatus statuses |		[		status := self pullRequest status.		generalStatus := status at: 'state'.		statuses := status at: 'statuses' ]	on: Error do: [ :e | 		generalStatus := 'Unknown'.		statuses := #() ].		UIManager default defer: [ 		self statusPanel widget			removeAllMorphs;			addMorphBack: (self iconForStatus: generalStatus) asMorph;			addMorphBack: generalStatus asMorph.	 	self checksTable widget dataSource: (IceGitHubPullRequestDataSource elements: statuses) ]	] fork! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!statusLabel	^ statusLabel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!statusLabel: anObject	statusLabel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!statusPanel	^ statusPanel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!statusPanel: anObject	statusPanel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!textForMergeable: mergeable	mergeable = true ifTrue: [ ^ 'Yes' ].	mergeable = false ifTrue: [ ^ 'There are conflicts' ].	^ mergeable asString	! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!toLabel	^ toLabel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!toLabel: anObject	toLabel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!toText	^ toText! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!toText: anObject	toText := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!urlLabel	^ urlLabel! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!urlLabel: anObject	urlLabel := anObject! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!urlText	^ urlText! !!IceGitHubPullRequestDetailModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!urlText: anObject	urlText := anObject! !!IceGitHubRejectPullRequestModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!availableTypes	^ #('merge' 'squash' 'rebase')! !!IceGitHubRejectPullRequestModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec 	<spec>	^ SpecLayout composed		newColumn: [ :col |			col 				newRow: [:row | row add: #messageLabel width: 80; add: #messageText ];				add: #acceptButton height: self buttonHeight  ];		yourself! !!IceGitHubRejectPullRequestModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!defaultType	^ 'merge'! !!IceGitHubRejectPullRequestModel class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!messageGhostText	^ 'Commit titleAdd an optional extented description'! !!IceGitHubRejectPullRequestModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!title	^ 'Accept pull request'! !!IceGitHubRejectPullRequestModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!accept	acceptBlock ifNotNil: [ 		acceptBlock cull: self ].		self window delete! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!acceptButton	^ acceptButton! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!acceptButton: anObject	acceptButton := anObject! !!IceGitHubRejectPullRequestModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ 500@250! !!IceGitHubRejectPullRequestModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	messageLabel := self newLabel.	messageText := self newText autoAccept: true.	acceptButton := self newButton.			messageLabel label: 'Comment'.	messageText 	whenBuiltDo: [ :this | this widget withGhostText: self class messageGhostText ].	acceptButton label: 'Reject pull request'.	acceptButton action: [ self accept ].		self focusOrder 		add: messageText;		add: acceptButton! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!message	^ self messageText text asString! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!messageLabel	^ messageLabel! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!messageLabel: anObject	messageLabel := anObject! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!messageText	^ messageText! !!IceGitHubRejectPullRequestModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!messageText: anObject	messageText := anObject! !!IceGitHubRejectPullRequestModel methodsFor: 'events' stamp: ' 7/24/2017 12:50:04'!onAccept: aBlock	acceptBlock := aBlock! !!IceGitHubSelectListModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!buttonLabel	^ 'Select'! !!IceGitHubSelectListModel class methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!defaultExtent 	^ 550@500! !!IceGitHubSelectListModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!defaultSpec	<spec>	^ SpecLayout composed		newColumn:[ :col | 			col  				newRow: #listPanel;				newRow: #selectButton height: self buttonHeight ];		yourself! !!IceGitHubSelectListModel class methodsFor: 'specs' stamp: ' 7/24/2017 12:50:04'!title	^ 'Select...'! !!IceGitHubSelectListModel methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!confirmSelection	acceptBlock ifNotNil: [ 		acceptBlock value: selectedItems ].	self window delete! !!IceGitHubSelectListModel methodsFor: 'private factory' stamp: ' 7/24/2017 12:50:04'!createCheckboxFor: anObject	^ CheckboxMorph 		on: (IceGitHubSelectItem list: selectedItems item: anObject) 		selected: #value 		changeSelected: #value:! !!IceGitHubSelectListModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!displayBlock: aBlock 	self listPanel displayBlock: aBlock! !!IceGitHubSelectListModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!initialExtent	^ self class defaultExtent! !!IceGitHubSelectListModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	selectedItems := Set new.	super initialize.	self title: self class title! !!IceGitHubSelectListModel methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWidgets	listPanel := self instantiate: FastTableModel.	listPanel icons: [ :each | self createCheckboxFor: each ].	selectButton := self newButton.		selectButton 		label: self class buttonLabel;		action: [ self confirmSelection ].		self focusOrder 		add: listPanel;		add: selectButton! !!IceGitHubSelectListModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!items: aCollection	self listPanel items: aCollection! !!IceGitHubSelectListModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!listPanel	^ listPanel! !!IceGitHubSelectListModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!listPanel: anObject	listPanel := anObject! !!IceGitHubSelectListModel methodsFor: 'events' stamp: ' 7/24/2017 12:50:04'!onAccept: aBlock	acceptBlock := aBlock! !!IceGitHubSelectListModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!selectButton	^ selectButton! !!IceGitHubSelectListModel methodsFor: 'accessing ui' stamp: ' 7/24/2017 12:50:04'!selectButton: anObject	selectButton := anObject! !!IceGitHubSelectListModel methodsFor: 'api' stamp: ' 7/24/2017 12:50:04'!selectLabel: aString	self selectButton label: aString! !!IceGitHubAPI class methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!obtainCredentials	| newCredentials provider |		provider := IceCredentialsProvider default.	newCredentials := IcePlaintextCredentials new.	IceCredentialsProvider default providePlaintextCredentialsTo: newCredentials.	^ newCredentials! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/24/2017 12:50:04'!acceptPullRequest: owner project: projectName number: aNumber data: aDictionary	^ self 		put: 'repos/', owner, '/', projectName, '/pulls/', aNumber asString, '/merge'		with: [ :client |			client 				entity: (ZnEntity text: (STON toJsonString: aDictionary));				contentType: ZnMimeType applicationJson ]! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/24/2017 12:50:04'!addComment: owner project: projectName number: aNumber data: aDictionary	^ self 		post: 'repos/', owner, '/', projectName, '/issues/', aNumber asString, '/comments'		with: [ :client |			client 				entity: (ZnEntity text: (STON toJsonString: aDictionary));				contentType: ZnMimeType applicationJson ]! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/24/2017 12:50:04'!addPullRequest: owner project: projectName data: aDictionary	^ self 		post: 'repos/', owner, '/', projectName, '/pulls'		with: [ :client |			client 				entity: (ZnEntity text: (STON toJsonString: aDictionary));				contentType: ZnMimeType applicationJson ]! !!IceGitHubAPI methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!contentsWithValidationDo: aBlock	^ (self responseWithValidationDo: aBlock) contents! !!IceGitHubAPI methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!credentials	^ credentials ifNil: [ credentials := self class obtainCredentials ]! !!IceGitHubAPI methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!credentials: anObject	credentials := anObject! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/24/2017 12:50:04'!delete: aString 	^ self jsonContentsWithValidationDo: [		(self newRequestTo: aString)			delete;			response ]! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/24/2017 12:50:04'!deleteBranch: owner project: projectName name: branchName	^ self delete: 'repos/', owner, '/', projectName, '/git/refs/heads/', branchName! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/24/2017 12:50:04'!get: aString 	^ self jsonContentsWithValidationDo: [		(self newRequestTo: aString)			get;			response ]! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/24/2017 12:50:04'!getBranch: owner project: projectName name: branchName	^ self get: 'repos/', owner,'/', projectName, '/branches/', branchName! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/24/2017 12:50:04'!getBranches: owner project: projectName	^ self get: 'repos/', owner,'/', projectName, '/branches'! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/24/2017 12:50:04'!getPaginated: aString 	^ IceGitHubAPIPaginatedResult api: self request: aString! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/24/2017 12:50:04'!getPullRequests: owner project: projectName	^ self getPaginated: 'repos/', owner, '/', projectName, '/pulls'		! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/24/2017 12:50:04'!getRaw: aString 	^ self responseWithValidationDo: [		(self newRequestTo: aString)			get;			response ]! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/24/2017 12:50:04'!getRepository: owner project: projectName	^ self get: 'repos/', owner,'/', projectName! !!IceGitHubAPI methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!jsonContentsWithValidationDo: aBlock	^ STON fromString: (self contentsWithValidationDo: aBlock)! !!IceGitHubAPI methodsFor: 'private factory' stamp: ' 7/24/2017 12:50:04'!newRequestTo: aString	^ ZnClient new 		in: [ :this | 			self credentials ifNotNil: [ 				this 					username: self credentials username 					password: self credentials password ] ]; 		headerAt: 'Accept' put: 'application/vnd.github.v3+json';		url: 'https://api.github.com/', aString;		yourself! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/24/2017 12:50:04'!patch: aString with: aBlock  	^ self jsonContentsWithValidationDo: [		(self newRequestTo: aString)			in: aBlock;			patch;			response ]! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/24/2017 12:50:04'!post: aString with: aBlock  	^ self jsonContentsWithValidationDo: [		(self newRequestTo: aString)			in: aBlock;			post;			response ]! !!IceGitHubAPI methodsFor: 'private requesting' stamp: ' 7/24/2017 12:50:04'!put: aString with: aBlock  	^ self jsonContentsWithValidationDo: [		(self newRequestTo: aString)			in: aBlock;			put;			response ]! !!IceGitHubAPI methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!responseWithValidationDo: aBlock	| response |		response := aBlock value.	response isSuccess 		ifFalse: [ IceGitHubError signalFor: response ].	^ response! !!IceGitHubAPI methodsFor: 'requesting' stamp: ' 7/24/2017 12:50:04'!updatePullRequest: owner project: projectName number: aNumber data: aDictionary 	^ self 		patch: 'repos/', owner, '/', projectName, '/pulls/', aNumber asString		with: [ :client |			client 				entity: (ZnEntity text: (STON toJsonString: aDictionary));				contentType: ZnMimeType applicationJson ]! !!IceGitHubAPIPaginatedResult class methodsFor: 'as yet unclassified' stamp: ' 7/24/2017 12:50:04'!api: anAPI request: aString	^ self new 		api: anAPI;		request: aString;		yourself		! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!all	| stream |	stream := Array new writeStream.	[ self hasNext ] 	whileTrue: [ stream << self next ].	^ stream contents! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!api	^ api! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!api: anObject	api := anObject! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!hasNext	^ result isNil or: [ self parseMorePages: (result headers at: 'Link' ifAbsent: [ nil ]) ]! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!next 	nextPage ifNil: [ nextPage := 1 ].	[ result := self api getRaw: (self request asUrl ? (#page -> nextPage asString)) asString ]	ensure: [ nextPage := nextPage + 1].	^ STON fromString: result contents! !!IceGitHubAPIPaginatedResult methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!parseMorePages: aString 	"github does not send 'Links' header if there are no pages, and it does not sends 'next' link	 if we are at the last page"	aString ifNil: [ ^ false ].	^ (aString substrings: ',') anySatisfy: [ :each | each includesSubstring: 'rel="next"' ] ! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!request	^ request! !!IceGitHubAPIPaginatedResult methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!request: anObject	request := anObject! !!IceGitHubCommand class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!repository: aRepository 	^ self new repository: aRepository ! !!IceGitHubCommand methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!credentials 	^ credentials ifNil: [ credentials := self obtainCredentials ]! !!IceGitHubCommand methodsFor: 'execute' stamp: ' 7/24/2017 12:50:04'!execute 	self subclassResponsibility! !!IceGitHubCommand methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!github	^ IceGitHubAPI new 		credentials: self credentials;		yourself! !!IceGitHubCommand methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!obtainCredentials	^ IceGitHubAPI obtainCredentials! !!IceGitHubCommand methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!reportError: error	UIManager default 		alert: error messageBody		title: 'Error creating pull request: ', error messageText! !!IceGitHubCommand methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceGitHubCommand methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: aRepository	repository := aRepository! !!IceGitHubNewPullRequestCommand methodsFor: 'execute' stamp: ' 7/24/2017 12:50:04'!execute 	(self validateMakePullRequestOn: self repository) ifFalse: [ ^ #() ].		(IceGitHubCreatePullRequestModel 		repository: self repository 		credentials: self credentials		headRemote: self remote)		setModal: true; 		onAccept: [ :pullRequest | 			[ 				pullRequest send.				UIManager default inform: 'Pull request created.' ]			on: IceGitHubError do: [ :e | self reportError: e ] ];		openWithSpec ! !!IceGitHubNewPullRequestCommand methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote	^ remote! !!IceGitHubNewPullRequestCommand methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote: anObject	remote := anObject! !!IceGitHubNewPullRequestCommand methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!validateMakePullRequestOn: aRepository	| status |		status := OrderedCollection new: 2.	aRepository isModified 		ifTrue: [ status add: 'Uncommited changes' ].	(aRepository outgoingCommitsTo: (aRepository pushRemote)) 		ifNotEmpty: [ :commits | '{1} not published' format: { commits size } ].	status ifEmpty: [ ^ true ].		^ UIManager default 		confirm: (('{1} has ongoing modifications ({2}). Do you want to continue anyway?') format: { aRepository name. status asCommaString })! !!IceGitHubRemoveBranchesCommand class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!repository: aRepository remote: aRemote	^ self new 		repository: aRepository;		remote: aRemote;		yourself! !!IceGitHubRemoveBranchesCommand methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!cacheAllBranches	self remoteBranches do: [ :each | | branchName |		branchName := each at: 'name'.		branchesByName 			at: branchName 			ifAbsentPut: [ self remoteBranch: branchName ] ]! !!IceGitHubRemoveBranchesCommand methodsFor: 'execute' stamp: ' 7/24/2017 12:50:04'!execute 	UIManager default 		informUser: ('Retrieving branch information from {1}' format: { self remote url })		during: [ self cacheAllBranches ].	IceGitHubSelectListModel new 		setModal: true;		title: ('Select branches to remove on remote {1}' format: {self remote remoteName});		selectLabel: 'Remove branches';		items: self remoteBranches;		displayBlock: [ :each | 			'{1} ({2})' format: { 				each at: 'name'. 				self timeSinceLastCommit: each } ];		onAccept: [ :selection | self removeBranches: selection ];		openWithSpec! !!IceGitHubRemoveBranchesCommand methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize 	super initialize.	branchesByName := OrderedDictionary new! !!IceGitHubRemoveBranchesCommand methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote	^ remote! !!IceGitHubRemoveBranchesCommand methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote: aRemote	remote := aRemote! !!IceGitHubRemoveBranchesCommand methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!remoteBranch: aName	^ self requestRemoteBranch: aName! !!IceGitHubRemoveBranchesCommand methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!remoteBranches	^ branches ifNil: [ branches := self requestRemoteBranches ]! !!IceGitHubRemoveBranchesCommand methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!removeBranch: json	| branchName |		branchName := json at: 'name'.	IceGitHubAPI new 		credentials: self credentials;		deleteBranch: self remote owner 			project: self remote projectBasename			name: branchName.	UIManager default inform: ('Branch {1} removed.' format: { branchName })			! !!IceGitHubRemoveBranchesCommand methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!removeBranches: aCollection	[ 		aCollection do: [ :each | self removeBranch: each ] ]	on: IceGitHubError do: [ :e | self reportError: e ]! !!IceGitHubRemoveBranchesCommand methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!requestRemoteBranch: aName	^ IceGitHubAPI new		getBranch: self remote owner 		project: self remote projectBasename		name: aName! !!IceGitHubRemoveBranchesCommand methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!requestRemoteBranches	^ IceGitHubAPI new		getBranches: self remote owner 		project: self remote projectBasename! !!IceGitHubRemoveBranchesCommand methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!timeSinceLastCommit: json	| branchName branchJson lastCommitDate |	branchName := json at: 'name'.	branchJson := branchesByName at: branchName.	lastCommitDate := ((((branchJson at: 'commit') at: 'commit') at: 'author') at: 'date') asDateAndTime.	^ '{1} days' format: { (Date today - lastCommitDate) days }! !!IceGitHubViewPullRequestCommand methodsFor: 'execute' stamp: ' 7/24/2017 12:50:04'!execute	UIManager default 		informUser: ('Retrieving pull requests from {1}' format: { self remote })  		during: [ 			IceGitHubPullRequestListBrowser new				repository: self repository;				remote: self remote;				refreshPullRequests;				open ]! !!IceGitHubViewPullRequestCommand methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote	^ remote! !!IceGitHubViewPullRequestCommand methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote: anObject	remote := anObject! !!IceGitHubPullRequest class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!fromJSON: aDictionary	^ self basicNew		initializeWithJSON: aDictionary;		yourself! !!IceGitHubPullRequest methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!acceptMessage: messageString type: typeString	IceGitHubAPI new 		acceptPullRequest: self owner 			project: self projectName			number: self number			data: { 				#commit_title -> (messageString lines 					ifNotEmpty: [ :each | each first trimBoth ] 					ifEmpty: [ '' ]). 				#commit_message -> (messageString lines 					ifNotEmpty: [ :lines | (lines allButFirst joinUsing: String lf) trimBoth ] 					ifEmpty: [ '' ]). 				#sha-> self headSHA.				#merge_method -> typeString } asDictionary! !!IceGitHubPullRequest methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!addComment: messageString	IceGitHubAPI new 		addComment: self owner 			project: self projectName			number: self number			data: { #body -> messageString } asDictionary! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!author	^ (self jsonAt: 'user') at: 'login'! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!baseLabel	^ (self jsonAt: #base) at: #label! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!baseSHA	^ (self jsonAt: #base) at: #sha! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!body	^ self jsonAt: #body! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branch	fetched ifFalse: [ self fetch ].	^ branch ifNil: [		branch := IceRemoteBranch			remoteName: self remote remoteName 			branchName: ((self jsonAt: #head) at: #ref)			inRepository: self repository.		branch ]! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branchName	^ self branch basename! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!detail	^ detail ifNil: [		detail := IceGitHubAPI new get: ((self jsonAt: #url) allButFirst: 23) ]! !!IceGitHubPullRequest methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!fetch	[ ^ self repository fetchFrom: self remote ]	ensure: [ fetched := true ]! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!headLabel	^ (self jsonAt: #head) at: #label! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!headSHA	^ (self jsonAt: #head) at: #sha! !!IceGitHubPullRequest methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initialize	super initialize.	fetched := false! !!IceGitHubPullRequest methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeWithJSON: aDictionary	json := aDictionary.	self initialize! !!IceGitHubPullRequest methodsFor: 'private accessing' stamp: ' 7/24/2017 12:50:04'!json	^ json! !!IceGitHubPullRequest methodsFor: 'private accessing' stamp: ' 7/24/2017 12:50:04'!jsonAt: aKey	^ self json at: aKey! !!IceGitHubPullRequest methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!mergeIntoImage	self repository 		ensureBranch: self branchName;		checkoutBranch: self branchName;		merge: self branch lastCommit! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!number	^ self jsonAt: #number! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!owner 	^ (((self jsonAt: #base) at: #repo) at: #owner) at: #login! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!projectName	^ ((self jsonAt: #base) at: #repo) at: #name! !!IceGitHubPullRequest methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!rejectMessage: messageString	messageString trimBoth 		ifNotEmpty: [ self addComment: messageString ].	IceGitHubAPI new 		updatePullRequest: self owner 			project: self projectName			number: self number			data: { #state -> #closed } asDictionary! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remote	| remote |	remote := IceRemote 		name: self author		url: (((self jsonAt: #head) at: #repo) at: #ssh_url).	^ self repository remotes 		detect: [ :each | each = remote ]		ifFound: [ :each | each ]		ifNone: [ 			self repository addRemote: remote.			remote ].		! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ repository! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository: anObject	repository := anObject! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!state	^ self jsonAt: #state! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!status	^ status ifNil: [ 		status := IceGitHubAPI new 			get: 'repos/', self owner, '/', self projectName, '/commits/', self headSHA, '/status' ]! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ self jsonAt: #title! !!IceGitHubPullRequest methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!url	^ self jsonAt: #url! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!baseBranchName	^ baseBranchName! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!baseBranchName: anObject	baseBranchName := anObject! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!baseRemote	^ baseRemote! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!baseRemote: anObject	baseRemote := anObject! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!body	^ body! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!body: anObject	body := anObject! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!credentials	^ credentials! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!credentials: anObject	credentials := anObject! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!headBranchName	^ headBranchName! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!headBranchName: anObject	headBranchName := anObject! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!headRemote	^ headRemote! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!headRemote: anObject	headRemote := anObject! !!IceGitHubPullRequestDefinition methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!send	| pullRequestData |	pullRequestData := { 		'title' -> self title.		'head' -> (self headRemote owner, ':', self headBranchName).		'base' -> self baseBranchName.		'body' -> self body.	} asDictionary.		IceGitHubAPI new 		credentials: self credentials;		addPullRequest: self baseRemote owner 			project: self baseRemote projectBasename 			data: pullRequestData! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title	^ title! !!IceGitHubPullRequestDefinition methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!title: anObject	title := anObject! !!IceGitHubSelectItem class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!list: selectedItems item: anObject	^ self basicNew 		initializeList: selectedItems item: anObject;		yourself! !!IceGitHubSelectItem class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!new	self error: 'Use #list:item:'! !!IceGitHubSelectItem methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!addItem	(list includes: item) ifTrue: [ ^ self ].	list add: item ! !!IceGitHubSelectItem methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeList: aCollection item: anObject	list := aCollection.	item := anObject.	self initialize! !!IceGitHubSelectItem methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!removeItem	(list includes: item) ifFalse: [ ^ self ].	list remove: item ! !!IceGitHubSelectItem methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!value 	^ list includes: item! !!IceGitHubSelectItem methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!value: aBoolean	aBoolean 		ifTrue: [ self addItem ]		ifFalse: [ self removeItem ]	! !!IceGitHubPullRequestPlugin class methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isAvailableFor: aRepository	"validate if this is a github repository"	^ aRepository origin host = 'github.com'! !!IceGitHubPullRequestPlugin methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!newPullRequest: aRepository 	^ self newPullRequest: aRepository remote: aRepository pushRemote ! !!IceGitHubPullRequestPlugin methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!newPullRequest: aRepository remote: aRemote	(IceGitHubNewPullRequestCommand repository: aRepository) 		remote: aRemote;		execute! !!IceGitHubPullRequestPlugin methodsFor: 'private actions' stamp: ' 7/24/2017 12:50:04'!newPullRequestAction	^ GLMGenericAction new		action: [ :presenter | self newPullRequest: presenter selection repository ];		category: 'GitHub';		showTitle: 'Create pull request...'; 		yourself! !!IceGitHubPullRequestPlugin methodsFor: 'private actions' stamp: ' 7/24/2017 12:50:04'!newPullRequestRemoteAction	^ GLMGenericAction new		action: [ :presentation :model |			self newPullRequest: model repository remote: presentation selection ];		category: 'GitHub';		showTitle: 'Create pull request...'; 		yourself! !!IceGitHubPullRequestPlugin methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remoteActionsFor: aRemote	^ { 	self newPullRequestRemoteAction.	self viewPullRequestsRemoteAction.	self removeOldBranchesRemoteAction. 	}! !!IceGitHubPullRequestPlugin methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!removeBranches: aRepository	self removeBranches: aRepository remote: aRepository pushRemote! !!IceGitHubPullRequestPlugin methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!removeBranches: aRepository remote: aRemote	(IceGitHubRemoveBranchesCommand 		repository: aRepository 		remote: aRemote)		execute! !!IceGitHubPullRequestPlugin methodsFor: 'private actions' stamp: ' 7/24/2017 12:50:04'!removeOldBranchesAction	^ GLMGenericAction new		action: [ :presentation | self removeBranches: presentation selection repository ];		category: 'GitHub';		showTitle: 'Remove old branches...'; 		yourself! !!IceGitHubPullRequestPlugin methodsFor: 'private actions' stamp: ' 7/24/2017 12:50:04'!removeOldBranchesRemoteAction	^ GLMGenericAction new		action: [ :presentation :model | 			self removeBranches: model remote: presentation selection ];		category: 'GitHub';		showTitle: 'Remove old branches...'; 		yourself! !!IceGitHubPullRequestPlugin methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repositoryActions	^ { 	self newPullRequestAction. 	self viewPullRequestsAction.	self removeOldBranchesAction. 	}! !!IceGitHubPullRequestPlugin methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!viewPullRequest: aRepository 	^ self viewPullRequest: aRepository remote: aRepository pushRemote ! !!IceGitHubPullRequestPlugin methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!viewPullRequest: aRepository remote: aRemote	(IceGitHubViewPullRequestCommand repository: aRepository) 		remote: aRemote;		execute! !!IceGitHubPullRequestPlugin methodsFor: 'private actions' stamp: ' 7/24/2017 12:50:04'!viewPullRequestsAction	^ GLMGenericAction new		action: [ :presenter | self viewPullRequest: presenter selection repository ];		category: 'GitHub';		showTitle: 'Review pull requests...'; 		yourself! !!IceGitHubPullRequestPlugin methodsFor: 'private actions' stamp: ' 7/24/2017 12:50:04'!viewPullRequestsRemoteAction	^ GLMGenericAction new		action: [ :presentation :model | 			self viewPullRequest: model repository remote: presentation selection ];		category: 'GitHub';		showTitle: 'Review pull requests...'; 		yourself! !"Iceberg-Plugin-GitHub"!!IceLibgitVersionReader commentStamp: 'NicoPasserini 7/7/2016 11:58' prior: 0!Reads an MCVersion from a git repository (its blob, not a working copy!!) using libgit bindings.Currently we only support metadata-less repositories.!!IceLibgitCommitWalk commentStamp: 'NicoPasserini 9/21/2016 14:26' prior: 0!Utility class for searching through a commit history taking advantage of git revwalk utilities. Found and returned commits will be added to the commit cache of the corresponding IceRepository.!!IceLibgitFileUtils commentStamp: 'NicoPasserini 7/7/2016 12:15' prior: 0!Emulates other 'file utils' classes by reading from a git repository (its blob, not a working copy'). Allows for reading any tree (from any commit) in the repository.!!IceLibgitLocalRepository commentStamp: 'NicoPasserini 6/28/2016 10:56' prior: 0!Adapter which allows an IceRepository to use libgit as underlying storage.!!Trait method!isPackageEntry: entry	^ entry isDirectory and: [ self canReadFileNamed: entry name ]	! !!Trait method!packageEntries	self codeDirectory exists ifFalse: [ ^ #() ].	^ self codeDirectory entries 		select: [ :entry | self isPackageEntry: entry ]	! !!Trait method!iceCommitFrom: aCommitish	"The type of 'aCommitish' depends on how each backend internal representation. "	^ self frontend		commitAt: (self commitIdFrom: aCommitish )		ifAbsentPut: [ self class parseCommitInfo: aCommitish ]! !!Trait method!codeDirectory	"Code repository might have been deleted or image might have been moved."	self repositoryDirectory exists		ifTrue: [ ^ self basicCodeDirectory ]		ifFalse: [ IceLocalRepositoryMissing signalFor: self frontend ]! !!Trait method!merge: aCommitId into: aBranchName	| currentBranchName |	currentBranchName := self branch name.	[ 		self checkoutBranch: aBranchName.		self merge: aCommitId ]	ensure: [ 		self checkoutBranch: currentBranchName ]! !!Trait method!basicCodeDirectory	^ self subdirectory isEmptyOrNil 		ifTrue: [ self repositoryDirectory ]		ifFalse: [ self repositoryDirectory / self subdirectory  ].! !!Trait method!isMissing	^ self repositoryDirectory isNil 		or: [ self repositoryDirectory exists not ]! !!Trait method!lookupPackages	^ (self packageEntries		collect: [ :entry |			entry packageName -> (IceSavedPackage 				named: entry packageName				repository: self frontend).		])		asDictionary! !!Trait method!description	"Use local directory as description, as Monticello uses this to determine if two repositories are the same. This allows for having multiple local clones of the same remote repositories, which in turn could allow for using standard Pharo tools, for example to compare versions."	^ self basicCodeDirectory pathString, ' (', self class description, ')'! !!Trait method!initialize	IceRepository defaultBackendType ifNil: [ 		IceRepository defaultBackend: self ]! !!IceLibgitTreeBuilder commentStamp: 'NicoPasserini 7/12/2016 11:29' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	builder:		<Object>	changes:		<Object>	children:		<Object>	entryName:		<Object>	originalTree:		<LGitTree> Contains the original contents on which this builder bases. Warning: this will not reflect the actual contents of the builder. Use #buildTree instead.	parent:		<Object>    Implementation Points!!IceSemanticVersion commentStamp: '<historical>' prior: 0!I represent the semver (http://semver.org) of libgit2. Since I exist just to be able to compare versions, I'm limited (reason why I'm not promoted to a more general package).!!IceLibgitStCypressWriter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!fileUtils	^ IceLibgitFileUtils current! !!IceLibgitStCypressWriter methodsFor: 'initialize-release' stamp: ' 7/24/2017 12:50:04'!propertyFileExtension  ^ MCFileTreeRepository defaultPropertyFileExtension! !!IceLibgitStCypressWriter methodsFor: 'visiting' stamp: ' 7/24/2017 12:50:04'!writeInDirectoryName: directoryNameOrPath fileName: fileName extension: ext visit: visitBlock    | directory |    directory := self directoryForDirectoryNamed: directoryNameOrPath.    self fileUtils        writeStreamFor: fileName , ext        in: directory        do: [ :fs |             self setFileStream: fs.            visitBlock value ]! !!IceLibgitVersionReader class methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!compatibleAuthorNameOf: aString	"Timestamp of method has a very precise format that needs to be fulfiled: 				'FirstnameLastname MM/DD/YYYY HH/MM' 		Problem is that git username is different: Firstname Lastname.	To make this compatible, we remove spaces... but this can be a problem in the future... 	we'll see."	^ aString reject: [ :each | each = Character space ]! !!IceLibgitVersionReader class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!on: aCommitOrTree iceVersion: iceVersion	^ (self on: aCommitOrTree) 		iceVersion: iceVersion; 		yourself! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!commit	^ stream! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!fileUtils	^ IceLibgitFileUtils current! !!IceLibgitVersionReader methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!hasMonticelloMetadata	^ false! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!iceVersion	^ iceVersion! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!iceVersion: anObject	iceVersion := anObject.	self packageDirectory: iceVersion package directoryPathString	! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!loadVersionInfo	^ info := self iceVersion info! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!packageNameFromPackageDirectory	^ iceVersion packageName! !!IceLibgitVersionReader methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!versionName	^ ('{1}-{2}.{3}' format: {		self packageNameFromPackageDirectory. 		self commit compatibleUsername. 		self versionNumber	})! !!IceLibgitWriter methodsFor: 'writing' stamp: ' 7/24/2017 12:50:04'!addString: string at: fileNameOrPath encodedTo: ignored    "fileNameOrPath may have one or two elements"    "encodeTo: arg, because FileTree uses UTF8 by default"	| split path fileName |	split := fileNameOrPath lastIndexOf: $/.	path := fileNameOrPath first: split.	fileName := fileNameOrPath copyFrom: split + 1.		(self packageFileDirectory entryByPath: path)		addEntryNamed: fileName withContents: string.! !!IceLibgitWriter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!fileUtils	^ IceLibgitFileUtils current! !!IceLibgitWriter methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!snapshotWriterClass	^ IceLibgitStCypressWriter! !!IceLibgitWriter methodsFor: 'visiting' stamp: ' 7/24/2017 12:50:04'!subPackageFileDirectoryFor: directoryNameOrPath	^ self packageFileDirectory entryByPath: directoryNameOrPath ! !!IceLibgitWriter methodsFor: 'visiting' stamp: ' 7/24/2017 12:50:04'!writeVersion: aVersion	directory := aVersion package name, '.package'.	self packageFileDirectory deleteAll.	self writeFormat.	self writePackage: aVersion package.	self writeDefinitions: aVersion.	aVersion dependencies do: [ :ea | self writeVersionDependency: ea ]! !!IceLibgitCommitWalk methodsFor: 'walking' stamp: ' 7/24/2017 12:50:04'!commitsDo: aBlock 	self maxNumber 		ifNil: [ super commitsDo: aBlock ]		ifNotNil: [ | count |			count := 0.			super commitsDo: [ :commit |				aBlock value: commit.				count := count + 1.				count == self maxNumber ifTrue: [ ^ self ]			]		]! !!IceLibgitCommitWalk methodsFor: 'walking' stamp: ' 7/24/2017 12:50:04'!firstCommit	^ self commitsDo: [ :commit | ^ commit ] ! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!fromBranch: branch	[ self revwalk pushReference: (lgitRepository lookupBranch: branch name) ]		on: LGit_GIT_EINVALIDSPEC do: [			"branch real branch, so try to find a corresponding treeish using revparse, 			this will handle stuff like 'master~1'"			self fromLGitId: (lgitRepository revparse: branch name) id		]! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!fromCommit: commit	self fromCommitId: commit id! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!fromCommitId: commitId	self fromLGitId: (LGitId fromHexString: commitId)! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!fromHead	self revwalk pushHead! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!fromLGitId: lGitId	self revwalk pushCommit: lGitId! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!fromTag: tag	self revwalk.	^ self fromLGitId: (lgitRepository revparse: tag name) id! !!IceLibgitCommitWalk methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!rawResultsDo: aBlockClosure 	self revwalk 		select: [ :result | self shouldInclude: result ]		thenDo: aBlockClosure! !!IceLibgitCommitWalk methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!revwalk	^ revwalk ifNil: [		repository withRepoDo: [ :repo |			"Keep a reference to the repo so that it does not get garbage collected 			(that would free C memory and make leave the revwalk object dumb)"			lgitRepository := repo. 			^ revwalk := LGitRevwalk of: repo.		] 	]! !!IceLibgitCommitWalk methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!shouldInclude: aLGitCommit 	^ self modifyingPackage 		ifNil: [ true ]		ifNotNil: [ :package | 			aLGitCommit changesFileNamed: package directoryPathString ]! !!IceLibgitCommitWalk methodsFor: 'walk definition' stamp: ' 7/24/2017 12:50:04'!uptoCommit: commit	self revwalk hideCommit: (LGitId fromHexString: commit id)! !!IceLibgitFileUtils class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!current    ^ Current ifNil: [ Current := self new ]! !!IceLibgitFileUtils methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!deleteAll: aTreeBuilder     ^ aTreeBuilder deleteAll! !!IceLibgitFileUtils methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!directoryExists: aLGitTreeEntry 	^ aLGitTreeEntry type = LGitObjectTypeEnum git_obj_tree! !!IceLibgitFileUtils methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!directoryFromEntry: treeEntry 	^ treeEntry object! !!IceLibgitFileUtils methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!directoryFromPath: aString relativeTo: aCommitOrTree	^ aCommitOrTree 		entryByPath: aString 		ifAbsent: [ 			IceMissingRepositoryEntry new name: aString; owner: aCommitOrTree; signal ] ! !!IceLibgitFileUtils methodsFor: 'as yet unclassified' stamp: ' 7/24/2017 12:50:04'!pathNameDelimiter	^ $/! !!IceLibgitFileUtils methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!readStreamFor: fileName in: tree do: aBlock	(tree entryByPath: fileName) readStreamDo: aBlock! !!IceLibgitFileUtils methodsFor: 'utilities' stamp: ' 7/24/2017 12:50:04'!writeStreamFor: fileName in: directory do: aBlock 	directory addEntryNamed: fileName withContents: (String streamContents: aBlock).! !!IceLibgitLocalRepository class methodsFor: 'descriptions' stamp: ' 7/24/2017 12:50:04'!description	^ 'Libgit'! !!IceLibgitLocalRepository class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!newRepositoryAt: aFileReference origin: anIceRemoteRepository subdirectory: aString	^ self new		location: aFileReference;		origin: anIceRemoteRepository;		subdirectory: aString;		yourself! !!IceLibgitLocalRepository class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!newRepositoryAt: aFileReference subdirectory: aString	^ self new		location: aFileReference;		subdirectory: aString;		yourself! !!IceLibgitLocalRepository class methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!parseCommitInfo: aLGitCommit	^ IceCommitInfo new		commitId: aLGitCommit id hexString;		username: aLGitCommit committer name;		datetime: aLGitCommit time asDateAndTime;		parentIds: (aLGitCommit parents collect: [ :parent | parent id hexString ]);		comment: aLGitCommit message! !!IceLibgitLocalRepository class methodsFor: 'utils' stamp: ' 7/24/2017 12:50:04'!requiredLibGit2MinimumVersion	^ IceSemanticVersion 		major: 0 		minor: 25 		patch: 1! !!IceLibgitLocalRepository class methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!shortName	^ 'Libgit'! !!IceLibgitLocalRepository class methodsFor: 'utils' stamp: ' 7/24/2017 12:50:04'!verifyBackendAvailabilityIfNot: aBlock	| presentVersion requiredVersion |		presentVersion := IceSemanticVersion fromArray: LGitLibrary uniqueInstance version.	requiredVersion := self requiredLibGit2MinimumVersion.		requiredVersion <= presentVersion 		ifFalse: [ ^ aBlock cull: requiredVersion cull: presentVersion ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!addFilesToIndex: aListOfPaths	self withRepoDo: [ :repo | 		| index |		index := repo index.		index addAll: aListOfPaths.		index writeToDisk.	]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!addRemote: aRemote	self withRepoDo: [ :repo |		repo addRemote: aRemote remoteName url: aRemote url ]! !!IceLibgitLocalRepository methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!addTo: aMCRepositoryGroup 	"For now do not add me as an MCRepository"! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!allBranches	self withRepoDo: [ :repo | 			^ OrderedCollection new: 10 streamContents: [ :stream |			repo allBranchesDo: [ :br :isLocal | 				stream nextPut: (					IceBranch 						named: br name 						local: isLocal						inRepository: self frontend) ]]]	! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!branch	"The branch variable and this accessor are useful when you do not have a real git repository yet. Once created it might be safer to use #currentBranch instead."	^ self lookupHead! !!IceLibgitLocalRepository methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!canReadFileNamed: aString 	^ aString endsWith: '.package'! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!changedFilesBetween: aCommitish and: otherCommitish	"Answer a list of files that changed between two commits"	| fromTree toTree |		self withRepoDo: [ :repo | | diff |		fromTree := (LGitCommit of: repo fromId: (LGitId fromHexString: aCommitish id)) tree.		toTree := (LGitCommit of: repo fromId: (LGitId fromHexString: otherCommitish id)) tree.				diff := LGitDiff of: repo.		diff diffTree: fromTree toTree: toTree. 		^ diff files ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!checkoutBranch: newBranchName 	self withRepoDo: [ :repo |		repo checkout: newBranchName ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!cloneRepository	self cloneRepositoryFrom: self origin! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!cloneRepositoryFrom: aRemote	^ self cloneRepositoryFrom: aRemote branch: nil! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!cloneRepositoryFrom: aRemote branch: aBranchName	| url |		url := aRemote url.	LGitGlobal runSequence: [ 		| repo cloneOptions |		repo := LGitRepository on: self location.		cloneOptions := LGitCloneOptions withCredentialsProvider: IceCredentialsProvider default.				repo clone: url options: cloneOptions.		aBranchName ifNotNil: [ 			repo checkout: aBranchName ].		(LGitRemote of: repo named: 'origin')			lookup;			setUrl: url ]! !!IceLibgitLocalRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!commitIdFrom: aLGitCommit 	^ aLGitCommit id hexString! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!commitIndexWithMessage: message andParents: parentCommitishList	self withRepoDo: [ :repo | 		| signature commitId indexTreeId |		[ signature := repo defaultSignature ]		on: LGit_GIT_ENOTFOUND do: [ :e | 			IceGitUsernameOrEmailNotFound guessKind: e ifNot: [ e pass ] ].		indexTreeId := repo index writeTreeAndReturnOid.		 		commitId := (LGitCommitBuilder of: repo)			tree: (LGitTree of: repo fromId: indexTreeId);			message: message;			parents: (repo isUnborn				ifTrue: [ #() ]				ifFalse: [ self libGitCommitsFrom: repo for: parentCommitishList ]);			"'HEAD' branch could not exist yet. No problem, libgit will create it, 			but we have to remember it to notify the frontend."			updateReference: ([ repo head name ] 				on: LGit_GIT_EUNBORNBRANCH				do: [ 'refs/heads/', self branch nameForFirstCommit ]);			author: signature;			committer: signature;			writeCommit;			commitId.					 ^ self class parseCommitInfo: (LGitCommit of: repo fromId: commitId) ]! !!IceLibgitLocalRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!commitsInBranch: branchName do: aBlock	"Iterates commit in a branch, in reverse chronological order (latest first)"	self withRepoDo: [ :repo |		(LGitRevwalk of: repo)			pushReference: (repo lookupBranch: branchName);			beSortedReverse;			do: aBlock ]! !!IceLibgitLocalRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!commitsInCurrentBranchDo: aBlock	self withRepoDo: [ :repo |		(LGitRevwalk of: repo)			pushHead;			do: aBlock.	]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!contentOfFileNamed: aPathString commit: aCommitId	self withRepoDo: [ :repo |		| commit |		commit := LGitCommit of: repo fromHexString: aCommitId.		^ (commit entryByPath: aPathString) object contents	]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!createBranch: branchName	self withRepoDo: [ :repo |		| newBranch |		newBranch := repo createBranch: branchName target: repo head.		repo setHead: newBranch ]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!currentBranch	"#currentBranch will look for the branch in the actual repository,	#branch is the branch that was set to me manually. Normally they should return the same value,	but if the repository does not yet exist, #currentBranch will fail."	self withRepoDo: [ :repo |		^ repo head basename	]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!fetch	self fetchFrom: self origin! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!fetchFrom: aRemote	self withRepoDo: [ :repo | 		(LGitRemote of: repo named: aRemote remoteName) 			lookup; 			fetchWithCredentials: IceCredentialsProvider default ]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!frontend	^ frontend! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!frontend: anObject	frontend := anObject! !!IceLibgitLocalRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!guessUsernameOrEmailNotFound: anError ifNot: notBlock 	(anError messageText = 'Config value ''user.name'' was not found' 		or: [ anError messageText = 'Config value ''user.email'' was not found' ])		ifTrue: [ IceGitUsernameOrEmailNotFound signal ].	notBlock value! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!init	"Initialize new repository (git init)"	LGitGlobal runSequence: [ 		(LGitRepository on: self location) init ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!internalStoreVersion: aMCVersion 	IceMetadatalessFileTreeWriter 		fileOut: aMCVersion 		on: (IceBackendWriterAdapter for: self).! !!IceLibgitLocalRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isCodeMissing	^ self subdirectory isEmptyOrNil 		ifTrue: [ self isMissing ]		ifFalse: [ (self repositoryDirectory / self subdirectory) exists not  ]! !!IceLibgitLocalRepository methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!isUnborn	self withRepoDo: [ :repo | ^ repo isUnborn ]! !!IceLibgitLocalRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!libGitCommitsFrom: aLGitRepository for: aListOfCommitish	^ aListOfCommitish collect: 		[ :commitish | 		LGitCommit of: aLGitRepository fromId: (LGitId fromHexString: commitish id) ]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!localBranchNames	self withRepoDo: [ :repo | ^ repo branches collect: #basename ]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location	^ location! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!location: anObject	location := anObject! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!lookupBranchNamed: branchName inRemote: remoteName	self withRepoDo: [ :repo |		[ repo lookupRemoteBranch: remoteName, '/', branchName ]			on: LGit_GIT_ENOTFOUND do: [ ^ nil ].				^ IceRemoteBranch 			remoteName: remoteName			branchName: branchName			inRepository: self frontend	]! !!IceLibgitLocalRepository methodsFor: 'private' stamp: ' 7/24/2017 12:50:04'!lookupHead	self withRepoDo: [ :repo | 		| head |		repo isUnborn ifTrue: [ ^ IceUnbornBranch new ].		head := repo head.		^ head isBranch 			ifTrue: [ IceLocalBranch named: head basename inRepository: self frontend ] 			ifFalse: [ head object asIcebergObjectInRepository: self ] ]! !!IceLibgitLocalRepository methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!mcVersionFor: iceVersion	self withRepoDo: [ :repo | 		| commit |		commit := LGitCommit of: repo fromId: (LGitId fromHexString: iceVersion commit id).		[ ^ (IceLibgitVersionReader 				on: commit				iceVersion: iceVersion) 				version ] 			on: IceMissingRepositoryEntry 			do: [ IceVersionDoesNotExist new version: iceVersion; signal ]	]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!merge: commitId	self withRepoDo: [ :repo | 		| myCommit theirCommit mergeBase |		"Decide if we can fast-forward or we must do a real merge"				myCommit := repo head object.		theirCommit := LGitCommit of: repo fromHexString: commitId.		mergeBase := repo mergeBaseBetween: myCommit id and: theirCommit id.				(mergeBase = myCommit id)			ifTrue: [ 				"No need to merge, just fast-forward current HEAD"				repo checkout_treeish: theirCommit.				repo head resolve setTargetId: theirCommit id.			]			ifFalse: [				| mergedIndex treeId signature |								"Merge both commits"				mergedIndex := myCommit merge: theirCommit.				mergedIndex hasConflicts 					ifTrue: [ 						"Abort merge and signal for manual merge. 						Index is not saved and repository will be discarded, 						so no further action is needed to abort the merge" 						IceMergeAborted signal 					]					ifFalse: [						"Commit mergedIndex"						signature := repo defaultSignature.						treeId := mergedIndex writeTreeAndReturnOid.						repo checkout_treeish: (LGitTree of: repo fromId: treeId).									(LGitCommitBuilder of: repo)							tree: (LGitTree of: repo fromId: treeId);							message: 'Merge with ', commitId;							parents: { myCommit. theirCommit };							updateReference: repo head name;							author: signature;							committer: signature;							writeCommit.							]			]	]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!mergeBaseBetween: aCommitId and: anotherCommitId 	self withRepoDo: [ :repo |		^ (repo 				mergeBaseBetween: (LGitId fromHexString: aCommitId) 				and: (LGitId fromHexString: anotherCommitId)) 				hexString ]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!newCommitWalk	^ IceLibgitCommitWalk forRepository: self! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!origin	| remotes |	remotes := self remotes.	remotes ifEmpty: [ ^ nil  ].	^ remotes		detect: [ :each | each isOrigin ]		ifNone: [ remotes first ]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!outgoingCommits	self withRepoDo: [ :repo |		| currentBranch commits walk |				commits := OrderedCollection new.		currentBranch := repo lookupBranch: self branch name.			walk := (LGitRevwalk of: repo)			pushReference: currentBranch;			hideReference: currentBranch upstream			yourself.					[ walk hasNext ] whileTrue: [ 			commits add: walk next		].		^ commits	]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!packagesPresentOn: aCommitish	"Answer a list of package names present on this commit"	self withRepoDo: [ :repo | | tree dir sourceEntries |		tree := (LGitCommit of: repo fromId: (LGitId fromHexString: aCommitish id)) tree.		self flag: #todo. "this needs to change with multiple dirs"		dir := self subdirectory.		sourceEntries := dir isEmptyOrNil			ifTrue: [ tree entries ]			ifFalse: [ (tree entryByPath: dir) entries ]. 		^ ((sourceEntries 			collect: [ :each | each filename ])			select: [ :each | each endsWith: '.package' ])			collect: [ :each | each copyFrom: 1 to: (each findString: '.package') - 1 ] ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!pull	self pullFrom: self origin! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!pullFrom: aRemote	self withRepoDo: [ :repo | 		| gitRemote myCommit theirCommit mergeBase |		"Fetch"		gitRemote := (LGitRemote of: repo named: aRemote remoteName) lookup.		gitRemote fetchWithCredentials: IceCredentialsProvider default.				"Decide if we can fast-forward or we must do a real merge"		myCommit := repo head object.		theirCommit := repo head upstream object.		mergeBase := repo mergeBaseBetween: myCommit id and: theirCommit id.				(mergeBase = myCommit id)			ifTrue: [ 				"No need to merge, just fast-forward current HEAD"				repo checkout_treeish: repo head upstream object.				repo fastForward			]			ifFalse: [				| mergedIndex treeId signature |								"Merge both commits"				mergedIndex := myCommit merge: theirCommit.								"Commit index"				signature := repo defaultSignature.				treeId := mergedIndex writeTreeAndReturnOid.					(LGitCommitBuilder of: repo)					tree: (LGitTree of: repo fromId: treeId);					message: 'Merge with ', repo head upstream name;					parents: { myCommit. theirCommit };					updateReference: repo head name;					author: signature;					committer: signature;					writeCommit.					]	]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!push	self pushTo: self origin! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!pushTo: aRemote	self withRepoDo: [ :repo |		| gitRemote reference remoteBranchName |				gitRemote := (LGitRemote of: repo named: aRemote remoteName) lookup.		reference := repo head.			remoteBranchName := reference name. "TODO: https://github.com/npasserini/iceberg/issues/90"				gitRemote			pushWithRefSpec: (LGitRefSpec new				source: reference name;				destination: remoteBranchName;				yourself)			pushOptions: (LGitPushOptions defaults				callbacks: (LGitRemoteCallbacks withProvider: IceCredentialsProvider default);				yourself).		"Since the push created the branch in the remote, we can now add an upstream to this branch."		reference upstream ifNil: [ 			reference setUpstream: aRemote remoteName, '/', reference basename ] ]! !!IceLibgitLocalRepository methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!readableFileNames	self shouldBeImplemented.! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!remoteUrl	self withRepoDo: [ :repo | ^ repo origin url ]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!remotes	| gitRemotes |	self withRepoDo: [ :repo | gitRemotes := repo allRemotes ].	^ gitRemotes collect: [ :each | 		(IceRemote url: each url)			remoteName: each remoteName;			yourself ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!removeRemote: aRemote	self withRepoDo: [ :repo |		(LGitRemote of: repo named: aRemote remoteName) 			lookup;			delete ]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repositoryDirectory	^ self location! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!revparse: aString 	self withRepoDo: [ :repo | 		^ (repo revparse: aString) asIcebergObjectInRepository: self	]! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!revparseCommit: aString 	self withRepoDo: [ :repo | 		^ self iceCommitFrom: (repo revparse: aString) object 	]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!setLongpaths: aBoolean global: globalBoolean 	"set user.name and user.email properties. 	 this could be a nonsense with other backends, but git has them and needs them :)"	self withRepoDo: [ :repo | | config |		config := repo config.		globalBoolean ifTrue: [ config := config openGlobal ].		config setBoolean: 'core.longpaths' to: aBoolean ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!stagedFiles	| statusMask modifiedPaths |	statusMask :=  (LGitStatusTypeEnum git_status_index_new value)				| (LGitStatusTypeEnum git_status_index_modified value)				| (LGitStatusTypeEnum git_status_index_deleted value)				| (LGitStatusTypeEnum git_status_index_typechange value)				| (LGitStatusTypeEnum git_status_index_renamed value).		self withRepoDo: 		[ :repo | 		modifiedPaths := repo index 			entriesSelect: [ :path :status | (status & statusMask) > 0 ] ].	^ modifiedPaths 		collect: [ :entry | entry first asFileReference ]! !!IceLibgitLocalRepository methodsFor: 'actions' stamp: ' 7/24/2017 12:50:04'!storeVersion: aMCVersion 	self withRepoDo: [ :repo | 		| treeBuilder signature parentCommit head |		head := repo head.		parentCommit := head object.		treeBuilder := IceLibgitTreeBuilder on: parentCommit tree.		IceLibgitWriter fileOut: aMCVersion on: (treeBuilder entryByPath: self subdirectory).				signature := repo defaultSignature.		(LGitCommitBuilder of: repo)			tree: treeBuilder buildTree;			message: aMCVersion info message;			parents: { parentCommit };			updateReference: head;			author: signature;			committer: signature;			writeCommit.			]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!subdirectory	^ subdirectory! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!subdirectory: anObject	subdirectory := anObject! !!IceLibgitLocalRepository methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!upstream	self withRepoDo: [ :repo | ^ repo head upstream ifNotNil: #name ]! !!IceLibgitLocalRepository methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!username: aName email: anEmail global: globalBoolean	"set user.name and user.email properties. 	 this could be a nonsense with other backends, but git has them and needs them :)"	self withRepoDo: [ :repo | | config |		config := repo config.		globalBoolean ifTrue: [ config := config openGlobal ].		config 			setString: 'user.name' to: aName;			setString: 'user.email' to: anEmail ]! !!IceLibgitLocalRepository methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!validate	"TODO"! !!IceLibgitLocalRepository methodsFor: 'private auxiliar' stamp: ' 7/24/2017 12:50:04'!withRepoDo: aBlock	LGitGlobal runSequence: [ 		| repo |		repo := (LGitRepository on: self location) open.		aBlock value: repo ]! !!IceLibgitTreeBuilder class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!on: aLGitTree	"Creates a tree builder on the root of the repository"	^ self new initializeWithTree: aLGitTree! !!IceLibgitTreeBuilder methodsFor: 'modifying' stamp: ' 7/24/2017 12:50:04'!addEntryNamed: name withContents: aString	self builder 		addEntry: (LGitBlob of: self repository fromString: aString)		filename: name.			self changes add: name.	hasChanges := true! !!IceLibgitTreeBuilder methodsFor: 'building' stamp: ' 7/24/2017 12:50:04'!buildTree	self children keysAndValuesDo: [ :childEntryName :childBuilder |		childBuilder hasChanges ifTrue: [ 			self builder 				addEntry: childBuilder buildTree				filename: childEntryName		]	].	^ self builder newTree! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!builder	^ builder ifNil: [ 		builder := LGitTreeBuilder 			of: self repository			fromTree: self initialTree ]! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!changes	^ changes ifNil: [ changes := OrderedCollection new ]! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!children	^ children ifNil: [ children := Dictionary new ]! !!IceLibgitTreeBuilder methodsFor: 'modifying' stamp: ' 7/24/2017 12:50:04'!deleteAll	self builder clear.! !!IceLibgitTreeBuilder methodsFor: 'patches' stamp: ' 7/24/2017 12:50:04'!directory	^ self ! !!IceLibgitTreeBuilder methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!entryByName: aString	^ self children 		at: aString 		ifAbsentPut: [  			self class new 				initializeWithParent: self 				entryName: aString ]! !!IceLibgitTreeBuilder methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!entryByPath: aString	^ (aString = '.' )		ifTrue: [ self ]		ifFalse: [( ($/ split: aString) reject: #isEmpty)			inject: self 			into: [ :treeBuilder :name | treeBuilder entryByName: name ]]! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!entryName	^ entryName! !!IceLibgitTreeBuilder methodsFor: 'querying' stamp: ' 7/24/2017 12:50:04'!hasChanges	^ hasChanges		or: [ initialTree isNil "It means that this is a new tree"		or: [ self children anySatisfy: #hasChanges ]]! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!initialTree	^ initialTree! !!IceLibgitTreeBuilder methodsFor: 'initializing' stamp: ' 7/24/2017 12:50:04'!initialize	super initialize.	hasChanges := false.	! !!IceLibgitTreeBuilder methodsFor: 'initializing' stamp: ' 7/24/2017 12:50:04'!initializeWithParent: anIceTreeBuilder entryName: aString	| treeEntry |	parent := anIceTreeBuilder.	entryName := aString.	treeEntry := parent builder getEntryNamed: entryName.	treeEntry isReady "i.e. the entry alredy exists in parent tree"		ifTrue: [ initialTree := treeEntry tree ]		ifFalse: [ 			"The entry didn't exist so this is a new entry"			hasChanges := true ]! !!IceLibgitTreeBuilder methodsFor: 'initializing' stamp: ' 7/24/2017 12:50:04'!initializeWithTree: aLGitTree	"This is a builder on the root of a repository"	initialTree := aLGitTree ! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!parent	^ parent! !!IceLibgitTreeBuilder methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut: $(.	self printPathOn: aStream.	aStream nextPut: $)! !!IceLibgitTreeBuilder methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printPathOn: aStream	parent 		ifNil: [ 			aStream nextPutAll: initialTree repository workingDirectoryName ]		ifNotNil: [ 				parent printPathOn: aStream.			aStream nextPut: $/;				nextPutAll: entryName ] ! !!IceLibgitTreeBuilder methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!repository	^ parent 		ifNotNil: [ self parent repository ]		ifNil: [ self initialTree owner ]! !!IceSemanticVersion class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!fromArray: anArray	^ self 		major: anArray first 		minor: anArray second 		patch: anArray third! !!IceSemanticVersion class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!major: majorNumber minor: minorNumber patch: patchNumber	^ self basicNew 		initializeMajor: majorNumber 			minor: minorNumber 			patch: patchNumber;		yourself! !!IceSemanticVersion class methodsFor: 'instance creation' stamp: ' 7/24/2017 12:50:04'!new	self error: 'Use one of my siblings'! !!IceSemanticVersion methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!< aMagnitude 	"Answer whether the receiver is less than the argument."	| version |	version := aMagnitude iceSemanticVersion.	^ self major < version major		or: [ self minor < version minor 		or: [ self patch < version patch ] ]! !!IceSemanticVersion methodsFor: 'testing' stamp: ' 7/24/2017 12:50:04'!= aMagnitude 	"Compare the receiver with the argument and answer with true if the 	receiver is equal to the argument. Otherwise answer false."	| version |		version := aMagnitude iceSemanticVersion.	^ self major = version major 		and: [ self minor = version minor		and: [ self patch = version patch ] ] ! !!IceSemanticVersion methodsFor: 'hash' stamp: ' 7/24/2017 12:50:04'!hash	^ ((self species hash		bitXor: self major)		bitXor: self minor)		bitXor: self patch! !!IceSemanticVersion methodsFor: 'converting' stamp: ' 7/24/2017 12:50:04'!iceSemanticVersion	^ self! !!IceSemanticVersion methodsFor: 'initialization' stamp: ' 7/24/2017 12:50:04'!initializeMajor: majorNumber minor: minorNumber patch: patchNumber	major := majorNumber.	minor := minorNumber. 	patch := patchNumber! !!IceSemanticVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!major	^ major! !!IceSemanticVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!minor	^ minor! !!IceSemanticVersion methodsFor: 'accessing' stamp: ' 7/24/2017 12:50:04'!patch	^ patch! !!IceSemanticVersion methodsFor: 'printing' stamp: ' 7/24/2017 12:50:04'!printOn: stream 	stream 		<< self major asString 		<< '.' << self minor asString 		<< '.' << self patch asString! !!Magnitude methodsFor: '*Iceberg-Libgit' stamp: ' 7/24/2017 12:50:04'!iceSemanticVersion	^ IceSemanticVersion major: self asInteger minor: 0 patch: 0! !"Iceberg-Libgit"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.586.mcz') load.ScriptLoader new update60510.!----End fileIn----!----QUIT----2017-07-24T12:50:16.527607+02:00 Pharo.image priorSource: 1264256!----QUIT----2017-07-24T12:50:28.334187+02:00 Pharo.image priorSource: 2151637!!ConfigurationOfTeapot commentStamp: 'TorstenBergmann 10/12/2015 10:01' prior: 0!Configuration for Teapot micro web framework.See http://smalltalkhub.com/#!!/~zeroflag/Teapot!!ConfigurationOfTeapot class methodsFor: 'development support' stamp: 'AttilaMagyar 8/24/2014 18:38'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!ConfigurationOfTeapot class methodsFor: 'private' stamp: 'AttilaMagyar 8/24/2014 18:38'!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #MetacelloBaseConfiguration ifAbsent: aBlock ].! !!ConfigurationOfTeapot class methodsFor: 'catalog' stamp: 'TorstenBergmann 10/12/2015 10:02'!catalogChangeLog	"Returns a paragraph describing the most important changes in the configuration class."	^ ' '! !!ConfigurationOfTeapot class methodsFor: 'catalog' stamp: 'TorstenBergmann 10/12/2015 10:01'!catalogContactInfo	"Returns a paragraph describing contact information such as email, mailing lists and website."	^ 'Contact the authors on the Pharo developer list (http://lists.pharo.org)'! !!ConfigurationOfTeapot class methodsFor: 'catalog' stamp: 'TorstenBergmann 10/12/2015 10:02'!catalogDescription	"Returns a paragraph describing the project"	^ 'Teapot is micro web framework on top of the Zinc HTTP components, that focuses on simplicity and ease of use.'! !!ConfigurationOfTeapot class methodsFor: 'catalog' stamp: 'TorstenBergmann 10/12/2015 10:03'!catalogKeyClassesAndExample	"Returns a paragraph or more describing the key classes of your project. You can use Pillar/Pier syntax to layout out the text i.e., ==Code== and - for bullet."	^ 'Checkout the class ==Teapot=='! !!ConfigurationOfTeapot class methodsFor: 'catalog' stamp: 'TorstenBergmann 10/12/2015 10:03'!catalogKeywords	"Returns an array of symbols"	^ #(micro web framework http sinatra) ! !!ConfigurationOfTeapot class methodsFor: 'private' stamp: 'AttilaMagyar 8/24/2014 18:38'!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!ConfigurationOfTeapot class methodsFor: 'private' stamp: 'AttilaMagyar 8/24/2014 18:38'!ensureMetacelloBaseConfiguration	Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			| repository version |			repository := MCHttpRepository location: 'http://seaside.gemstone.com/ss/metacello' user: '' password: ''.			repository				versionReaderForFileNamed: 'Metacello-Base-DaleHenrichs.2.mcz'				do: [ :reader | 					version := reader version.					version load.					version workingCopy repositoryGroup addRepository: repository ] ]! !!ConfigurationOfTeapot class methodsFor: 'metacello tool support' stamp: 'AttilaMagyar 8/24/2014 18:38'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfTeapot class methodsFor: 'loading' stamp: 'AttilaMagyar 8/24/2014 18:38'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!ConfigurationOfTeapot class methodsFor: 'loading' stamp: 'AttilaMagyar 8/24/2014 18:38'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!ConfigurationOfTeapot class methodsFor: 'loading' stamp: 'AttilaMagyar 8/24/2014 18:38'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!ConfigurationOfTeapot class methodsFor: 'accessing' stamp: 'AttilaMagyar 8/24/2014 18:38'!project	^self new project! !!ConfigurationOfTeapot class methodsFor: 'development support' stamp: 'AttilaMagyar 8/24/2014 18:38'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOfTeapot methodsFor: 'baselines' stamp: 'AttilaMagyar 8/24/2014 18:40'!baseline01: spec	<version: '0.1-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/zeroflag/Teapot/main/'.		spec package: 'Teapot-Core'. ].! !!ConfigurationOfTeapot methodsFor: 'baselines' stamp: 'TorstenBergmann 10/12/2015 13:26'!baseline20: spec	<version: '2.0-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/zeroflag/Teapot/main/'.		spec project: 'NeoJSON' with: [				spec					className: #ConfigurationOfNeoJSON;					versionString: #'stable';					repository: 'http://mc.stfx.eu/Neo' ].						spec 			package: 'Teapot-Core' with: [				spec requires: #('NeoJSON' ). ];			package: 'Teapot-Tools' with: [				spec requires: #('Teapot-Core' ). ];			package: 'Teapot-Tests' with: [				spec requires: #('Teapot-Core' ). ].		spec 			group: 'Core' with: #('Teapot-Core' );			group: 'Tools' with: #('Teapot-Tools' );			group: 'Tests' with: #('Teapot-Tests' );			group: 'default' with: #('Tools' 'Tests' ). ].! !!ConfigurationOfTeapot methodsFor: 'baselines' stamp: 'TorstenBergmann 4/13/2016 22:08'!baseline21: spec	<version: '2.1-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/zeroflag/Teapot/main/'.		spec 			project: 'NeoJSON' with: [				spec					className: #ConfigurationOfNeoJSON;					versionString: #'stable';					repository: 'http://mc.stfx.eu/Neo' ];			project: 'WebBrowser' with: [				spec					className: #ConfigurationOfWebBrowser;					versionString: #'stable';					repository: 'http://smalltalkhub.com/mc/TorstenBergmann/WebBrowser/main/' ].		spec 			package: 'Teapot-Core' with: [				spec requires: #('NeoJSON' ). ];			package: 'Teapot-Tools' with: [				spec requires: #('Teapot-Core' 'WebBrowser' ). ];			package: 'Teapot-Tests' with: [				spec requires: #('Teapot-Core' ). ].		spec 			group: 'Core' with: #('Teapot-Core' );			group: 'Tools' with: #('Teapot-Tools' );			group: 'Tests' with: #('Teapot-Tests' );			group: 'default' with: #('Tools' 'Tests' ). ].! !!ConfigurationOfTeapot methodsFor: 'baselines' stamp: 'TorstenBergmann 4/13/2016 22:10'!baseline22: spec	<version: '2.2-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/zeroflag/Teapot/main/'.		spec 			project: 'NeoJSON' with: [				spec					className: #ConfigurationOfNeoJSON;					versionString: #'stable';					repository: 'http://mc.stfx.eu/Neo' ];			project: 'WebBrowser' with: [				spec					className: #ConfigurationOfWebBrowser;					versionString: #'stable';					repository: 'http://smalltalkhub.com/mc/TorstenBergmann/WebBrowser/main/' ].		spec 			package: 'Teapot-Core' with: [				spec requires: #('NeoJSON' ). ];			package: 'Teapot-Tools' with: [				spec requires: #('Teapot-Core' 'WebBrowser' ). ];			package: 'Teapot-Tests' with: [				spec requires: #('Teapot-Core' ). ].		spec 			group: 'Core' with: #('Teapot-Core' );			group: 'Tools' with: #('Teapot-Tools' );			group: 'Tests' with: #('Teapot-Tests' );			group: 'default' with: #('Tools' 'Tests' ). ].! !!ConfigurationOfTeapot methodsFor: 'baselines' stamp: 'TorstenBergmann 10/5/2016 22:14'!baseline23: spec	<version: '2.3-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/zeroflag/Teapot/main/'.		spec 			project: 'NeoJSON' with: [				spec					className: #ConfigurationOfNeoJSON;					versionString: #'stable';					repository: 'http://mc.stfx.eu/Neo' ];			project: 'WebBrowser' with: [				spec					className: #ConfigurationOfWebBrowser;					versionString: #'stable';					repository: 'http://smalltalkhub.com/mc/TorstenBergmann/WebBrowser/main/' ].		spec 			package: 'Teapot-Core' with: [				spec requires: #('NeoJSON' ). ];			package: 'Teapot-Tools' with: [				spec requires: #('Teapot-Core' 'WebBrowser' ). ];			package: 'Teapot-Tests' with: [				spec requires: #('Teapot-Core' ). ].		spec 			group: 'Core' with: #('Teapot-Core' );			group: 'Tools' with: #('Teapot-Tools' );			group: 'Tests' with: #('Teapot-Tests' );			group: 'default' with: #('Tools' 'Tests' ). ].! !!ConfigurationOfTeapot methodsFor: 'baselines' stamp: 'TorstenBergmann 10/5/2016 22:14'!baseline24: spec	<version: '2.4-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/zeroflag/Teapot/main/'.		spec 			project: 'NeoJSON' with: [				spec					className: #ConfigurationOfNeoJSON;					versionString: #'stable';					repository: 'http://mc.stfx.eu/Neo' ];			project: 'WebBrowser' with: [				spec					className: #ConfigurationOfWebBrowser;					versionString: #'stable';					repository: 'http://smalltalkhub.com/mc/TorstenBergmann/WebBrowser/main/' ].		spec 			package: 'Teapot-Core' with: [				spec requires: #('NeoJSON' ). ];			package: 'Teapot-Tools' with: [				spec requires: #('Teapot-Core' 'WebBrowser' ). ];			package: 'Teapot-Tests' with: [				spec requires: #('Teapot-Core' ). ].		spec 			group: 'Core' with: #('Teapot-Core' );			group: 'Tools' with: #('Teapot-Tools' );			group: 'Tests' with: #('Teapot-Tests' );			group: 'default' with: #('Tools' 'Tests' ). ].! !!ConfigurationOfTeapot methodsFor: 'accessing' stamp: 'AttilaMagyar 8/24/2014 18:38'!customProjectAttributes	 "Edit to return a collection of any custom attributes e.g. for conditional loading: Array with: #'Condition1' with: #'Condition2.	For more information see: http://code.google.com/p/metacello/wiki/CustomProjectAttrributes"	^ #().! !!ConfigurationOfTeapot methodsFor: 'symbolic versions' stamp: 'TorstenBergmann 10/5/2016 22:14'!development: spec	<symbolicVersion: #'development'>	spec for: #'common' version: '2.4-baseline'.! !!ConfigurationOfTeapot methodsFor: 'accessing' stamp: 'AttilaMagyar 8/24/2014 18:38'!project	^ project ifNil: [ 		"Bootstrap Metacello if it is not already loaded"		(self class baseConfigurationClassIfAbsent: []) ensureMetacello.		"Construct Metacello project"		project := MetacelloMCProject new projectAttributes: self customProjectAttributes. 		(Smalltalk at: #MetacelloVersionConstructor) on: self project: project.		project loadType: #linear. "change to #atomic if desired"		project ]! !!ConfigurationOfTeapot methodsFor: 'symbolic versions' stamp: 'TorstenBergmann 10/5/2016 22:20'!stable: spec	<symbolicVersion: #'stable'>	spec for: #'common' version: '2.3'.! !!ConfigurationOfTeapot methodsFor: 'versions' stamp: 'AttilaMagyar 8/24/2014 20:01'!version08: spec	<version: '0.8' imports: #('0.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.8'.		spec author: 'AttilaMagyar'.		spec timestamp: '8/24/2014 20:01'.		spec package: 'Teapot-Core' with: 'Teapot-Core-AttilaMagyar.52'. ].! !!ConfigurationOfTeapot methodsFor: 'versions' stamp: 'AttilaMagyar 5/9/2015 20:40'!version091: spec	<version: '0.91' imports: #('0.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.91'.		spec author: 'AttilaMagyar'.		spec timestamp: '5/9/2015 18:18'.		spec package: 'Teapot-Core' with: 'Teapot-Core-AttilaMagyar.76'. ].! !!ConfigurationOfTeapot methodsFor: 'versions' stamp: 'AttilaMagyar 3/1/2015 20:57'!version09: spec	<version: '0.9' imports: #('0.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.9'.		spec author: 'AttilaMagyar'.		spec timestamp: '1/3/2015 20:01'.		spec package: 'Teapot-Core' with: 'Teapot-Core-AttilaMagyar.69'. ].! !!ConfigurationOfTeapot methodsFor: 'versions' stamp: 'TorstenBergmann 10/12/2015 14:07'!version20: spec	<version: '2.0' imports: #('2.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 2.0'.		spec author: 'TorstenBergmann'.		spec timestamp: '10/12/2015 13:11'.		spec project: 'NeoJSON' with: #'stable'.		spec 			package: 'Teapot-Core' with: 'Teapot-Core-TorstenBergmann.80';			package: 'Teapot-Tools' with: 'Teapot-Tools-TorstenBergmann.4';			package: 'Teapot-Tests' with: 'Teapot-Tests-AttilaMagyar.53'. ].! !!ConfigurationOfTeapot methodsFor: 'versions' stamp: 'TorstenBergmann 4/13/2016 22:09'!version21: spec	<version: '2.1' imports: #('2.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 2.1'.		spec author: 'TorstenBergmann'.		spec timestamp: '4/13/2016 22:09'.		spec 			project: 'NeoJSON' with: #'stable';			project: 'WebBrowser' with: #'stable'.		spec 			package: 'Teapot-Core' with: 'Teapot-Core-TorstenBergmann.80';			package: 'Teapot-Tools' with: 'Teapot-Tools-TorstenBergmann.5';			package: 'Teapot-Tests' with: 'Teapot-Tests-AttilaMagyar.53'. ].! !!ConfigurationOfTeapot methodsFor: 'versions' stamp: 'AttilaMagyar 7/11/2016 21:48'!version22: spec	<version: '2.2' imports: #('2.2-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 2.2'.		spec author: 'AttilaMagyar'.		spec timestamp: '11/7/2016 21:45'.		spec 			project: 'NeoJSON' with: #'stable';			project: 'WebBrowser' with: #'stable'.		spec 			package: 'Teapot-Core' with: 'Teapot-Core-AttilaMagyar.84';			package: 'Teapot-Tools' with: 'Teapot-Tools-AttilaMagyar.14';			package: 'Teapot-Tests' with: 'Teapot-Tests-AttilaMagyar.54'. ].! !!ConfigurationOfTeapot methodsFor: 'versions' stamp: 'TorstenBergmann 10/7/2016 23:08'!version23: spec	<version: '2.3' imports: #('2.2-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 2.3'.		spec author: 'TorstenBergmann'.		spec timestamp: '05/10/2016 21:45'.		spec 			project: 'NeoJSON' with: #'stable';			project: 'WebBrowser' with: #'stable'.		spec 			package: 'Teapot-Core' with: 'Teapot-Core-AttilaMagyar.84';			package: 'Teapot-Tools' with: 'Teapot-Tools-TorstenBergmann.19';			package: 'Teapot-Tests' with: 'Teapot-Tests-AttilaMagyar.54'. ].! !"ConfigurationOfTeapot"!!ConfigurationOfNeoJSON commentStamp: '<historical>' prior: 0!I am ConfigurationOfNeoJSON, a Metacello configuration for NeoJSON.NeoJSON is a flexible and efficient reader and writer for JSON.!!ConfigurationOfNeoJSON class methodsFor: 'development support' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!ConfigurationOfNeoJSON class methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #MetacelloBaseConfiguration ifAbsent: aBlock ].! !!ConfigurationOfNeoJSON class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/5/2016 09:38'!catalogContactInfo	^ 'Written and maintained by Sven Van Caekenberghe (http://stfx.eu) and the community. Discussions on the Pharo mailing lists.'! !!ConfigurationOfNeoJSON class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/5/2016 09:39'!catalogDescription	^ 'JSON (JavaScript Object Notation) is a popular data-interchange format. NeoJSON is an elegant and efficient standalone Smalltalk framework to read and write JSON converting to or from Smalltalk objects.'! !!ConfigurationOfNeoJSON class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/5/2016 09:39'!catalogKeywords	^ #(format input output json serialization encoding text javascript)! !!ConfigurationOfNeoJSON class methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!ConfigurationOfNeoJSON class methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!ensureMetacelloBaseConfiguration	Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			| repository version |			repository := MCHttpRepository location: 'http://seaside.gemstone.com/ss/metacello' user: '' password: ''.			repository				versionReaderForFileNamed: 'Metacello-Base-DaleHenrichs.2.mcz'				do: [ :reader | 					version := reader version.					version load.					version workingCopy repositoryGroup addRepository: repository ] ]! !!ConfigurationOfNeoJSON class methodsFor: 'metacello tool support' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfNeoJSON class methodsFor: 'loading' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!ConfigurationOfNeoJSON class methodsFor: 'loading' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!ConfigurationOfNeoJSON class methodsFor: 'loading' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!ConfigurationOfNeoJSON class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!project	^self new project! !!ConfigurationOfNeoJSON class methodsFor: 'development support' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOfNeoJSON methodsFor: 'baselines' stamp: 'SvenVanCaekenberghe 6/22/2012 16:53'!baseline1: spec	<version: '1-baseline'>		spec for: #common do: [		spec 			blessing: #baseline;			repository: 'http://mc.stfx.eu/Neo';			package: 'Neo-JSON-Core';			package: 'Neo-JSON-Tests' with: [ spec requires: 'Neo-JSON-Core' ];			group: 'default' with: #('Neo-JSON-Core' 'Neo-JSON-Tests');			group: 'Core' with: #('Neo-JSON-Core');			group: 'Tests' with: #('Neo-JSON-Tests') ]! !!ConfigurationOfNeoJSON methodsFor: 'baselines' stamp: 'PaulDeBruicker 11/2/2014 20:39'!baseline2: spec	<version: '2-baseline'>	spec		for: #common		do: [ 			spec				blessing: #baseline;				repository: 'http://mc.stfx.eu/Neo';				package: 'Neo-JSON-Core';				package: 'Neo-JSON-Tests' with: [ spec requires: 'Neo-JSON-Core' ];				group: 'default' with: #('Neo-JSON-Core' 'Neo-JSON-Tests');				group: 'Core' with: #('Neo-JSON-Core');				group: 'Tests' with: #('Neo-JSON-Tests') ].	spec		for: #gemstone		do: [ 			spec				baseline: 'NeoJSON' with: [ spec repository: 'github://GsDevKit/NeoJSON:master/repository' ];				import: 'NeoJSON' ]! !!ConfigurationOfNeoJSON methodsFor: 'symbolic versions' stamp: 'SvenVanCaekenberghe 7/11/2016 10:22'!bleedingEdge: spec	<symbolicVersion: #'bleedingEdge'>! !!ConfigurationOfNeoJSON methodsFor: 'symbolic versions' stamp: 'SvenVanCaekenberghe 7/11/2016 10:22'!development: spec	<symbolicVersion: #'development'>! !!ConfigurationOfNeoJSON methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!project	^ project ifNil: [ | constructor |		"Bootstrap Metacello if it is not already loaded"		(self class baseConfigurationClassIfAbsent: []) ensureMetacello.		"Construct Metacello project"		constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.		project := constructor project.		project loadType: #linear. "change to #atomic if desired"		project ]! !!ConfigurationOfNeoJSON methodsFor: 'symbolic versions' stamp: 'SvenVanCaekenberghe 5/29/2017 14:40'!stable: spec	<symbolicVersion: #'stable'>		spec for: #common version: '16'.		spec for: #gemstone version: '13'.! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 3/29/2015 11:39'!version10: spec	<version: '10' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.29';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.26' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 11/25/2015 09:34'!version11: spec	<version: '11' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.30';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.30' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 1/22/2016 12:58'!version12: spec	<version: '12' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.31';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.31' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 7/4/2016 14:58'!version13: spec	<version: '13' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.33';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.33' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 2/2/2017 13:46'!version14: spec	<version: '14' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.37';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.35' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 2/2/2017 13:50'!version15: spec	<version: '15' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.37';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.36' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 5/29/2017 14:40'!version16: spec	<version: '16' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.42';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.39' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 9/27/2012 20:29'!version1: spec	<version: '1' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.17';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.15' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 12/18/2012 10:27'!version2: spec	<version: '2' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.19';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.16' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 5/29/2013 15:54'!version3: spec	<version: '3' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.20';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.16' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 8/30/2013 11:12'!version4: spec	<version: '4' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.23';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.18' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 9/3/2013 12:22'!version5: spec	<version: '5' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.24';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.19' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 12/27/2013 19:02'!version6: spec	<version: '6' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.24';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.20' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 12/27/2013 21:44'!version7: spec	<version: '7' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.24';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.21' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 1/21/2014 20:08'!version8: spec	<version: '8' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.24';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.22' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 4/24/2014 13:29'!version9: spec	<version: '9' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.27';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.24' ]! !"ConfigurationOfNeoJSON"!!ConfigurationOfWebBrowser commentStamp: 'TorstenBergmann 4/13/2016 08:47' prior: 0!General and platform independent WebBrowser access for Pharo 5.0 onwards based on UFFI!!ConfigurationOfWebBrowser class methodsFor: 'development support' stamp: 'TorstenBergmann 4/13/2016 08:45'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!ConfigurationOfWebBrowser class methodsFor: 'private' stamp: 'TorstenBergmann 4/13/2016 08:45'!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #'ConfigurationOf'		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #'ConfigurationOf' ifAbsent: aBlock ].! !!ConfigurationOfWebBrowser class methodsFor: 'catalog' stamp: 'TorstenBergmann 4/13/2016 08:48'!catalogChangeLog	"Returns a paragraph describing the most important changes in the configuration class."	^ ''! !!ConfigurationOfWebBrowser class methodsFor: 'catalog' stamp: 'TorstenBergmann 4/13/2016 08:49'!catalogContactInfo	"Returns a paragraph describing contact information such as email, mailing lists and website."	^ 'You can get in contact with the author on the Pharo mailinglist (http://lists.pharo.org)'! !!ConfigurationOfWebBrowser class methodsFor: 'catalog' stamp: 'TorstenBergmann 4/13/2016 09:22'!catalogDescription	"Returns a paragraph describing the project"	^ 'General and platform independent WebBrowser access for Pharo 4.0 onwards based on NativeBoost, for Pharo 5.0 onwards based on UFFI'! !!ConfigurationOfWebBrowser class methodsFor: 'catalog' stamp: 'TorstenBergmann 4/13/2016 08:49'!catalogKeyClassesAndExample	"Returns a paragraph or more describing the key classes of your project. You can use Pillar/Pier syntax to layout out the text i.e., ==Code== and - for bullet."	^ 'Check the example on the class side of class ==WebBrowser==.'! !!ConfigurationOfWebBrowser class methodsFor: 'catalog' stamp: 'TorstenBergmann 4/13/2016 08:50'!catalogKeywords	"Returns an array of symbols"	^ #(webbrowser utility url platform web internet) ! !!ConfigurationOfWebBrowser class methodsFor: 'private' stamp: 'TorstenBergmann 4/13/2016 08:45'!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!ConfigurationOfWebBrowser class methodsFor: 'private' stamp: 'TorstenBergmann 4/13/2016 08:45'!ensureMetacelloBaseConfiguration  Smalltalk    at: #'ConfigurationOf'    ifAbsent: [       | repository version |      repository := MCHttpRepository        location: 'http://smalltalkhub.com/mc/dkh/metacello/main'        user: ''        password: ''.      repository        versionReaderForFileNamed: 'Metacello-Base-dkh.107'        do: [ :reader |           version := reader version.          version load.          version workingCopy repositoryGroup addRepository: repository ] ]! !!ConfigurationOfWebBrowser class methodsFor: 'metacello tool support' stamp: 'TorstenBergmann 4/13/2016 08:45'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfWebBrowser class methodsFor: 'loading' stamp: 'TorstenBergmann 4/13/2016 08:45'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!ConfigurationOfWebBrowser class methodsFor: 'loading' stamp: 'TorstenBergmann 4/13/2016 08:45'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!ConfigurationOfWebBrowser class methodsFor: 'loading' stamp: 'TorstenBergmann 4/13/2016 08:45'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!ConfigurationOfWebBrowser class methodsFor: 'accessing' stamp: 'TorstenBergmann 4/13/2016 08:45'!project	^self new project! !!ConfigurationOfWebBrowser class methodsFor: 'development support' stamp: 'TorstenBergmann 4/13/2016 08:45'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOfWebBrowser methodsFor: 'baselines' stamp: 'TorstenBergmann 4/13/2016 08:46'!baseline01: spec	<version: '0.1-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/TorstenBergmann/WebBrowser/main/'.		spec package: #'WebBrowser-Core'.		spec 			group: 'Core' with: #(#'WebBrowser-Core' );			group: 'all' with: #('Core' );			group: 'default' with: #('all' ). ].! !!ConfigurationOfWebBrowser methodsFor: 'baselines' stamp: 'TorstenBergmann 4/13/2016 09:47'!baseline02: spec	<version: '0.2-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/TorstenBergmann/WebBrowser/main/'.		spec package: #'WebBrowser-Core'.		spec 			group: 'Core' with: #(#'WebBrowser-Core' );			group: 'all' with: #('Core' );			group: 'default' with: #('all' ). ].! !!ConfigurationOfWebBrowser methodsFor: 'baselines' stamp: 'TorstenBergmann 4/13/2016 09:48'!baseline03: spec	<version: '0.3-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/TorstenBergmann/WebBrowser/main/'.		spec package: #'WebBrowser-Core'.		spec 			group: 'Core' with: #(#'WebBrowser-Core' );			group: 'all' with: #('Core' );			group: 'default' with: #('all' ). ].! !!ConfigurationOfWebBrowser methodsFor: 'accessing' stamp: 'TorstenBergmann 4/13/2016 08:45'!customProjectAttributes    "Edit to return a collection of any custom attributes e.g. for conditional loading: Array with: #'Condition1' with: #'Condition2.	For more information see: http://code.google.com/p/metacello/wiki/CustomProjectAttrributes "    ^ #()! !!ConfigurationOfWebBrowser methodsFor: 'symbolic versions' stamp: 'TorstenBergmann 4/13/2016 09:48'!development: spec	<symbolicVersion: #'development'>	spec for: #'common' version: '0.3-baseline'.! !!ConfigurationOfWebBrowser methodsFor: 'accessing' stamp: 'TorstenBergmann 4/13/2016 08:45'!project    ^ project        ifNil: [             "Bootstrap Metacello if it is not already loaded"            self class ensureMetacello.            project := MetacelloMCProject new projectAttributes: self customProjectAttributes.	"Create the Metacello project"            (Smalltalk at: #'MetacelloVersionConstructor') on: self project: project.	"Construct the project"            project loadType: #'linear'.	"change to #atomic if desired"            project ]! !!ConfigurationOfWebBrowser methodsFor: 'symbolic versions' stamp: 'TorstenBergmann 4/13/2016 09:48'!stable: spec	<symbolicVersion: #'stable'>	spec for: #'pharo4.x' version: '0.1.0'.	spec for: #'common' version: '0.2.0'.! !!ConfigurationOfWebBrowser methodsFor: 'versions' stamp: 'TorstenBergmann 4/13/2016 09:22'!version010: spec	<version: '0.1.0' imports: #('0.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'Version 0.1.0 for Pharo 4 based on NB'.		spec author: 'TorstenBergmann'.		spec timestamp: '4/13/2016 08:46'.		spec package: #'WebBrowser-Core' with: 'WebBrowser-Core-TorstenBergmann.1'. ].! !!ConfigurationOfWebBrowser methodsFor: 'versions' stamp: 'TorstenBergmann 4/13/2016 09:47'!version020: spec	<version: '0.2.0' imports: #('0.2-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'Version 0.2.0 for Pharo 5 based on UFFI'.		spec author: 'TorstenBergmann'.		spec timestamp: '4/13/2016 08:46'.		spec package: #'WebBrowser-Core' with: 'WebBrowser-Core-TorstenBergmann.5'. ].! !"ConfigurationOfWebBrowser"!!NeoJSONMapper commentStamp: '<historical>' prior: 0!I am NeoJSONMapper.I hold a mapping from schema identifiers to objects that known how to read or write instances from or to JSON.Schema identifiers are either Smalltalk classes or Symbols.I offer a builder interface to construct mappings. The standard object mapping represents a Smalltalk object as a map, mapping some or all instance variables, or a set of accessors (getter/setter methods). Furthermore, for each value an optional schema can be specified.Using a custom mapping, a reader and/or writer block can deal with special cases such as specific collection types with an optional schema for the elements, or a direct mapping of semi primitive types such as Date or DateAndTime.A mapping can be specified explicitely on a mapper, or can be resolved using the #neoJsonMapping: class method.Here are some examples:	mapper mapAllInstVarsFor: Point.	mapper for: TestObject do: [ :mapping |		mapping mapInstVars: #(id name).		(mapping mapInstVar: #timestamp to: 'created-at') valueSchema: DateAndTime.		(mapping mapInstVar: #points) valueSchema: #ArrayOfPoints.		(mapping mapInstVar: #bytes) valueSchema: ByteArray ].	mapper for: DateAndTime customDo: [ :mapping |		mapping decoder: [ :string | DateAndTime fromString: string ].		mapping encoder: [ :dateAndTime | dateAndTime printString ] ].	mapper for: #ArrayOfPoints customDo: [ :mapping |		mapping listOfElementSchema: Point ].  	mapper for: ByteArray customDo: [ :mapping |		mapping listOfType: ByteArray ]!!NeoJSONReader commentStamp: 'SvenVanCaekenberghe 3/16/2016 11:23' prior: 0!I am NeoJSONReader.I am a NeoJSONMapper.I parse a JSON representation from a textual stream into Smalltalk objects.Primitive types are automatically mapped to their Smalltalk counterpart: Numbers, Strings, Booleans and UndefinedObject.When parsing using #next, lists normally become Arrays and maps become Dictionaries.An alternative listClass or mapClass can be specified.When parsing using #nextAs: a schema can be specified. This schema defines a mapping to be used.Here are some examples:	NeoJSONReader fromString: ' [ 1,2,3 ] '.	NeoJSONReader fromString: ' [ 3.14159, true, false, null, "string" ] '.	NeoJSONReader fromString: ' { "x" : 1, "y" : 2 } '.		(NeoJSONReader on: ' { "x" : 1, "y" : 2 } ' readStream)		mapInstVarsFor: Point;		nextAs: Point.					(NeoJSONReader on: '[ { "x" : 1, "y" : 2 }, { "x" : 3, "y" : 4 } ]' readStream)		mapInstVarsFor: Point;		for: #ArrayOfPoints customDo: [ :mapping |			mapping listOfElementSchema: Point ];		nextAs: #ArrayOfPoints.	(NeoJSONReader on: '[ { "x" : 1, "y" : 2 }, { "x" : 3, "y" : 4 } ]' readStream)		mapInstVarsFor: Point;		nextListAs: Point.!!NeoJSONWriter commentStamp: '<historical>' prior: 0!I am NeoJSONWriter.I am a NeoJSONMapper.I write a JSON representation of Smalltalk objects to a textual stream.Objects implementing #neoJsonOn: can be encoded.A number of primitive types, like Strings, Numbers, Booleans and UndefinedObject are treated specially.Collection are encoded as lists, except for Dictionaries that are encoded as maps.All other objects need a mapping to help in doing the encoding.Here are some examples:	NeoJSONWriter toString: #(1 2 3).	NeoJSONWriter toString: { Float pi. true. false. 'string' }.	NeoJSONWriter toStringPretty: (Dictionary new at: #x put: 1; at: #y put: 2; yourself).		String streamContents: [ :stream |		(NeoJSONWriter on: stream)			prettyPrint: true;			mapInstVarsFor: Point;			nextPut: (Array with: 1@3 with: -1@3) ].	!!NeoJSONMapping commentStamp: 'SvenVanCaekenberghe 3/23/2014 19:22' prior: 0!I am NeoJSONMapping, an abstract superclass for mapping definitions.!!NeoJSONCustomMapping commentStamp: '<historical>' prior: 0!I am NeoJSONCustomMapping.I read the next JSON value and turn it into a Smalltalk object using a converter block.!!NeoJSONObjectMapping commentStamp: '<historical>' prior: 0!I am NeoJSONObjectMapping.I describe how instances of a Smalltalk class are mapped to a JSON map.I do this using set of NeoJSONPropertyMappings.I know the Smalltalk class that I am a mapping for. This class is the schema identifier and is used to instanciate new objects.A mapping can be based on any combination of instance variables or accessors (getter/setter pairs). I offer a builder interface to constuct property mappings.!!NeoJSONPropertyMapping commentStamp: '<historical>' prior: 0!I am NeoJSONPropertyMapping.I describe how a property of a Smalltalk class maps to a JSON property.A property is either an instance variable or getter/setter pair.I hold a getter and setter block to do the actual work. The property name is used in JSON.Optionally, the schema for the value of my property can be specified. This is then used recursively.!!NeoJSONStreamingWriter commentStamp: '<historical>' prior: 0!I am NeoJSONStreamingWriter.I help in writing streamed maps and lists.This is an internal class used by NeoJSONWriter to deal with interleaving elements and separators as well as pretty printing.!!NeoJSONObject commentStamp: 'SvenVanCaekenberghe 4/26/2017 10:53' prior: 0!I am NeoJSONObject.I am a Dictionary.I behave more like a JavaScript object. I return nil for missing keys. I allow any property to be read or set by using a normal accessor message.The following are equivalent:	self foo.	self at: #foo.As are the following	self foo: 1. 	self at: #foo put: 1.	Except that in the first case, self is returned.I can optionally be used by NeoJSONReader as mapClass (see #mapClass:).For output, I act just like my superclass (it is thus not necessary to do any conversions).Example:	NeoJSONObject fromString: '{"foo":1,"bar":-2}'.	NeoJSONObject new foo: 1; bar: -2.	{ #x -> 100. #y -> 200 } as: NeoJSONObject.	(NeoJSONObject new data: (NeoJSONObject new id: #sensor1; value: 37.5)) asString.I use JSON as my printed representation. To convert me to JSON, use #printString or #asString.Additionally, I support path access for nested instances of me, using #atPath: and #atPath:put:The first is special because it returns nil as soon as a key is missing. The second is special because it creates extra levels (instances of me) as needed to follow the path of keys.	NeoJSONObject new atPath: #(one two three) put: 42; yourself.	NeoJSONObject new atPath: #(one two three) put: 42; atPath: #(one two three).		!!NeoJSONParseError commentStamp: '<historical>' prior: 0!I am NeoJSONParseError.I am an Error.I am signalled when JSON input is not valid while parsing.!!NeoJSONMappingNotFound commentStamp: '<historical>' prior: 0!I am NeoJSONMappingNotFound.I am a NotFound exception.I am signalled when no mapping is found for a schema.!!NeoJSONMapper methodsFor: 'private' stamp: 'SvenVanCaekenberghe 3/22/2014 10:57'!customMappingFor: schemaName	^ self mappings		at: schemaName		ifAbsentPut: [ 			NeoJSONCustomMapping new				schemaName: schemaName;				yourself ]! !!NeoJSONMapper methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 3/22/2014 10:56'!for: schemaName customDo: block	"Execute the code in block to further customize the mapping for schemaName.	Create and add a new custom mapping for schemaName if necessary."		| mapping |	mapping := self customMappingFor: schemaName.	block value: mapping.	^ mapping! !!NeoJSONMapper methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 3/22/2014 10:57'!for: smalltalkClass do: block	"Execute the code in block to further customize the mapping for schemaName.	Create and add a new standard object mapping for schemaName if necessary."		| mapping |	mapping := self objectMappingFor: smalltalkClass.	block value: mapping.	^ mapping! !!NeoJSONMapper methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 3/22/2014 10:54'!mapAllInstVarsFor: smalltalkClass	"Map the instance variables of smalltalkClass and all its super classes"	| mapping |	mapping := self objectMappingFor: smalltalkClass.	mapping mapAllInstVars.	^ mapping! !!NeoJSONMapper methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 3/22/2014 10:54'!mapInstVarsFor: smalltalkClass	"Map the instance variables of smalltalkClass"	| mapping |	mapping := self objectMappingFor: smalltalkClass.	mapping mapInstVars.	^ mapping! !!NeoJSONMapper methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/12/2012 15:48'!mappingFor: schema	^ self 		mappingFor: schema 		ifAbsent: [ NeoJSONMappingNotFound signalFor: schema in: self ]! !!NeoJSONMapper methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:24'!mappingFor: schema ifAbsent: block	(self mappings includesKey: schema)		ifFalse: [ self resolveMappingFor: schema ].	^ self mappings		at: schema		ifAbsent: block! !!NeoJSONMapper methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/7/2012 14:55'!mappings	^ mappings		ifNil: [ mappings := Dictionary new ]! !!NeoJSONMapper methodsFor: 'private' stamp: 'SvenVanCaekenberghe 3/22/2014 10:54'!objectMappingFor: smalltalkClass	^ self mappings		at: smalltalkClass		ifAbsentPut: [ 			NeoJSONObjectMapping new				subjectClass: smalltalkClass;				yourself ]! !!NeoJSONMapper methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/9/2012 18:29'!resolveMappingFor: class	(class respondsTo: #neoJsonMapping:)		ifTrue: [ 			class perform: #neoJsonMapping: with: self ]! !!NeoJSONReader class methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 6/9/2012 18:26'!fromString: string	^ (self on: string readStream) next! !!NeoJSONReader class methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 6/9/2012 18:30'!fromString: string as: schema	^ (self on: string readStream) nextAs: schema! !!NeoJSONReader class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 6/13/2012 16:10'!on: readStream	"Initialize on readStream, which should be a character stream that 	implements #next, #peek, #atEnd and (optionally) #close."	^ self new		on: readStream;		yourself! !!NeoJSONReader methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/6/2013 14:46'!atEnd	^ readStream atEnd! !!NeoJSONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/2/2012 13:50'!close	readStream ifNotNil: [		readStream close.		readStream := nil ]! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/2/2012 21:26'!consumeWhitespace	"Strip whitespaces from the input stream."	[ readStream atEnd not and: [ readStream peek isSeparator ] ]		whileTrue: [ 			readStream next ]! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/12/2012 15:54'!error: text	NeoJSONParseError signal: text! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/2/2012 14:01'!expectChar: character	"Expect character and consume input and optional whitespace at the end,	 throw an error otherwise."	(self matchChar: character)		ifFalse: [ self error: character asString, ' expected' ]! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 5/29/2017 09:38'!failIfNotAtEnd	self atEnd		ifFalse: [ self error: 'extraneous input detected' ]! !!NeoJSONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/13/2012 09:39'!initialize 	super initialize.	propertyNamesAsSymbols := false! !!NeoJSONReader methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/13/2012 09:37'!listClass	"Return the collection type to use for JSON lists"		^ listClass ifNil: [ Array ]! !!NeoJSONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/13/2012 09:38'!listClass: collectionClass	listClass := collectionClass! !!NeoJSONReader methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/13/2012 09:37'!mapClass	"Return the collection type to use for JSON maps"		^ mapClass ifNil: [ Dictionary ]! !!NeoJSONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/13/2012 09:38'!mapClass: collectionClass	mapClass := collectionClass! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/3/2012 10:57'!match: string do: block	"Try to read and consume string and execute block if successful.	Else do nothing (but do not back up)"	(string allSatisfy: [ :each | readStream peekFor: each ])		ifTrue: [ 			self consumeWhitespace.			block value ]! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/3/2012 10:51'!matchChar: character	"Tries to match character, consume input and 	answer true if successful and consumes whitespace at the end.	When character does not match, return false and leave stream untouched."	^ (readStream peekFor: character)		ifTrue: [ 			self consumeWhitespace.			true ]		ifFalse: [ false ]! !!NeoJSONReader methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/7/2012 16:56'!next	"Primary interface to parse a JSON value.	Return either primitives, a listClass or a mapClass instance."		^ self 		consumeWhitespace; 		parseValue! !!NeoJSONReader methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/16/2016 11:21'!nextAs: schema	"Secondary interface to parse JSON.	Return an object according to schema.	If schema is nil, act like #next"		| mapping |	schema ifNil: [ ^ self next ].	self consumeWhitespace.	mapping := self mappingFor: schema.	^ mapping readFrom: self! !!NeoJSONReader methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/16/2016 10:58'!nextListAs: schema	"Secondary interface to parse JSON.	Return a list of objects, each element according to schema."		^ self listClass streamContents: [ :stream |			self parseListDo: [ 				stream nextPut: (self nextAs: schema) ] ]! !!NeoJSONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/13/2012 16:10'!on: aReadStream	"Initialize on aReadStream, which should be a character stream that 	implements #next, #peek, #atEnd and (optionally) #close."		readStream := aReadStream! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 5/29/2017 10:25'!parseCharacter	| char |	(char := readStream next) = $\ 		ifFalse: [ ^ char ].	('/"\' includes: (char := readStream next))		ifTrue: [ ^ char ].	('bfnrt' includes: char)		ifTrue: [ ^ self unescapeChar: char ].	char = $u		ifTrue: [ ^ self parseCharacterHex ].	char 		ifNil: [ self error: 'invalid escape, end of file' ]		ifNotNil: [ self error: 'invalid escape character \' , char asString ]! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/24/2016 14:48'!parseCharacterHex	| value codePoint |	value := self parseCharacterHex4Value.	(value < 16rD800 or: [ value > 16rDBFF ])		ifTrue: [ codePoint := value ]		ifFalse: [ | leadSurrogate trailSurrogate |			"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"			"See https://tools.ietf.org/html/rfc7159#section-7"			leadSurrogate := value.			trailSurrogate := self parseTrailingSurrogateHexEscape.			codePoint := (leadSurrogate - 16rD800) * 16r400 + (trailSurrogate - 16rDC00).			codePoint := 16r10000 + codePoint ].	^ Character codePoint: codePoint! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/24/2016 14:41'!parseCharacterHex4Value	| value |	value := self parseCharacterHexDigit.	3 timesRepeat: [ 		value := (value << 4) + self parseCharacterHexDigit ].	^ value! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/2/2012 14:21'!parseCharacterHexDigit	| digit |	readStream atEnd 		ifFalse: [ 			digit := readStream next asInteger.			(digit between: "$0" 48 and: "$9" 57)				ifTrue: [ ^ digit - 48 ].			(digit between: "$A" 65 and: "$F" 70)				ifTrue: [ ^ digit - 55 ].			(digit between: "$a" 97 and: "$f" 102)				ifTrue: [ ^ digit - 87 ] ].	self error: 'hex-digit expected'! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/2/2012 14:16'!parseConstantDo: block	"Parse and consume either true|false|nil|null and execute block 	or else do nothing (but do not back up).	Hand written implementation to avoid the use of #position:"		(readStream peek = $t)		ifTrue: [			^ self match: 'true' do: [ block value: true ] ].	(readStream peek = $f)		ifTrue: [			^ self match: 'false' do: [ block value: false ] ].	(readStream peek = $n)		ifTrue: [			^ self match: 'null' do: [ block value: nil ] ]! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/7/2012 17:17'!parseList	^ self listClass 		streamContents: [ :stream |			self parseListElementsDo: [ :each |				stream nextPut: each ] ]		! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 5/29/2017 10:56'!parseListDo: block	self expectChar: $[.	(self matchChar: $]) 		ifTrue: [ ^ self ].	[ readStream atEnd ] 		whileFalse: [			block value.			(self matchChar: $]) 				ifTrue: [ ^ self ].			(self matchChar: $,)				ifFalse: [ self error: ', or ] expected' ] ].	self error: 'incomplete list'! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/7/2012 17:16'!parseListElementsDo: block	self parseListDo: [ 		block value: self parseValue ]! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/7/2012 17:23'!parseMap	| map |	map := self mapClass new.	self parseMapKeysAndValuesDo: [ :key :value |		map at: key put: value ].	^ map! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 5/29/2017 10:56'!parseMapDo: block	self expectChar: ${.	(self matchChar: $})		ifTrue: [ ^ self ].	[ readStream atEnd ] whileFalse: [		block value.		(self matchChar: $}) 			ifTrue: [ ^ self ].		(self matchChar: $,)			ifFalse: [ self error: ', or } expected' ] ].	self error: 'incomplete map'! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/7/2012 17:22'!parseMapKeysAndValuesDo: block	self parseMapKeysDo: [ :key |		block value: key value: self parseValue ]! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/7/2012 17:23'!parseMapKeysDo: block	self parseMapDo: [ | key |		key := self parsePropertyName.		self expectChar: $:.		block value: key ]! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 12/3/2012 11:08'!parseNumber	| negated number |	negated := readStream peekFor: $-.	number := self parseNumberInteger.	(readStream peekFor: $.)		ifTrue: [ number := number + self parseNumberFraction ].	((readStream peekFor: $e) or: [ readStream peekFor: $E ])		ifTrue: [ number := number * self parseNumberExponent ].	negated		ifTrue: [ number := number negated ].	self consumeWhitespace.	^ number! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 5/29/2017 09:45'!parseNumberExponent	| number negated |	number := 0.	(negated := readStream peekFor: $-)		ifFalse: [ readStream peekFor: $+ ].	(readStream atEnd or: [ readStream peek isDigit not ])		ifTrue: [ self error: 'number exponent expected' ].	[ readStream atEnd not and: [ readStream peek isDigit ] ]		whileTrue: [ number := 10 * number + readStream next digitValue ].	negated		ifTrue: [ number := number negated ].	number positive 		ifTrue: [ number > Float emax ifTrue: [ self error: 'number exponent too large' ] ]		ifFalse: [ number < Float emin ifTrue: [ self error: 'number exponent too small' ] ].	^ 10 raisedTo: number! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/2/2012 14:00'!parseNumberFraction	| number power |	number := 0.	power := 1.0.	[ readStream atEnd not and: [ readStream peek isDigit ] ] 		whileTrue: [			number := 10 * number + readStream next digitValue.			power := power * 10.0 ].	^ number / power! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/12/2012 16:15'!parseNumberInteger	| number |	number := nil.	[ readStream atEnd not and: [ readStream peek isDigit ] ] 		whileTrue: [ 			number := 10 * (number ifNil: [ 0 ]) + readStream next digitValue ].	number ifNil: [ self error: 'Integer digit expected' ].	^ number! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/13/2012 09:40'!parsePropertyName	| name |	name := self parseValue.	^ name isString		ifTrue: [ 			propertyNamesAsSymbols 				ifTrue: [ name asSymbol ]				ifFalse: [ name ] ]		ifFalse: [ 			self error: 'property name must be a string, not ', name asString ]! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 3/10/2017 13:51'!parseString	| result |	(readStream peekFor: $")		ifFalse: [ self error: '" expected' ].	result := self stringStreamContents: [ :stream | 		[ readStream atEnd or: [ readStream peek = $" ] ] 			whileFalse: [ stream nextPut: self parseCharacter ] ].	self expectChar: $".	^ result! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/24/2016 14:49'!parseTrailingSurrogateHexEscape	(readStream next = $\ and: [ readStream next = $u ])		ifTrue: [ ^ self parseCharacterHex4Value ]		ifFalse: [ self error: 'trailing surrogate hex escape expected' ]! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/12/2012 15:56'!parseValue	| char |	readStream atEnd ifFalse: [ 		char := readStream peek.		char = ${			ifTrue: [ ^ self parseMap ].		char = $[			ifTrue: [ ^ self parseList ].		char = $"			ifTrue: [ ^ self parseString ].		(char = $- or: [ char isDigit ])			ifTrue: [ ^ self parseNumber ].		self parseConstantDo: [ :value | ^ value ] ].	self error: 'invalid input: ', char asString! !!NeoJSONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/13/2012 09:39'!propertyNamesAsSymbols: boolean	propertyNamesAsSymbols := boolean! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/7/2012 16:54'!stringStreamContents: block	"Like String streamContents: block	but reusing the underlying buffer for improved efficiency"		stringStream 		ifNil: [ 			stringStream := (String new: 32) writeStream ].	stringStream reset.	block value: stringStream.	^ stringStream contents! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/7/2012 16:55'!unescapeChar: char	"Handle one of the named character escapes, b, f, n, r or t. Else fail."		char = $b		ifTrue: [ ^ Character backspace ].	char = $f		ifTrue: [ ^ Character newPage ].	char = $n		ifTrue: [ ^ Character lf ].	char = $r		ifTrue: [ ^ Character cr ].	char = $t		ifTrue: [ ^ Character tab ].	self error: 'Unknown escape char: ', (String with: char)! !!NeoJSONWriter class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 6/14/2012 09:54'!on: writeStream	"Initialize on writeStream, which should be a character stream that 	implements #nextPut:, #nextPutAll:, #space and (optionally) #close."	^ self new		on: writeStream;		yourself! !!NeoJSONWriter class methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 6/9/2012 18:27'!toString: object	^ String streamContents: [ :stream |			(self on: stream) nextPut: object ]! !!NeoJSONWriter class methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 6/9/2012 18:28'!toStringPretty: object	^ String streamContents: [ :stream |			(self on: stream)				prettyPrint: true; 				nextPut: object ]! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 9/3/2013 12:00'!asciiOnly: boolean	asciiOnly := boolean! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/2/2012 22:06'!close	writeStream ifNotNil: [		writeStream close.		writeStream := nil ]! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 9/3/2013 11:58'!doesCodePointNeedEscaping: code	code < 32 ifTrue: [ ^ true ].	( code = 34 or: [ code = 92 ]) ifTrue: [ ^ true ].	^ asciiOnly and: [ code > 126 ]	! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 9/3/2013 11:55'!encodeChar: char	| code |	code := char codePoint.	(self doesCodePointNeedEscaping: code)		ifTrue: [ self escapeChar: code ]		ifFalse: [ writeStream nextPut: char ]! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/3/2012 19:41'!encodeKey: key value: value	self nextPut: key.	self prettyPrintSpace.	writeStream nextPut: $:.	self prettyPrintSpace.	self nextPut: value! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 3/23/2014 21:53'!encodeKey: key value: value as: valueSchema	self nextPut: key.	self prettyPrintSpace.	writeStream nextPut: $:.	self prettyPrintSpace.	self nextPut: value as: valueSchema! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/24/2016 14:17'!escapeChar: code	code = 34		ifTrue: [ ^ writeStream nextPutAll: '\"' ].	code = 92		ifTrue: [ ^ writeStream nextPutAll: '\\' ].	code = 47		ifTrue: [ ^ writeStream nextPutAll: '\/' ].	code = 8		ifTrue: [ ^ writeStream nextPutAll: '\b' ].	code = 12		ifTrue: [ ^ writeStream nextPutAll: '\f' ].			code = 10		ifTrue: [ ^ writeStream nextPutAll: '\n' ].			code = 13		ifTrue: [ ^ writeStream nextPutAll: '\r' ].			code = 9		ifTrue: [ ^ writeStream nextPutAll: '\t' ].			self escapeUnicode: code! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/24/2016 14:29'!escapeUnicode4: codePoint	writeStream nextPutAll: '\u'.	codePoint printOn: writeStream base: 16 nDigits: 4! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 11/24/2016 10:06'!escapeUnicode: codePoint	codePoint <= 16rFFFF		ifTrue: [ self escapeUnicode4: codePoint ]		ifFalse: [ 			codePoint <= 16r10FFFF				ifTrue: [ | leadSurrogate trailSurrogate shifted |					"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"					"See https://tools.ietf.org/html/rfc7159#section-7"					shifted := codePoint - 16r10000.					leadSurrogate := 16rD800 + (shifted // 16r400).					trailSurrogate := 16rDC00 + (shifted \\ 16r400).					self escapeUnicode4: leadSurrogate.					self escapeUnicode4: trailSurrogate ]				ifFalse: [ self error: 'Character Unicode code point outside encoder range' ] ]! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/3/2012 19:31'!indentedDo: block	level := level + 1.	block value.	level := level - 1! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 5/28/2014 20:43'!initialize	super initialize.	self newLine: String cr.	self prettyPrint: false.	self asciiOnly: false.	self writeNil: false.	level := 0! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/3/2012 19:32'!listElementSeparator	writeStream nextPut: $,.	self newlineIndent! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/3/2012 19:32'!mapElementSeparator	writeStream nextPut: $,.	self newlineIndent! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 12/10/2012 16:27'!newLine: string	newLine := string! !!NeoJSONWriter methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 4/17/2014 11:58'!newline	"Write a newline on the stream that I wrap.	What gets written depends on the configuration, see #newLine:"		writeStream nextPutAll: newLine! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 4/17/2014 11:55'!newlineIndent	prettyPrint		ifTrue: [ 			self newline.			level timesRepeat: [ writeStream nextPut: Character tab ] ]! !!NeoJSONWriter methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/2/2012 22:11'!nextPut: anObject	anObject neoJsonOn: self! !!NeoJSONWriter methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/23/2014 21:57'!nextPut: anObject as: schema	"Secondary interface to write JSON.	Write objects according to schema."		| mapping |	schema ifNil: [ ^ self nextPut: anObject ].	mapping := self mappingFor: schema.	^ mapping writeObject: anObject on: self! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/14/2012 09:54'!on: aWriteStream	"Initialize on aWriteStream, which should be a character stream that 	implements #nextPut:, #nextPutAll:, #space and (optionally) #close."	writeStream := aWriteStream! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/2/2012 22:06'!prettyPrint: boolean	prettyPrint := boolean! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/10/2012 16:33'!prettyPrintSpace	prettyPrint		ifTrue: [ writeStream nextPut: Character space ]! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/2/2012 22:18'!writeBoolean: boolean	boolean printOn: writeStream! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/2/2012 22:19'!writeFloat: float	float printOn: writeStream! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/2/2012 22:18'!writeInteger: integer	integer printOn: writeStream	! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:20'!writeList: collection	self writeListStreamingDo: [ :jsonListWriter |		collection do: [ :each |			jsonListWriter writeElement: each ] ]! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:19'!writeListStreamingDo: block	writeStream nextPut: $[.	self writeStreamingDo: block.	writeStream nextPut: $]! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:04'!writeMap: keyValueCollection	self writeMapStreamingDo: [ :jsonMapWriter |		keyValueCollection keysAndValuesDo: [ :key :value |			jsonMapWriter writeKey: key value: value ] ]! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:19'!writeMapStreamingDo: block	writeStream nextPut: ${.	self writeStreamingDo: block.	writeStream nextPut: $}! !!NeoJSONWriter methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2014 20:44'!writeNil	^ writeNil! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 5/28/2014 20:43'!writeNil: boolean	writeNil := boolean! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/2/2012 22:15'!writeNull	writeStream nextPutAll: 'null'! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/7/2012 15:55'!writeObject: anObject	| mapping |	mapping := self mappingFor: anObject class.	mapping		writeObject: anObject		on: self! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:19'!writeStreamingDo: block	| mapWriter |	mapWriter := NeoJSONStreamingWriter on: self.	self indentedDo: [		block value: mapWriter ].	mapWriter wasUsed		ifTrue: [ self newlineIndent ]		ifFalse: [ self prettyPrintSpace ]! !!NeoJSONWriter methodsFor: 'writing' stamp: 'MaxLeske 4/30/2017 13:40'!writeString: string	writeStream nextPut: $".	1 to: string size do: [ :index |		self encodeChar: (string at: index) ].	writeStream nextPut: $"! !!NeoJSONCustomMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/13/2012 11:14'!decoder: block	"Set a decoder block that accepts the next object representation read 	and converts it into the actual object to be returned."	self reader: [ :jsonReader | | representation |		representation := jsonReader next.		block value: representation ]! !!NeoJSONCustomMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/13/2012 11:14'!encoder: block	"Set a encoder block that accepts the next object to be written 	and converts it into the actual representation to be written."	self writer: [ :jsonWriter :anObject | | representation |		representation := block value: anObject.		jsonWriter nextPut: representation ]! !!NeoJSONCustomMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/23/2014 19:24'!identifier	^ schemaName ! !!NeoJSONCustomMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/13/2012 11:38'!listOfElementSchema: elementSchema	"Set the reader to a block that will create an instance of the	standard listClass while reading a list of elements of type elementSchema"	self reader: [ :jsonReader |		jsonReader listClass streamContents: [ :stream |			jsonReader parseListDo: [ | element |				element := jsonReader nextAs: elementSchema.				stream nextPut: element ] ] ]	"we do not set a writer, #neoJsonOn: should be sufficient"! !!NeoJSONCustomMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/13/2012 11:25'!listOfType: collectionClass	"Set the reader to a block that will create an instance of collectionClass 	using #streamContents: while reading a list of elements"	self reader: [ :jsonReader |		collectionClass streamContents: [ :stream |			jsonReader parseListDo: [ | element |				element := jsonReader next.				stream nextPut: element ] ] ]	"we do not set a writer, #neoJsonOn: should be sufficient"! !!NeoJSONCustomMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/13/2012 11:39'!listOfType: collectionClass andElementSchema: elementSchema	"Set the reader to a block that will create an instance of collectionClass 	using #streamContents: while reading a list of elements of type elementSchema"	self reader: [ :jsonReader |		collectionClass streamContents: [ :stream |			jsonReader parseListDo: [ | element |				element := jsonReader nextAs: elementSchema.				stream nextPut: element ] ] ]	"we do not set a writer, #neoJsonOn: should be sufficient"! !!NeoJSONCustomMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 8/30/2013 11:04'!mapWithValueSchema: valueSchema	"Set the reader to a block that will create an instance of the	standard mapClass while reading values of type valueSchema,	with standard keys"	self reader: [ :jsonReader | | map |		map := jsonReader mapClass new.		jsonReader parseMapKeysDo: [ :key | | value |				value := jsonReader nextAs: valueSchema.				map at: key put: value ].		map ]	"we do not set a writer, #neoJsonOn: should be sufficient"! !!NeoJSONCustomMapping methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 3/24/2014 10:34'!readFrom: jsonReader	^ reader 		ifNil: [ jsonReader next ]		ifNotNil: [ reader value: jsonReader ]! !!NeoJSONCustomMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/24/2014 10:36'!reader: block	"Set the reader to block, a 1 argument block that when given 	a jsonReader as argument reads the object that I represent.	When there is no reader block, the default #next will be used."		reader := block! !!NeoJSONCustomMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/8/2012 21:09'!schemaName: schema	schemaName := schema! !!NeoJSONCustomMapping methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 3/23/2014 22:10'!writeObject: anObject on: jsonWriter	writer 		ifNil: [ anObject neoJsonOn: jsonWriter ]		ifNotNil: [ writer value: jsonWriter value: anObject ]! !!NeoJSONCustomMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/23/2014 22:12'!writer: block	"Set the writer to block, a 2 argument block that when given: a jsonWriter 	and the object to write will write the object that I represent.	When there is no writer block, the default #neoJsonOn: will be used."		writer := block! !!NeoJSONMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/23/2014 19:22'!identifier	self subclassResponsibility ! !!NeoJSONMapping methodsFor: 'printing' stamp: 'SvenVanCaekenberghe 3/23/2014 19:24'!printOn: stream	super printOn: stream.	stream nextPut: $(; print: self identifier; nextPut: $)! !!NeoJSONMapping methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 3/23/2014 19:23'!readFrom: jsonReader	self subclassResponsibility ! !!NeoJSONMapping methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 3/23/2014 19:23'!writeObject: anObject on: jsonWriter	self subclassResponsibility ! !!NeoJSONObjectMapping methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 12/30/2015 11:44'!allowNil	allowNil := true! !!NeoJSONObjectMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/23/2014 19:25'!identifier	^ subjectClass ! !!NeoJSONObjectMapping methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 7/11/2016 10:54'!initialize	super initialize.	properties := OrderedCollection new.	allowNil := false! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/12/2012 13:13'!mapAccessor: accessor	^ self mapAccessor: accessor to: accessor ! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/12/2012 13:12'!mapAccessor: accessor mutator: mutator to: propertyName	^ self 		mapProperty: propertyName		getter: [ :object | object perform: accessor ]		setter: [ :object :value | object perform: mutator with: value ] ! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/12/2012 13:13'!mapAccessor: accessor to: propertyName	^ self 		mapProperty: propertyName		getter: [ :object | object perform: accessor ]		setter: [ :object :value | object perform: accessor asMutator with: value ] ! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/12/2012 13:14'!mapAccessors: accessors	accessors do: [ :each |		self mapAccessor: each ]! !!NeoJSONObjectMapping methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 6/6/2012 16:00'!mapAllInstVars	self mapInstVars: subjectClass allInstVarNames! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/9/2012 18:37'!mapInstVar: instVarName	^ self mapInstVar: instVarName to: instVarName ! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/9/2012 18:36'!mapInstVar: instVarName to: propertyName	| index |	index := subjectClass 		instVarIndexFor: instVarName 		ifAbsent: [ self error: 'Inst var not found: ', instVarName printString ].	^ self 		mapProperty: propertyName		getter: [ :object | object instVarAt: index ]		setter: [ :object :value | object instVarAt: index put: value ] ! !!NeoJSONObjectMapping methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 6/6/2012 15:59'!mapInstVars	self mapInstVars: subjectClass instVarNames! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/6/2012 16:00'!mapInstVars: instVarNames	instVarNames do: [ :each |		self mapInstVar: each ]! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 7/11/2016 11:01'!mapProperty: propertyName getter: readBlock setter: writeBlock	| propertyMapping |	propertyMapping := NeoJSONPropertyMapping new.	propertyMapping 		propertyName: propertyName;		getter: readBlock;		setter: writeBlock.	properties removeAllSuchThat: [ :each | each propertyName = propertyName ].	properties addLast: propertyMapping.	^ propertyMapping ! !!NeoJSONObjectMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 7/11/2016 10:58'!propertyNamed: propertyName ifAbsent: block	^ properties detect: [ :each | each propertyName = propertyName ] ifNone: block! !!NeoJSONObjectMapping methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 12/30/2015 11:48'!readFrom: jsonReader	| anObject |	anObject := subjectClass new.	allowNil ifTrue: [ 		jsonReader parseConstantDo: [ :value | 			^ value ifNotNil: [ jsonReader error: 'Unexpected boolean constant' ] ] ].	jsonReader parseMapKeysDo: [ :key |		(self propertyNamed: key ifAbsent: [ nil ])			ifNil: [				"read, skip & ignore value"				jsonReader next ]			ifNotNil: [ :mapping |				mapping readObject: anObject from: jsonReader ] ].	^ anObject! !!NeoJSONObjectMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:32'!subjectClass: smalltalkClass	subjectClass := smalltalkClass! !!NeoJSONObjectMapping methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 7/11/2016 10:54'!writeObject: anObject on: jsonWriter	jsonWriter writeMapStreamingDo: [ :jsonMapWriter |		properties do: [ :each |			each writeObject: anObject on: jsonMapWriter ] ]! !!NeoJSONPropertyMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:34'!getter: block	getter := block! !!NeoJSONPropertyMapping methodsFor: 'printing' stamp: 'SvenVanCaekenberghe 7/4/2013 19:07'!printOn: stream	super printOn: stream.	stream nextPut: $(; print: propertyName; nextPut: $)! !!NeoJSONPropertyMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 7/11/2016 10:59'!propertyName	^ propertyName ! !!NeoJSONPropertyMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:34'!propertyName: string	propertyName := string! !!NeoJSONPropertyMapping methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/8/2012 17:04'!readObject: anObject from: jsonReader	| value |	value := jsonReader nextAs: valueSchema.	setter value: anObject value: value! !!NeoJSONPropertyMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:34'!setter: block	setter := block! !!NeoJSONPropertyMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/8/2012 17:01'!valueSchema: schemaName	valueSchema := schemaName! !!NeoJSONPropertyMapping methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 5/28/2014 20:46'!writeObject: anObject on: jsonMapWriter	| value |	value := getter value: anObject.	(value notNil or: [ jsonMapWriter writeNil ])		ifTrue: [ jsonMapWriter writeKey: propertyName value: value as: valueSchema ] ! !!NeoJSONStreamingWriter class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 6/6/2012 15:05'!on: jsonWriter	^ self new		on: jsonWriter;		yourself! !!NeoJSONStreamingWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/6/2012 14:48'!initialize	super initialize.	first := true! !!NeoJSONStreamingWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/6/2012 14:49'!on: aJSONWriter	jsonWriter := aJSONWriter! !!NeoJSONStreamingWriter methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:00'!wasUsed	^ first not! !!NeoJSONStreamingWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:15'!writeElement: value	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter listElementSeparator ].	jsonWriter nextPut: value ! !!NeoJSONStreamingWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:01'!writeKey: key value: value	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter mapElementSeparator ].	jsonWriter encodeKey: key value: value ! !!NeoJSONStreamingWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 3/23/2014 21:53'!writeKey: key value: value as: valueSchema	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter mapElementSeparator ].	jsonWriter encodeKey: key value: value as: valueSchema! !!NeoJSONStreamingWriter methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2014 20:45'!writeNil	^ jsonWriter writeNil! !!Object methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/5/2012 22:29'!neoJsonOn: neoJSONWriter	neoJSONWriter writeObject: self! !!Number methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/2/2012 22:17'!neoJsonOn: neoJSONWriter	neoJSONWriter writeFloat: self asFloat! !!Dictionary methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/3/2012 19:30'!neoJsonOn: neoJSONWriter	neoJSONWriter writeMap: self! !!NeoJSONObject class methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 9/8/2014 13:33'!fromString: string	"Parse string as JSON, so that maps become instances of me"	^ (NeoJSONReader on: string readStream)			mapClass: NeoJSONObject;			propertyNamesAsSymbols: true;			next! !!NeoJSONObject methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 9/8/2014 11:43'!at: key	"I return nil for missing keys.	My superclass would signal a KeyNotFound."		^ self at: key ifAbsent: [ nil ]! !!NeoJSONObject methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 4/26/2017 09:06'!atPath: keyCollection	"Use each key in keyCollection recursively, stop when nil is encountered"		| value |	value := self.	keyCollection do: [ :each |		value := value at: each.		value ifNil: [ ^ nil ] ].	^ value ! !!NeoJSONObject methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 4/26/2017 11:29'!atPath: keyCollection put: newValue	"Use each key in keyCollection recursively, create new levels when needed"		| target |	keyCollection ifEmpty: [ ^ self ].	target := self.	keyCollection allButLastDo: [ :each |		(target at: each)			ifNil: [ target := target at: each put: target species new ]			ifNotNil: [ :subValue | target := subValue ] ].	^ target at: keyCollection last put: newValue! !!NeoJSONObject methodsFor: 'reflective operations' stamp: 'SvenVanCaekenberghe 2/3/2017 14:29'!doesNotUnderstand: message	"Overwritten so that 'self foo' becomes 'self at: #foo'	and 'self foo: 1' becomes 'self at: #foo put: 1' except that self is returned"		| key |	key := message selector.	key isUnary		ifTrue: [ ^ self at: key ].	^ (key isKeyword and: [ key numArgs = 1 ])		ifTrue: [ self at: key allButLast asSymbol put: message arguments first; yourself ]		ifFalse: [ super doesNotUnderstand: message ]! !!NeoJSONObject methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 9/8/2014 11:46'!name	"Overwritten to make this accessor available as key"		^ self at: #name! !!NeoJSONObject methodsFor: 'printing' stamp: 'SvenVanCaekenberghe 9/8/2014 11:45'!printOn: stream	"I use my JSON representation when printing myself"		(NeoJSONWriter on: stream) nextPut: self! !!NeoJSONObject methodsFor: 'evaluating' stamp: 'SvenVanCaekenberghe 9/8/2014 11:46'!value	"Overwritten to make this accessor available as key"		^ self at: #value! !!UndefinedObject methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/2/2012 22:15'!neoJsonOn: neoJSONWriter	neoJSONWriter writeNull! !!String methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/2/2012 22:26'!neoJsonOn: neoJSONWriter	neoJSONWriter writeString: self! !!Boolean methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/2/2012 22:14'!neoJsonOn: neoJSONWriter	neoJSONWriter writeBoolean: self! !!Integer methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/2/2012 22:17'!neoJsonOn: neoJSONWriter	neoJSONWriter writeInteger: self! !!OrderedDictionary methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 8/26/2015 12:03'!neoJsonOn: neoJSONWriter	neoJSONWriter writeMap: self! !!Collection methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/3/2012 19:29'!neoJsonOn: neoJSONWriter	neoJSONWriter writeList: self! !!SmallDictionary methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/3/2012 19:30'!neoJsonOn: neoJSONWriter	neoJSONWriter writeMap: self! !!NeoJSONMappingNotFound methodsFor: 'printing' stamp: 'SvenVanCaekenberghe 6/12/2012 15:47'!standardMessageText	^ String streamContents: [ :stream |		stream << 'No mapping found for '.		stream print: self object.		stream << ' in '.		stream print: self collection class ]! !"Neo-JSON-Core"!!NeoJSONBenchmarkTests commentStamp: 'SvenVanCaekenberghe 6/5/2012 10:05' prior: 0!I am NeoJSONBenchmarkTests.This test is obviously dependent on hardware, but the margin is quite high.!!NeoJSONObjectTests commentStamp: 'SvenVanCaekenberghe 9/8/2014 12:39' prior: 0!I am NeoJSONObjectTests, I hold unit tests for NeoJSONObject.!!NeoJSONReaderTests commentStamp: 'SvenVanCaekenberghe 6/2/2012 14:02' prior: 0!I am NeoJSONReaderTests, a test suite for NeoJSONReader.!!NeoJSONWriteReadTests commentStamp: 'SvenVanCaekenberghe 6/4/2012 15:34' prior: 0!I am NeoJSONWriteReadTests.!!NeoJSONWriteReadAsciiOnlyTests commentStamp: 'SvenVanCaekenberghe 11/24/2016 10:07' prior: 0!I am NeoJSONWriteReadAsciiOnlyTests.!!NeoJSONWriteReadMockStreamTests commentStamp: 'SvenVanCaekenberghe 11/24/2016 10:07' prior: 0!I am NeoJSONWriteReadMockStreamTests.!!NeoJSONWriteReadPrettyPrintedTests commentStamp: 'SvenVanCaekenberghe 6/5/2012 09:50' prior: 0!I am NeoJSONWriteReadPrettyPrintedTests.!!NeoJSONWriterTests commentStamp: 'SvenVanCaekenberghe 6/2/2012 22:20' prior: 0!I am NeoJSONWriterTests, a test suite for NeoJSONWriter.!!NeoJSONBenchmark commentStamp: 'SvenVanCaekenberghe 6/5/2012 09:48' prior: 0!I am NeoJSONBenchmark.I hold 1000 objects of the form Dictionary('color'->'green' 'enabled'->false 'id'->1 'name'->'Name-1' 'value'->0.002 ) in an Array.I hold the JSON serialization of that as a String of the form '[{"value":0.002,"enabled":false,"name":"Name-1","color":"green","id":1}, ...| benchmark |benchmark := NeoJSONBenchmark new.[benchmark read] bench.| benchmark |benchmark := NeoJSONBenchmark new.[benchmark write] bench.| benchmark |benchmark := NeoJSONBenchmark new.[benchmark read] timeToRun.| benchmark |benchmark := NeoJSONBenchmark new.[benchmark write] timeToRun.!!NeoJSONMockStream commentStamp: '<historical>' prior: 0!I am NeoJSONMockStream.I wrap another stream to validate the limited API used.!!NeoJSONTestObject1 commentStamp: '<historical>' prior: 0!I am NeoJSONTestObject1.I repesent a domain model object.I have the following properties:- id <Integer>- name <String>- timestamp <DateAndTime>- points <Array of: Point>- bytes <ByteArray>My JSON representation is like this:- id <Number>- name <String>- created-at <ISO8601 String>- points <Array of: <Map x,y>- bytes <Array of: Number>!!NeoJSONTestObject2 commentStamp: 'SvenVanCaekenberghe 3/22/2014 09:36' prior: 0!I am NeoJSONTestObject2.Instance Variables	data:		<String>	height:		<Integer>	id:			<Integer>	width:		<Integer>Used for benchmarking and other tests.!!NeoJSONTestObject3 commentStamp: 'SvenVanCaekenberghe 3/22/2014 09:40' prior: 0!I am NeoJSONTestObject3, a subclass of NeoJSONTestObject2.Instance Variables	color:			<String>	transparent :	<Boolean>I am used for inheritance testing.!!NeoJSONValidation commentStamp: 'SvenVanCaekenberghe 5/28/2017 16:40' prior: 0!I am NeoJSONValidation, a set of tests to validate NeoJSON against some external rules.Both positive & negative tests are includes.Some of these are implementation choices.http://seriot.ch/parsing_json.phphttps://github.com/nst/JSONTestSuitehttps://github.com/nst/JSONTestSuite.git  test_parsing  test_transformhttps://github.com/miloyip/nativejson-benchmarkhttps://github.com/miloyip/nativejson-benchmark.git  data/jsonchecker  data/roundtripThis can only be run with the correct setup (checkout/config).  NeoJSONValidation new runNativeJsonBenchmarkRoundTrip.  NeoJSONValidation new runNativeJsonBenchmarkJsonCheckerPasses.  NeoJSONValidation new runNativeJsonBenchmarkJsonCheckerFailures.  NeoJSONValidation new runJsonTestSuiteTestParsingPasses.  NeoJSONValidation new runJsonTestSuiteTestParsingFailures.  NeoJSONValidation new runJsonTestSuiteTestParsingInfo.Logging goes to a file, neo-json-validation.log!!NeoJSONBenchmarkTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:20'!testObject2	| json |	json := NeoJSONWriter toString: NeoJSONTestObject2 new.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject2)		equals: NeoJSONTestObject2 new! !!NeoJSONBenchmarkTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/15/2014 19:29'!testPrettyPrinted	| benchmark |	benchmark := NeoJSONBenchmark new.	self		assert: benchmark writePrettyPrintedRead		equals: benchmark read! !!NeoJSONBenchmarkTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/15/2014 19:30'!testRead	| benchmark |	benchmark := NeoJSONBenchmark new.	benchmark read! !!NeoJSONBenchmarkTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/15/2014 19:30'!testWrite	| benchmark |	benchmark := NeoJSONBenchmark new.	benchmark write! !!NeoJSONObjectTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 4/26/2017 16:14'!testAtPath	| object |	object := { #one -> ({ #two -> ({ #three -> 42 } as: NeoJSONObject) } as: NeoJSONObject) } as: NeoJSONObject.	self assert: (object atPath: #(one two three)) equals: 42.	self assert: (object atPath: #(one two three)) equals: object one two three.		self assert: (object atPath: #(missing)) equals: nil.	self assert: (object atPath: #(one missing)) equals: nil.	self assert: (object atPath: #(one two missing)) equals: nil.	self assert: (object atPath: #(one two missing)) equals: object one two missing.		object := { #foo -> 42 } as: NeoJSONObject.	self assert: (object atPath: #(foo)) equals: 42.	self assert: (object atPath: #(foo)) equals: object foo.	self assert: (object atPath: #(foo)) equals: (object at: #foo).	self assert: (object atPath: #()) equals: object.	! !!NeoJSONObjectTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 4/26/2017 16:17'!testAtPathPut	| object |	object := NeoJSONObject new.	object atPath: #(one test) put: 42.	self assert: (object atPath: #(one test)) equals: 42.	self assert: object one test equals: 42.	object atPath: #(one two three) put: #foo.	self assert: (object atPath: #(one two three)) equals: #foo.	self assert: object one two three equals: #foo.	object atPath: #(one two threeBis) put: #bar.	self assert: (object atPath: #(one two threeBis)) equals: #bar.	self assert: object one two threeBis equals: #bar.		self assert: object foo isNil.	self assert: (object atPath: #() put: 1) equals: object.	self assert: (object atPath: #(foo) put: 1) equals: 1.	self assert: (object atPath: #(foo)) equals: 1.	self assert: object foo equals: 1	 ! !!NeoJSONObjectTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 9/8/2014 12:39'!testCRUD	| object |	object := NeoJSONObject new.	self assert: object isEmpty.	self assert: object foo equals: nil.	object foo: 123.	self assert: object foo equals: 123.	self assert: object printString equals: '{"foo":123}'.	object name: 'test'.	object value: Float pi.	self assert: object name equals: 'test'.	self assert: (object value closeTo: Float pi).	self assert: object keys asSet equals: #(foo name value) asSet.	object removeKey: #foo.	self assert: object foo equals: nil.	object removeAll.	self assert: object isEmpty! !!NeoJSONObjectTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 11/25/2015 09:19'!testJSON	| data  json object |	data := { #foo->1. #bar->2. #str->'Str!!'. #bool->true. #flt->1.5 } as: NeoJSONObject.	json := NeoJSONWriter toString: data .	object := NeoJSONObject fromString: json.	self assert: object class equals: NeoJSONObject.	self assert: object equals: data.	json := (NeoJSONWriter toString: object).	self assert: (NeoJSONObject fromString: json) equals: object! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 12/30/2015 12:29'!testAllowNil	self 		should: [ 			(NeoJSONReader on: 'null' readStream)				mapInstVarsFor: Point;				nextAs: Point ] 		raise: NeoJSONParseError.	self		assert: ((NeoJSONReader on: 'null' readStream)						mapInstVarsFor: Point;						for: Point do: [ :mapping | mapping allowNil ];						nextAs: Point)		equals: nil.	self		assert: ((NeoJSONReader on: '[ { "x" : 1, "y" : 2 }, null, { "x" : 3, "y" : -1 } ]' readStream)						mapInstVarsFor: Point;						for: Point do: [ :mapping | mapping allowNil ];						for: #ArrayOfPoints customDo: [ :mapping | mapping listOfElementSchema: Point ];						nextAs: #ArrayOfPoints)		equals: { 1 @ 2. nil. 3 @ -1 }.! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:32'!testArrayOfPoints	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			for: #ArrayOfPoints customDo: [ :mapping |				mapping listOfElementSchema: Point ];			nextAs: #ArrayOfPoints ].	self assert: (reader value: '[ { "x":1, "y":2 }, { "x":-1, "y":-2 } ]') equals: { 1@2. -1@ -2 }. 	self assert: (reader value: '[ ]') equals: #().	self assert: (reader value: '[ { } ]') equals: { Point new }! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/16/2016 10:58'!testArrayOfPointsUsingNextListAs	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			mapInstVarsFor: Point;			nextListAs: Point ].	self assert: (reader value: '[ { "x":1, "y":2 }, { "y":-2, "x":-1 } ]') equals: { 1@2. -1@ -2 }. 	self assert: (reader value: '[ ]') equals: #().	self assert: (reader value: '[ { } ]') equals: { Point new }! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 13:18'!testAssociation	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Association do: [ :mapping |				mapping mapAccessors: #(key value) ]; 			nextAs: Association ].	self assert: (reader value: '{"key":"foo","value":42}') equals: 'foo' -> 42. 	self assert: (reader value: '{}') equals: Association new! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/13/2012 14:44'!testBooleans	self assert: (NeoJSONReader on: 'true' readStream) next equals: true.	self assert: (NeoJSONReader on: 'false' readStream) next equals: false.	self should: [ (NeoJSONReader on: 'tru' readStream) next ] raise: NeoJSONParseError.	self should: [ (NeoJSONReader on: 'falsE' readStream) next ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:32'!testByteArray	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: ByteArray customDo: [ :mapping |				mapping listOfType: ByteArray ];			nextAs: ByteArray ].	self assert: (reader value: '[ 1, 2, 3 ]') equals: #[1 2 3].	self assert: (reader value: '[ ]') equals: ByteArray new! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:02'!testDate	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: Date customDo: [ :mapping |				mapping decoder: [ :string | Date fromString: string ] ];			nextAs: Date ].	self assert: (reader value: ' "2012-06-08" ') equals: (Date newDay: 8 month: 6 year: 2012)! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:02'!testDateAndTime 	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: DateAndTime customDo: [ :mapping |				mapping decoder: [ :string | DateAndTime fromString: string ] ];			nextAs: DateAndTime ].	self 		assert: (reader value: ' "2012-02-14T16:40:18+01:00" ') 		equals: (DateAndTime year: 2012 month: 2 day: 14 hour: 16 minute: 40 second: 18 offset: 1 hour)! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/2/2012 21:49'!testFloats	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: ((reader value: '123.0') closeTo: 123.0).	self assert: ((reader value: '-123.0') closeTo: -123.0).	self assert: ((reader value: '123.0e0') closeTo: 123.0).	self assert: ((reader value: '123e6') closeTo: 123e6).	self assert: ((reader value: '123e+6') closeTo: 123e6).	self assert: ((reader value: '123e-6') closeTo: 123e-6).	self assert: ((reader value: '123E6') closeTo: 123e6).	self assert: ((reader value: '123E+6') closeTo: 123e6).	self assert: ((reader value: '123E-6') closeTo: 123e-6).	self assert: ((reader value: '-123e6') closeTo: -123e6).	self assert: ((reader value: '-123e-6') closeTo: -123e-6).	self assert: ((reader value: '-123E6') closeTo: -123e6).	self assert: ((reader value: '-123E-6') closeTo: -123e-6).	self assert: ((reader value: '3.14159') closeTo: Float pi).	self assert: ((reader value: '0.123e6') closeTo: 0.123e6).	self assert: ((reader value: '0.123e-6') closeTo: 0.123e-6).	self assert: ((reader value: '-0.123E6') closeTo: -0.123e6).	self assert: ((reader value: '-0.123E-6') closeTo: -0.123e-6).! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 16:08'!testIntegers	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '123') equals: 123.	self assert: (reader value: '00123') equals: 123.	self assert: (reader value: '-123') equals: -123.	self assert: (reader value: '-0123') equals: -123.	self assert: (reader value: '0') equals: 0.	self assert: (reader value: '-0') equals: 0.	self assert: (reader value: '00') equals: 0.	self assert: (reader value: ' 123	') equals: 123.	self should: [ reader value: '+1' ] raise: NeoJSONParseError.	self should: [ reader value: ' - ' ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 16:16'!testLists	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '[1,2,3]') equals: #(1 2 3).	self assert: (reader value: '[]') equals: #().	self assert: (reader value: ' [ 1 , 2 , 3 ] ') equals: #(1 2 3).	self assert: (reader value: ' [ ] ') equals: #().	self should: [ reader value: '[1,]' ] raise: NeoJSONParseError. 	self should: [ reader value: '[' ] raise: NeoJSONParseError.	self should: [ reader value: ']' ] raise: NeoJSONParseError.	self should: [ reader value: '[}' ] raise: NeoJSONParseError! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 16:16'!testMaps	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '{"x":1,"y":2}') equals: (Dictionary newFromPairs: #( 'x' 1 'y' 2)).	self assert: (reader value: '{}') equals: Dictionary new.	self assert: (reader value: ' { "x" : 1 , "y" : 2 } ' ) equals: (Dictionary newFromPairs: #( 'x' 1 'y' 2)).	self assert: (reader value: ' { } ') equals: Dictionary new.	self should: [ reader value: '{"foo":}' ] raise: NeoJSONParseError. 	self should: [ reader value: '{"foo":9,}' ] raise: NeoJSONParseError. 	self should: [ reader value: '{9:true,}' ] raise: NeoJSONParseError. 	self should: [ reader value: '{' ] raise: NeoJSONParseError.	self should: [ reader value: '}' ] raise: NeoJSONParseError.	self should: [ reader value: '{]' ] raise: NeoJSONParseError! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/24/2014 11:58'!testNextStringAsHex	| string |	string := (NeoJSONReader on: '"466F6F2062617221"' readStream)		for: #StringAsHex			customDo: [ :mapping | 					mapping						encoder: [ :x | x asByteArray hex asUppercase ];						decoder: [ :x | (ByteArray readHexFrom: x) asString ] ];		nextAs: #StringAsHex.	self assert: string equals: 'Foo bar!!'! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/24/2016 14:15'!testNonBMPCharacterDecoding	"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"	| string object |	string := String with: 16r1D11E asCharacter. "MUSICAL SYMBOL G CLEF"	object := (NeoJSONReader fromString: '"\uD834\uDD1E"').	self assert: object equals: string! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/13/2012 14:29'!testNull	self assert: (NeoJSONReader on: 'null' readStream) next equals: nil.	self assert: (NeoJSONReader on: '	null ' readStream) next equals: nil.	self should: [ (NeoJSONReader on: '	nil ' readStream) next ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/13/2012 10:18'!testOrderedCollection	| json list |	json := '[ 1, 2, 3 ]'.	list := (NeoJSONReader on: json readStream) 		listClass: OrderedCollection;		next.	self 		assert: list 		equals: (OrderedCollection with: 1 with: 2 with: 3).	self 		assert: list class 		equals: OrderedCollection! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:33'!testOrderedCollectionOfPoints	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			for: #OrderedCollectionOfPoints customDo: [ :mapping |				mapping listOfType: OrderedCollection andElementSchema: Point ];			nextAs: #OrderedCollectionOfPoints ].	self assert: (reader value: '[ { "x":1, "y":2 }, { "x":-1, "y":-2 } ]') equals: { 1@2. -1@ -2 } asOrderedCollection. 	self assert: (reader value: '[ ]') equals: OrderedCollection new.	self assert: (reader value: '[ { } ]') equals: (OrderedCollection with: Point new)! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 5/29/2017 11:00'!testParseErrors	self should: [ NeoJSONReader fromString: 'zero' ] raise: NeoJSONParseError.	self should: [ NeoJSONReader fromString: '#' ] raise: NeoJSONParseError.	self should: [ NeoJSONReader fromString: '@' ] raise: NeoJSONParseError.		self should: [ (NeoJSONReader on: '[1,2,3]true' readStream) next; failIfNotAtEnd ] raise: NeoJSONParseError.	self should: [ (NeoJSONReader on: '{"foo":1}"extra"' readStream) next; failIfNotAtEnd ] raise: NeoJSONParseError.	self should: [ (NeoJSONReader on: '[]"extra"' readStream) next; failIfNotAtEnd ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 15:58'!testPoint	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) nextAs: Point ].	self should: [ reader value: '{"x":1,"y":2}' ] raise: NeoJSONMappingNotFound! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/8/2012 14:04'!testPoint1	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapProperty: 'x' getter: [ :point | point x ] setter: [ :point :value | point setX: value setY: point y ].				mapping mapProperty: 'y' getter: [ :point | point y ] setter: [ :point :value | point setX: point x setY: value ]. ];			nextAs: Point ].	self assert: (reader value: '{"x":1,"y":2}') equals: 1@2. 	self assert: (reader value: '{}') equals: Point new! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/7/2012 15:23'!testPoint2	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			mapAllInstVarsFor: Point;			nextAs: Point ].	self assert: (reader value: '{"x":1,"y":2}') equals: 1@2. 	self assert: (reader value: '{}') equals: Point new! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/8/2012 14:04'!testPoint3	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			nextAs: Point ].	self assert: (reader value: '{"x":1,"y":2}') equals: 1@2. 	self assert: (reader value: '{}') equals: Point new! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/24/2014 10:43'!testPointUsingAsString	| point |	point := (NeoJSONReader on: '{"x":"1","y":"2"}' readStream)		for: Point			do: [ :mapping | 					(mapping 						mapProperty: #x 						getter: [ :object | object x ] 						setter: [ :object :value | object setX: value setY: object y ])						valueSchema: #AsString.					(mapping						mapProperty: #y						getter: [ :object | object y ]						setter: [ :object :value | object setX: object x setY: value ]) 						valueSchema: #AsString ];		for: #AsString			customDo: [ :mapping | 					mapping						encoder: [ :x | x asString ];						decoder: [ :x | x asNumber ] ];		nextAs: Point.	self assert: point equals: 1 @ 2! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/13/2012 10:00'!testPropertyNamesAsSymbols	| json map |	json := '{ "x" : true, "y" : false, "key-1" : 1 }'.	map := (NeoJSONReader on: json readStream) 		propertyNamesAsSymbols: true; 		next.	self 		assert: map 		equals: (Dictionary new at: #x put: true; at: #y put: false; at: #'key-1' put: 1; yourself).	self assert: (map keys allSatisfy: [ :each | each isSymbol ])! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 7/4/2013 18:38'!testSmallDictionary	| json map smallDictionaryClass |	json := '{ "x" : true, "y" : false, "key-1" : 1 }'.	smallDictionaryClass := Smalltalk at: #SmallDictionary ifAbsent: [ Dictionary ].	map := (NeoJSONReader on: json readStream) 		mapClass: smallDictionaryClass;		next.	self 		assert: map 		equals: (smallDictionaryClass new at: #x put: true; at: #y put: false; at: #'key-1' put: 1; yourself).	self 		assert: map class 		equals: smallDictionaryClass! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/10/2017 13:49'!testStrings	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '"foo"') equals: 'foo'.	self assert: (reader value: '""') equals: ''.	self assert: (reader value: '"Foo BAR"') equals: 'Foo BAR'.	self assert: (reader value: '" foo "') equals: ' foo '.	self assert: (reader value: '"\u00E9l\u00E8ve en Fran\u00E7ais"') equals: 'élève en Français'.	self 		assert: (reader value: '"\"\\\/\t\r\n\f\b"') 		equals: (String withAll: { 					$". $\. $/. Character tab. Character cr. Character lf.  Character newPage. Character backspace }).	self should: [ reader value: '"open' ] raise: NeoJSONParseError.	self should: [ reader value: '"\uAA"' ] raise: NeoJSONParseError.	self should: [ reader value: '"\uZZ"' ] raise: NeoJSONParseError.	self should: [ reader value: '"\x"' ] raise: NeoJSONParseError.	self should: [ reader value: ' " ' ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:02'!testSymbol	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: Symbol customDo: [ :mapping |				mapping decoder: [ :string | string asSymbol ] ];			nextAs: Symbol ].	self assert: (reader value: ' "foo" ') equals: #foo.	self assert: (reader value: ' "FOO-1" ') equals: #'FOO-1'! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:02'!testTime	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: Time customDo: [ :mapping |				mapping decoder: [ :string | Time fromString: string ] ];			nextAs: Time ].	self assert: (reader value: ' "14:30:08" ') equals: (Time hour: 14 minute: 30 second: 8)! !!NeoJSONWriteReadAsciiOnlyTests methodsFor: 'private' stamp: 'SvenVanCaekenberghe 11/24/2016 10:03'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) asciiOnly: true; nextPut: object ].	^ (NeoJSONReader on: json readStream) next ! !!NeoJSONWriteReadMockStreamTests methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/13/2012 16:28'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: (NeoJSONMockStream on: stream))			prettyPrint: true;			nextPut: object ].	^ (NeoJSONReader on: (NeoJSONMockStream on: json readStream)) next ! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 8/30/2013 11:05'!testDictionaryOfObject2	| data json reader |	data := Dictionary new.	data 		at: #one put: NeoJSONTestObject2 example1;		at: #two put: NeoJSONTestObject2 example1.	json := NeoJSONWriter toStringPretty: data.	reader := NeoJSONReader on: json readStream.	reader for: #DictionaryOfObject2 customDo: [ :mapping |		mapping mapWithValueSchema: NeoJSONTestObject2 ].  	self 		assert: (reader nextAs: #DictionaryOfObject2)		equals: data! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:49'!testObject1	| json |	json := NeoJSONWriter toStringPretty: NeoJSONTestObject1 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject1)		equals: NeoJSONTestObject1 example1! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 8/30/2013 11:05'!testObject2	| json |	json := NeoJSONWriter toStringPretty: NeoJSONTestObject2 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject2)		equals: NeoJSONTestObject2 example1! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/22/2014 10:59'!testObject3	| json |	json := NeoJSONWriter toStringPretty: NeoJSONTestObject3 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject3)		equals: NeoJSONTestObject3 example1! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/4/2012 15:45'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) 			prettyPrint: true;			nextPut: object ].	^ (NeoJSONReader on: json readStream) next ! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 8/30/2013 11:03'!testDictionaryOfObject2	| data json reader |	data := Dictionary new.	data 		at: #one put: NeoJSONTestObject2 example1;		at: #two put: NeoJSONTestObject2 example1.	json := NeoJSONWriter toString: data.	reader := NeoJSONReader on: json readStream.	reader for: #DictionaryOfObject2 customDo: [ :mapping |		mapping mapWithValueSchema: NeoJSONTestObject2 ].  	self 		assert: (reader nextAs: #DictionaryOfObject2)		equals: data! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/4/2012 15:51'!testFloats	| objects |	objects := { Float pi . 1.0 . -1.0 . 0.0 . 1.5e6 . -1.5e6 . 1.5e-6 . -1.5e-6 }.	(self writeRead: objects) 		with: objects 		do: [ :first :second | self assert: (first closeTo: second) ]! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/4/2012 15:46'!testIntegers	| objects |	objects := { 1. -1. 0. 123467890. -1234567890 }.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/4/2012 15:51'!testLists	| objects |	objects := { #(1 2 3). #(). #( 'foo' 'bar') }.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/4/2012 15:53'!testMaps	| objects |	objects := { 		Dictionary new.		Dictionary with: 'x' -> 1.		Dictionary newFromPairs: #( 'foo' true 'bar' false 'zero' 0 'null' nil 'string' 'Hello World!!' ) }.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:48'!testObject1	| json |	json := NeoJSONWriter toString: NeoJSONTestObject1 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject1)		equals: NeoJSONTestObject1 example1! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 8/30/2013 10:12'!testObject2	| json |	json := NeoJSONWriter toString: NeoJSONTestObject2 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject2)		equals: NeoJSONTestObject2 example1! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/22/2014 10:14'!testObject3	| json |	json := NeoJSONWriter toString: NeoJSONTestObject3 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject3)		equals: NeoJSONTestObject3 example1! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/4/2012 15:46'!testSpecials	| objects |	objects := { true. false. nil }.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 11/24/2016 10:04'!testStrings	| objects |	objects := { 		'foo'. 'Foo BAR'. ''. '	\\'''. 		'élève en Français'. 		String with: (Character codePoint: 12354) "HIRAGANA LETTER A" }.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/4/2012 15:36'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) nextPut: object ].	^ (NeoJSONReader on: json readStream) next ! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 9/3/2013 12:06'!testAsciiOnlyStrings	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				asciiOnly: true;				nextPut: object ] ].	self assert: (writer value: 'élève français') equals: '"\u00E9l\u00E8ve fran\u00E7ais"'.	self assert: (writer value: 'foo') equals: '"foo"'.	self assert: (writer value: 'Foo BAR') equals: '"Foo BAR"'.	self assert: (writer value: '') equals: '""'.	self		assert: (writer value: (String withAll: { 					$". $\. $/. Character tab. Character cr. Character lf.  Character newPage. Character backspace }))		equals: '"\"\\/\t\r\n\f\b"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 13:19'!testAssociation	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Association do: [ :mapping |					mapping mapAccessors: #(key value) ]; 				nextPut: object ] ].	self assert: (writer value: 'foo' -> 42) equals: '{"key":"foo","value":42}'.	self assert: (writer value: Association new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/3/2012 19:56'!testBooleans	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: true) equals: 'true'.	self assert: (writer value: false) equals: 'false'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/8/2012 21:54'!testByteArray	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: #[1 2 3]) equals: '[1,2,3]'.	self assert: (writer value: #[]) equals: '[]'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:02'!testDate	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Date customDo: [ :mapping |					mapping encoder: [ :date | date yyyymmdd ] ];				nextPut: object ] ].	self assert: (writer value: (Date newDay: 8 month: 6 year: 2012)) equals: '"2012-06-08"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:02'!testDateAndTime 	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: DateAndTime customDo: [ :mapping |					mapping encoder: [ :dateAndTime | dateAndTime printString ] ];				nextPut: object ] ].	self 		assert: (writer value: (DateAndTime year: 2012 month: 2 day: 14 hour: 16 minute: 40 second: 18 offset: 1 hour)) 		equals: '"2012-02-14T16:40:18+01:00"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/2/2012 22:24'!testFloats	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: 123.0) equals: '123.0'.	self assert: (writer value: -123.0) equals: '-123.0'.	self assert: (writer value: 0.0) equals: '0.0'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/2/2012 22:24'!testIntegers	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: 123) equals: '123'.	self assert: (writer value: -123) equals: '-123'.	self assert: (writer value: 0) equals: '0'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/3/2012 19:39'!testLists	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: #(1 2 3)) equals: '[1,2,3]'.	self assert: (writer value: #()) equals: '[]'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 9/4/2015 14:02'!testListsExtra	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	#( OrderedCollection LinkedList ByteArray IntegerArray SortedCollection ) do: [ :each |		Smalltalk at: each ifPresent: [ :collectionClass |			self assert: (writer value: (collectionClass withAll: #(1 2 3))) equals: '[1,2,3]'.			self assert: (writer value: collectionClass new) equals: '[]' ] ]! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/3/2012 19:40'!testMaps	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: (Dictionary newFromPairs: #( 'x' 1 'y' 2))) equals: '{"x":1,"y":2}'.	self assert: (writer value: Dictionary new) equals: '{}'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 8/26/2015 14:05'!testMapsExtra	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: (IdentityDictionary newFromPairs: #( 'x' 1))) equals: '{"x":1}'.	self assert: (writer value: IdentityDictionary new) equals: '{}'.	#( SmallDictionary OrderedDictionary OrderedIdentityDictionary ) do: [ :each |		| dictionaryClass |		dictionaryClass := Smalltalk at: each ifAbsent: [ nil ].		dictionaryClass ifNotNil: [				self assert: (writer value: (dictionaryClass new at: 'x' put: 1; at: 'y' put: 2; yourself)) equals: '{"x":1,"y":2}'.			self assert: (writer value: dictionaryClass new) equals: '{}'] ]! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/24/2014 11:57'!testNextPutStringAsHex	| output |	output := String		streamContents: [ :out | 			(NeoJSONWriter on: out)				for: #StringAsHex					customDo: [ :mapping | 							mapping								encoder: [ :x | x asByteArray hex asUppercase ];								decoder: [ :x | (ByteArray readHexFrom: x) asString ] ];				nextPut: 'Foo bar!!' as: #StringAsHex ].	self assert: output equals: '"466F6F2062617221"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/24/2016 14:15'!testNonBMPCharacterEncoding	"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"	| string json |	string := String with: 16r1D11E asCharacter. "MUSICAL SYMBOL G CLEF"	json := String streamContents: [ :out |		(NeoJSONWriter on: out) asciiOnly: true; nextPut: string ].	self assert: json equals: '"\uD834\uDD1E"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/2/2012 22:23'!testNull	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: nil) equals: 'null'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 15:58'!testPoint	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self should: [ writer value: 1@2 ] raise: NeoJSONMappingNotFound! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/8/2012 14:04'!testPoint1	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Point do: [ :mapping |					mapping mapProperty: 'x' getter: [ :point | point x ] setter: [ :point :value | point x: value ].					mapping mapProperty: 'y' getter: [ :point | point y ] setter: [ :point :value | point y: value ]. ];				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/6/2012 17:29'!testPoint2	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				mapAllInstVarsFor: Point;				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/8/2012 14:04'!testPoint3	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Point do: [ :mapping |					mapping mapInstVars: #(x y) ];				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/24/2014 10:41'!testPointUsingAsString	| output |	output := String		streamContents: [ :out | 			(NeoJSONWriter on: out)				for: Point					do: [ :mapping | 							(mapping 								mapProperty: #x 								getter: [ :object | object x ] 								setter: [ :object :value | object setX: value setY: object y ])								valueSchema: #AsString.							(mapping								mapProperty: #y								getter: [ :object | object y ]								setter: [ :object :value | object setX: object x setY: value ]) 								valueSchema: #AsString ];				for: #AsString					customDo: [ :mapping | 							mapping								encoder: [ :x | x asString ];								decoder: [ :x | x asNumber ] ];				nextPut: 1 @ 2 ].	self assert: output equals: '{"x":"1","y":"2"}'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 5/28/2014 20:49'!testPointWriteNil	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				writeNil: true;				mapAllInstVarsFor: Point;				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{"x":null,"y":null}'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 7/1/2016 23:50'!testPreservePropertyOrder	| writer testObject |	(testObject := NeoJSONTestObject2 new)		id: 123;		width: 100;		height: 50;		data: 'test'.	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: NeoJSONTestObject2 do: [ :mapping | mapping mapInstVars: #(id width height data) ];				nextPut: object ] ].	self assert: (writer value: testObject) equals: '{"id":123,"width":100,"height":50,"data":"test"}'.	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: NeoJSONTestObject2 do: [ :mapping | mapping mapInstVars: #(width height data id) ];				nextPut: object ] ].	self assert: (writer value: testObject) equals: '{"width":100,"height":50,"data":"test","id":123}'.	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: NeoJSONTestObject2 do: [ :mapping | mapping mapInstVars: #(data id height width) ];				nextPut: object ] ].	self assert: (writer value: testObject) equals: '{"data":"test","id":123,"height":50,"width":100}'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/10/2012 21:15'!testStrings	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: 'foo') equals: '"foo"'.	self assert: (writer value: 'Foo BAR') equals: '"Foo BAR"'.	self assert: (writer value: '') equals: '""'.	self		assert: (writer value: (String withAll: { 					$". $\. $/. Character tab. Character cr. Character lf.  Character newPage. Character backspace }))		equals: '"\"\\/\t\r\n\f\b"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/8/2012 21:56'!testSymbol	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: #foo) equals: '"foo"'.	self assert: (writer value: #'FOO-1') equals: '"FOO-1"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:02'!testTime	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Time customDo: [ :mapping |					mapping encoder: [ :time | time print24 ] ];				nextPut: object ] ].	self assert: (writer value: (Time hour: 14 minute: 30 second: 8)) equals: '"14:30:08"'! !!NeoJSONBenchmark methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/4/2012 18:49'!initialize	super initialize.	objects := Array new: 1000.	1 to: 1000 do: [ :each |		| map |		(map := Dictionary new)			at: 'id' put: each;			at: 'name' put: 'Name-', each asString;			at: 'enabled' put: (#( true false) at: (each \\ 2) + 1);			at: 'color' put: (#( 'red' 'green' 'blue' ) at: (each \\ 3) + 1);			at: 'value' put: each + each / 1000.0.		objects at: each put: map ].	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) nextPut: objects ]		! !!NeoJSONBenchmark methodsFor: 'public' stamp: 'SvenVanCaekenberghe 6/4/2012 17:02'!read	^ (NeoJSONReader on: json readStream) next! !!NeoJSONBenchmark methodsFor: 'public' stamp: 'SvenVanCaekenberghe 6/4/2012 17:26'!write	^ String streamContents: [ :stream |		(NeoJSONWriter on: stream) nextPut: objects ]! !!NeoJSONBenchmark methodsFor: 'public' stamp: 'SvenVanCaekenberghe 6/6/2012 15:07'!writePrettyPrintedRead	| output |	output := String streamContents: [ :stream |		(NeoJSONWriter on: stream) 			prettyPrint: true;			nextPut: objects ].	^ (NeoJSONReader on: output readStream) 		next! !!NeoJSONMockStream class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 6/13/2012 16:25'!on: stream	^ self new		stream: stream;		yourself! !!NeoJSONMockStream methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/13/2012 16:23'!atEnd	^ stream atEnd! !!NeoJSONMockStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/13/2012 16:23'!close	^ stream close! !!NeoJSONMockStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/13/2012 16:22'!next	^ stream next! !!NeoJSONMockStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/13/2012 16:23'!nextPut: character	^ stream nextPut: character! !!NeoJSONMockStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/13/2012 16:23'!nextPutAll: string	^ stream nextPutAll: string! !!NeoJSONMockStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/13/2012 16:22'!peek	^ stream peek! !!NeoJSONMockStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 12/3/2012 10:53'!peekFor: char	^ stream peekFor: char! !!NeoJSONMockStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/13/2012 16:23'!space	^ stream space! !!NeoJSONMockStream methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/13/2012 16:22'!stream: anObject	stream := anObject! !!NeoJSONTestObject1 class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 6/9/2012 18:06'!example1	^ self new		id: 123;		name: 'Example1';		timestamp: (DateAndTime year: 2012 month: 06 day: 08 hour: 14 minute: 30 second: 15 offset: 1 hour);		points: { 1@2. 3@4 };		bytes: #[ 2 4 6 8 ];		yourself! !!NeoJSONTestObject1 class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:34'!neoJsonMapping: mapper	mapper for: self do: [ :mapping |		mapping mapInstVars: #(id name).		(mapping mapInstVar: #timestamp to: 'created-at') valueSchema: DateAndTime.		(mapping mapInstVar: #points) valueSchema: #ArrayOfPoints.		(mapping mapInstVar: #bytes) valueSchema: ByteArray ].	mapper for: DateAndTime customDo: [ :mapping |		mapping decoder: [ :string | DateAndTime fromString: string ].		mapping encoder: [ :dateAndTime | dateAndTime printString ] ].	mapper for: #ArrayOfPoints customDo: [ :mapping |		mapping listOfElementSchema: Point ].  	mapper mapAllInstVarsFor: Point.	mapper for: ByteArray customDo: [ :mapping |		mapping listOfType: ByteArray ]! !!NeoJSONTestObject1 methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:45'!= anObject	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ id = anObject id		and: [			name = anObject name				and: [					timestamp = anObject timestamp						and: [							points = anObject points								and: [ bytes = anObject bytes ] ] ] ]! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:03'!bytes	^ bytes! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:04'!bytes: byteArray	bytes := byteArray! !!NeoJSONTestObject1 methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:46'!hash	^ id hash bitXor: (name hash bitXor: (timestamp hash bitXor: (points hash bitXor: bytes hash)))! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:02'!id	^ id! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:03'!id: integer	id := integer! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:02'!name	^ name! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:03'!name: string	name := string! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:03'!points	^ points! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:04'!points: arrayOfPoints	points := arrayOfPoints ! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:03'!timestamp	^ timestamp! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:03'!timestamp: dateAndTime 	timestamp := dateAndTime ! !!NeoJSONTestObject2 class methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:53'!benchmark10k	"self benchmark10k"		self benchmark: 10000! !!NeoJSONTestObject2 class methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:54'!benchmark10kAsDictionary	"self benchmark10kAsDictionary"		self benchmarkAsDictionary: 10000! !!NeoJSONTestObject2 class methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:54'!benchmark200k	"self benchmark200k"		self benchmark: 200000! !!NeoJSONTestObject2 class methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:52'!benchmark: count	"self benchmark: 1000"		| collection json size |	collection := Array new: count withAll: self example1.	size := 2 + (count * (NeoJSONWriter toString: self example1) size) + count - 1.	Transcript 		cr;		<< ('Serializing {1} objects took ms ' format: { count });		show: [ json := String new: size streamContents: [ :stream |								(NeoJSONWriter on: stream) nextPut: collection ] ] timeToRun.	Transcript 		cr;		<< ('Deserializing {1} objects took ms ' format: { count });		show: [ NeoJSONReader fromString: json ] timeToRun.! !!NeoJSONTestObject2 class methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:53'!benchmarkAsDictionary: count	"self benchmarkAsDictionary: 1000"		| collection json size |	collection := Array new: count withAll: self example1 asDictionary.	size := 2 + (count * (NeoJSONWriter toString: self example1 asDictionary) size) + count - 1.	Transcript 		cr;		<< ('Serializing {1} objects took ms ' format: { count });		show: [ json := String new: size streamContents: [ :stream |								(NeoJSONWriter on: stream) nextPut: collection ] ] timeToRun.	Transcript 		cr;		<< ('Deserializing {1} objects took ms ' format: { count });		show: [ NeoJSONReader fromString: json ] timeToRun.! !!NeoJSONTestObject2 class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!example1	^ self new		id: 13;		width: 250;		height: 110;		data: (String new: 512 withAll: $a);		yourself! !!NeoJSONTestObject2 class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/22/2014 10:50'!neoJsonMapping: mapper	"For inheritance mapping to work, the schema/classname must be self,	but the instance variables have to be enumerated manually per class"	mapper for: self do: [ :mapping |		mapping mapInstVars: #(id width height data) ] ! !!NeoJSONTestObject2 methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:22'!= anObject	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ id = anObject id		and: [			height = anObject height				and: [					width = anObject width						and: [							data = anObject data ] ] ]! !!NeoJSONTestObject2 methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 6/10/2012 20:47'!asDictionary	^ Dictionary new		at: #id put: id;		at: #height put: height;		at: #width put: width;		at: #data put: data;		yourself! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!data	^ data! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!data: anObject	data := anObject! !!NeoJSONTestObject2 methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:22'!hash	^ id hash bitXor: (width hash bitXor: (height hash bitXor: data hash))! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!height	^ height! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!height: anObject	height := anObject! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!id	^ id! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!id: anObject	id := anObject! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!width	^ width! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!width: anObject	width := anObject! !!NeoJSONTestObject3 class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 3/22/2014 09:43'!example1	^ super example1		data: (String new: 8 withAll: $a);		color: 'red';		transparent: true;		yourself! !!NeoJSONTestObject3 class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/22/2014 10:50'!neoJsonMapping: mapper	"For inheritance mapping to work, the schema/classname must be self,	but the instance variables have to be enumerated manually per class"		super neoJsonMapping: mapper.	mapper for: self do: [ :mapping |		mapping mapInstVars: #(color transparent) ]! !!NeoJSONTestObject3 methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 3/22/2014 09:45'!= anObject	^ super = anObject 		and: [ color = anObject color			and: [ transparent = anObject transparent ] ]! !!NeoJSONTestObject3 methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 3/22/2014 09:46'!asDictionary	^ super asDictionary		at: #color put: color;		at: #transparent put: transparent;		yourself! !!NeoJSONTestObject3 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/22/2014 09:43'!color	^ color! !!NeoJSONTestObject3 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/22/2014 09:43'!color: anObject	color := anObject! !!NeoJSONTestObject3 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/22/2014 09:43'!transparent	^ transparent! !!NeoJSONTestObject3 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/22/2014 09:43'!transparent: anObject	transparent := anObject! !!NeoJSONValidation methodsFor: 'private' stamp: 'SvenVanCaekenberghe 5/29/2017 09:28'!closeLog	logStream ifNotNil: [ 		logStream close.		logStream := nil ].	^ self logFile exists		ifTrue: [ self logFile contents ] 		ifFalse: [ 'log file is empty' ]! !!NeoJSONValidation methodsFor: 'private' stamp: 'SvenVanCaekenberghe 5/29/2017 09:27'!ensureLog	logStream ifNil: [ 		logStream := self logFile ensureDelete; writeStream. 		logStream setToEnd ]	! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 11:25'!gitDirectory	^ gitDirectory ifNil: [ gitDirectory := FileLocator home / #Develop / #git ]! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 11:23'!gitDirectory: fileReference	gitDirectory := fileReference! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 11:26'!jsonTestSuiteDirectory	^ self gitDirectory / #JSONTestSuite! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 11:27'!jsonTestSuiteTestParsingDirectory	^ self jsonTestSuiteDirectory / 'test_parsing'! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 13:50'!jsonTestSuiteTestParsingFailFiles	^ self jsonTestSuiteTestParsingDirectory childrenMatching: 'n_*.json'! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 13:50'!jsonTestSuiteTestParsingInfoFiles	^ self jsonTestSuiteTestParsingDirectory childrenMatching: 'i_*.json'! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 13:50'!jsonTestSuiteTestParsingPassFiles	^ self jsonTestSuiteTestParsingDirectory childrenMatching: 'y_*.json'! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 11:27'!jsonTestSuiteTestTransformDirectory	^ self jsonTestSuiteDirectory / 'test_transform'! !!NeoJSONValidation methodsFor: 'private' stamp: 'SvenVanCaekenberghe 5/29/2017 09:25'!log: message	self ensureLog.	logStream nextPutAll: message; lf; flush! !!NeoJSONValidation methodsFor: 'private' stamp: 'SvenVanCaekenberghe 5/29/2017 09:26'!logFile	^ 'neo-json-validation.log' asFileReference! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 11:28'!nativeJsonBenchmarkDataDirectory	^ self nativeJsonBenchmarkDirectory / #data! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 11:28'!nativeJsonBenchmarkDirectory	^ self gitDirectory / 'nativejson-benchmark'! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 11:29'!nativeJsonBenchmarkJsonCheckerDirectory	^ self nativeJsonBenchmarkDataDirectory / #jsonchecker! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 12:05'!nativeJsonBenchmarkJsonCheckerFailFiles	^ self nativeJsonBenchmarkJsonCheckerDirectory childrenMatching: 'fail*.json'! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 12:05'!nativeJsonBenchmarkJsonCheckerPassFiles	^ self nativeJsonBenchmarkJsonCheckerDirectory childrenMatching: 'pass*.json'! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 11:29'!nativeJsonBenchmarkRoundTripDirectory	^ self nativeJsonBenchmarkDataDirectory / #roundtrip! !!NeoJSONValidation methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2017 11:34'!nativeJsonBenchmarkRoundTripFiles	^ self nativeJsonBenchmarkRoundTripDirectory children! !!NeoJSONValidation methodsFor: 'running' stamp: 'SvenVanCaekenberghe 5/29/2017 09:57'!runJsonTestSuiteTestParsingFailures	^ self		validateFiles: self jsonTestSuiteTestParsingFailFiles 		usingTest: [ :file | 			| data success |			success := false.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next; failIfNotAtEnd ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := true ].			success ]! !!NeoJSONValidation methodsFor: 'running' stamp: 'SvenVanCaekenberghe 5/29/2017 09:25'!runJsonTestSuiteTestParsingInfo	^ self		validateFiles: self jsonTestSuiteTestParsingInfoFiles 		usingTest: [ :file | 			| data success |			success := true.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := false ].			success ]! !!NeoJSONValidation methodsFor: 'running' stamp: 'SvenVanCaekenberghe 5/29/2017 09:25'!runJsonTestSuiteTestParsingPasses	^ self		validateFiles: self jsonTestSuiteTestParsingPassFiles 		usingTest: [ :file | 			| data success |			success := true.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := false ].			success ]! !!NeoJSONValidation methodsFor: 'running' stamp: 'SvenVanCaekenberghe 5/29/2017 09:40'!runNativeJsonBenchmarkJsonCheckerFailures	^ self		validateFiles: self nativeJsonBenchmarkJsonCheckerFailFiles		usingTest: [ :file | 			| data success |			success := false.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next; failIfNotAtEnd ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := true ].			success ]! !!NeoJSONValidation methodsFor: 'running' stamp: 'SvenVanCaekenberghe 5/29/2017 09:25'!runNativeJsonBenchmarkJsonCheckerPasses	^ self		validateFiles: self nativeJsonBenchmarkJsonCheckerPassFiles		usingTest: [ :file | 			| data success |			success := true.			[ data := file readStreamDo: [ :in | (NeoJSONReader on: in) next ] ]				on: NeoJSONParseError				do: [ :exception | self log: exception printString. success := false ].			success ]! !!NeoJSONValidation methodsFor: 'running' stamp: 'SvenVanCaekenberghe 5/29/2017 09:25'!runNativeJsonBenchmarkRoundTrip	^ self 		validateFiles: self nativeJsonBenchmarkRoundTripFiles		usingTest: [ :file |			| data json |			data := file readStreamDo: [ :in | (NeoJSONReader on: in) next ].			json := NeoJSONWriter toString: data.			json = file contents ]! !!NeoJSONValidation methodsFor: 'private' stamp: 'SvenVanCaekenberghe 5/29/2017 09:25'!validateFiles: files usingTest: block	| total succeeded failed |	total := succeeded := failed := 0.	files do: [ :file | 		| success |		self log: 'Running ' , file pathString.		self log: ([ file contents contractTo: 64 ] on: Error do: [ :exception | exception printString ]).		success := [ block value: file ]			on: Error			do: [ :exception | self log: '  Errored. ' , exception printString. false ].		total := total + 1.		success			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed := failed + 1 ].		self log: (success ifTrue: [ '  Succeeded' ] ifFalse: [ '  Failed' ]); log: '' ].	self log: ('{1} total = {2} succeeded + {3} failed' format: { total. succeeded. failed }).	^ self closeLog! !"Neo-JSON-Tests"!!WBMacWebBrowser commentStamp: 'TorstenBergmann 4/13/2016 08:24' prior: 0!Access to the web browser on Mac!!WBUnixWebBrowser commentStamp: 'TorstenBergmann 4/13/2016 08:24' prior: 0!Access to the web browser on Unix!!WBWindowsWebBrowser commentStamp: 'TorstenBergmann 4/13/2016 08:24' prior: 0!Access to the web browser on Windows!!WebBrowser commentStamp: 'TorstenBergmann 4/13/2016 08:25' prior: 0!General access to a webbrowser!!WBMacWebBrowser class methodsFor: 'examples' stamp: 'TorstenBergmann 4/13/2016 08:35'!example	self openOn: 'http://www.pharo.org'! !!WBMacWebBrowser class methodsFor: 'instance creation' stamp: 'TorstenBergmann 4/13/2016 08:36'!openOn: anURLString	"	self openOn: 'http://www.pharo.org'	"	| openCommand |	openCommand := 'open "{1}"' format: { anURLString }.	self system: openCommand.! !!WBMacWebBrowser class methodsFor: 'private - uffi' stamp: 'TorstenBergmann 4/13/2016 09:46'!system: command	^ self ffiCall: #(#int #system #(#char #* #command)) module: LibC! !!WBUnixWebBrowser class methodsFor: 'examples' stamp: 'TorstenBergmann 4/13/2016 08:31'!example	self openOn: 'http://www.pharo.org'! !!WBUnixWebBrowser class methodsFor: 'instance creation' stamp: 'TorstenBergmann 4/13/2016 08:36'!openOn: anURLString	"	self openOn: 'http://www.pharo.org'	"	| openCommand |	openCommand := 'xdg-open {1} &' format: { anURLString }.	self system: openCommand.! !!WBUnixWebBrowser class methodsFor: 'private - uffi' stamp: 'TorstenBergmann 4/13/2016 09:45'!system: command	^ self ffiCall: #(#int #system #(#char #* #command)) module: LibC! !!WBWindowsWebBrowser class methodsFor: 'examples' stamp: 'TorstenBergmann 4/13/2016 08:28'!example	self openOn: 'http://www.pharo.org'! !!WBWindowsWebBrowser class methodsFor: 'instance creation' stamp: 'TorstenBergmann 4/13/2016 08:36'!openOn: anURLString	"	self openOn: 'http://www.pharo.org'	"	^self shellExecute: 'open' file: anURLString parameters: '' directory: '' show: 5 "SW_SHOW"! !!WBWindowsWebBrowser class methodsFor: 'private - uffi' stamp: 'TorstenBergmann 4/13/2016 09:45'!shellExecute: lpOperation file: lpFile parameters: lpParameters directory: lpDirectory show: nShowCmd			^self ffiCall: #( 			FFIConstantHandle ShellExecuteA(     				0,     				String* lpOperation,         			String* lpFile,     				String* lpParameters,     				String* lpDirectory,        			int nShowCmd)) module: #shell32! !!WebBrowser class methodsFor: 'example' stamp: 'TorstenBergmann 4/13/2016 08:41'!example	self openOn: 'http://www.pharo.org'! !!WebBrowser class methodsFor: 'instance-creation' stamp: 'TorstenBergmann 4/13/2016 08:40'!openOn: aURLString	"Open the webbrowser on the given URL"		^self webbrowserClassForPlatform openOn: aURLString	! !!WebBrowser class methodsFor: 'private - accessing' stamp: 'TorstenBergmann 4/13/2016 08:39'!webbrowserClassForPlatform	Smalltalk os isUnix ifTrue: [ ^WBUnixWebBrowser ].	Smalltalk os isWindows ifTrue: [ ^WBWindowsWebBrowser ].	(Smalltalk os isMacOS or: [ Smalltalk os isMacOSX ])  		ifTrue: [ ^WBMacWebBrowser ].	self error: 'No web browser class for platform provided'! !"WebBrowser-Core"!!TeaNoSuchParam commentStamp: 'AttilaMagyar 11/16/2014 17:04' prior: 0!This exception indicates that the given parameter was not found in the TeaRequest.!!TeaAbort commentStamp: 'AttilaMagyar 8/9/2014 22:55' prior: 0!I'm an exception that immediately stops a request within a filter or route.!!IsObject commentStamp: 'AttilaMagyar 8/13/2014 22:09' prior: 0!I'm the base class of the type constraints. I match to any object. My subclasses can restict the type of placeholders.Example:Teapot on	GET: '/user/<id:IsInteger>' -> [:req | users findById: (req at: #id)];	start.This route matches to the '/users/12' but does not match to '/users/foobar'. In case of matching, the the path paramter "id" will be converted to an integer.You can extend the built in type constraints with your own constraints, by implementing the "placeholder type constraint" protocol. Then you can use the class name in the URL.!!IsInteger commentStamp: 'AttilaMagyar 8/3/2014 17:27' prior: 0!I'm a type constraint that matches to positive or negative integers.!!IsNumber commentStamp: 'AttilaMagyar 8/3/2014 17:27' prior: 0!I'm a type constraint that matches to positive or negative floats or integers.!!Send commentStamp: 'AttilaMagyar 8/2/2014 19:53' prior: 0!I can send messages to objects on a http requests. The selector of the message can take maximum 2 arguments ( TeaRequest and TeaResponse).Example:Teapot on	GET: '/hi' -> (Send message: #greet to: controller);	start.	!!TeaErrorHandler commentStamp: 'AttilaMagyar 8/24/2014 18:02' prior: 0!An error handler handles Exceptions signaled by the Routes or before actions.!!TeaFilter commentStamp: 'AttilaMagyar 9/27/2014 23:54' prior: 0!After and Before filters!!TeaAfterFilter commentStamp: 'AttilaMagyar 9/27/2014 23:58' prior: 0!An after filter is evaluated after each (matching) request. This filter has access to the response object generated by the matching route. The response can be modified from the filter, e.g. addition headers can be added.!!TeaBeforeFilter commentStamp: 'AttilaMagyar 9/27/2014 23:59' prior: 0!A before filter is evaluated before (matching) each request. This filter has access to the request object. For example, a before filter can be used to validate session attributes for authentication.!!TeaGlobUrlSegment commentStamp: 'AttilaMagyar 8/14/2014 21:23' prior: 0!My subclasses form the elements of TeaGlobUrlPatterns!!TeaLiteral commentStamp: 'AttilaMagyar 7/27/2014 12:28' prior: 0!A literal url pattern segment that matches to a string.!!TeaLiteralStop commentStamp: 'AttilaMagyar 8/10/2014 23:30' prior: 0!I'm a placeholder at the last position.!!TeaPlaceholder commentStamp: 'AttilaMagyar 7/27/2014 14:33' prior: 0!I'm a placeholder with a key. My content is substituted with a value.!!TeaPlaceholderStop commentStamp: 'AttilaMagyar 7/27/2014 14:34' prior: 0!I'm a placeholder at the last position.!!TeaWildcard commentStamp: 'AttilaMagyar 7/27/2014 12:29' prior: 0!A wildcard url pattern segment that matches to anything.!!TeaWildcardStop commentStamp: 'AttilaMagyar 7/27/2014 14:34' prior: 0!I'm a Wildcard at the last position.!!TeaMethodMatcher commentStamp: 'AttilaMagyar 8/12/2014 21:11' prior: 0!I can be matched against an HTTP method. I will return either true or false.!!TeaOutput commentStamp: 'AttilaMagyar 8/10/2014 23:18' prior: 0!I have various response transformer methods on my class side, that can be used as follows:Teapot on	GET: '/books' -> books; output: #json;	start.	Some of the transformers require optional dependencies, like Neo-JSON, STON, or Mustache.!!TeaPadding commentStamp: 'AttilaMagyar 7/27/2014 12:35' prior: 0!An url is padded by me, if its size is to short. I don't match to any literal URL, so it's like I'm not there.!!TeaRequest commentStamp: 'AttilaMagyar 7/30/2014 22:32' prior: 0!I extend the ZnRequest with addition methods for convenience.!!TeaRequestMatcher commentStamp: 'AttilaMagyar 9/27/2014 23:54' prior: 0!I can be matched against a ZnRequest. I check the http method and url of the request. !!TeaResponse commentStamp: 'AttilaMagyar 9/28/2014 20:26' prior: 0!A TeaResponse represents an HTTP response returned by a Route. The ZnResponse is generated from the TeaResponse by the given response transformer.!!TeaRoute commentStamp: 'AttilaMagyar 8/10/2014 23:24' prior: 0!A route handles http requests if it matches to the route. I have four major parts.- A handler that can be a block, a value or a message send.- An url pattern that can be matched against actual urls.- An http method that can be matched against the actual http method.- A response transformer for creating ZnResponse from the object returned by the handler.!!TeaRouter commentStamp: 'AttilaMagyar 8/2/2014 23:09' prior: 0!A zn delegate baseclass!!TeaCompositeRouter commentStamp: 'AttilaMagyar 8/10/2014 23:27' prior: 0!I'm a composite zn delegate, built from other zn delegates. I forward the request to the first delegate that returns other than 404 as response. Errors are handled with the help of the registered error handlers.!!TeaDynamicRouter commentStamp: 'AttilaMagyar 8/10/2014 23:26' prior: 0!I'm a ZnDelegate. I serve dynamically generated contents. The request is handled by the first route object, that returns other than 404 as response.!!TeaStaticRouter commentStamp: 'AttilaMagyar 8/2/2014 23:12' prior: 0!I'm a ZnDelegate based on ZnStaticFileServerDelegate. I serve static content from a file system directory.!!TeaUrlPattern commentStamp: 'AttilaMagyar 8/14/2014 21:26' prior: 0!An URL pattern can be matched agains actual urls. The pattern may collect named parameters from the URL in case of match.!!TeaGlobUrlPattern commentStamp: 'AttilaMagyar 8/14/2014 21:26' prior: 0!An UrlPattern is made from segments. I can be matched against an actual URL. '*' and <named-parameters> can be used inside the pattern.I can parse the pattern from a string by saying:	self parseString: '/foo/*/<id>/bar'Which will create a pattern that matches to an URL like this: 	/foo/xyz/12/bar!!TeaRxUrlPattern commentStamp: 'AttilaMagyar 8/14/2014 21:27' prior: 0!I'm an URL pattern that uses a regular expression internally. I collect subexpressions in case of matching.!!TeaUrlPatternSet commentStamp: 'AttilaMagyar 6/16/2015 18:31' prior: 0!I match to the given url if any of my elements match.E.g.Teapot on	GET: {'/a'. '/b'} -> 'ab';	start.		Both ZnEasy get: '/a' and ZnEasy get: '/b' returns 'ab'!!Teapot commentStamp: 'AttilaMagyar 6/8/2016 22:12' prior: 0!I'm the Teapot server on top of ZnServer. I can handle URL routing as follows:Teapot on      GET: '/hi' -> 'Hello World!!';      GET: '/a/*/b' -> (Send message: #ab: to: controller);      GET: '/users' -> [ users ]; output: #json	      GET: '/user/<id>' -> [ :req | (req at: #id) ]; output: #ston;      PUT: '/books/<id>' -> [ :req | | book |	  book := Book author: (req at: #author) title: (req at: #title).        books at: (req at: #id) put: book ]; 	  output: #ston;      start.For more configuration option see the Teapot class>>configure method.!!ZnResponse methodsFor: '*Teapot-Core' stamp: 'AttilaMagyar 9/28/2014 18:48'!teaTransform: aResponseTransformer request: aTeaRequest	^ self! !!RxMatcher methodsFor: '*Teapot-Core' stamp: 'AttilaMagyar 8/14/2014 22:32'!asTeaUrlPattern	^ TeaRxUrlPattern fromRxMatcher: self! !!String methodsFor: '*Teapot-Core' stamp: 'AttilaMagyar 8/14/2014 22:33'!asTeaUrlPattern	^ TeaGlobUrlPattern parseString: self! !!TeaNoSuchParam class methodsFor: 'signaling' stamp: 'AttilaNamed 2/28/2015 22:54'!signalWithParam: aSymbol	(self new setParam: aSymbol) signal: 'Param ', aSymbol printString, ' not found'! !!TeaNoSuchParam methodsFor: 'accessing' stamp: 'AttilaNamed 2/28/2015 22:43'!param	^ param! !!TeaNoSuchParam methodsFor: 'initialization' stamp: 'AttilaNamed 2/28/2015 22:42'!setParam: aSymbol	param := aSymbol.	^ self! !!TeaAbort class methodsFor: 'instance creation' stamp: 'AttilaMagyar 8/17/2014 19:14'!response: aZnResponse	^ self new setResponse: aZnResponse! !!TeaAbort methodsFor: 'converting' stamp: 'AttilaMagyar 10/13/2014 20:30'!response	^ response! !!TeaAbort methodsFor: 'initialization' stamp: 'AttilaMagyar 8/17/2014 19:14'!setResponse: aZnResponse	response := aZnResponse.	^ self! !!BlockClosure methodsFor: '*Teapot-Core' stamp: 'AttilaMagyar 9/28/2014 19:41'!teaEvalActionOnException: anException request: aTeaRequest	^ self cull: anException cull: aTeaRequest! !!BlockClosure methodsFor: '*Teapot-Core' stamp: 'AttilaMagyar 9/28/2014 19:41'!teaEvalActionOnRequest: aTeaRequest	^ self cull: aTeaRequest! !!BlockClosure methodsFor: '*Teapot-Core' stamp: 'AttilaMagyar 10/8/2014 19:48'!teaEvalActionOnRequest: aTeaRequest response: aZnResponse	^ self cull: aTeaRequest cull: aZnResponse! !!IsInteger class methodsFor: 'type constraint' stamp: 'AttilaMagyar 8/3/2014 17:23'!matchesTo: aString	^ '-?\d+' asRegex matches: aString! !!IsInteger class methodsFor: 'type constraint' stamp: 'AttilaMagyar 8/3/2014 17:55'!parseString: aString	^ aString asInteger! !!IsNumber class methodsFor: 'type constraint' stamp: 'AttilaMagyar 8/16/2014 14:23'!matchesTo: aString	Number readFrom: aString ifFail: [ ^false ].	^ true! !!IsNumber class methodsFor: 'type constraint' stamp: 'AttilaMagyar 8/3/2014 17:56'!parseString: aString	^ aString asNumber! !!IsObject class methodsFor: 'type constraint' stamp: 'AttilaMagyar 8/3/2014 17:09'!matchesTo: aString	^ true! !!IsObject class methodsFor: 'type constraint' stamp: 'AttilaMagyar 8/3/2014 17:07'!parseString: aString	^ aString! !!Object methodsFor: '*Teapot-Core' stamp: 'AttilaMagyar 9/28/2014 19:41'!teaEvalActionOnException: anException request: aTeaRequest	^ self! !!Object methodsFor: '*Teapot-Core' stamp: 'AttilaMagyar 9/28/2014 19:41'!teaEvalActionOnRequest: aTeaRequest	^ self! !!Object methodsFor: '*Teapot-Core' stamp: 'AttilaNamed 2/28/2015 23:27'!teaTransform: aResponseTransformer request: aTeaRequest	^ aResponseTransformer cull: (TeaResponse ok body: self) cull: aTeaRequest! !!Send class methodsFor: 'instance creation' stamp: 'AttilaMagyar 8/10/2014 21:16'!message: aSymbol to: anObject	^ self new 		setSelector: aSymbol 		receiver: anObject! !!Send methodsFor: 'printing' stamp: 'AttilaMagyar 8/16/2014 18:28'!printOn: aStream	aStream 		nextPutAll: '(Send message: ';		nextPutAll: selector printString;		nextPutAll: ' to: '.	receiver printOn: aStream.	aStream nextPut: $)! !!Send methodsFor: 'initialization' stamp: 'AttilaMagyar 8/10/2014 20:53'!setSelector: aSymbol receiver: anObject	selector := aSymbol.	receiver := anObject.	^ self	! !!Send methodsFor: 'tea action' stamp: 'AttilaMagyar 9/28/2014 19:41'!teaEvalActionOnException: anException request: aTeaRequest	^ receiver 		perform: selector 		withEnoughArguments: { anException. aTeaRequest }	! !!Send methodsFor: 'tea action' stamp: 'AttilaMagyar 9/28/2014 19:41'!teaEvalActionOnRequest: aTeaRequest	^ receiver 		perform: selector 		withEnoughArguments: { aTeaRequest }	! !!Send methodsFor: 'tea action' stamp: 'AttilaMagyar 10/8/2014 19:48'!teaEvalActionOnRequest: aTeaRequest response: aZnResponse	^ receiver 		perform: selector 		withEnoughArguments: { aTeaRequest. aZnResponse }	! !!TeaErrorHandler class methodsFor: 'instance creation' stamp: 'AttilaMagyar 8/24/2014 16:35'!for: anExceptionSet action: aTeaAction responseTransformer: aResponseTransformer	^ self new 		setExceptions: anExceptionSet 		action: aTeaAction 		responseTransformer: aResponseTransformer! !!TeaErrorHandler methodsFor: 'error handler' stamp: 'AttilaMagyar 8/24/2014 17:56'!canHandleError: anException	^ exceptions handles: anException! !!TeaErrorHandler methodsFor: 'error handler' stamp: 'AttilaMagyar 9/28/2014 19:41'!handleError: anException request: aTeaRequest	| result |	^ (self canHandleError: anException)		ifTrue:			[ result := action teaEvalActionOnException: anException request: aTeaRequest.			result teaTransform: responseTransformer request: aTeaRequest ]		ifFalse: 			[ self error: 'Cannot handle ', anException printString ]! !!TeaErrorHandler methodsFor: 'error handler' stamp: 'AttilaMagyar 8/24/2014 17:00'!responseTransformer: aResponseTransformer 	responseTransformer := aResponseTransformer! !!TeaErrorHandler methodsFor: 'initialization' stamp: 'AttilaMagyar 8/24/2014 18:00'!setExceptions: anExceptionSet action: aTeaAction responseTransformer: aResponseTransformer	exceptions := anExceptionSet.	action := aTeaAction.	responseTransformer := aResponseTransformer.	^ self! !!TeaAfterFilter methodsFor: 'response handling' stamp: 'AttilaMagyar 10/8/2014 19:55'!handleRequest: aZnRequest response: aZnResponse	requestMatcher 		matchRequest: aZnRequest 		ifMatch: [ :aTeaRequest | action teaEvalActionOnRequest: aTeaRequest response: aZnResponse ]		ifNoMatch: [ ]! !!TeaBeforeFilter methodsFor: 'request handling' stamp: 'AttilaMagyar 10/8/2014 19:53'!handleRequest: aZnRequest	requestMatcher 		matchRequest: aZnRequest 		ifMatch: [ :aTeaRequest | action teaEvalActionOnRequest: aTeaRequest ]		ifNoMatch: [ ]! !!TeaFilter class methodsFor: 'instance creation' stamp: 'AttilaMagyar 9/27/2014 22:29'!urlPattern: anUrlPattern action: aTeaAction	^ self new 		setMatcher: (TeaRequestMatcher method: TeaMethodMatcher any url: anUrlPattern)		action: aTeaAction! !!TeaFilter methodsFor: 'initialization' stamp: 'AttilaMagyar 9/27/2014 22:33'!setMatcher: aTeaRequestMatcher action: aTeaAction	requestMatcher := aTeaRequestMatcher.	action := aTeaAction.	^ self! !!TeaFilter methodsFor: 'acccessing' stamp: 'AttilaMagyar 5/8/2015 19:01'!whenClause: aBlockClosure 	requestMatcher whenClause: aBlockClosure ! !!TeaGlobUrlSegment methodsFor: 'url pattern segment' stamp: 'AttilaMagyar 7/27/2014 15:09'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	self subclassResponsibility! !!TeaLiteral class methodsFor: 'instance creation' stamp: 'AttilaMagyar 7/30/2014 22:00'!fromString: aString atLast: aBoolean	| class |	class := aBoolean ifTrue: [ TeaLiteralStop ] ifFalse: [ TeaLiteral ].	^ class new setLiteral: aString! !!TeaLiteral methodsFor: 'url pattern segment' stamp: 'AttilaMagyar 8/3/2014 18:22'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	^ literal = urlSegments first and: 		[ adjacentPatterns first 			matches: urlSegments allButFirst 			rest: adjacentPatterns allButFirst 			placeholders: aDictionary ]! !!TeaLiteral methodsFor: 'printing' stamp: 'AttilaMagyar 7/30/2014 22:20'!printOn: aStream	aStream nextPutAll: literal.	! !!TeaLiteral methodsFor: 'initialization' stamp: 'AttilaMagyar 7/27/2014 16:30'!setLiteral: aString	literal := aString.	^ self! !!TeaLiteralStop methodsFor: 'url pattern segment' stamp: 'AttilaMagyar 8/3/2014 18:11'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	^ urlSegments size = 1 and: [ literal = urlSegments first ]! !!TeaPlaceholder class methodsFor: 'private' stamp: 'AttilaMagyar 8/3/2014 17:33'!createPlaceholderName: key typeConstraint: aTypeConstraint atLast: aBoolean	| class |	class := aBoolean		ifTrue: [ TeaPlaceholderStop ]		ifFalse: [ TeaPlaceholder ].	^ class new 		setPlaceholderName: key 		typeConstraint: aTypeConstraint! !!TeaPlaceholder class methodsFor: 'instance creation' stamp: 'AttilaMagyar 8/3/2014 17:31'!fromString: aString atLast: aBoolean	| spec typeConstraint key |	self mustBeValidPlaceholder: aString.	spec := aString allButFirst allButLast findTokens: ':'.	key := spec first.	typeConstraint := spec at: 2 ifAbsent: #IsObject.	^ self 		createPlaceholderName: key 		typeConstraint: (Smalltalk at: typeConstraint asSymbol)		atLast: aBoolean! !!TeaPlaceholder class methodsFor: 'private' stamp: 'AttilaMagyar 7/28/2014 22:28'!mustBeValidPlaceholder: aString	((aString beginsWith: '<') and: [ aString endsWith: '>' ])		ifFalse: [ self error: 'Invalid placeholder name: ', aString ]! !!TeaPlaceholder methodsFor: 'url pattern segment' stamp: 'AttilaMagyar 8/3/2014 17:58'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	(typeConstraint matchesTo: urlSegments first) 		ifFalse: [ ^ false ].				aDictionary 		at: placeholderName 		put: (typeConstraint parseString: urlSegments first).					^ adjacentPatterns first 		matches: urlSegments allButFirst 		rest: adjacentPatterns allButFirst 		placeholders: aDictionary! !!TeaPlaceholder methodsFor: 'printing' stamp: 'AttilaMagyar 7/28/2014 22:28'!printOn: aStream	aStream 		nextPut: $<;		nextPutAll: placeholderName;		nextPut: $>! !!TeaPlaceholder methodsFor: 'initialization' stamp: 'AttilaMagyar 8/3/2014 17:32'!setPlaceholderName: aString typeConstraint: aTypeConstraint	placeholderName := aString asSymbol.	typeConstraint := aTypeConstraint.	^ self! !!TeaPlaceholderStop methodsFor: 'url pattern segment' stamp: 'AttilaMagyar 8/3/2014 18:00'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	| match |	match := urlSegments size = 1 		and: [ urlSegments first ~= TeaPadding 		and: [ (typeConstraint matchesTo: urlSegments first) ] ].	match ifTrue:		 [ aDictionary			at: placeholderName 			put: (typeConstraint parseString: urlSegments first) ].	^ match! !!TeaWildcard class methodsFor: 'instance creation' stamp: 'AttilaMagyar 7/30/2014 22:00'!atLast: aBoolean	^ aBoolean		ifTrue: [ TeaWildcardStop new ]		ifFalse: [ TeaWildcard new ]! !!TeaWildcard methodsFor: 'url pattern segment' stamp: 'AttilaMagyar 7/27/2014 15:10'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	^ adjacentPatterns first 		matches: urlSegments allButFirst 		rest: adjacentPatterns allButFirst 		placeholders: aDictionary! !!TeaWildcard methodsFor: 'printing' stamp: 'AttilaMagyar 7/27/2014 12:54'!printOn: aStream	aStream nextPut: $*! !!TeaWildcardStop methodsFor: 'url pattern segment' stamp: 'AttilaMagyar 7/27/2014 15:10'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	^ true! !!TeaMethodMatcher class methodsFor: 'instance creation' stamp: 'AttilaMagyar 8/16/2014 18:12'!any	^ self new 		setMatcherBlock: [ :anyMethod | true ] 		name: 'ANY'! !!TeaMethodMatcher class methodsFor: 'instance creation' stamp: 'AttilaMagyar 8/16/2014 18:12'!exactly: aSymbol	^ self new 		setMatcherBlock: [ :actual | actual = aSymbol ] 		name: aSymbol asString! !!TeaMethodMatcher methodsFor: 'http method matcher' stamp: 'AttilaMagyar 8/12/2014 20:58'!matchesHttpMethod: aSymbol	^ matcherBlock value: aSymbol	! !!TeaMethodMatcher methodsFor: 'printing' stamp: 'AttilaMagyar 8/16/2014 18:15'!printOn: aStream	aStream 		nextPutAll: name;		nextPut: $:! !!TeaMethodMatcher methodsFor: 'initialization' stamp: 'AttilaMagyar 8/16/2014 18:11'!setMatcherBlock: aBlockClosure name: aString	matcherBlock := aBlockClosure.	name := aString.	^ self! !!TeaOutput class methodsFor: 'response transformers' stamp: 'AttilaMagyar 8/16/2014 13:52'!html	^ self stringWithContentType: ZnMimeType textHtml! !!TeaOutput class methodsFor: 'response transformers' stamp: 'AttilaMagyar 5/9/2015 17:00'!json	^ [ :aTeaResponse | | entity |		entity := ZnStringEntity 			with: ((self optionalClass: #NeoJSONWriter) toString: aTeaResponse body) 			type: (ZnMimeType applicationJson charSet: aTeaResponse charSet; yourself).		self 			znEntity: entity			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers' stamp: 'AttilaMagyar 9/28/2014 19:20'!mustache: templateStringOrStream contentType: contentType	^ [ :aTeaResponse | | model object entity |		object := aTeaResponse body.		model := (object respondsTo: #asDictionary) ifTrue: [ object asDictionary ] ifFalse: [ object ].				entity := (ZnStringEntity 			with: (((self optionalClass: #MustacheTemplate) on: templateStringOrStream) value: model) 			type: contentType).		self 			znEntity: entity			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers' stamp: 'AttilaMagyar 7/30/2014 22:09'!mustacheHtml: templateString 	^ self mustache: templateString contentType: ZnMimeType textHtml.! !!TeaOutput class methodsFor: 'private' stamp: 'AttilaMagyar 9/5/2014 15:40'!optionalClass: aSymbol	[ ^ Smalltalk at: aSymbol ]		on: KeyNotFound		do: [ self error: 'An optional dependency ', aSymbol, ' was not found. Please load it first.' ]! !!TeaOutput class methodsFor: 'response transformers' stamp: 'AttilaMagyar 5/9/2015 17:02'!ston	^ [ :aTeaResponse | | entity |		entity := ZnStringEntity 			with: ((self optionalClass: #STON) toString: aTeaResponse body) 			type: (ZnMimeType textPlain charSet: aTeaResponse charSet; yourself).		self 			znEntity: entity			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers' stamp: 'AttilaMagyar 8/8/2014 20:07'!stream	^ self stream: ZnMimeType applicationOctetStream ! !!TeaOutput class methodsFor: 'response transformers' stamp: 'AttilaMagyar 9/28/2014 19:20'!stream: aZnMimeType	^ [ :aTeaResponse | | entity |		entity := ZnStreamingEntity 			readFrom: aTeaResponse body			usingType: aZnMimeType			andLength: aTeaResponse body size.		self 			znEntity: entity			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers' stamp: 'AttilaMagyar 5/9/2015 17:18'!stringWithContentType: aZnMimeType 	^ [ :aTeaResponse | | entity |		entity := ZnStringEntity new			contentType: (aZnMimeType charSet: aTeaResponse charSet; yourself);			string: aTeaResponse body asString;			yourself.		self 			znEntity: entity 			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers' stamp: 'AttilaMagyar 8/16/2014 13:52'!text	^ self stringWithContentType: ZnMimeType textPlain! !!TeaOutput class methodsFor: 'private' stamp: 'AttilaNamed 2/28/2015 23:58'!znEntity: aZnEntity code: anInteger headers: aDictionary	| headers |	headers := ZnHeaders defaultResponseHeaders.	headers addAll: aDictionary.	^ ZnResponse new		statusLine: (ZnStatusLine code: anInteger);		headers: headers;		entity: aZnEntity;		yourself! !!TeaRequest class methodsFor: 'instance creation' stamp: 'AttilaMagyar 8/12/2014 21:41'!fromZnRequest: aZnRequest	^ self fromZnRequest: aZnRequest pathParams: Dictionary new! !!TeaRequest class methodsFor: 'instance creation' stamp: 'AttilaMagyar 8/12/2014 21:42'!fromZnRequest: aZnRequest pathParams: aDictionary	^ self new setZnRequest: aZnRequest pathParams: aDictionary! !!TeaRequest methodsFor: 'aborting' stamp: 'AttilaNamed 3/1/2015 20:01'!abort: response	(TeaAbort response: response) signal! !!TeaRequest methodsFor: 'acccessing - params' stamp: 'AttilaNamed 2/28/2015 22:40'!at: aSymbol	^ self 		at: aSymbol 		ifAbsent: [ TeaNoSuchParam signalWithParam: aSymbol ]! !!TeaRequest methodsFor: 'acccessing - params' stamp: 'AttilaMagyar 7/30/2014 16:51'!at: aSymbol ifAbsent: aBlock	"Gets the value of a path parameter, query parameter for form parameter.		E.g. /foo/<path-param>/bar		E.g. /foo?queryParam=value"	^ pathParams at: aSymbol ifAbsent: [ self queryOrFormParam: aSymbol ifAbsent: aBlock	"XXX do something better" ]! !!TeaRequest methodsFor: 'reflective operations' stamp: 'AttilaMagyar 7/28/2014 20:31'!doesNotUnderstand: aMessage	^ aMessage sendTo: znRequest! !!TeaRequest methodsFor: 'private' stamp: 'AttilaMagyar 7/30/2014 16:40'!formParam: aSymbol ifAbsent: aBlock	^ (znRequest entity isKindOf: ZnApplicationFormUrlEncodedEntity) "XXX do something better" 		ifTrue: [ znRequest entity at: aSymbol ifAbsent: aBlock ]		ifFalse: aBlock! !!TeaRequest methodsFor: 'private' stamp: 'AttilaMagyar 7/30/2014 16:40'!queryOrFormParam: aSymbol ifAbsent: aBlock	^ znRequest uri 		queryAt: aSymbol 		ifAbsent: [ self formParam: aSymbol ifAbsent: aBlock ]! !!TeaRequest methodsFor: 'initialization' stamp: 'AttilaMagyar 7/28/2014 21:04'!setZnRequest: aZnRequest pathParams: aDictionary	znRequest := aZnRequest.	pathParams := aDictionary.	^ self! !!TeaRequestMatcher class methodsFor: 'instance creation' stamp: 'AttilaMagyar 9/27/2014 22:25'!method: aMethodMatcher url: anUrlPattern	^ self new setPattern: anUrlPattern method: aMethodMatcher! !!TeaRequestMatcher methodsFor: 'request matcher' stamp: 'AttilaMagyar 9/27/2014 21:19'!matchRequest: aZnRequest ifMatch: matchBlock ifNoMatch: noMatchBlock	| matches placeholders |	placeholders := Dictionary new.	matches := self matchesRequest: aZnRequest placeholders: placeholders.	^ matches		ifTrue: [ matchBlock value: (TeaRequest fromZnRequest: aZnRequest pathParams: placeholders) ]		ifFalse: [ noMatchBlock value ]! !!TeaRequestMatcher methodsFor: 'private' stamp: 'AttilaMagyar 5/8/2015 19:25'!matchesRequest: aZnRequest placeholders: placeholders	| matchesPartially |	matchesPartially := (methodMatcher matchesHttpMethod: aZnRequest method)		and: [ urlPattern matchesUrl: aZnRequest url placeholders: placeholders ].		matchesPartially ifFalse: [ ^ false ].	^ whenClause cull: (TeaRequest fromZnRequest: aZnRequest pathParams: placeholders).! !!TeaRequestMatcher methodsFor: 'printing' stamp: 'AttilaMagyar 10/26/2015 21:54'!printOn: aStream	methodMatcher printOn: aStream.	aStream space.	urlPattern printOn: aStream.! !!TeaRequestMatcher methodsFor: 'initialization' stamp: 'AttilaMagyar 5/4/2015 22:17'!setPattern: anUrlPattern method: aMethodMatcher	urlPattern := anUrlPattern.	methodMatcher := aMethodMatcher.	whenClause := [ :anyRequest | true ].	^ self! !!TeaRequestMatcher methodsFor: 'accessing' stamp: 'AttilaMagyar 5/4/2015 21:49'!whenClause: aBlockClosure 	whenClause := aBlockClosure! !!TeaResponse class methodsFor: 'instance creation' stamp: 'AttilaNamed 2/28/2015 23:09'!badRequest	^ self code: ZnStatusLine badRequest code! !!TeaResponse class methodsFor: 'instance creation' stamp: 'AttilaNamed 2/28/2015 23:21'!code: anInteger	^ self new code: anInteger! !!TeaResponse class methodsFor: 'instance creation' stamp: 'AttilaNamed 2/28/2015 23:23'!created	^ self code: ZnStatusLine created code! !!TeaResponse class methodsFor: 'instance creation' stamp: 'AttilaNamed 2/28/2015 23:10'!methodNotAllowed	^ self code: ZnStatusLine methodNotAllowed code ! !!TeaResponse class methodsFor: 'instance creation' stamp: 'AttilaNamed 2/28/2015 23:11'!notFound	^ self code: ZnStatusLine notFound code ! !!TeaResponse class methodsFor: 'instance creation' stamp: 'AttilaNamed 2/28/2015 23:11'!notModified	^ self code: ZnStatusLine notModified code! !!TeaResponse class methodsFor: 'instance creation' stamp: 'AttilaNamed 2/28/2015 23:44'!ok	^ self code: ZnStatusLine ok code! !!TeaResponse class methodsFor: 'instance creation' stamp: 'AttilaNamed 2/28/2015 23:11'!redirect	^ self code: ZnStatusLine redirect code! !!TeaResponse class methodsFor: 'instance creation' stamp: 'AttilaNamed 2/28/2015 23:11'!serverError	^ self code: ZnStatusLine internalServerError code! !!TeaResponse class methodsFor: 'instance creation' stamp: 'AttilaNamed 2/28/2015 23:54'!unauthorized	^ self code: ZnStatusLine unauthorized code! !!TeaResponse methodsFor: 'accessing' stamp: 'AttilaMagyar 9/28/2014 18:51'!body	^ body! !!TeaResponse methodsFor: 'accessing' stamp: 'AttilaNamed 2/28/2015 23:21'!body: anObject	body := anObject.	^ self! !!TeaResponse methodsFor: 'accessing' stamp: 'AttilaMagyar 5/9/2015 16:53'!charSet	^ charSet! !!TeaResponse methodsFor: 'accessing' stamp: 'AttilaMagyar 5/9/2015 18:05'!charSet: aString	charSet := aString.	^ self! !!TeaResponse methodsFor: 'accessing' stamp: 'AttilaMagyar 9/28/2014 19:00'!code	^ code! !!TeaResponse methodsFor: 'accessing' stamp: 'AttilaNamed 2/28/2015 23:21'!code: anInteger	code := anInteger.	^ self! !!TeaResponse methodsFor: 'accessing' stamp: 'AttilaNamed 2/28/2015 23:29'!headerName: nameString value: valueString	headers at: nameString put: valueString.	^ self! !!TeaResponse methodsFor: 'accessing' stamp: 'AttilaMagyar 9/28/2014 19:11'!headers	^ headers! !!TeaResponse methodsFor: 'accessing' stamp: 'AttilaNamed 2/28/2015 23:30'!headers: aDictionary	headers := aDictionary asDictionary.	^ self! !!TeaResponse methodsFor: 'initialization' stamp: 'AttilaMagyar 5/9/2015 16:54'!initialize	super initialize.	headers := Dictionary new.	body := String crlf.	code := ZnStatusLine ok code.	charSet := 'utf-8'.! !!TeaResponse methodsFor: 'accessing' stamp: 'AttilaNamed 2/28/2015 23:41'!location: url	self headerName: 'Location' value: url asString.	^ self! !!TeaResponse methodsFor: 'response transforming' stamp: 'AttilaMagyar 9/28/2014 18:49'!teaTransform: aResponseTransformer request: aTeaRequest	^ aResponseTransformer cull: self cull: aTeaRequest! !!TeaRoute class methodsFor: 'instance creation' stamp: 'AttilaMagyar 11/8/2015 18:31'!matcher: aTeaRequestMatcher action: aTeaAction transformer: aResponseTransformer port: portNumber	^ self new 		setMatcher: aTeaRequestMatcher		action: aTeaAction		transformer: aResponseTransformer		port: portNumber "XXX only used by teapsoon inspector"! !!TeaRoute methodsFor: 'request handling' stamp: 'AttilaMagyar 9/28/2014 19:41'!handleRequest: aZnRequest	^ requestMatcher 		matchRequest: aZnRequest 		ifMatch: 			[ :aTeaRequest | | result |			result := action teaEvalActionOnRequest: aTeaRequest.			result teaTransform: responseTransformer request: aTeaRequest ]		ifNoMatch: 			[ ZnResponse notFound: aZnRequest uri ]! !!TeaRoute methodsFor: 'printing' stamp: 'AttilaMagyar 10/26/2015 21:52'!printOn: aStream	requestMatcher printOn: aStream.	aStream nextPutAll: ' -> '.	action printOn: aStream.! !!TeaRoute methodsFor: 'accessing' stamp: 'AttilaMagyar 7/31/2014 21:18'!responseTransformer: aBlock	responseTransformer := aBlock! !!TeaRoute methodsFor: 'initialization' stamp: 'AttilaMagyar 11/8/2015 18:32'!setMatcher: aTeaRequestMatcher action: aTeaAction transformer: aResponseTransformer port: portNumber	requestMatcher := aTeaRequestMatcher.	action := aTeaAction.	responseTransformer := aResponseTransformer.	port := portNumber.	^ self! !!TeaRoute methodsFor: 'acccessing' stamp: 'AttilaMagyar 5/8/2015 18:55'!whenClause: aBlockClosure 	requestMatcher whenClause: aBlockClosure! !!TeaCompositeRouter class methodsFor: 'instance creation' stamp: 'AttilaMagyar 8/3/2014 11:25'!routers: teaRouterCollection	^ self new setRouters: teaRouterCollection! !!TeaCompositeRouter methodsFor: 'filters' stamp: 'AttilaMagyar 5/8/2015 19:00'!addAfterFilter: aTeaFilter	^ afterFilters add: aTeaFilter! !!TeaCompositeRouter methodsFor: 'filters' stamp: 'AttilaMagyar 5/8/2015 19:00'!addBeforeFilter: aTeaFilter	^ beforeFilters add: aTeaFilter! !!TeaCompositeRouter methodsFor: 'error handing' stamp: 'AttilaMagyar 8/24/2014 17:10'!addErrorHandler: aTeaErrorHandler	^ errorhandlers add: aTeaErrorHandler! !!TeaCompositeRouter methodsFor: 'private' stamp: 'AttilaMagyar 9/27/2014 21:40'!evaluateAfterFilters: aZnRequest response: aZnResponse	afterFilters do: [ :each | each handleRequest: aZnRequest response: aZnResponse ]! !!TeaCompositeRouter methodsFor: 'private' stamp: 'AttilaMagyar 9/27/2014 19:54'!evaluateBeforeFilters: aZnRequest	beforeFilters do: [ :each | each handleRequest: aZnRequest ]! !!TeaCompositeRouter methodsFor: 'private' stamp: 'AttilaMagyar 9/27/2014 22:43'!evaluateRouters: aZnRequest	routers do: [ :each | | response |		response := each handleRequest: aZnRequest.		response isNotFound ifFalse: [ ^ response ] ].	^ ZnResponse notFound: aZnRequest uri! !!TeaCompositeRouter methodsFor: 'private' stamp: 'AttilaMagyar 9/22/2014 21:44'!exceptionOccurred: anException request: aZnRequest	| handler |	handler := errorhandlers 		detect: [ :each | each canHandleError: anException ]		ifNone: [ anException pass ].			^ handler handleError: anException request: (TeaRequest fromZnRequest: aZnRequest).	! !!TeaCompositeRouter methodsFor: 'zn delegate' stamp: 'AttilaMagyar 9/27/2014 22:21'!handleRequest: aZnRequest	| response |	^ [ self evaluateBeforeFilters: aZnRequest.	     response := self evaluateRouters: aZnRequest.	     self evaluateAfterFilters: aZnRequest response: response.	     response		   ] on: Exception 	     do: [ :ex | self exceptionOccurred: ex request: aZnRequest ]! !!TeaCompositeRouter methodsFor: 'initialization' stamp: 'AttilaMagyar 9/27/2014 19:50'!initialize	super initialize.	errorhandlers := OrderedCollection new.	beforeFilters := OrderedCollection new.	afterFilters := OrderedCollection new.! !!TeaCompositeRouter methodsFor: 'initialization' stamp: 'AttilaMagyar 8/3/2014 11:28'!setRouters: teaRouterCollection	routers := teaRouterCollection asArray.	^ self! !!TeaDynamicRouter methodsFor: 'route dispatcher' stamp: 'AttilaMagyar 7/31/2014 23:15'!addRoute: aRoute	^ routes add: aRoute.	! !!TeaDynamicRouter methodsFor: 'zn delegate' stamp: 'AttilaMagyar 8/16/2014 18:58'!handleRequest: aZnRequest	routes do: [ :each | | aZnResponse |		aZnResponse := each handleRequest: aZnRequest.		aZnResponse isNotFound ifFalse: [ ^ aZnResponse ] ].		^ ZnResponse notFound: aZnRequest uri! !!TeaDynamicRouter methodsFor: 'initialization' stamp: 'AttilaMagyar 7/31/2014 23:12'!initialize	super initialize.	routes := OrderedCollection new.! !!TeaDynamicRouter methodsFor: 'accessing' stamp: 'TorstenBergmann 10/12/2015 13:58'!routes	^routes! !!TeaRouter methodsFor: 'zn delegate' stamp: 'AttilaMagyar 8/2/2014 23:09'!handleRequest: aZnRequest	self subclassResponsibility ! !!TeaStaticRouter methodsFor: 'zn delegate' stamp: 'AttilaMagyar 8/2/2014 23:06'!handleRequest: aZnRequest	^ delegate 		ifNil: [ ZnResponse notFound: aZnRequest uri  ] 		ifNotNil: [ delegate handleRequest: aZnRequest ]! !!TeaStaticRouter methodsFor: 'acccessing' stamp: 'AttilaMagyar 8/2/2014 23:06'!urlPrefix: urlPrefixString path: pathString	delegate ifNil: [ delegate := ZnStaticFileServerDelegate new ].	delegate		prefixFromString: urlPrefixString;		directory: pathString asFileReference.! !!TeaGlobUrlPattern class methodsFor: 'private' stamp: 'AttilaMagyar 8/16/2014 18:36'!createSegment: aString atLast: aBoolean	aString = '*' 		ifTrue: [ ^ TeaWildcard atLast: aBoolean ].	(aString beginsWith: '<')		ifTrue: [ ^ TeaPlaceholder fromString: aString atLast: aBoolean ].	^ TeaLiteral fromString: aString atLast: aBoolean! !!TeaGlobUrlPattern class methodsFor: 'private' stamp: 'AttilaMagyar 8/16/2014 18:37'!parseSegments: aString	| tokens |	tokens := aString findTokens: '/'.	^ tokens collectWithIndex: [ :each :idx | 		self createSegment: each atLast: idx = tokens size ]! !!TeaGlobUrlPattern class methodsFor: 'instance creation' stamp: 'AttilaMagyar 7/26/2014 23:04'!parseString: aString	^ self new setSegments: (self parseSegments: aString)! !!TeaGlobUrlPattern methodsFor: 'url matcher' stamp: 'AttilaMagyar 7/30/2014 22:01'!matchesUrl: anUrl placeholders: aDictionary	| urlSegments |	urlSegments := self padUrlSegments: anUrl with: TeaPadding size: segments size.	segments isEmpty		ifTrue: [ ^ urlSegments isEmpty ].	^ segments first 		matches: urlSegments 		rest: segments allButFirst 		placeholders: aDictionary! !!TeaGlobUrlPattern methodsFor: 'private' stamp: 'AttilaMagyar 8/3/2014 18:36'!padUrlSegments: anUrl with: padding size: anInteger	| urlSegments |	urlSegments := anUrl segments isEmptyOrNil 		ifTrue: [ OrderedCollection new ]		ifFalse: [ self trimTrailingSlash: anUrl segments ].	urlSegments size < segments size		ifTrue: [ urlSegments := urlSegments forceTo: anInteger paddingWith: padding ].	^ urlSegments! !!TeaGlobUrlPattern methodsFor: 'printing' stamp: 'AttilaMagyar 10/26/2015 21:55'!printOn: aStream	aStream nextPut: $'.	segments 		do: [ :each | each printOn: aStream ]		separatedBy: [ aStream nextPut: $/ ].	aStream nextPut: $'.! !!TeaGlobUrlPattern methodsFor: 'initialization' stamp: 'AttilaMagyar 7/26/2014 23:23'!setSegments: anArray	segments := anArray.	^ self! !!TeaGlobUrlPattern methodsFor: 'private' stamp: 'AttilaMagyar 8/3/2014 18:29'!trimTrailingSlash: urlSegments 	^ (urlSegments isNotEmpty and: [ urlSegments last = '/' ])		ifTrue: [ urlSegments allButLast ]		ifFalse: [ urlSegments ]! !!TeaRxUrlPattern class methodsFor: 'instance creation' stamp: 'AttilaMagyar 8/14/2014 22:27'!fromRxMatcher: aRxMatcher 	^ self new initializeRxMatcher: aRxMatcher ! !!TeaRxUrlPattern methodsFor: 'private' stamp: 'AttilaMagyar 8/16/2014 19:21'!hasMatched: aZnUrl	"XXX RxMatcher has state. Consider something better"	^ lock critical: [ (regexp matches: aZnUrl path) or: [ regexp matches: '/', aZnUrl path ] ]! !!TeaRxUrlPattern methodsFor: 'initialization' stamp: 'AttilaMagyar 8/14/2014 22:27'!initializeRxMatcher: aRxMatcher 	regexp := aRxMatcher.	lock := Mutex new.	^ self! !!TeaRxUrlPattern methodsFor: 'url matcher' stamp: 'AttilaMagyar 8/14/2014 22:28'!matchesUrl: aZnUrl placeholders: aDictionary 	| match |	match := self hasMatched: aZnUrl.	match ifTrue:		[ 2 to: regexp subexpressionCount do: [ :i | 			aDictionary at: i - 1put: (regexp subexpression: i) ] ].	^ match! !!TeaRxUrlPattern methodsFor: 'printing' stamp: 'AttilaMagyar 10/26/2015 22:01'!printOn: aStream	aStream nextPutAll: '<regexp>'.! !!TeaUrlPattern methodsFor: 'url matcher' stamp: 'AttilaMagyar 8/14/2014 21:21'!matchesUrl: anUrl placeholders: aDictionary	self subclassResponsibility ! !!TeaUrlPatternSet class methodsFor: 'instance creation' stamp: 'AttilaMagyar 6/16/2015 18:27'!fromCollection: aCollection 	^ self new setPatterns: (aCollection collect: #asTeaUrlPattern)! !!TeaUrlPatternSet methodsFor: 'url matcher' stamp: 'AttilaMagyar 6/16/2015 18:45'!matchesUrl: anUrl placeholders: aDictionary	^ patterns anySatisfy: [ :each | each matchesUrl: anUrl placeholders: aDictionary ]! !!TeaUrlPatternSet methodsFor: 'printing' stamp: 'AttilaMagyar 6/16/2015 18:53'!printOn: aStream	aStream nextPut: ${.	patterns 		do: [ :each | each printOn: aStream ]		separatedBy: [ aStream nextPut: $. ].	aStream nextPut: $}.! !!TeaUrlPatternSet methodsFor: 'initialization' stamp: 'AttilaMagyar 6/16/2015 18:27'!setPatterns: aCollection 	patterns := aCollection.	^ self! !!Teapot class methodsFor: 'instance creation' stamp: 'AttilaMagyar 6/8/2016 22:24'!configure: optionsAssociations	"Create a new Teapot instance with optional properties. 	 - Teapot properties: #defaultOutput	 - ZnServer properties: See options protocol of ZnServer for specific usages.		Example: Teapot configure: { 		#defaultOutput -> #json. 		#bindAddress -> #[192 168 0 3].		#port -> 8080. 		#debugMode -> true 	}."		^ self new initializeOptions: optionsAssociations! !!Teapot class methodsFor: 'instance creation' stamp: 'AttilaMagyar 8/13/2014 21:09'!on	"Create Teapot with default properties."		^ self configure: { }! !!Teapot class methodsFor: 'controlling' stamp: 'AttilaMagyar 8/9/2014 17:11'!stopAll	self allInstancesDo: #stop! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 4/17/2015 23:48'!CONNECT: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #CONNECT)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 4/17/2015 23:48'!DELETE: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #DELETE)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 4/18/2015 00:09'!GET: patternActionAssoc	self 		addRouteMethod: (TeaMethodMatcher exactly: #GET) 		pattern: patternActionAssoc key 		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 4/17/2015 23:48'!HEAD: patternActionAssoc	self 		addRouteMethod: (TeaMethodMatcher exactly: #HEAD) 		pattern: patternActionAssoc key 		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 4/17/2015 23:48'!OPTIONS: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #OPTIONS)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 4/17/2015 23:48'!PATCH: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #PATCH)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 4/17/2015 23:48'!POST: patternActionAssoc	self 		addRouteMethod: (TeaMethodMatcher exactly: #POST) 		pattern: patternActionAssoc key 		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 4/17/2015 23:48'!PUT: patternActionAssoc	self 		addRouteMethod: (TeaMethodMatcher exactly: #PUT) 		pattern: patternActionAssoc key 		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 4/17/2015 23:48'!TRACE: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #TRACE)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'private' stamp: 'AttilaMagyar 11/8/2015 18:31'!addRouteMethod: aTeaMethodMatcher pattern: pattern action: aTeaAction	current := dynamicRouter addRoute:		(TeaRoute			matcher: (TeaRequestMatcher method: aTeaMethodMatcher url: pattern asTeaUrlPattern)			action: aTeaAction			transformer: defaultOutput			port: server port)! !!Teapot methodsFor: 'filters' stamp: 'AttilaMagyar 5/8/2015 19:17'!after: patternActionAssoc	current := compositeRouter addAfterFilter:				(TeaAfterFilter 			urlPattern: patternActionAssoc key asTeaUrlPattern 			action: patternActionAssoc value)! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 4/18/2015 00:02'!any: patternActionAssoc	self		addRouteMethod: TeaMethodMatcher any		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'filters' stamp: 'AttilaMagyar 5/8/2015 19:17'!before: patternActionAssoc	current := compositeRouter addBeforeFilter:				(TeaBeforeFilter 			urlPattern: patternActionAssoc key asTeaUrlPattern 			action: patternActionAssoc value)! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 5/8/2015 19:17'!exception: anExceptionSetActionAssoc	current := compositeRouter addErrorHandler:		(TeaErrorHandler			for: anExceptionSetActionAssoc key			action: anExceptionSetActionAssoc value			responseTransformer: defaultOutput)! !!Teapot methodsFor: 'initialization' stamp: 'AttilaMagyar 10/13/2014 20:41'!initializeOptions: optionsAssociations			dynamicRouter := TeaDynamicRouter new.	staticRouter := TeaStaticRouter new.	compositeRouter := TeaCompositeRouter routers: {dynamicRouter. staticRouter}.		defaultOutput := self responseTransformer: (optionsAssociations asDictionary at: #defaultOutput ifAbsent: #html).										self exception: TeaAbort -> [ :abort :req | abort response teaTransform: [ :same | same ] request: req].	server := ZnServer defaultServerClass new.	server delegate: compositeRouter.		optionsAssociations do: [ :each | server optionAt: each key put:  each value ].		^ self! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 5/8/2015 19:17'!output: transformerBlockOrSymbol	current responseTransformer: (self responseTransformer: transformerBlockOrSymbol)	! !!Teapot methodsFor: 'private' stamp: 'AttilaMagyar 8/13/2014 20:51'!responseTransformer: transformerBlockOrSymbol	^ transformerBlockOrSymbol isSymbol		ifTrue: [ TeaOutput perform: transformerBlockOrSymbol ]		ifFalse: [ transformerBlockOrSymbol ]! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 8/16/2014 18:38'!serveStatic: urlPrefixString from: pathString		staticRouter urlPrefix: urlPrefixString path: pathString! !!Teapot methodsFor: 'accessing' stamp: 'AttilaMagyar 8/2/2014 20:56'!server	^ server! !!Teapot methodsFor: 'controlling' stamp: 'AttilaMagyar 9/28/2014 18:14'!start	server start! !!Teapot methodsFor: 'controlling' stamp: 'AttilaMagyar 8/13/2014 20:24'!stop	server stop! !!Teapot methodsFor: 'filters' stamp: 'AttilaMagyar 5/8/2015 19:17'!when: aBlockClosure 	current whenClause: aBlockClosure	! !!Collection methodsFor: '*Teapot-Core' stamp: 'AttilaMagyar 6/16/2015 18:26'!asTeaUrlPattern	^ TeaUrlPatternSet fromCollection: self! !"Teapot-Core"!!TeaKeyValueList commentStamp: 'AttilaMagyar 10/31/2015 16:20' prior: 0!I'm built up from a dynamically extensible list of other components.!!Cupboard commentStamp: 'TorstenBergmann 10/8/2015 21:36' prior: 0!A cupboad for teapots!!TeaIconProvider commentStamp: 'TorstenBergmann 10/5/2016 21:57' prior: 0!An icon provider for tools icons with an icon cache!!TeaFormTab commentStamp: 'AttilaMagyar 10/30/2015 19:47' prior: 0!I'm built up from a dynamically extensible key value pair list (TeaKeyValueInput). I can represent POST parameters or HTTP headers for example.!!TeaKeyValueInput commentStamp: 'AttilaMagyar 10/30/2015 20:21' prior: 0!Two inputs and a remove button.!!TeaRequestBodyTabs commentStamp: 'AttilaMagyar 10/30/2015 20:17' prior: 0!I graphically represent a request body that can be viewed in multiple ways.!!Teaspoon commentStamp: 'AttilaMagyar 10/30/2015 19:33' prior: 0!I provide a graphical interface for quickly testing and excesising routes. Right click on a route in the inspector to open me.!!TeaKeyValueList class methodsFor: 'specs' stamp: 'AttilaMagyar 10/31/2015 14:28'!defaultSpec	^ SpecLayout composed! !!TeaKeyValueList methodsFor: 'protocol' stamp: 'AttilaMagyar 10/31/2015 19:45'!addKey: keyString value: valueString	self needFullRebuild: false.		self buildWithSpecLayout: 		(self dynamicLayout: 			(self asAssociations copyWith: keyString -> valueString))! !!TeaKeyValueList methodsFor: 'private' stamp: 'AttilaMagyar 10/31/2015 19:42'!asAssociations	^ models collect: #asAssociation! !!TeaKeyValueList methodsFor: 'private' stamp: 'AttilaMagyar 10/31/2015 19:52'!dynamicLayout: associations	self focusOrder removeAll.	models removeAll.	self widgets removeAll.	^ SpecLayout composed newColumn: [ :col |			associations doWithIndex: [:assoc :i | 				| inputName widget |				inputName := ('input', i asString) asSymbol.				self instantiateModels: {inputName.  #TeaKeyValueInput}.				widget := self perform: inputName.				widget					setKey: assoc key					value: assoc value					removeAction: [ :me | self remove: me ].				models add: widget.				self focusOrder add: widget.				col 					newRow: [ :row | row add: inputName ] ] ].		! !!TeaKeyValueList methodsFor: 'initialization' stamp: 'AttilaMagyar 10/31/2015 19:32'!initialize	super initialize.	models := OrderedCollection new.! !!TeaKeyValueList methodsFor: 'protocol' stamp: 'AttilaMagyar 10/31/2015 19:42'!items	^ self withoutDuplicatesAndBlanks: (self asAssociations asOrderedDictionary)! !!TeaKeyValueList methodsFor: 'protocol' stamp: 'AttilaMagyar 10/31/2015 19:39'!items: keyedCollection	self needFullRebuild: false.	self buildWithSpecLayout: 		(self dynamicLayout: 			(self withoutDuplicatesAndBlanks: keyedCollection))! !!TeaKeyValueList methodsFor: 'private' stamp: 'AttilaMagyar 10/31/2015 19:42'!remove: model	self needFullRebuild: false.	models remove: model.	self buildWithSpecLayout: (self dynamicLayout: self asAssociations)! !!TeaKeyValueList methodsFor: 'private' stamp: 'AttilaMagyar 10/31/2015 19:38'!withoutDuplicatesAndBlanks: keyedCollection	| keyset |	keyset := PluggableSet new		equalBlock: [ :a :b | a key = b key ];		hashBlock: [ :x | x key hash ];		yourself.					keyedCollection keysAndValuesDo: [ :key :value | 		keyset add: (key -> value) ].	^ keyset reject: [ :each | 		each key isEmptyOrNil or: [ each value isEmptyOrNil ] ]! !!Cupboard class methodsFor: 'accessing' stamp: 'TorstenBergmann 10/5/2016 21:56'!iconProvider	^TeaIconProvider! !!Cupboard class methodsFor: 'world menu' stamp: 'TorstenBergmann 10/5/2016 21:55'!menuCommandOn: aBuilder 	<worldMenu> 		(aBuilder item: #'Teapot')	 		help: 'Teatime'; 		parent: #'Tools' translated;		icon: self iconProvider teapotIcon;		action: [ self soleInstance inspect ].	 aBuilder withSeparatorAfter ! !!Cupboard class methodsFor: 'instance creation' stamp: 'TorstenBergmann 10/8/2015 21:37'!new	self error: 'Do not create new instances - access using #soleInstance'! !!Cupboard class methodsFor: 'private' stamp: 'TorstenBergmann 10/8/2015 21:38'!reset	<script>		soleInstance := nil.	 ! !!Cupboard class methodsFor: 'accessing' stamp: 'TorstenBergmann 10/8/2015 21:38'!soleInstance	<script: 'self soleInstance inspect'>		^ soleInstance ifNil: [ soleInstance := self basicNew initialize ]! !!Cupboard methodsFor: 'inspecting' stamp: 'TorstenBergmann 10/5/2016 22:05'!gtInspectorTeapotsIn: composite	<gtInspectorPresentationOrder: 0>  		^(composite list)		title: 'Teapots';		icon: [:each | self iconForTeapot: each ];		display: [ self teapots ]; 		format: [:each | self nameForTeapot: each ];		selectionAct:  [:each | each selection ifNotNil: [ each selection start ]. each update ] icon: self iconProvider teapotServerStartIcon entitled: 'Start';		selectionAct: [:each | each selection ifNotNil: [ each selection stop ]. each update ] icon: self iconProvider teapotServerStopIcon entitled: 'Stop';		act: [:each | self onNewServer. each update ] icon: self iconProvider teapotServerIcon entitled: 'New Teapot';		act: [:each | self onNewStaticServer. each update ] icon: self iconProvider teapotServerStaticIcon entitled: 'New Teapot (serving static)'		! !!Cupboard methodsFor: 'private' stamp: 'TorstenBergmann 10/5/2016 21:57'!iconForTeapot: aTeapot	^aTeapot server isRunning 			ifTrue: [ self iconProvider teapotServerStartIcon ] 			ifFalse: [ self iconProvider teapotServerStopIcon ]! !!Cupboard methodsFor: 'accessing' stamp: 'TorstenBergmann 10/5/2016 21:56'!iconProvider	^self class iconProvider! !!Cupboard methodsFor: 'private' stamp: 'TorstenBergmann 10/8/2015 21:39'!nameForTeapot: aTeapot	^String streamContents: [:stream |		stream nextPutAll: aTeapot server port asString.		stream nextPutAll: ' - '.		stream nextPutAll: (aTeapot server isRunning ifTrue: [ 'running' ] ifFalse: [ 'stopped' ]) ].! !!Cupboard methodsFor: 'actions' stamp: 'TorstenBergmann 10/5/2016 21:33'!onNewServer	|port pot |	port := UIManager default request: 'New server' initialAnswer: '80'.	port ifNil: [ ^self ].	pot := Teapot configure: { 		#port -> port asNumber	}.	pot start			! !!Cupboard methodsFor: 'actions' stamp: 'TorstenBergmann 10/5/2016 21:33'!onNewStaticServer	|port directory pot |	port := UIManager default request: 'New server' initialAnswer: '80'.	port ifNil: [ ^self ].	directory := UIManager default chooseDirectory: 'Serve directory'.	directory ifNil: [ ^self ].	pot := Teapot configure: { 		#port -> port asNumber	}.	pot serveStatic: '/' from: directory.	pot start			! !!Cupboard methodsFor: 'printing' stamp: 'TorstenBergmann 10/8/2015 21:39'!printOn: aStream	aStream nextPutAll: 'Cupboard'! !!Cupboard methodsFor: 'accessing' stamp: 'TorstenBergmann 10/12/2015 09:38'!teapots	^Teapot allInstances! !!TeaIconProvider class methodsFor: 'accessing' stamp: 'TorstenBergmann 10/5/2016 21:55'!icons	IconCache ifNil: [ IconCache := Dictionary new ].	^IconCache! !!TeaIconProvider class methodsFor: 'icons' stamp: 'TorstenBergmann 10/5/2016 21:52'!teapotIcon	^ self icons			at: #'teapotIcon'			ifAbsentPut: [ Form fromBinaryStream: (Base64MimeConverter mimeDecodeToBytes: self teapotIconContents readStream) ].! !!TeaIconProvider class methodsFor: 'private - icons' stamp: 'TorstenBergmann 10/5/2016 21:52'!teapotIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABhklEQVR42rWSPSxDURTHzzmvr8TyRBP00Y1BQiwiRD+YkKiPyWqTSDAZjUaj2SyS0lbEpNWPRCTEYBeNKrv4qN57nFYiPoqXNM7Nzcs799zf/Z//vQg1Bv4rIO4LdDCgF5FPwrn0s2PAdmsf1RkNvbK6KbMLGGaR4SCcTz19A0S8A3NkGo/TuexWORG1A/2MvE9EHuQ3PsuQeFFcWjXQtaEVjpHBzZLexj07cK4Je1jTKBn6khmzCNzyJo7h41dAD8z6FJEs+TuT1hijdnAICdJS8ShFRSlv/Ms4Zp6ZzKd2Y75gBqM+v9DoChgt587zsrtObRSLdFFpMm4Hk0AQcgpw89N6CdyHCnGtAthp93e6gI6l0yZ08DTEi1NibSmCpffqeFvILF+C3MD47/LFK8Y9MNRiOJe5+3RczDviYXpJisvdP+wXo2FCVCbC10dc9SHF7eF6QD2vUC8Qkkf0uiT9wFon5OSVqUL65oui6hGxBy3TMMsAU+Y9Ki5M3KZ1lZZqi5oBr2z5j75RN5raAAAAAElFTkSuQmCC'! !!TeaIconProvider class methodsFor: 'icons' stamp: 'TorstenBergmann 10/5/2016 21:52'!teapotServerIcon	^ self icons			at: #'teapotServerIcon'			ifAbsentPut: [ Form fromBinaryStream: (Base64MimeConverter mimeDecodeToBytes: self teapotServerIconContents readStream) ].! !!TeaIconProvider class methodsFor: 'private - icons' stamp: 'TorstenBergmann 10/5/2016 21:52'!teapotServerIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAC0UlEQVR4Xo2SbU+SURzG+RS2hDdufQBtM0e58GHa8o2W3mbWkjbLhzURTTNEHnwowNKG2oM6JUWF2+fHTJ2aJaFCPlAzJygGOMPM8qF8wqtbXli2rK7t2v7n7Fy/c8520fbk4nKEkZkpIUViKckXSEj9qBEjehNG3kxDILxLenoyCVdXVwbtMHl7s4hJ4ypsi1uUHbDad2Fz2kGtd2G2bWBIZ0Jz6wvLHtDL69RBIIvlS2hGFqEbW4FhcgWmuU0YzduYNu9QswOmDw7MWhwUaAe2Tw7M29dxIyGV3Af4+voR3X1mDAwuoLd/Hl09c9Q8D/34MgVcxYz1O+yft2Ff3sTYWxvKK/oRxU44CGhpe4/Orlm0tk+joWkS6toJ1KhHoax5jdLyPsgLn0GUrUZMnBTnw64jPj7lIEBNjqK+8R1U5DiU1XqUP9WitGwQfEEJMgRS5D8ohrJKjampKQhF9+HjG8j9BeBPlCk0qFDqUKbQ4knJSzwsom6Vd1N/lcJgMGBraxvf1jfw5es64mJvwfMEk9gHBAaeIeQFXXhcPIDCwl7k5z9HrqwDUkkL2Ox0aLXDWFvbwsLCMmZm7QgJYeNsUNBPgLu7B1MirUdeXidk0nbkZDdBLKqjXIuIiBS0tXXBal2C0bSEVxoTgoOjQGfQD/YiLU1MioQqZ1AoUEOQoYZISCI8PBnVNc2YMFiocpnR1jEM9lUO/lioa9FJZDqvygnYsxNwIQmKikYqbMGAZgbquh4kcsU4tJUyWYklg6/aBxDhXBQ9UkE3/hGDQzNIThUg5BxbcyjgKFVRHk9uEWSonIAwgoukm3eo0CW4uR1DQEAktRdN0v4md4/jTA4n17L3ipjYe2D5ROK0z0VcTuSBL6zElajYPNq/5OcfQGRlKZHAKaLal4/bPAXkBa3IypZr6HQ6g/Y/8vI6SVRW9qChUYPsnCJNaGgE9/czPwCyhvLlWzqQAwAAAABJRU5ErkJggg=='! !!TeaIconProvider class methodsFor: 'icons' stamp: 'TorstenBergmann 10/5/2016 21:52'!teapotServerStartIcon	^ self icons			at: #'teapotServerStartIcon'			ifAbsentPut: [ Form fromBinaryStream: (Base64MimeConverter mimeDecodeToBytes: self teapotServerStartIconContents readStream) ].! !!TeaIconProvider class methodsFor: 'private - icons' stamp: 'TorstenBergmann 10/5/2016 21:52'!teapotServerStartIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADR0lEQVR4Xn2T71fTZRyG+S804RV56k3Hc6jciTpHICnNOnVYfCWhCZiiCAxGlEbbhCg2TjQdIYlCwWIIU0crDhAiiOA8xL6B4kFqG7+22QYRHCL5Nbia7ByOnNPpc859zvPmup7nOef+hDw5JzOydQWfaU0qtdYkDjro/9VJv2in8lKdVaMtNUkkksiQ/xtr3ygu3yqe6TU8U4+zHjgHM/FwmT5xFMtP3S71GY1JocjT7dgRGrZF0NH1O+LdBe7en8c+tohzfBXHmB/HhB/n5BpjrkA8fh4GLnB7/0aRm2/aImhpG6LH6qOz20N7xwQ3ezzYBv/i3vBCAF7CN7PK1NwyA0Muqr69wcmMj7cKmiw22q6P09xip8nyANPVIeobBqhv/IXq7zopK2+l4PNG0k5oiBfSSUxM1W0RNDRaMf8wTOOVe9TVi9QY+rhY1UthkQGlUsPZc5UYjSbsdgenPikmIkIibMK7JS9G5p0vIfF8Dqll+ZRUmKmouIlef52c3HOINhsrKys8+meZ2dkFUlKziY19LSiQ7JUIh5vep2SgmNbJFgy/1XC09SgHNXI0xRbSjmvo6uxiIQB7vbPYHX8glaYSFxcnhGx7altYglmgxl5Ns+tHFlcfMTI3TJ2zluzeLA4pPyLlSCENDddwu2dwOP+kq/tB4P/pbNwe/UGU7thtGbXOSuaX51hfX9+IdfoW+pESdpdHkpx6hksXjQzdn6TfNo7Z0kumXBUUPK/YZZKLR5ha9G7Cj+Nf82NxX+E5YziyFCXlFbXYRDc9t0epu9yCUlUaFLycJzEliq9TMfkF7TPmALyGb9nDhUkN6hE5uy4/TVLyp3xZWoU46KM30FZ5zile3SsNdkCaJdW9eecF0u1vUT+t3xC4lhx86BQ4OPgKMd/EIktWkZmlJu5dGeHhO9m3T4bscEZQEBoWGpbbeZwi1zF+nq8LvmBlgq+8uSTciiFNpSUzs4zomCT2RL9HUk4+6oLv2f/GO4rNDhx4+4CQcTXFVTRygralKmqnNMithyisLrBqtUYUiguB9p3ldH4N+q+bAxU+bfrPbYzaHyVsj9guPBv5jCB5Kbi6UXtiBIOhnWvmO3TcsBEfn6B4kvkXxV9YN+ClYBQAAAAASUVORK5CYII='! !!TeaIconProvider class methodsFor: 'icons' stamp: 'TorstenBergmann 10/5/2016 22:05'!teapotServerStaticIcon	^ self icons			at: #'teapotServerStaticIcon'			ifAbsentPut: [ Form fromBinaryStream: (Base64MimeConverter mimeDecodeToBytes: self teapotServerStaticIconContents readStream) ].! !!TeaIconProvider class methodsFor: 'private - icons' stamp: 'TorstenBergmann 10/5/2016 22:05'!teapotServerStaticIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADIElEQVR42l2Ta0gUURTH/1fHWVNz2dLNIinQ0shAKCsSixIp7EMQ7VKbH8SICopo6UFaiBqZBm5R1Bc1i7ZwJw1DlzbQfKTr9rA+aGX2MFbbNsu21Np259Gdcczwwsw5c+85vzn/e+8hoCM0NHThjh07KySJQBAl5BcUGUSRAEREWWkh19Ls4H788DkFQRjCjEHkV0xMrKGj+70tWquRcZBBygIkGkEQDATg9Qyjr/f5kL2p3vmw5QHn831XgEpcbKze0GDvs7FhGmgoIyJCQyEhNJ0ghBDlNyGyCZEQpqFw0Y+8XBN3395gVAB6vd5grX1s07Dh4IMieD6I8FlhiIyaBZZlEDmbQVQEo0j6NPwVz3sGcL26nGtttU8DKqvbbSyrQTDIq08QoijQPfHD7/fj14Qfo76f8AwPYmTkHSbGPnMOx71pwKXLDhsTxirJPD8JoBoxOPiSKhjFnDk6KlWLtFWpuHW7EdVVl8xu96BFBcwznCu/a2MYdjo5QEECjzdve7BvbzaSkpKpPAEBXsDJE8WotVUaR0e/cQogLi7OkF9ww8Zq6B4EJgFysCjyePXahf37tyElJRXj4xP49TsI85HjcLkcRo/Hw5HVaQlRSUv0pdu3rj/IIAj30E/09Osxf8EKMAxDAY+Rk5OF1NSV8P8BPnt9OF9WjMamm/ECT48xL3fzoePmLSW6CEYLegISL6HD9RFdL3jodDqMfHEjOTke0XOTkLw8HV7vF9zhrKi5dlGpnpwpybHmH0s3EZ5+C/Tq8HRSkFQ7OQfqV9S+QtrGw/B8eg9nZycuWApVQNFua8HRDJMcJKnBRJj0CfX/Abh+rM06hPq6Gjx1PXO2tTWtUwAlhbsoYINJDpbUBKLCiJoszx04WwfHow9ITFyNsXEv1+1sNiqA4tNG6ynzRhNouUSYgkhqJdMS9pzhEIhbg8XaZXDYr1qePOkyK4CiUwbr6SOZJjJTgmqnAEevtGJRym709j50VlVeNE51Jtm0IcWcmbE0WxLpCdBWlgQRoFdY9sfG/PqYeQkr5IZqfzrg7n/nsQwM9Fv+b+e/lwaeIIipiHQAAAAASUVORK5CYII='! !!TeaIconProvider class methodsFor: 'icons' stamp: 'TorstenBergmann 10/5/2016 21:52'!teapotServerStopIcon	^ self icons			at: #'teapotServerStopIcon'			ifAbsentPut: [ Form fromBinaryStream: (Base64MimeConverter mimeDecodeToBytes: self teapotServerStopIconContents readStream) ].! !!TeaIconProvider class methodsFor: 'private - icons' stamp: 'TorstenBergmann 10/5/2016 21:52'!teapotServerStopIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADO0lEQVR4Xn2T7U+TVxiH+xdsGfso0Q+Gbh+UBYFEsjeSzS6yKWDWdKyMurEXytDyVsfcKHRtFKdWRFyljxoiVbEoq3vxPVM2qKwd5XXZYK30BYotuEXWQaSUa8/GdDZLdidX7i/nvk7OOb8jebhK399uqtfvsdXqGmx9A15cbi9Ot4cWi9VRUrLNtGnTZrnk/6q710swHCM0vchkeInJyH3iTIQX+WHAj6vPw8e1u2ylpRrTunXpWQmCq9+M4h6KMjByl7HxOby+RTzjcbx+kcAStwJxxicWRVmc8K/3uHSlhwTB1xeH+c4R4XpXiCvXAlz/Nige4w6DI7/j8c8zNR1j5m6MUe805+xOzC32REGn3cXlq36+uuDh8/M/Yzs7zKn2fto7XAitN2g+chljQwea8kMoCspQKsscCYJT7T102n/iTMcQJ0+7aT3hRDjWw8HmC2zbvpP9piMcP96G0+nCaj1NXv5W24PhZLGExjO06Fux7LdjOdrNZ+YbHGy6hmFXO21tVhYWYszP32N2do69ew/xVrFmWaDKzatoK1IFbxoM/GhpoddoxKpS0/CBwO7dX1Dz4TGaD5uZm1sgEpklEJihvEJHdfVHNsnG7Gz5RaUSryA84NY/vXOLAl25mR07BOrqDExMzuAL/IZ78DbKwjLS0jLlEqtCERyqqmasvp5fHmJUZKSmhk8zXxJ3sqDV1jI8EqSv3ye+zCQvv1LIixtkcok9dS1Rv49YNCryR0JfiM5yMvNpqkSBpnwn/YMhurq99Nz0kpPzOiuSVyRLvpRKmQuFiC/F/0s8ztn09VRWmSlRa+l1BcWQ3WHPvhaKVGXLGegqKGAsO5tg7mZuFxYSURUxVfgGvtw8RmUyhLTnqKg0o3jtXd4s1iBNeZL1WTL0emFZ8Iw0Rf79Y0kEVq4kLBJZtYopsY+LOB55FJ2qXrwDgRc2bOXZ5xW8qq5AU3kYXd2Bf0O0JUVaMZiRQTQ3l/miImbz8xlIz0AoUTuamjqo1gq8856JKu1R9h04T2OjNZia+lTiR0p9Qppl3JhjM65ZYzPIZLa1q1f/vSAp6fHkE9ZLdJzrRv9Jk6P4bbXpr9Ddn/sTU0VgFvyaFxkAAAAASUVORK5CYII='! !!TeaIconProvider class methodsFor: 'icons' stamp: 'TorstenBergmann 10/5/2016 21:53'!teaspoonIcon	^ self icons			at: #'teaspoonIcon'			ifAbsentPut: [ Form fromBinaryStream: (Base64MimeConverter mimeDecodeToBytes: self teaspoonIconContents readStream) ].! !!TeaIconProvider class methodsFor: 'private - icons' stamp: 'TorstenBergmann 10/5/2016 21:51'!teaspoonIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABdklEQVR42mNkoBAwgoiJs6fLvHv/oe/d27cM6urqTxQVFfq8HV2fEG1AQ1f7qlevX4XCBDk5OBnExcWLynLy+4kyIK+idNWfv39C0SUNDQz7U6PjiggaMG3+3L4r164UokvycPMwdDU0MxI0YNfhgzK7du96/O37NwwFCfEJYWY6+qvxGgACPdMmF967f68PXYG8nHxYeW4BYQNAYM6yxX23bt0q/PL1C1xMVFRsdWNZZRhRBsDA8YtnQw8ePMTw8+fP0JevXoby8vCu7qxvCiPaAGRQ2dyw6uOnj6FArzzR09Oz9LR3ekKSASDQNWXi4wcPH8hwc3E/YefgsGyprHlCkgGgWNqzd89xYNjIMDMxP2FkZLSc1NH9hGgDQKCuo1Xm/fv3x//++yvDyMD4hIWV1XJiW+cTog0AAWCKlfn79+/x/wz/ZZiZmZ+oKCtbkmQACORXlcv8//fvODDpy0hJSh0n2QAQmDx3lsynT59W/fnz5wkA2dSUkQj2i7UAAAAASUVORK5CYII='! !!TeaMethodMatcher methodsFor: '*Teapot-Tools' stamp: 'AttilaMagyar 10/25/2015 18:06'!asString	^ name! !!TeaRoute methodsFor: '*Teapot-Tools' stamp: 'AttilaMagyar 11/8/2015 19:02'!gtInspectorRouteIn: composite	<gtInspectorPresentationOrder: 80>	| presentation |	presentation := composite morph.	presentation		title: 'Teaspoon';		display: 			[ | teaspoon |				teaspoon := Teaspoon new 					method: requestMatcher methodMatcher asString					url: requestMatcher urlPattern asTeaspoonPath					port: port.				teaspoon onHttpResultDo: [ :result | presentation selection: result ].				teaspoon buildWithSpec ]! !!TeaUrlPatternSet methodsFor: '*Teapot-Tools' stamp: 'AttilaMagyar 11/8/2015 18:25'!asRequestBuilderPath	^ patterns 		ifEmpty: [ '/' ]		ifNotEmpty: [ patterns first asTeaspoonPath ]! !!TeaUrlPatternSet methodsFor: '*Teapot-Tools' stamp: 'AttilaMagyar 11/8/2015 18:25'!asTeaspoonPath	^ patterns 		ifEmpty: [ '/' ]		ifNotEmpty: [ patterns first asTeaspoonPath ]! !!Teapot methodsFor: '*Teapot-Tools' stamp: 'TorstenBergmann 10/7/2016 23:02'!gtInspectorDynamicRoutesIn: composite	<gtInspectorPresentationOrder: 0>  		^(composite list)		title: ['Dynamic routes' translated];		 		display: [ dynamicRouter routes ]; 		format: [:each | each printString ];		selectionAct: [:p | p entity removeDynamicRoute: p selection. 			p pane browser update ] entitled: 'Remove route' translated;		selectionAct: [:p | p entity removeAllDynamicRoutes. 			p pane browser update ] entitled: 'Remove all' translated! !!Teapot methodsFor: '*Teapot-Tools' stamp: 'TorstenBergmann 10/7/2016 23:01'!removeAllDynamicRoutes 	dynamicRouter routes removeAll! !!Teapot methodsFor: '*Teapot-Tools' stamp: 'TorstenBergmann 10/5/2016 20:59'!removeDynamicRoute: aRoute	dynamicRouter routes remove: aRoute! !!TeaFormTab class methodsFor: 'specs' stamp: 'AttilaMagyar 10/26/2015 21:14'!defaultSpec	^ SpecLayout composed		newColumn: [ :col |			col 				add: #form;				add: #addButton height: self buttonHeight ]! !!TeaFormTab methodsFor: 'accessing' stamp: 'AttilaMagyar 10/26/2015 21:13'!addButton	^ addButton ! !!TeaFormTab methodsFor: 'accessing' stamp: 'AttilaMagyar 10/25/2015 20:16'!form	^ form! !!TeaFormTab methodsFor: 'initialization' stamp: 'AttilaMagyar 10/31/2015 19:45'!initializePresenter	addButton whenActionPerformedDo: [ form addKey: '' value: '' ]! !!TeaFormTab methodsFor: 'initialization' stamp: 'AttilaMagyar 10/31/2015 19:44'!initializeWidgets	addButton := self newButton label: 'Add parameter'; yourself.	form := self instantiate: TeaKeyValueList.	self focusOrder 		add: form;		add: addButton.! !!TeaFormTab methodsFor: 'protocol' stamp: 'AttilaMagyar 10/31/2015 16:30'!updateKeyValus: keyValueCollection	form items: keyValueCollection! !!TeaFormTab methodsFor: 'private' stamp: 'AttilaMagyar 10/31/2015 17:42'!urlEncoded	| url formParams |	url := '/' asZnUrl.	formParams := form items.	formParams ifEmpty: [ ^ '' ].	formParams do: [ :association | url := url withQuery: association ].	^ url asString allButFirst: 2	! !!TeaFormTab methodsFor: 'protocol' stamp: 'AttilaMagyar 11/1/2015 21:00'!writeUrlEncodedTo: aTextModel	self urlEncoded 		ifNotEmpty: [ aTextModel text: self urlEncoded ]! !!TeaKeyValueInput class methodsFor: 'specs' stamp: 'AttilaMagyar 10/25/2015 22:37'!defaultSpec	^ SpecLayout composed		newRow: [ :row |			row				add: #keyInput;				add: #valueInput;				add: #removeButton ]		 height: self height! !!TeaKeyValueInput class methodsFor: 'accessing' stamp: 'AttilaMagyar 10/25/2015 22:38'!height	^ self inputTextHeight max: self buttonHeight! !!TeaKeyValueInput class methodsFor: 'instance creation' stamp: 'AttilaMagyar 10/30/2015 20:34'!key: keyString value: valueString removeAction: aBlock	^ self new		setKey: keyString 		value: valueString		removeAction: aBlock! !!TeaKeyValueInput methodsFor: 'converting' stamp: 'AttilaMagyar 10/30/2015 20:23'!asAssociation	^ keyInput text -> valueInput text! !!TeaKeyValueInput methodsFor: 'initialization' stamp: 'AttilaMagyar 10/30/2015 23:52'!initializeWidgets		keyInput := self newTextInput autoAccept: true; ghostText: 'key'; yourself.	valueInput := self newTextInput autoAccept: true; ghostText: 'value'; yourself.	removeButton := self newButton label: 'Remove'; yourself.	self focusOrder		add: keyInput;		add: valueInput;		add: removeButton.		! !!TeaKeyValueInput methodsFor: 'accessing' stamp: 'AttilaMagyar 10/25/2015 20:13'!keyInput	^ keyInput! !!TeaKeyValueInput methodsFor: 'accessing' stamp: 'AttilaMagyar 10/25/2015 21:04'!removeButton	^ removeButton! !!TeaKeyValueInput methodsFor: 'initialization' stamp: 'AttilaMagyar 10/30/2015 20:39'!setKey: keyString value: valueString removeAction: aBlock	keyInput text: keyString.	valueInput text: valueString.	removeButton whenActionPerformedDo: [ aBlock value: self ].	^ self! !!TeaKeyValueInput methodsFor: 'accessing' stamp: 'AttilaMagyar 10/25/2015 20:13'!valueInput	^ valueInput! !!TeaRequestBodyTabs class methodsFor: 'specs' stamp: 'AttilaMagyar 10/30/2015 20:08'!defaultSpec	^ SpecLayout composed		newColumn: [ :col |			col 				add: #label height: self inputTextHeight;				add: #requestBody ]! !!TeaRequestBodyTabs methodsFor: 'private' stamp: 'AttilaMagyar 10/30/2015 22:22'!formTabTitle	^ 'Form'! !!TeaRequestBodyTabs methodsFor: 'initialization' stamp: 'AttilaMagyar 10/30/2015 20:08'!initializeWidgets	label := self newLabel label: 'Request body'; yourself.	requestBody := self newRequestBody.! !!TeaRequestBodyTabs methodsFor: 'accessing' stamp: 'AttilaMagyar 10/30/2015 20:08'!label	^ label! !!TeaRequestBodyTabs methodsFor: 'initialization' stamp: 'AttilaMagyar 11/1/2015 21:01'!newRequestBody	raw := self newText autoAccept: true; yourself.	form := TeaFormTab new.	^ self newTabManager			addTab: (self newTab				label: self rawTabTitle;				closeable: false;				model: raw);			addTab: (self newTab				label: self formTabTitle;				closeable: false;								model: form);			whenTabSelected: [:selected |				selected label = self formTabTitle					ifTrue: [ form updateKeyValus: ('?', raw text) asUrl query ] 					ifFalse: [ form writeUrlEncodedTo: raw ] ]! !!TeaRequestBodyTabs methodsFor: 'private' stamp: 'AttilaMagyar 10/30/2015 22:22'!rawTabTitle	^ 'Raw'! !!TeaRequestBodyTabs methodsFor: 'accessing' stamp: 'AttilaMagyar 10/30/2015 20:09'!requestBody	^ requestBody! !!TeaRequestBodyTabs methodsFor: 'protocol' stamp: 'AttilaMagyar 10/30/2015 22:22'!urlEncoded	requestBody selectedTab label = self formTabTitle		ifTrue: [ raw text: form urlEncoded ].	^ raw text! !!Teaspoon class methodsFor: 'specs' stamp: 'AttilaMagyar 10/30/2015 20:57'!defaultSpec	^ SpecLayout composed		newColumn: [ :col | 												col 				newRow: [ :row | 					row 						add: #methodDropList width: 90;						add: #urlInput ]				height: self inputTextHeight.			col				add: #requestBody;				add: #contentTypeLabel height: self inputTextHeight;				add: #contentTypeDropList height: self inputTextHeight.			col 				newRow: 					[ :row | row add: #execButton ] 				height: self buttonHeight						]! !!Teaspoon class methodsFor: 'private - accessing' stamp: 'TorstenBergmann 10/5/2016 21:59'!iconProvider	^TeaIconProvider ! !!Teaspoon class methodsFor: 'world menu' stamp: 'TorstenBergmann 10/5/2016 21:59'!menuCommandOn: aBuilder 	<worldMenu> 		(aBuilder item: #'Teaspoon')	 		help: 'Teaspoon'; 		parent: #'Tools' translated;		icon: self iconProvider teaspoonIcon;		action: [ self open ].! !!Teaspoon class methodsFor: 'interface' stamp: 'TorstenBergmann 10/5/2016 21:35'!open	<script>		(self new)		openWithSpec;		yourself! !!Teaspoon class methodsFor: 'specs' stamp: 'AttilaMagyar 10/30/2015 19:35'!title	^ 'Teaspoon client'! !!Teaspoon methodsFor: 'private' stamp: 'AttilaMagyar 10/30/2015 22:09'!client	^ ZnClient new		url: self urlInput text;		method: self methodDropList selectedItem;		entity: (ZnStreamingEntity 			readFrom: (ReadStream on: requestBody urlEncoded)			usingType: self contentTypeDropList selectedItem			andLength: requestBody urlEncoded size)		yourself! !!Teaspoon methodsFor: 'private' stamp: 'TorstenBergmann 10/5/2016 23:32'!consumer	^ consumer ifNil: [ consumer := [ :any | any inspect ] ]! !!Teaspoon methodsFor: 'accessing' stamp: 'AttilaMagyar 10/25/2015 17:24'!contentTypeDropList	^ contentTypeDropList! !!Teaspoon methodsFor: 'accessing' stamp: 'AttilaMagyar 10/25/2015 17:28'!contentTypeLabel	^ contentTypeLabel! !!Teaspoon methodsFor: 'accessing' stamp: 'AttilaMagyar 10/25/2015 18:27'!execButton	^ execButton! !!Teaspoon methodsFor: 'api' stamp: 'AttilaMagyar 10/25/2015 22:32'!initialExtent	^  580@420! !!Teaspoon methodsFor: 'initialization' stamp: 'TorstenBergmann 10/5/2016 23:31'!initializePresenter	execButton		whenActionPerformedDo: [ 			self urlInput text notEmpty				ifTrue: [ self consumer value: self client execute ]]! !!Teaspoon methodsFor: 'initialization' stamp: 'AttilaMagyar 10/30/2015 22:11'!initializeWidgets	methodDropList := self newMethodDropList.	urlInput := self newTextInput autoAccept: true; yourself.	requestBody := TeaRequestBodyTabs new.	contentTypeLabel := self newLabel label: 'Content Type'; yourself.	contentTypeDropList := self newContentTypeDropList.	execButton := self newButton label: 'Execute request'; yourself.! !!Teaspoon methodsFor: 'tea spoon' stamp: 'AttilaMagyar 11/8/2015 18:24'!method: methodString url: urlString port: portNumber	self populateMethod: methodString.	self populateUrl: urlString port: portNumber.! !!Teaspoon methodsFor: 'accessing' stamp: 'AttilaMagyar 10/25/2015 17:33'!methodDropList	^ methodDropList! !!Teaspoon methodsFor: 'initialization' stamp: 'AttilaMagyar 10/30/2015 22:29'!newContentTypeDropList	| dropList |	dropList := self newDropList.	#(		applicationFormUrlEncoded 		applicationJson 		applicationXml 		applicationSton 		applicationOctetStream 		text 		textHtml 		textPlain	) do: [ :each | dropList addItemLabeled: (each value: ZnMimeType) do: [] ].		^ dropList! !!Teaspoon methodsFor: 'initialization' stamp: 'AttilaMagyar 10/30/2015 21:03'!newMethodDropList	| dropList |	dropList := self newDropList.	ZnConstants knownHTTPMethods do: [ :each | 		dropList addItemLabeled: each do: [] ].	^ dropList! !!Teaspoon methodsFor: 'tea spoon' stamp: 'AttilaMagyar 11/8/2015 19:03'!onHttpResultDo: aBlock	consumer := aBlock! !!Teaspoon methodsFor: 'private' stamp: 'AttilaMagyar 11/8/2015 18:23'!populateMethod: methodString	| selected |	selected := methodDropList listItems		detect: [ :each | each = methodString ]		ifNone: [ methodDropList listItems first ].	methodDropList setSelectedItem: selected! !!Teaspoon methodsFor: 'private' stamp: 'AttilaMagyar 11/8/2015 18:24'!populateUrl: urlString port: portNumber	| pathSegment |	pathSegment := urlString.	(pathSegment beginsWith: '/') 		ifFalse: [ pathSegment := '/', pathSegment ].		urlInput text: ('http://localhost:', portNumber asString, pathSegment)! !!Teaspoon methodsFor: 'accessing' stamp: 'AttilaMagyar 10/30/2015 20:56'!requestBody	^ requestBody! !!Teaspoon methodsFor: 'accessing' stamp: 'AttilaMagyar 10/25/2015 17:22'!urlInput	^ urlInput! !!TeaRequestMatcher methodsFor: '*Teapot-Tools' stamp: 'AttilaMagyar 10/25/2015 18:02'!methodMatcher	^ methodMatcher! !!TeaRequestMatcher methodsFor: '*Teapot-Tools' stamp: 'AttilaMagyar 10/25/2015 18:03'!urlPattern	^ urlPattern! !!TeaGlobUrlPattern methodsFor: '*Teapot-Tools' stamp: 'AttilaMagyar 11/8/2015 18:25'!asTeaspoonPath	^ String streamContents: [ :aStream |			segments 				do: [ :each | each printOn: aStream ]				separatedBy: [ aStream nextPut: $/ ] ]! !!TeaRxUrlPattern methodsFor: '*Teapot-Tools' stamp: 'AttilaMagyar 11/8/2015 18:25'!asTeaspoonPath	^ '/'! !"Teapot-Tools"!!TeaTestClient commentStamp: 'AttilaMagyar 7/29/2014 22:38' prior: 0!Http client for testing.!!TeaUrlPatternTest methodsFor: 'private' stamp: 'AttilaMagyar 8/14/2014 21:22'!pattern: patternString matches: urlString	| placeholders |	placeholders := Dictionary new.	self assert: ((TeaGlobUrlPattern parseString: patternString) matchesUrl: urlString asUrl placeholders: placeholders).	^ placeholders! !!TeaUrlPatternTest methodsFor: 'private' stamp: 'AttilaMagyar 8/14/2014 21:22'!pattern: patternString noMatch: urlString	| placeholders |	placeholders := Dictionary new.	self deny: ((TeaGlobUrlPattern parseString: patternString) matchesUrl: urlString asUrl placeholders: placeholders).	^ placeholders! !!TeaUrlPatternTest methodsFor: 'tests' stamp: 'AttilaMagyar 7/29/2014 20:12'!testLongerPatternEndedPlaceholder	self pattern: '/a/b/<id>' noMatch: '/a/b'.! !!TeaUrlPatternTest methodsFor: 'tests' stamp: 'AttilaMagyar 7/26/2014 21:18'!testLongerPatternEndedWildcard	self pattern: '/a/b/c/*' matches: '/a/b/c'.	self pattern: '/1/2/3/*/*' matches: '/1/2/3'.		self pattern: '/a/b/c/*' noMatch: '/a/b'.! !!TeaUrlPatternTest methodsFor: 'tests' stamp: 'AttilaMagyar 7/26/2014 21:11'!testNoWildcard		self pattern: '/aa' matches: '/aa'.	self pattern: '/aa' noMatch: '/bb'.! !!TeaUrlPatternTest methodsFor: 'tests' stamp: 'AttilaMagyar 7/28/2014 22:29'!testPlaceholderSubstitute	| placeholders |		placeholders := self pattern: '/<id>/a/b' matches: '/123/a/b'.	self assert: (placeholders at: #id) equals: '123'.		placeholders := self pattern: '/a/<id>/b' matches: '/a/25/b'.	self assert: (placeholders at: #id) equals: '25'.		placeholders := self pattern: '/a/b/<id>' matches: '/a/b/xyz'.		self assert: (placeholders at: #id) equals: 'xyz'.		! !!TeaUrlPatternTest methodsFor: 'tests' stamp: 'AttilaMagyar 8/3/2014 17:25'!testPlaceholderTypeMatch	| placeholders |	placeholders := self pattern: '/<id:IsInteger>' matches: '/12'.	self assert: (placeholders at: #id) equals: 12.		placeholders := self pattern: '/<id:IsInteger>/abc' matches: '/-34/abc'.	self assert: (placeholders at: #id) equals: -34.		placeholders := self pattern: '/<float:IsNumber>/<int:IsNumber>' matches: '/3.14/3'.	self assert: (placeholders at: #float) equals: 3.14.	self assert: (placeholders at: #int) equals: 3.	! !!TeaUrlPatternTest methodsFor: 'tests' stamp: 'AttilaMagyar 8/3/2014 17:18'!testPlaceholderTypeNoMatch	self pattern: '/<id:IsInteger>' noMatch: '/foobar'.		self pattern: '/<id:IsNumber>' noMatch: '/foobar'.	self pattern: '/<id:IsInteger>' noMatch: '/12.3'.		! !!TeaUrlPatternTest methodsFor: 'tests' stamp: 'AttilaMagyar 7/28/2014 22:28'!testPlaceholders	self pattern: '/<id>/a/b' matches: '/1/a/b'.	self pattern: '/a/<id>/b' matches: '/a/2/b'.	self pattern: '/a/b/<id>' matches: '/a/b/1'.			self pattern: '/<id>/a/b' noMatch: '/1/a/c'.	self pattern: '/a/<id>/b' noMatch: '/a/2/c'.	self pattern: '/a/b/<id>' noMatch: '/a/c/1'.! !!TeaUrlPatternTest methodsFor: 'tests' stamp: 'AttilaMagyar 8/3/2014 18:36'!testRoot	self pattern: '/' matches: '/'.		self pattern: '/' noMatch: '/a'.		self pattern: '/a' noMatch: '/'.	self pattern: '/a/b' noMatch: '/'.	! !!TeaUrlPatternTest methodsFor: 'tests' stamp: 'AttilaMagyar 7/29/2014 20:12'!testShorterPatternEndedPlaceholder	self pattern: '/a/b/<id>' noMatch: '/a/b/1/2'.	! !!TeaUrlPatternTest methodsFor: 'tests' stamp: 'AttilaMagyar 7/27/2014 11:39'!testShorterPatternEndedWildcard	 	self pattern: '/a/*' matches: '/a/b/c'.	self pattern: '/*' matches: '/1/2/3'.	 	self pattern: '/a/*' noMatch: '/b/b/c'.	self pattern: '/a/b' noMatch: '/a/b/c'.	! !!TeaUrlPatternTest methodsFor: 'tests' stamp: 'AttilaMagyar 7/27/2014 15:33'!testTralingSlash	self pattern: '/a/b' matches: '/a/b/'.! !!TeaUrlPatternTest methodsFor: 'tests' stamp: 'AttilaMagyar 7/26/2014 21:09'!testWildcards	self pattern: '/*/1/2' matches: '/0/1/2'.	self pattern: '/a/b/*' matches: '/a/b/c'.	self pattern: '/x/*/z' matches: '/x/y/z'.		self pattern: '/*/1/2' noMatch: '/a/1/z'.		self pattern: '/a/b/*' noMatch: '/a/1/z'.		self pattern: '/x/*/z' noMatch: '/a/1/z'.						! !!TeapotAbortTest methodsFor: 'running' stamp: 'AttilaNamed 3/1/2015 20:08'!setUp	server := Teapot on		GET: 'badrequest' -> [ :req | req abort: (ZnResponse badRequest: req) ];		GET: 'unauthorized' -> [ :req | req abort: TeaResponse unauthorized ];		GET: 'abortstring' -> [ :req | req abort: 'abort test' ];				start.! !!TeapotAbortTest methodsFor: 'running' stamp: 'AttilaMagyar 8/9/2014 22:15'!tearDown	server stop! !!TeapotAbortTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testAbortSupportsAnyObject	self assert: (TeaTestClient httpGetString: '/abortstring') equals: 'abort test'.! !!TeapotAbortTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testErrorCodes	self assert: (TeaTestClient httpGet: '/badrequest') code equals: 400.	self assert: (TeaTestClient httpGet: '/unauthorized') code equals: 401.! !!TeapotAfterTest methodsFor: 'running' stamp: 'AttilaMagyar 9/27/2014 22:24'!setUp	server := Teapot on		after: '/after/<param>' -> [ :req :resp | resp headers at: 'header-key' put: (req at: #param) ];		GET: '/after/*' -> 'after-return';				start		! !!TeapotAfterTest methodsFor: 'running' stamp: 'AttilaMagyar 9/22/2014 21:12'!tearDown	server stop! !!TeapotAfterTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testAfterFilterCanModifyResponse	| response |		response := TeaTestClient httpGet: '/after/header-value'.	self assert: response entity string equals: 'after-return'.	self assert: (response headers at: 'header-key') equals: 'header-value'.		response := TeaTestClient httpPost: '/after/notfound'.	self assert: response code equals: 404.	self assert: (response headers at: 'header-key') equals: 'notfound'.! !!TeapotBeforeTest methodsFor: 'private' stamp: 'AttilaMagyar 8/17/2014 19:35'!forbidden	^ ZnResponse new		statusLine: ZnStatusLine forbidden;		headers: ZnHeaders defaultResponseHeaders;		yourself! !!TeapotBeforeTest methodsFor: 'private' stamp: 'AttilaMagyar 8/11/2014 21:45'!logRequest: aTeaRequest	log add: (aTeaRequest at: #user)! !!TeapotBeforeTest methodsFor: 'running' stamp: 'AttilaMagyar 8/24/2014 18:04'!setUp	log := OrderedCollection new.	server := Teapot on		before: '/secure/*' -> [ :req | ((req at: #user) = 'admin' and: [ (req at: #pass) = '****' ]) 			ifFalse: [ req abort: self forbidden ] ];		before: '*' -> (Send message: #logRequest: to: self);		before: '*' -> 'any';		GET: '/secure' -> 'protected';		GET: '/secure/1/2/3' -> 'protected';		POST: '/public' -> 'public';		start		! !!TeapotBeforeTest methodsFor: 'running' stamp: 'AttilaMagyar 8/11/2014 21:26'!tearDown	server stop! !!TeapotBeforeTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testAuthentication	self assert: (TeaTestClient httpGetString: '/secure?user=admin&pass=****') equals: 'protected'.	self assert: (TeaTestClient httpGetString: '/secure/1/2/3?user=admin&pass=****') equals: 'protected'.			self assert: (TeaTestClient httpGet: '/secure?user=user01&pass=****') code equals: 403.	self assert: (TeaTestClient httpGet: '/secure/1/2/3?user=user02&pass=****') code equals: 403.			self assert: (TeaTestClient httpPostString: '/public?user=any') equals: 'public'.! !!TeapotBeforeTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testMultipleBeforeHandlers	TeaTestClient httpGet: '/secure?user=admin&pass=****'.	TeaTestClient httpGet: '/secure/1/2/3?user=admin&pass=****'.		TeaTestClient httpGet: '/secure?user=user01&pass=****'. "403 before second filter"	TeaTestClient httpPost: '/public?user=pubuser'.					self assert: log asArray equals: #(admin admin pubuser).! !!TeapotDefaultFormatTest methodsFor: 'running' stamp: 'AttilaMagyar 8/13/2014 20:50'!setUp	server := (Teapot configure: { #defaultOutput -> #text })		GET: 'default' -> 'any';		GET: 'html' -> 'any'; output: #html;		start		! !!TeapotDefaultFormatTest methodsFor: 'running' stamp: 'AttilaMagyar 8/5/2014 20:51'!tearDown	server stop! !!TeapotDefaultFormatTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testDefault	self 		assert: (TeaTestClient httpGet: '/default') contentType 		equals: ZnMimeType textPlain! !!TeapotDefaultFormatTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testOverride	self 		assert: (TeaTestClient httpGet: '/html') contentType 		equals: ZnMimeType textHtml! !!TeapotEncodingTest methodsFor: 'running' stamp: 'AttilaMagyar 5/9/2015 18:15'!setUp	server := Teapot on		GET: 'enc' -> (TeaResponse ok 								body: 'árvíztűrő tükörfúrógép'; 								charSet: 'iso-8859-2');		start! !!TeapotEncodingTest methodsFor: 'running' stamp: 'AttilaMagyar 5/9/2015 18:11'!tearDown	server stop! !!TeapotEncodingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testUserSpecifiedEncoding	| response |	response := TeaTestClient httpGet: '/enc'.	self 		assert: response entity string		equals: 'árvíztűrő tükörfúrógép'.			self 		assert: response contentType charSet		equals: 'iso-8859-2'! !!TeapotErrorHandlingTest methodsFor: 'private' stamp: 'AttilaMagyar 8/12/2014 21:40'!handleError: ex request: req	self assert: (ex isKindOf: Exception).	self assert: (req isKindOf: TeaRequest).	^ ZnResponse ok: (ZnStringEntity text: 'outofbounds/domainerror handled')! !!TeapotErrorHandlingTest methodsFor: 'running' stamp: 'AttilaMagyar 9/28/2014 18:54'!setUp	server := Teapot on		GET: '/zerodiv' -> [ 1 / 0 ];		GET: '/sub' -> [ #() at: 123 ];					GET: '/domain' -> [ -2 sqrt ];		GET: '/nonbool' -> [ NotYetImplemented signal ];		GET: '/keynotfound' -> [ KeyNotFound signal ];		exception: ZeroDivide -> [ :ex :req | 'zerodiv handled' ];		exception: SubscriptOutOfBounds, DomainError -> (Send message: #handleError:request: to: self);		exception: NotYetImplemented -> (ZnResponse ok: (ZnStringEntity text: 'nonbool handled'));		exception: KeyNotFound -> 42;		output: [ :resp :req | ZnResponse ok: (ZnStringEntity text: resp body printStringRoman) ];		start		! !!TeapotErrorHandlingTest methodsFor: 'running' stamp: 'AttilaMagyar 8/4/2014 13:05'!tearDown	server stop! !!TeapotErrorHandlingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testHandlesExceptionSet	self assert: (TeaTestClient httpGetString: '/sub') equals: 'outofbounds/domainerror handled'.		self assert: (TeaTestClient httpGetString: '/domain') equals: 'outofbounds/domainerror handled'.		! !!TeapotErrorHandlingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testHandlesOneException	self assert: (TeaTestClient httpGetString: '/zerodiv') equals: 'zerodiv handled'.	! !!TeapotErrorHandlingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testTransformingErroHandlerResponse	self assert: (TeaTestClient httpGetString: '/keynotfound') equals: 'XLII'.! !!TeapotErrorHandlingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testValueAsExceptionHandler	self assert: (TeaTestClient httpGetString: '/nonbool') equals: 'nonbool handled'.	! !!TeapotFormParamsTest methodsFor: 'running' stamp: 'AttilaMagyar 11/16/2014 17:07'!setUp	server := Teapot on		POST: '/form' -> [ :req | (req at: #foo), '-', (req at: #bar) ];		exception: TeaNoSuchParam -> 'no such param';		start.! !!TeapotFormParamsTest methodsFor: 'running' stamp: 'AttilaMagyar 7/29/2014 22:34'!tearDown	server stop! !!TeapotFormParamsTest methodsFor: 'tests' stamp: 'AttilaMagyar 8/13/2014 21:01'!testFormParams	| result |	result := ZnEasy post: 'http://localhost:1701/form' data: (ZnApplicationFormUrlEncodedEntity new 		at: 'foo' put: 'abc'; 		at: 'bar' put: '123'; 		yourself).	self assert: result entity string equals: 'abc-123'.! !!TeapotFormParamsTest methodsFor: 'tests' stamp: 'AttilaMagyar 11/16/2014 17:07'!testFormParamsNotFound	| result |	result := ZnEasy post: 'http://localhost:1701/form' data: (ZnApplicationFormUrlEncodedEntity new 		at: 'invalid1' put: 'abc'; 		at: 'invalid2' put: '123'; 		yourself).	self assert: result entity string equals: 'no such param'! !!TeapotFormatTest methodsFor: 'running' stamp: 'AttilaMagyar 10/16/2014 20:45'!setUp	server := Teapot on		GET: '/a' -> [ 4 ]; output: [ :resp :req | ZnResponse ok: (ZnStringEntity text: resp body printStringRoman) ];		GET: 'default' -> 'any';		GET: '/plain' -> 'any'; output: #text;		GET: 'xml' -> 'any'; output: (TeaOutput stringWithContentType: ZnMimeType applicationXml);		start		! !!TeapotFormatTest methodsFor: 'running' stamp: 'AttilaMagyar 7/29/2014 22:37'!tearDown	server stop! !!TeapotFormatTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testArbitraryContentType	self 		assert: (TeaTestClient httpGet: '/xml') contentType 		equals: (ZnMimeType applicationXml charSet: 'utf-8'; yourself)! !!TeapotFormatTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testConverting	self assert: (TeaTestClient httpGetString: '/a') equals: 'IV'.	! !!TeapotFormatTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testDefaultContentTypeIsHtml	self 		assert: (TeaTestClient httpGet: '/default') contentType 		equals: ZnMimeType textHtml! !!TeapotFormatTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testSetsContentType	self 		assert: (TeaTestClient httpGet: '/plain') contentType 		equals: ZnMimeType textPlain! !!TeapotMessageSendTest methodsFor: 'web controller' stamp: 'AttilaMagyar 8/2/2014 19:32'!msg1	^ 'msg1 result'! !!TeapotMessageSendTest methodsFor: 'web controller' stamp: 'AttilaMagyar 8/10/2014 20:56'!msg2Req: req nil: resp	self assert: resp isNil.	^ 'msg2 ', (req at: #param)! !!TeapotMessageSendTest methodsFor: 'web controller' stamp: 'AttilaMagyar 8/2/2014 19:44'!msg3Req: req	^ 'msg3 ', (req at: #param)! !!TeapotMessageSendTest methodsFor: 'running' stamp: 'AttilaMagyar 8/10/2014 20:55'!setUp	server := Teapot on		GET: '/msg1' -> (Send message: #msg1 to: self);		GET: '/msg2/<param>' -> (Send message: #msg2Req:nil: to: self);				GET: '/msg3/<param>' -> (Send message: #msg3Req: to: self);							start.		! !!TeapotMessageSendTest methodsFor: 'running' stamp: 'AttilaMagyar 8/2/2014 19:30'!tearDown	server stop! !!TeapotMessageSendTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testReceivingOneArgKeywordMessage	self assert: (TeaTestClient httpGetString: '/msg3/bar') equals: 'msg3 bar'.! !!TeapotMessageSendTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testReceivingTwoArgsKeywordMessage	self assert: (TeaTestClient httpGetString: '/msg2/foo') equals: 'msg2 foo'.! !!TeapotMessageSendTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testReceivingUnaryMessage	self assert: (TeaTestClient httpGetString: '/msg1') equals: 'msg1 result'.! !!TeapotPathParamTest methodsFor: 'running' stamp: 'AttilaMagyar 8/10/2014 20:15'!setUp	server := Teapot on		GET: '/user/<id>' -> [ :req | '1-', (req at: #id) ];		GET: '/user/<id>/create' -> [ :req | '2-', (req at: #id) ];		GET: '/<id>/<user>' -> [ :req | '3-', (req at: #id) ];						POST: '/user/<id>/create' -> [ :req | '4-', (req at: #id) ];		start.		! !!TeapotPathParamTest methodsFor: 'running' stamp: 'AttilaMagyar 7/29/2014 22:04'!tearDown	server stop! !!TeapotPathParamTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testPlaceholderAtLast	self assert: (TeaTestClient httpGetString: 'user/12') equals: '1-12'	! !!TeapotPathParamTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testPlaceholderFirst	self assert: (TeaTestClient httpGetString: '54/user') equals: '3-54'.	! !!TeapotPathParamTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testPlaceholderInside	self assert: (TeaTestClient httpGetString: 'user/34/create') equals: '2-34'.		! !!TeapotPathParamTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testPlaceholderPost	self assert: (TeaTestClient httpPostString: '/user/789/create') equals: '4-789'.		! !!TeapotQueryParamsTest methodsFor: 'running' stamp: 'AttilaMagyar 8/10/2014 20:15'!setUp	server := Teapot on		GET: '/query' -> [ :req | req at: #foo ];		GET: '/queryopt' -> [ :req | req at: #foo ifAbsent: [ 'default' ] ];				start! !!TeapotQueryParamsTest methodsFor: 'running' stamp: 'AttilaMagyar 7/26/2014 22:56'!tearDown	server stop! !!TeapotQueryParamsTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testDefaultQueryParam	self assert: (TeaTestClient httpGetString: '/queryopt') equals: 'default'.	! !!TeapotQueryParamsTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testQueryParam	self assert: (TeaTestClient httpGetString: '/query?foo=bar') equals: 'bar'.	self assert: (TeaTestClient httpGetString: '/queryopt?foo=baz') equals: 'baz'.! !!TeapotRegexpTest methodsFor: 'running' stamp: 'AttilaMagyar 8/14/2014 21:16'!setUp	server := Teapot on		GET: '/./' asRegex -> [ 'regexp' ];		GET: '\w+(\d)/\d/xxx' asRegex -> [ :req | req at: 1 ];		GET: '/(\d)/([abc]+)/\d/(.*)' asRegex -> [ :req | (req at: 1), (req at: 2), (req at: 3) ];				start! !!TeapotRegexpTest methodsFor: 'running' stamp: 'AttilaMagyar 8/14/2014 20:18'!tearDown	server stop! !!TeapotRegexpTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testCollectingSubexpressions	self assert: (TeaTestClient httpGetString: '/abc3/4/xxx') equals: '3'.		self assert: (TeaTestClient httpGetString: '/1/aabbcc/2/foobar') equals: '1aabbccfoobar'.! !!TeapotRegexpTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testIgnoresQueryParam	self assert: (TeaTestClient httpGetString: '/k/?param=value') equals: 'regexp'.	! !!TeapotRegexpTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testRegexpMatch	self assert: (TeaTestClient httpGetString: 'k/') equals: 'regexp'.	! !!TeapotResponseTest methodsFor: 'running' stamp: 'AttilaNamed 2/28/2015 23:27'!setUp	server := Teapot on		GET: '/test400' -> [ 			TeaResponse badRequest				body: 'malformed input';				headers: { 'my-header' -> 'my-value' } ];		start! !!TeapotResponseTest methodsFor: 'running' stamp: 'AttilaMagyar 9/28/2014 18:27'!tearDown	server stop! !!TeapotResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testReturnsCustomCodeBodyAndHeaders	| response |	response := TeaTestClient httpGet: '/test400'.	self assert: response entity string equals: 'malformed input'.	self assert: response code equals: 400.	self assert: (response headers at: 'my-header') equals: 'my-value'.! !!TeapotReturnResponseTest methodsFor: 'running' stamp: 'AttilaMagyar 8/10/2014 22:05'!setUp	| stream |	stream := ZnStreamingEntity		readFrom: 'direct stream' readStream		usingType: ZnMimeType textHtml		andLength: 'direct stream' size.			server := Teapot on		GET: '/resp1' -> [ :req | ZnResponse ok: (ZnStringEntity text: 'direct response') ];		GET: '/resp2' -> (ZnResponse ok: stream);		GET: '/redirect' -> (ZnResponse redirect: '/redirect_location');		GET: '/redirect_location' -> 'redirected here';		start! !!TeapotReturnResponseTest methodsFor: 'running' stamp: 'AttilaMagyar 8/10/2014 20:39'!tearDown	server stop! !!TeapotReturnResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testDirectStreamResponse	self assert: (TeaTestClient httpGetString: '/resp2') equals: 'direct stream'.	! !!TeapotReturnResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testDirectStringResponse	self assert: (TeaTestClient httpGetString: '/resp1') equals: 'direct response'.	! !!TeapotReturnResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testRedirect	self assert: (TeaTestClient httpGetString: '/redirect') equals: 'redirected here'.	! !!TeapotRouteSetTest methodsFor: 'running' stamp: 'AttilaMagyar 6/16/2015 18:43'!setUp	server := Teapot on		before: { '/secure/*' . '/protected/*' } -> [ :req | req abort: TeaResponse unauthorized ];			GET: {'/a'. '/b'. '/c'} -> 'abc';		POST: { '/x/<param>'. '/y/<param>' } -> [ :req | req at: #param ];		after: { '/a'. '/b' } -> [ :req :resp | resp headers at: 'test' put: 'ab' ];		start.! !!TeapotRouteSetTest methodsFor: 'running' stamp: 'AttilaMagyar 6/16/2015 18:21'!tearDown	server stop! !!TeapotRouteSetTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testMatchesAnyRouteInAfterFilter	| response |	response := TeaTestClient httpGet: '/a'.	self assert: (response headers at: 'test') equals: 'ab'.		response := TeaTestClient httpGet: '/b'.	self assert: (response headers at: 'test') equals: 'ab'.			response := TeaTestClient httpGet: '/c'.	self assert: (response headers at: 'test' ifAbsent: nil) equals: nil.! !!TeapotRouteSetTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testMatchesAnyRouteInBeforeFilter	| response |	response := TeaTestClient httpGet: '/secure/123'.	self assert: response code equals: 401.		response := TeaTestClient httpGet: '/protected/123'.	self assert: response code equals: 401.! !!TeapotRouteSetTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testMatchesAnyRouteInSet	self assert: (TeaTestClient httpGetString: '/a') equals: 'abc'.	self assert: (TeaTestClient httpGetString: '/b') equals: 'abc'.	self assert: (TeaTestClient httpGetString: '/c') equals: 'abc'.! !!TeapotRouteSetTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testMatchesAnyRouteInSetWithParams	self assert: (TeaTestClient httpPostString: '/x/value1') equals: 'value1'.	self assert: (TeaTestClient httpPostString: '/y/value2') equals: 'value2'.	! !!TeapotRoutingTest methodsFor: 'running' stamp: 'AttilaMagyar 4/18/2015 00:09'!setUp	server := Teapot on		GET: '/' -> '1';		GET: '/a' -> '2';		GET: '/a/*/b' -> [ '3' ];		GET: '/*/c' -> [ '4' ];			GET: '/x/y/*' -> [ '5' ];		GET: '/x/*/*/z/*' -> [ '6' ];		any: 'any' -> 'any';		start.		! !!TeapotRoutingTest methodsFor: 'running' stamp: 'AttilaMagyar 7/29/2014 21:59'!tearDown	server stop! !!TeapotRoutingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!test404 	self assert: (TeaTestClient httpGet: '1/2/3/4') code equals: 404! !!TeapotRoutingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testAnyMatchesToAnyHttpMethod 	self assert: (TeaTestClient httpGetString: 'any') equals: 'any'. 	self assert: (TeaTestClient httpPostString: 'any') equals: 'any'. 	self assert: (TeaTestClient httpPutString: 'any') equals: 'any'.	 	self assert: (TeaTestClient httpDeleteString: 'any') equals: 'any'.! !!TeapotRoutingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testMultipleWildcard	self assert: (TeaTestClient httpGetString: 'x/foo/bar/z/baz') equals: '6'.	self assert: (TeaTestClient httpGetString: 'x/foo/bar/z/baz/123') equals: '6'.	! !!TeapotRoutingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testNoWildcard	self assert: (TeaTestClient httpGetString: '') equals: '1'.	self assert: (TeaTestClient httpGetString: '/a') equals: '2'.		! !!TeapotRoutingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testWildcardEnd	self assert: (TeaTestClient httpGetString: '/x/y/foo') equals: '5'.		! !!TeapotRoutingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testWildcardFirst	self assert: (TeaTestClient httpGetString: 'foo/c') equals: '4'	! !!TeapotRoutingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testWildcardInside	self assert: (TeaTestClient httpGetString: 'a/bar/b') equals: '3'	! !!TeapotStaticFilesTest methodsFor: 'private' stamp: 'AttilaMagyar 8/3/2014 11:14'!createTempHtdocs	| tmpHtdocs |	tmpHtdocs := FileLocator temp asFileReference / 'test_htdocs'.	tmpHtdocs createDirectory.	tmpHtdocs / 'index.html' writeStreamDo: [ :stream | stream nextPutAll: 'static index' ].	tmpHtdocs / 'a.txt' writeStreamDo: [ :stream | stream nextPutAll: 'a' ].	tmpHtdocs / 'b.txt' writeStreamDo: [ :stream | stream nextPutAll: 'static' ].	^ tmpHtdocs! !!TeapotStaticFilesTest methodsFor: 'running' stamp: 'AttilaMagyar 8/3/2014 11:19'!setUp	htdocs := self createTempHtdocs.	server := Teapot on		GET: 'here/are/statics/b.txt' -> 'dynamic';		serveStatic: 'here/are/statics' from: htdocs;		start! !!TeapotStaticFilesTest methodsFor: 'running' stamp: 'AttilaMagyar 8/3/2014 11:16'!tearDown	htdocs deleteAll.	server stop.! !!TeapotStaticFilesTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testDynamicContentServedBeforeStatic	self assert: (TeaTestClient httpGetString: 'here/are/statics/b.txt') equals: 'dynamic'.	! !!TeapotStaticFilesTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testStaticFile	self assert: (TeaTestClient httpGetString: 'here/are/statics/a.txt') equals: 'a'.	! !!TeapotStaticFilesTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testStaticIndexHtml	self assert: (TeaTestClient httpGetString: 'here/are/statics') equals: 'static index'.	! !!TeapotStaticFilesTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testStaticNotFound	self assert: (TeaTestClient httpGet: 'here/are/statics/notfound.txt') code equals: 404.	! !!TeapotStreamingTest methodsFor: 'private' stamp: 'AttilaMagyar 8/8/2014 20:16'!content	^ (ByteArray new: 4096 withAll: 65) asString! !!TeapotStreamingTest methodsFor: 'private' stamp: 'AttilaMagyar 8/8/2014 20:14'!createDownloadableFile	| file |	file := FileLocator temp asFileReference / 'download.file'.	file writeStreamDo: [ :stream | stream nextPutAll: self content ].	^ file! !!TeapotStreamingTest methodsFor: 'private' stamp: 'AttilaMagyar 8/8/2014 20:12'!deleteDownloadableFile	downloadFile delete! !!TeapotStreamingTest methodsFor: 'running' stamp: 'AttilaMagyar 8/10/2014 20:29'!setUp	downloadFile := self createDownloadableFile.	server := Teapot on		GET: '/stream' -> downloadFile readStream;		output: #stream;		start! !!TeapotStreamingTest methodsFor: 'running' stamp: 'AttilaMagyar 8/8/2014 20:11'!tearDown	self deleteDownloadableFile.	server stop.! !!TeapotStreamingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testStreamingContent	self 		assert: (TeaTestClient httpGet: '/stream') contents asString 		equals: self content	! !!TeapotTeaResponseTest methodsFor: 'running' stamp: 'AttilaNamed 3/1/2015 00:03'!setUp	server := Teapot on		GET: '/ok' -> (TeaResponse ok body: 'tested ok');		GET: '/badrequest' -> [:req | TeaResponse badRequest body: 'Bad Request'];		GET: '/created' -> [:req | TeaResponse created body: 'Created'; location: req url];		GET: '/notallowed' -> [:req | TeaResponse methodNotAllowed ];		GET: '/notfound' -> [:req | TeaResponse notFound ];		GET: '/notmodified' -> [:req | TeaResponse notModified ];		GET: '/redirect' -> (TeaResponse redirect location: '/target');		GET: '/servererror' -> (TeaResponse serverError body: 'tested server error');		GET: '/unauthorized' -> (TeaResponse unauthorized body: 'Unauthorized'; headerName: 'WWW-Authenticate' value: 'tested unauthorized');		start! !!TeapotTeaResponseTest methodsFor: 'running' stamp: 'AttilaMagyar 10/13/2014 19:35'!tearDown	server stop.! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testBadRequest	| response |	response := TeaTestClient httpGet: '/badrequest'.	self assert: response code equals: 400.	self assert: response entity string equals: 'Bad Request'! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testCreated	| response |	response := TeaTestClient httpGet: '/created'.	self assert: response code equals: 201.	self assert: response entity string equals: 'Created'.	self assert: (response headers at: 'Location') equals: '/created'.! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testMethodNotAllowed	| response |	response := TeaTestClient httpGet: '/notallowed'.	self assert: response code equals: 405.! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testNotFound	| response |	response := TeaTestClient httpGet: '/notfound'.	self assert: response code equals: 404.! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testNotModified	| response |	response := TeaTestClient httpGet: '/notmodified'.	self assert: response code equals: 304.! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testOk	| response |	response := TeaTestClient httpGet: '/ok'.	self assert: response code equals: 200.	self assert: response entity string equals: 'tested ok'.! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testRedirect	| response |	response := TeaTestClient httpGetNoRedirect: '/redirect'.	self assert: response code equals: 302.	self assert: (response headers at: 'Location') equals: '/target'.! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testServerError	| response |	response := TeaTestClient httpGet: '/servererror'.	self assert: response code equals: 500.	self assert: response entity string equals: 'tested server error'! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testUnauthorized	| response |	response := TeaTestClient httpGet: '/unauthorized'.	self assert: response code equals: 401.	self assert: response entity string equals: 'Unauthorized'.	self assert: (response headers at: 'WWW-Authenticate') equals: 'tested unauthorized'.! !!TeapotWhenClauseTest methodsFor: 'running' stamp: 'AttilaMagyar 5/8/2015 20:01'!setUp	server := Teapot on		any: '/when' -> 'get'; when: [:req | req method = 'GET'];		any: '/when' -> 'post'; when: [:req | req method = 'POST'];		any: '/when/<p>' -> 'param-dispatch'; when: [:req | (req at: #p) = 'pval'];		any: '/when' -> 'unfiltered';		any: '/never' -> 'never match'; when: [ false ];		before: '/*' -> [:req | 			req abort: (TeaResponse ok body: 'before') ]; 			when: [:req | req relativeUrl path = 'beforeurl' ];		after: '/*' -> [:req :resp | 			resp statusLine: ZnStatusLine ok. 			resp entity: (ZnStringEntity text: 'after') ]; 			when: [:req | req relativeUrl path = 'afterurl' ];		start! !!TeapotWhenClauseTest methodsFor: 'running' stamp: 'AttilaMagyar 5/4/2015 21:23'!tearDown	server stop! !!TeapotWhenClauseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testDispatchesOnMethodInWhenFilter	self 		assert: (TeaTestClient httpGetString: '/when') 		equals: 'get'.		self 		assert: (TeaTestClient httpPutString: '/when/pval') 		equals: 'param-dispatch'.	self 		assert: (TeaTestClient httpPostString: '/when') 		equals: 'post'.	self 		assert: (TeaTestClient httpDeleteString: '/when') 		equals: 'unfiltered'.			self assert: (TeaTestClient httpGet: '/never') isNotFound.! !!TeapotWhenClauseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testWhenClauseWithBeforeAfterFilter	self 		assert: (TeaTestClient httpGetString: 'beforeurl') 		equals: 'before'.	self 		assert: (TeaTestClient httpGetString: 'afterurl') 		equals: 'after'.! !!TeaTestClient class methodsFor: 'private' stamp: 'AttilaMagyar 4/18/2015 00:06'!httpDeleteString: aString	^ ZnClient new		url: 'http://localhost:1701/', aString;		delete	! !!TeaTestClient class methodsFor: 'private' stamp: 'AttilaMagyar 8/13/2014 21:00'!httpGet: aString	^ ZnEasy get: 'http://localhost:1701/', aString	! !!TeaTestClient class methodsFor: 'private' stamp: 'AttilaMagyar 10/13/2014 19:52'!httpGetNoRedirect: aString	^ ZnClient new		followRedirects: false;		get: 'http://localhost:1701/', aString;				response	! !!TeaTestClient class methodsFor: 'private' stamp: 'AttilaMagyar 7/29/2014 22:07'!httpGetString: aString	^ (self httpGet: aString) entity string	! !!TeaTestClient class methodsFor: 'private' stamp: 'AttilaMagyar 8/13/2014 21:00'!httpPost: aString	^ ZnEasy post: 'http://localhost:1701/', aString data: (ZnEntity text: 'any')	! !!TeaTestClient class methodsFor: 'private' stamp: 'AttilaMagyar 7/29/2014 22:26'!httpPostString: aString	^ (self httpPost: aString) entity string	! !!TeaTestClient class methodsFor: 'private' stamp: 'AttilaMagyar 4/18/2015 00:03'!httpPut: aString	^ ZnEasy put: 'http://localhost:1701/', aString data: (ZnEntity text: 'any')	! !!TeaTestClient class methodsFor: 'private' stamp: 'AttilaMagyar 4/18/2015 00:03'!httpPutString: aString	^ (self httpPut: aString) entity string	! !"Teapot-Tests"!----SNAPSHOT----2017-07-29T14:21:42.391136+09:00 Pharo6.1-64.image priorSource: 2151717!----QUIT/NOSAVE----2017-07-29T14:22:04.527752+09:00 Pharo6.1-64.image priorSource: 2400752!----QUIT/NOSAVE----2017-07-29T14:26:47.882664+09:00 Pharo6.1-64.image priorSource: 2400752!----SNAPSHOT----2017-07-29T14:28:28.208042+09:00 test.image priorSource: 2400752!----SNAPSHOT----2017-07-29T14:30:18.801706+09:00 test.image priorSource: 2401028!----QUIT/NOSAVE----2017-07-29T14:30:29.288039+09:00 test.image priorSource: 2401111!Object subclass: #TestClass	instanceVariableNames: ''	classVariableNames: ''	package: 'Sever-Test'!!TestClass methodsFor: 'as yet unclassified' stamp: 'rchaser53 7/29/2017 14:33'!start	Teapot on    GET: '/welcome' -> 'Hello World!!';    start.! !!TestClass class methodsFor: 'as yet unclassified' stamp: 'rchaser53 7/29/2017 14:33'!start	Teapot on    GET: '/welcome' -> 'Hello World!!';    start.! !!TestClass class methodsFor: 'starting' stamp: 'rchaser53 7/29/2017 14:34' prior: 35956056!start	Teapot on    GET: '/welcome' -> 'Hello World!!'.! !TestClass class	instanceVariableNames: 'teapot'!!TestClass class methodsFor: 'starting' stamp: 'rchaser53 7/29/2017 14:35' prior: 35956219!start	teapot := Teapot on    GET: '/welcome' -> 'Hello World!!'.! !!TestClass class methodsFor: 'starting' stamp: 'rchaser53 7/29/2017 14:35'!initialize	teapot := Teapot on    GET: '/welcome' -> 'Hello World!!'.! !!TestClass class methodsFor: 'starting' stamp: 'rchaser53 7/29/2017 14:35' prior: 35956422!start	teapot start.! !!TestClass class methodsFor: 'starting' stamp: 'rchaser53 7/29/2017 14:35'!stop	teapot stop.! !Object subclass: #TeaPotServer	instanceVariableNames: 'teapot'	classVariableNames: ''	package: 'Tea-Pot-Server'!!TeaPotServer methodsFor: 'as yet unclassified' stamp: 'rchaser53 7/29/2017 14:39'!initialize teapot := Teapot on    GET: '/welcome' -> 'Hello World!!'.! !!TeaPotServer methodsFor: 'initialization' stamp: 'rchaser53 7/29/2017 14:39' prior: 35957058!initialize 	teapot := Teapot on   		GET: '/welcome' -> 'Hello World!!'.! !!TeaPotServer methodsFor: 'as yet unclassified' stamp: 'rchaser53 7/29/2017 14:40'!start	teapot start.! !!TeaPotServer methodsFor: 'accessing' stamp: 'rchaser53 7/29/2017 14:40'!stop	teapot stop.! !----SNAPSHOT----2017-07-29T14:40:45.646126+09:00 test.image priorSource: 2401111!----SNAPSHOT----2017-07-29T14:42:23.635548+09:00 test.image priorSource: 2403076!